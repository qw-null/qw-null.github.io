---
title: 【我眼中的】 - 【3】作用域 & 执行上下文
date: 2022-04-18 11:21:17
categories:
- 我眼中的系列
tags:
- 我眼中的系列
---
![](https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220419202053.png)

<hr>

## 1.作用域 

[其他参考内容](https://qw-null.github.io/2022/02/25/Javascript%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/#2-3-1-%E4%BD%9C%E7%94%A8%E5%9F%9F)

作用域是指程序一个代码坐在的区域，它规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。
![](https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220314203108.png)

JavaScript 采用<span style="background-color:#f1c40f">词法作用域(lexical scoping)</span>，也就是静态作用域。

#### 1.1 静态作用域与动态作用域

因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。

动态作用域，函数的作用域是在函数调用的时候才决定的。（在JS中没有的）

```javascript
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();
```

上述代码的执行结果是1。执行流程是执行```bar()```时会调用内部的```foo()```，执行 ```foo()```时，先从 ```foo``` 函数内部查找是否有局部变量 ```value```，如果没有，<b style="background-color:#F39C12">就根据书写的位置，查找上面一层的代码</b>，也就是 value 等于 1，所以结果会打印 1。

>假设JavaScript采用动态作用域，让我们分析下执行过程：
执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。

## 2.执行上下文栈

[其他参考内容](https://qw-null.github.io/2022/02/25/Javascript%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/#2-2%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88)

通常说的JS可执行代码有三类：全局代码、函数代码、eval代码。

举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做"执行上下文(execution context)"。

接下来问题来了，我们写的函数多了，如何管理创建的那么多执行上下文呢？

所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。

<hr>

为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：

``` ECStack = []; ```

试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 ```globalContext``` 表示它，并且只有当整个应用程序结束的时候，```ECStack``` 才会被清空，所以程序结束之前， ```ECStack``` 最底部永远有个 ```globalContext```：

``` ECStack = [ globalContext ]; ```

现在 JavaScript 遇到下面的这段代码了：

```javascript
function fun3() {
    console.log('fun3')
}

function fun2() {
    fun3();
}

function fun1() {
    fun2();
}

fun1();
```

当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：

```javascript
// 伪代码

// fun1()
ECStack.push(<fun1> functionContext);

// fun1中竟然调用了fun2，还要创建fun2的执行上下文
ECStack.push(<fun2> functionContext);

// 擦，fun2还调用了fun3！
ECStack.push(<fun3> functionContext);

// fun3执行完毕
ECStack.pop();

// fun2执行完毕
ECStack.pop();

// fun1执行完毕
ECStack.pop();

// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext
```

#### 思考题
⭐ 代码段一
```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

⭐ 代码段二
```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？
答案就是执行上下文栈的变化不一样。

模拟代码段一：
```javascript
ECStack.push(<checkscope> functionContext);
ECStack.push(<f> functionContext);
ECStack.pop();
ECStack.pop();
```

模拟代码段二：
```javascript
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
```