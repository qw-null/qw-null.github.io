<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据治理技术调研</title>
    <url>/2024/06/05/%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="1-制造业质量域不良件追溯场景的数据治理"><a href="#1-制造业质量域不良件追溯场景的数据治理" class="headerlink" title="1.制造业质量域不良件追溯场景的数据治理"></a>1.制造业质量域不良件追溯场景的数据治理</h2><p><a href="https://www.bilibili.com/video/BV1VU411Z7Av/?share_source=copy_web&vd_source=f3ff8a2761a3e07339584c4852cdd504">基于业务场景的数据治理最佳实践（一）：制造业质量域不良件追溯场景的数据治理</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051021895.png"><br>一般而言，企业的制度体系都已经有了（右侧），现在更多想做的是基于已有的制度体系去支撑某一个业务域的建设。 – <strong>赋能业务</strong></p>
<h4 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051026722.png"><br>SRM、OTWB、DC、GLES是单独的系统。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051030847.png"><br>前期的调研非常重要，了解并解决业务部门的痛点是治理的关键所在。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051041963.png"></p>
<h4 id="计划及实施"><a href="#计划及实施" class="headerlink" title="计划及实施"></a>计划及实施</h4><p><strong>质量域 数据标准编制</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051042552.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051048376.png"></p>
<h4 id="预期成果"><a href="#预期成果" class="headerlink" title="预期成果"></a>预期成果</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051051627.png"><br>顶层 – 业务数字化需要先有</p>
<h2 id="2-再谈数据架构与数据治理"><a href="#2-再谈数据架构与数据治理" class="headerlink" title="2.再谈数据架构与数据治理"></a>2.再谈数据架构与数据治理</h2><p><a href="https://www.bilibili.com/video/BV1VU411Z7Av/?share_source=copy_web&vd_source=f3ff8a2761a3e07339584c4852cdd504">基于业务场景的数据治理最佳实践（一）</a><br>不要忽略全局：企业架构管理<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051103142.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051104157.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051105180.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051105366.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051108038.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051108984.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051109452.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051110462.png"></p>
<p><strong>企业数据模型（EDM） &amp; 企业数仓模型（EDW）</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051112083.png"><br>一般推荐先做企业数据模型，再在此基础上再做企业数仓模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051117258.png"></p>
<p><strong>数据治理 &amp; 数据中台一体化</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202406051117179.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>数据治理</tag>
      </tags>
  </entry>
  <entry>
    <title>若依框架学习笔记</title>
    <url>/2024/02/19/%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-学习路线图"><a href="#1-学习路线图" class="headerlink" title="1. 学习路线图"></a>1. 学习路线图</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240122093531148.png" alt="image-20240122093531148"></p>
<h2 id="2-框架运行"><a href="#2-框架运行" class="headerlink" title="2. 框架运行"></a>2. 框架运行</h2><p><a href="https://ruoyi.vip/">若依框架官网</a></p>
<h4 id="2-1-后端运行"><a href="#2-1-后端运行" class="headerlink" title="2.1 后端运行"></a>2.1 后端运行</h4><p>0⃣️  数据库配置</p>
<p>配置文件位置：ruoyi-adimn/src/main/resources/application-druid.yml</p>
<p>配置步骤：</p>
<p>1⃣️  本地创建数据库ry-vue（通过配置文件得知）</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240122094833492.png" alt="image-20240122094833492" style="zoom:50%;" />

<p>2⃣️  运行sql脚本 （位置：sql/ry_20231130.sql）</p>
<p>✅ 运行完成后数据库表即可建立完成</p>
<p>3⃣️  查看redis配置 （位置：ruoyi-adimn/src/main/resources/application.yml）</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240122095233790.png" alt="image-20240122095233790" style="zoom:50%;" />

<p>本地启动redis</p>
<p>4⃣️  启动项目</p>
<p>启动类的位置：ruoyi-adimn/src/main/java/com/ruoyi/RuoYiApplication</p>
<h4 id="2-2-前端运行"><a href="#2-2-前端运行" class="headerlink" title="2.2 前端运行"></a>2.2 前端运行</h4><p>前端目录：RUOYI-UI</p>
<p>下载依赖：<code>npm install</code></p>
<p>运行前端代码：<code>npm run dev</code></p>
<h2 id="3-项目分析"><a href="#3-项目分析" class="headerlink" title="3. 项目分析"></a>3. 项目分析</h2><p>RuoYi-Vue 是一个单体项目，但是根据多模块进行管理，将不同的模块进行隔离</p>
<p>其中，<code> ruoyi-quartz</code>和<code> ruoyi-quartz</code>可以进行删除，其余模块对其没有任何依赖</p>
<h4 id="3-1-文件结构"><a href="#3-1-文件结构" class="headerlink" title="3.1.文件结构"></a>3.1.文件结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.ruoyi     </span><br><span class="line">├── common            // 工具类</span><br><span class="line">│       └── annotation                    // 自定义注解</span><br><span class="line">│       └── config                        // 全局配置</span><br><span class="line">│       └── constant                      // 通用常量</span><br><span class="line">│       └── core                          // 核心控制</span><br><span class="line">│       └── enums                         // 通用枚举</span><br><span class="line">│       └── exception                     // 通用异常</span><br><span class="line">│       └── filter                        // 过滤器处理</span><br><span class="line">│       └── utils                         // 通用类处理</span><br><span class="line">├── framework         // 框架核心</span><br><span class="line">│       └── aspectj                       // 注解实现</span><br><span class="line">│       └── config                        // 系统配置</span><br><span class="line">│       └── datasource                    // 数据权限</span><br><span class="line">│       └── interceptor                   // 拦截器</span><br><span class="line">│       └── manager                       // 异步处理</span><br><span class="line">│       └── security                      // 权限控制</span><br><span class="line">│       └── web                           // 前端控制</span><br><span class="line">├── ruoyi-generator   // 代码生成（可移除）</span><br><span class="line">├── ruoyi-quartz      // 定时任务（可移除）</span><br><span class="line">├── ruoyi-system      // 系统代码</span><br><span class="line">├── ruoyi-admin       // 后台服务</span><br></pre></td></tr></table></figure>

<p><strong>PS：</strong></p>
<p>1.代码分开存放：controller（位置：<code>ruoyi-admin/src/main/java/com/ruoyi/web/controller/</code>），controller调用的service、mapper、domain在<code>ruoyi-system</code>目录下</p>
<p>2.<code>ruoyi-admin</code>使用到<code>framework</code>内容</p>
<p>在<code>ruoyi-admin</code>的<code>pom.xml</code>中引入</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240122103339887.png" alt="image-20240122103339887" style="zoom:50%;" />

<p>同样在<code>framework</code>的<code>pom.xml</code>中引入<code>ruoyi-system</code></p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240122103701409.png" alt="image-20240122103701409" style="zoom:50%;" />

<h2 id="4-RBAC模型"><a href="#4-RBAC模型" class="headerlink" title="4.RBAC模型"></a>4.RBAC模型</h2><ul>
<li>若依框架的权限管理功能是基于<strong>RBAC</strong>来实现的，即：系统中所有的权限，都是基于角色来控制的</li>
<li>框架对权限的控制，不仅支持菜单的功能，还支持菜单中的每一个按钮的权限控制</li>
</ul>
<p>RBAC（基于角色的访问控制）模型包含的表有下面五张：</p>
<ol>
<li><p>用户表 </p>
</li>
<li><p>角色表</p>
</li>
<li><p>菜单表</p>
</li>
<li><p>用户角色关联表</p>
</li>
<li><p>角色菜单关联表</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240122110117943.png" alt="image-20240122110117943" style="zoom:50%;" />

<p>查询当前登录用户的所拥有的权限菜单（登录人ID：2）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys_menu t1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> sys_role_menu t2 <span class="keyword">on</span> t1.menu_id <span class="operator">=</span> t2.menu_id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> sys_user_role t3 <span class="keyword">on</span> t2.role_id <span class="operator">=</span> t3.role_id</span><br><span class="line"><span class="keyword">where</span> t3.user_id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-数据字典"><a href="#5-数据字典" class="headerlink" title="5.数据字典"></a>5.数据字典</h2><p>数据字典的功能由两张表组成：</p>
<ol>
<li>sys_dict_type：字典类型表</li>
<li>sys_dict_data：字典数量表</li>
</ol>
<p>两者之间的关系：<code>sys_dict_type</code>表的<code>dict_type</code>字段关联<code>sys_dict_data</code>的<code>dict_type</code>字段</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240122112919670.png" alt="image-20240122112919670" style="zoom:50%;" />



<h2 id="6-拦截器"><a href="#6-拦截器" class="headerlink" title="6.拦截器"></a>6.拦截器</h2><h4 id="6-1-前端拦截器"><a href="#6-1-前端拦截器" class="headerlink" title="6.1 前端拦截器"></a>6.1 前端拦截器</h4><p>前端拦截器分为 前置拦截器 和 响应拦截器</p>
<p><strong>前置拦截器</strong></p>
<p>前置拦截器的代码写在<code>request.js</code>文件中，路径为 src - utils - request.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// request拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 是否需要设置 token</span></span><br><span class="line">  <span class="keyword">const</span> isToken = (config.<span class="property">headers</span> || &#123;&#125;).<span class="property">isToken</span> === <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 是否需要防止数据重复提交</span></span><br><span class="line">  <span class="keyword">const</span> isRepeatSubmit = (config.<span class="property">headers</span> || &#123;&#125;).<span class="property">repeatSubmit</span> === <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getToken</span>() &amp;&amp; !isToken) &#123;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Bearer &#x27;</span> + <span class="title function_">getToken</span>() <span class="comment">// 让每个请求携带自定义token 请根据实际情况自行修改</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// get请求映射params参数</span></span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">method</span> === <span class="string">&#x27;get&#x27;</span> &amp;&amp; config.<span class="property">params</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> url = config.<span class="property">url</span> + <span class="string">&#x27;?&#x27;</span> + <span class="title function_">tansParams</span>(config.<span class="property">params</span>);</span><br><span class="line">    url = url.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    config.<span class="property">params</span> = &#123;&#125;;</span><br><span class="line">    config.<span class="property">url</span> = url;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isRepeatSubmit &amp;&amp; (config.<span class="property">method</span> === <span class="string">&#x27;post&#x27;</span> || config.<span class="property">method</span> === <span class="string">&#x27;put&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> requestObj = &#123;</span><br><span class="line">      <span class="attr">url</span>: config.<span class="property">url</span>,</span><br><span class="line">      <span class="attr">data</span>: <span class="keyword">typeof</span> config.<span class="property">data</span> === <span class="string">&#x27;object&#x27;</span> ? <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(config.<span class="property">data</span>) : config.<span class="property">data</span>,</span><br><span class="line">      <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> requestSize = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(requestObj)).<span class="property">length</span>; <span class="comment">// 请求数据大小</span></span><br><span class="line">    <span class="keyword">const</span> limitSize = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 限制存放数据5M</span></span><br><span class="line">    <span class="keyword">if</span> (requestSize &gt;= limitSize) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`[<span class="subst">$&#123;config.url&#125;</span>]: `</span> + <span class="string">&#x27;请求数据大小超出允许的5M限制，无法进行防重复提交验证。&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> sessionObj = cache.<span class="property">session</span>.<span class="title function_">getJSON</span>(<span class="string">&#x27;sessionObj&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (sessionObj === <span class="literal">undefined</span> || sessionObj === <span class="literal">null</span> || sessionObj === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">      cache.<span class="property">session</span>.<span class="title function_">setJSON</span>(<span class="string">&#x27;sessionObj&#x27;</span>, requestObj)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> s_url = sessionObj.<span class="property">url</span>;                  <span class="comment">// 请求地址</span></span><br><span class="line">      <span class="keyword">const</span> s_data = sessionObj.<span class="property">data</span>;                <span class="comment">// 请求数据</span></span><br><span class="line">      <span class="keyword">const</span> s_time = sessionObj.<span class="property">time</span>;                <span class="comment">// 请求时间</span></span><br><span class="line">      <span class="keyword">const</span> interval = <span class="number">1000</span>;                         <span class="comment">// 间隔时间(ms)，小于此时间视为重复提交</span></span><br><span class="line">      <span class="keyword">if</span> (s_data === requestObj.<span class="property">data</span> &amp;&amp; requestObj.<span class="property">time</span> - s_time &lt; interval &amp;&amp; s_url === requestObj.<span class="property">url</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> message = <span class="string">&#x27;数据正在处理，请勿重复提交&#x27;</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`[<span class="subst">$&#123;s_url&#125;</span>]: `</span> + message)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(message))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cache.<span class="property">session</span>.<span class="title function_">setJSON</span>(<span class="string">&#x27;sessionObj&#x27;</span>, requestObj)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>前置拦截器完成功能：</p>
<ol>
<li>在请求头中添加token</li>
<li>get请求映射params参数</li>
<li>阻止重复请求重复提交（虽然前端做了，但一般后台也需要做借口幂等性校验）</li>
</ol>
<h4 id="6-2-响应拦截器"><a href="#6-2-响应拦截器" class="headerlink" title="6.2 响应拦截器"></a>6.2 响应拦截器</h4><p>响应拦截器也在<code>request.js</code>文件中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 未设置状态码则默认成功状态</span></span><br><span class="line">    <span class="keyword">const</span> code = res.<span class="property">data</span>.<span class="property">code</span> || <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 获取错误信息</span></span><br><span class="line">    <span class="keyword">const</span> msg = errorCode[code] || res.<span class="property">data</span>.<span class="property">msg</span> || errorCode[<span class="string">&#x27;default&#x27;</span>]</span><br><span class="line">    <span class="comment">// 二进制数据则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">request</span>.<span class="property">responseType</span> ===  <span class="string">&#x27;blob&#x27;</span> || res.<span class="property">request</span>.<span class="property">responseType</span> ===  <span class="string">&#x27;arraybuffer&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.<span class="property">data</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (code === <span class="number">401</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isRelogin.<span class="property">show</span>) &#123;</span><br><span class="line">        isRelogin.<span class="property">show</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="title class_">MessageBox</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;登录状态已过期，您可以继续留在该页面，或者重新登录&#x27;</span>, <span class="string">&#x27;系统提示&#x27;</span>, &#123; <span class="attr">confirmButtonText</span>: <span class="string">&#x27;重新登录&#x27;</span>, <span class="attr">cancelButtonText</span>: <span class="string">&#x27;取消&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span> &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          isRelogin.<span class="property">show</span> = <span class="literal">false</span>;</span><br><span class="line">          store.<span class="title function_">dispatch</span>(<span class="string">&#x27;LogOut&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            location.<span class="property">href</span> = <span class="string">&#x27;/index&#x27;</span>;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        isRelogin.<span class="property">show</span> = <span class="literal">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;无效的会话，或者会话已过期，请重新登录。&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">500</span>) &#123;</span><br><span class="line">      <span class="title class_">Message</span>(&#123; <span class="attr">message</span>: msg, <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span> &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(msg))</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">601</span>) &#123;</span><br><span class="line">      <span class="title class_">Message</span>(&#123; <span class="attr">message</span>: msg, <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span> &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code !== <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="title class_">Notification</span>.<span class="title function_">error</span>(&#123; <span class="attr">title</span>: msg &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res.<span class="property">data</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span> + error)</span><br><span class="line">    <span class="keyword">let</span> &#123; message &#125; = error;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="string">&quot;Network Error&quot;</span>) &#123;</span><br><span class="line">      message = <span class="string">&quot;后端接口连接异常&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.<span class="title function_">includes</span>(<span class="string">&quot;timeout&quot;</span>)) &#123;</span><br><span class="line">      message = <span class="string">&quot;系统接口请求超时&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.<span class="title function_">includes</span>(<span class="string">&quot;Request failed with status code&quot;</span>)) &#123;</span><br><span class="line">      message = <span class="string">&quot;系统接口&quot;</span> + message.<span class="title function_">substr</span>(message.<span class="property">length</span> - <span class="number">3</span>) + <span class="string">&quot;异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Message</span>(&#123; <span class="attr">message</span>: message, <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>, <span class="attr">duration</span>: <span class="number">5</span> * <span class="number">1000</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="6-2-后端拦截器"><a href="#6-2-后端拦截器" class="headerlink" title="6.2 后端拦截器"></a>6.2 后端拦截器</h4><p>路径：<code>ruoyi-framework/src/main/java/com/ruoyi/framework/interceptor/RepeatSubmitInterceptor.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ruoyi.framework.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson2.JSON;</span><br><span class="line"><span class="keyword">import</span> com.ruoyi.common.annotation.RepeatSubmit;</span><br><span class="line"><span class="keyword">import</span> com.ruoyi.common.core.domain.AjaxResult;</span><br><span class="line"><span class="keyword">import</span> com.ruoyi.common.utils.ServletUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防止重复提交拦截器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ruoyi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RepeatSubmitInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();</span><br><span class="line">            <span class="type">RepeatSubmit</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(RepeatSubmit.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.isRepeatSubmit(request, annotation))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">AjaxResult</span> <span class="variable">ajaxResult</span> <span class="operator">=</span> AjaxResult.error(annotation.message());</span><br><span class="line">                    ServletUtils.renderString(response, JSON.toJSONString(ajaxResult));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证是否重复提交由子类实现具体的防重复提交的规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation 防重复注解参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isRepeatSubmit</span><span class="params">(HttpServletRequest request, RepeatSubmit annotation)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-登录流程"><a href="#7-登录流程" class="headerlink" title="7.登录流程"></a>7.登录流程</h2><p>登录流程图：</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240123090704845.png" alt="image-20240123090704845" style="zoom:50%;" />

<h4 id="7-1-登录技术栈分析"><a href="#7-1-登录技术栈分析" class="headerlink" title="7.1 登录技术栈分析"></a>7.1 登录技术栈分析</h4><p>上述流程中，登录成功后，最后会给前端返回一个token，会调用TokenService的createToken方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*位置： ruoyi-framework/src/main/java/com/ruoyi/framework/web/service/TokenService.java */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建令牌</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginUser 用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 令牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(LoginUser loginUser)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> IdUtils.fastUUID();</span><br><span class="line">    loginUser.setToken(token);</span><br><span class="line">    setUserAgent(loginUser);</span><br><span class="line">    refreshToken(loginUser);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(Constants.LOGIN_USER_KEY, token);</span><br><span class="line">    <span class="keyword">return</span> createToken(claims);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据声明生成令牌</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> claims 数据声明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 令牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">createToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">            .setClaims(claims)</span><br><span class="line">            .signWith(SignatureAlgorithm.HS512, secret).compact();</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上<code>createToken</code>方法就是采用JWT的方式生成令牌返回给前端</p>
<h4 id="7-2-token校验"><a href="#7-2-token校验" class="headerlink" title="7.2 token校验"></a>7.2 token校验</h4><p>登录成功后，我们每一个请求到后台时，都需要对token进行权限校验，若依框架对token的校验是用过滤器实现的</p>
<p>过滤器位置：<code>ruoyi-framework/src/main/java/com/ruoyi/framework/security/filter/JwtAuthenticationTokenFilter.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ruoyi.framework.security.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.WebAuthenticationDetailsSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;</span><br><span class="line"><span class="keyword">import</span> com.ruoyi.common.core.domain.model.LoginUser;</span><br><span class="line"><span class="keyword">import</span> com.ruoyi.common.utils.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> com.ruoyi.common.utils.StringUtils;</span><br><span class="line"><span class="keyword">import</span> com.ruoyi.framework.web.service.TokenService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * token过滤器 验证token有效性</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ruoyi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenService tokenService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> tokenService.getLoginUser(request);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotNull(loginUser) &amp;&amp; StringUtils.isNull(SecurityUtils.getAuthentication()))</span><br><span class="line">        &#123;</span><br><span class="line">            tokenService.verifyToken(loginUser);</span><br><span class="line">            <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">            authenticationToken.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>getLoginUser</code>方法作用：</p>
<ol>
<li>从请求头中获取到<code>token</code>，然后解析得到我们设置进去的<code>UUID</code></li>
<li>然后再以<code>UUID</code>作为<code>key</code>去<code>Redis</code>中获取到登录账号信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 位置：ruoyi-framework/src/main/java/com/ruoyi/framework/web/service/TokenService.java */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取用户身份信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> LoginUser <span class="title function_">getLoginUser</span><span class="params">(HttpServletRequest request)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取请求携带的令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getToken(request);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(token))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> parseToken(token);</span><br><span class="line">            <span class="comment">// 解析对应的权限以及用户信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> (String) claims.get(Constants.LOGIN_USER_KEY);</span><br><span class="line">            <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> getTokenKey(uuid);</span><br><span class="line">            <span class="type">LoginUser</span> <span class="variable">user</span> <span class="operator">=</span> redisCache.getCacheObject(userKey);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            log.error(<span class="string">&quot;获取用户信息异常&#x27;&#123;&#125;&#x27;&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>verifyToken</code>方法作用：校验令牌超时时间和当前时间的差值，如果小于20分钟的话，就会刷新令牌的超时时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证令牌有效期，相差不足20分钟，自动刷新缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginUser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 令牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">verifyToken</span><span class="params">(LoginUser loginUser)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">expireTime</span> <span class="operator">=</span> loginUser.getExpireTime();</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (expireTime - currentTime &lt;= MILLIS_MINUTE_TEN)</span><br><span class="line">    &#123;</span><br><span class="line">        refreshToken(loginUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-按钮权限控制"><a href="#8-按钮权限控制" class="headerlink" title="8.按钮权限控制"></a>8.按钮权限控制</h2><p>若依框架不仅对菜单实现了权限控制，还对按钮实现了权限控制。</p>
<h4 id="8-1-前端"><a href="#8-1-前端" class="headerlink" title="8.1 前端"></a>8.1 前端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-row :gutter=&quot;10&quot; class=&quot;mb8&quot;&gt;</span><br><span class="line">    &lt;el-col :span=&quot;1.5&quot;&gt;</span><br><span class="line">      &lt;el-button</span><br><span class="line">        type=&quot;primary&quot;</span><br><span class="line">        plain</span><br><span class="line">        icon=&quot;el-icon-plus&quot;</span><br><span class="line">        size=&quot;mini&quot;</span><br><span class="line">        @click=&quot;handleAdd&quot;</span><br><span class="line">        v-hasPermi=&quot;[&#x27;system:user:add&#x27;]&quot;</span><br><span class="line">      &gt;新增&lt;/el-button&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line">    &lt;el-col :span=&quot;1.5&quot;&gt;</span><br><span class="line">      &lt;el-button</span><br><span class="line">        type=&quot;success&quot;</span><br><span class="line">        plain</span><br><span class="line">        icon=&quot;el-icon-edit&quot;</span><br><span class="line">        size=&quot;mini&quot;</span><br><span class="line">        :disabled=&quot;single&quot;</span><br><span class="line">        @click=&quot;handleUpdate&quot;</span><br><span class="line">        v-hasPermi=&quot;[&#x27;system:user:edit&#x27;]&quot;</span><br><span class="line">      &gt;修改&lt;/el-button&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line">     &lt;el-col :span=&quot;1.5&quot;&gt;</span><br><span class="line">      &lt;el-button</span><br><span class="line">        type=&quot;danger&quot;</span><br><span class="line">        plain</span><br><span class="line">        icon=&quot;el-icon-delete&quot;</span><br><span class="line">        size=&quot;mini&quot;</span><br><span class="line">        :disabled=&quot;multiple&quot;</span><br><span class="line">        @click=&quot;handleDelete&quot;</span><br><span class="line">        v-hasPermi=&quot;[&#x27;system:user:remove&#x27;]&quot;</span><br><span class="line">      &gt;删除&lt;/el-button&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line">    &lt;el-col :span=&quot;1.5&quot;&gt;</span><br><span class="line">      &lt;el-button</span><br><span class="line">        type=&quot;info&quot;</span><br><span class="line">        plain</span><br><span class="line">        icon=&quot;el-icon-upload2&quot;</span><br><span class="line">        size=&quot;mini&quot;</span><br><span class="line">        @click=&quot;handleImport&quot;</span><br><span class="line">        v-hasPermi=&quot;[&#x27;system:user:import&#x27;]&quot;</span><br><span class="line">      &gt;导入&lt;/el-button&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line">    &lt;el-col :span=&quot;1.5&quot;&gt;</span><br><span class="line">      &lt;el-button</span><br><span class="line">        type=&quot;warning&quot;</span><br><span class="line">        plain</span><br><span class="line">        icon=&quot;el-icon-download&quot;</span><br><span class="line">        size=&quot;mini&quot;</span><br><span class="line">        @click=&quot;handleExport&quot;</span><br><span class="line">        v-hasPermi=&quot;[&#x27;system:user:export&#x27;]&quot;</span><br><span class="line">      &gt;导出&lt;/el-button&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line">    &lt;right-toolbar :showSearch.sync=&quot;showSearch&quot; @queryTable=&quot;getList&quot; :columns=&quot;columns&quot;&gt;&lt;/right-toolbar&gt;</span><br><span class="line">  &lt;/el-row&gt;</span><br></pre></td></tr></table></figure>

<p>很多按钮都有<code>v-hasPermi=&quot;[&#39;xxx:xxx:xxx&#39;]&quot;</code>，<code>v-hasPermi</code>是<code>vue</code>的自定义指令，属性值就是创建按钮时定义的权限标志。</p>
<p>其定义在<code>ruoyi-ui/src/directive/permission/hasPermi.js</code>文件中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * v-hasPermi 操作权限处理</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2019 ruoyi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = binding</span><br><span class="line">    <span class="keyword">const</span> all_permission = <span class="string">&quot;*:*:*&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> permissions = store.<span class="property">getters</span> &amp;&amp; store.<span class="property">getters</span>.<span class="property">permissions</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; value <span class="keyword">instanceof</span> <span class="title class_">Array</span> &amp;&amp; value.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> permissionFlag = value</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> hasPermissions = permissions.<span class="title function_">some</span>(<span class="function"><span class="params">permission</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> all_permission === permission || permissionFlag.<span class="title function_">includes</span>(permission)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!hasPermissions) &#123;</span><br><span class="line">        el.<span class="property">parentNode</span> &amp;&amp; el.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`请设置操作权限标签值`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-2-后端"><a href="#8-2-后端" class="headerlink" title="8.2 后端"></a>8.2 后端</h4><h5 id="8-2-1-接口权限"><a href="#8-2-1-接口权限" class="headerlink" title="8.2.1 接口权限"></a>8.2.1 接口权限</h5><p>在<code>controller</code>中随便找一个接口为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取菜单列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;system:menu:list&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> AjaxResult <span class="title function_">list</span><span class="params">(SysMenu menu)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;SysMenu&gt; menus = menuService.selectMenuList(menu, getUserId());</span><br><span class="line">    <span class="keyword">return</span> success(menus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现其中有这样一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;system:menu:list&#x27;)&quot;)</span></span><br></pre></td></tr></table></figure>

<p>进入<code>hasPermi</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 路径：ruoyi-framework/src/main/java/com/ruoyi/framework/web/service/PermissionService.java */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证用户是否具备某权限</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permission 权限字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 用户是否具备某权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPermi</span><span class="params">(String permission)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(permission))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> SecurityUtils.getLoginUser();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNull(loginUser) || CollectionUtils.isEmpty(loginUser.getPermissions()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PermissionContextHolder.setContext(permission);</span><br><span class="line">    <span class="keyword">return</span> hasPermissions(loginUser.getPermissions(), permission);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码逻辑如下：</p>
<ol>
<li>通过<code>SecurityUtils</code>工具类从<code>Security</code>上下文中获取到登录用户信息</li>
<li>然后从用户信息中获取到该用户所拥有的权限字符串集合</li>
<li>然后做对比，看其中是否包含【@ss.hasPermi(‘system:menu:list’)】中的权限字符串</li>
<li>包含就可以访问该方法，不包含就不可以访问该方法</li>
</ol>
<h3 id="权限方法"><a href="#权限方法" class="headerlink" title="权限方法"></a>权限方法</h3><p><code>@PreAuthorize</code>注解用于配置接口要求用户拥有某些权限才可访问，它拥有如下方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hasPermi</td>
<td>String</td>
<td>验证用户是否具备某权限</td>
</tr>
<tr>
<td>lacksPermi</td>
<td>String</td>
<td>验证用户是否不具备某权限，与 hasPermi逻辑相反</td>
</tr>
<tr>
<td>hasAnyPermi</td>
<td>String</td>
<td>验证用户是否具有以下任意一个权限</td>
</tr>
<tr>
<td>hasRole</td>
<td>String</td>
<td>判断用户是否拥有某个角色</td>
</tr>
<tr>
<td>lacksRole</td>
<td>String</td>
<td>验证用户是否不具备某角色，与 isRole逻辑相反</td>
</tr>
<tr>
<td>hasAnyRoles</td>
<td>String</td>
<td>验证用户是否具有以下任意一个角色，多个逗号分隔</td>
</tr>
</tbody></table>
<p><a href="https://doc.ruoyi.vip/ruoyi-vue/document/htsc.html#%E6%9D%83%E9%99%90%E6%B3%A8%E8%A7%A3">详细信息</a></p>
<h5 id="8-2-1-数据权限"><a href="#8-2-1-数据权限" class="headerlink" title="8.2.1 数据权限"></a>8.2.1 数据权限</h5><p><a href="https://doc.ruoyi.vip/ruoyi/document/htsc.html#%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90">文档内容</a></p>
<h2 id="9-项目实战"><a href="#9-项目实战" class="headerlink" title="9. 项目实战"></a>9. 项目实战</h2><p><strong>项目背景和需求说明</strong></p>
<p>学生成绩管理系统</p>
<ul>
<li><p>对学校的【课程信息】和【分数信息】进行管理</p>
</li>
<li><p>老师角色的人登录系统后，可以对【课程信息】和【分数信息】进行维护，进行增删改查</p>
</li>
<li><p>学生角色的人登录系统后，可以查看【课程信息】和【分数信息】，但是不能进行修改和删除操作就这么一个简单的需求，接下来，我们看看利用若依框架，如何快速的进行开发</p>
</li>
</ul>
<p><strong>项目表结构分析</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_score`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_score` (</span><br><span class="line">	`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">	`create_time` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">	`create_user_name` <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人姓名&#x27;</span>,</span><br><span class="line">	`course_id` <span class="type">BIGINT</span>(<span class="number">2</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程ID&#x27;</span>,</span><br><span class="line">	`user_id` <span class="type">BIGINT</span>(<span class="number">1</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">	`score` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分数&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> key(`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;分数表&#x27;</span> ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"></span><br><span class="line"><span class="comment">---------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_course`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_course` (</span><br><span class="line">	`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">	`create_time` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">	`create_user_name` <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人姓名&#x27;</span>,</span><br><span class="line">	`course_name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程名称&#x27;</span>,</span><br><span class="line">	`course_status` <span class="type">INT</span>(<span class="number">1</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程状态（1:不可用；2:可用）&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> key(`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;课程表&#x27;</span> ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p><strong>代码生成</strong></p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240123143822327.png" alt="image-20240123143822327" style="zoom:50%;" />



<p>选择 “生成代码” 按钮，即可下载生成好的代码。</p>
<p><strong>拷贝代码到项目中并测试</strong></p>
<p>① 后端代码 - <code>位置：main/java</code></p>
<p>分为四个文件夹<code>controller</code>、<code>domain</code>、<code>mapper</code>、<code>service</code></p>
<ol>
<li><p><code>domain</code>实体类，拷贝放置位置<code>ruoyi-system/src/main/java/com/ruoyi/system/domain</code></p>
</li>
<li><p><code>mapper</code>，拷贝放置位置<code>ruoyi-system/src/main/java/com/ruoyi/system/mapper</code></p>
</li>
<li><p><code>service</code>，拷贝放置位置<code>ruoyi-system/src/main/java/com/ruoyi/system/service</code></p>
</li>
<li><p><code>mapper.xml</code>，拷贝放置位置<code>ruoyi-system/src/main/resources/mapper/system</code></p>
</li>
<li><p><code>controller</code>，拷贝放置位置<code>ruoyi-admin/src/main/java/com/ruoyi/web/controller/system</code></p>
</li>
</ol>
<p>② 前端代码 - <code>位置：vue</code></p>
<p>分为两个文件夹<code>api</code>、<code>views</code></p>
<ol>
<li><code>api下的js文件</code>，拷贝放置位置<code>RUOYI-UI/src/api/system</code></li>
<li><code>views下的vue文件</code>，拷贝放置位置<code>RUOYI-UI/src/views/system</code>，一般需要带着文件夹，例如<code>hourdb/index.vue</code></li>
</ol>
<p>③ 执行sql文件，完成菜单生成</p>
<p>在<code>ry-vue</code>下执行即可，执行完成后，可在<code>sys_menu</code>下查看生成的菜单数据</p>
<p>④ 执行maven - compile</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2024/01/18/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-Docker概述"><a href="#1-Docker概述" class="headerlink" title="1.Docker概述"></a>1.Docker概述</h2><h4 id="1-1-Docker-为什么会出现？"><a href="#1-1-Docker-为什么会出现？" class="headerlink" title="1.1 Docker 为什么会出现？"></a>1.1 Docker 为什么会出现？</h4><ol>
<li><p>一款产品从开发到上线，一般至少有开发 /上线 两套环境！每套环境的配置都不同。</p>
</li>
<li><p>开发与运维之间的难题：我在自己电脑上可以运行，版本更新导致服务不可用……</p>
</li>
<li><p>环境配置十分麻烦，每一台机器都要部署环境（集群Redis、ES、Hadoop……）</p>
</li>
<li><p>发布一个项目（jar包 + Redis\Mysql\jdk\ES…），项目带上环境安装打包</p>
</li>
<li><p>之前在服务器上配置一个应用环境 Redis、jdk、ES、Hadoop，配置十分麻烦，且不能够跨平台</p>
</li>
</ol>
<p>Docker给以上问题提出了解决方案！！</p>
<p>流程：java项目 – jar+环境 – 打包项目带上环境（镜像） –  发布到Docker仓库：商店 – 下载发布的镜像 – 直接运行即可</p>
<p>Docker的思想来源于集装箱，通过隔离机制，可以将服务器利用到极致。</p>
<h4 id="1-2-Docker历史"><a href="#1-2-Docker历史" class="headerlink" title="1.2 Docker历史"></a>1.2 Docker历史</h4><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240104155418100.png" alt="image-20240104155418100" style="zoom:50%;" />

<p>Docker是基于Go语言开发的。</p>
<p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>文档：<a href="https://docs.docker.com/get-started/overview/">https://docs.docker.com/get-started/overview/</a></p>
<p>DockerHub：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h4 id="1-3-Docker能做什么？"><a href="#1-3-Docker能做什么？" class="headerlink" title="1.3 Docker能做什么？"></a>1.3 Docker能做什么？</h4><p>== 虚拟机技术 ==</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240104160406126.png" alt="image-20240104160406126" style="zoom:50%;" />

<p><strong>虚拟机技术存在的缺点：</strong></p>
<p>1.资源占用非常多</p>
<p>2.冗余步骤多</p>
<p>3.启动很慢</p>
<p>== 容器化技术 ==</p>
<p><span style="color:red;">容器化技术不是模拟一个完整的操作系统！！</span></p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240104161511514.png" alt="image-20240104161511514" style="zoom:50%;" />

<p>比较Docker和虚拟机技术的不同：</p>
<ul>
<li>传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器内的应用是直接运行在宿主机的内核，容器是没有自己的内核，也没有虚拟硬件，所以轻便</li>
<li>每个容器间是相互隔离的，每个容器内都有一个属于自己的文件系统，互不影响</li>
</ul>
<p>== DevOps（开发、运维）==</p>
<p><strong>应用更快速交付和部署</strong></p>
<p>传统：一堆文件，安装程序</p>
<p>Docker：打包镜像发布测试，一键运行</p>
<p><strong>更便捷的升级和扩缩容</strong></p>
<p>使用Docker后，部署应用像是搭积木一样</p>
<p><strong>更简单的系统运维</strong></p>
<p>在容器化之后，开发和测试环境高度一致</p>
<p><strong>更高效的计算资源利用</strong></p>
<p>Docker是内核级别的虚拟化</p>
<h2 id="2-Docker安装"><a href="#2-Docker安装" class="headerlink" title="2.Docker安装"></a>2.Docker安装</h2><h4 id="2-1-Docker的基本组成"><a href="#2-1-Docker的基本组成" class="headerlink" title="2.1 Docker的基本组成"></a>2.1 Docker的基本组成</h4><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/1912698-20201229222645994-415295107.png" alt="img" style="zoom:50%;" />

<p><strong>镜像（image）</strong>：Docker镜像就好比是一个模板，可通过这个模板来创建容器服务。通过一个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中）。</p>
<p><strong>容器（container）</strong>：Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。</p>
<p><strong>仓库（repository）</strong>：存放镜像的地方。仓库分为公有仓库和私有仓库。</p>
<h4 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h4><p>1.环境查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240104165041325.png" alt="image-20240104165041325" style="zoom:50%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240104165225937.png" alt="image-20240104165225937" style="zoom:50%;" />

<p>2.安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1.卸载旧版本Docker</span></span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2.需要的安装包</span></span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3.设置镜像的仓库</span></span></span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （国内镜像地址）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 4.安装Docker引擎 ce-社区版  ee-企业版</span></span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># tips:更新yum软件包索引</span></span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 5.启动Docker</span></span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 6.方法一：判断是否安装成功</span></span></span><br><span class="line">docker -v</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 6.方法二：判断是否安装成功</span></span></span><br><span class="line">sudo docker run hello-world</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 7.查看安装的hello-world镜像</span></span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 8.卸载Docker</span></span></span><br><span class="line">sudo yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras</span><br><span class="line">sudo rm -rf /var/lib/docker #Docker的默认工作路径：/var/lib/docker</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<h4 id="2-3-run流程和Docker原理"><a href="#2-3-run流程和Docker原理" class="headerlink" title="2.3 run流程和Docker原理"></a>2.3 run流程和Docker原理</h4><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240105104710214.png" alt="image-20240105104710214" style="zoom:50%;" />

<h4 id="2-4-底层原理"><a href="#2-4-底层原理" class="headerlink" title="2.4 底层原理"></a>2.4 底层原理</h4><p><strong>Docker是怎么工作的？</strong></p>
<p>Docker是一个Client- Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问。Docker Server接收到Docker Client的指令，就会执行这个命令。</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240105111556497.png" alt="image-20240105111556497" style="zoom:50%;" />

<p><strong>Docker为什么比VM快？</strong></p>
<ul>
<li>Docker有着比虚拟机更少的抽象层</li>
<li>Docker利用的是宿主机的内核,而不需要加载操作系统OS内核：<em>当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核，进而避免引寻、加载操作系统内核返回等比较费时费资源的过程。</em></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/bec855a4f0634c52a80ee604e760234a-20240105111842805.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240105112010205.png" alt="image-20240105112010205"></p>
<h2 id="3-Docker命令"><a href="#3-Docker命令" class="headerlink" title="3.Docker命令"></a>3.Docker命令</h2><h3 id="3-1帮助命令"><a href="#3-1帮助命令" class="headerlink" title="3.1帮助命令"></a>3.1帮助命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version      # 显示docker版本信息</span><br><span class="line">docker info         # 显示docker系统信息，包括镜像和容器</span><br><span class="line">docker 命令 --help   # 帮助命令</span><br></pre></td></tr></table></figure>

<h3 id="3-2镜像命令"><a href="#3-2镜像命令" class="headerlink" title="3.2镜像命令"></a>3.2镜像命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images  # 查看本地主机上的镜像</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240105112846850.png" alt="image-20240105112846850"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search 镜像名称   # 搜索镜像</span><br><span class="line">-----</span><br><span class="line">docker pull 镜像名称     # 下载镜像，`docker pull`默认拉取最新版的镜像</span><br><span class="line">docker pull 镜像名称:版本号 #下载指定版本镜像，例如：docker pull mysql:5.7</span><br><span class="line">------</span><br><span class="line">docker rmi -f 容器ID    # 删除指定容器 </span><br><span class="line">docker rmi -f 容器ID 容器ID 容器ID   # 删除多个容器</span><br><span class="line">docker rmi -f $(docker images -aq) # 删除全部容器</span><br></pre></td></tr></table></figure>

<h3 id="3-3容器命令"><a href="#3-3容器命令" class="headerlink" title="3.3容器命令"></a>3.3容器命令</h3><p>说明：有了镜像才可以创建容器。</p>
<p>以下载一个CentOS镜像来测试学习</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建容器并启动</span></span><br><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#参数说明：</span></span></span><br><span class="line">  --name=&quot;Name&quot; 容器名称 tomcat01，tomcat02，用来区分容器</span><br><span class="line">  -d            后台方式运行</span><br><span class="line">  -it           使用交互方式运行</span><br><span class="line">  -p            指定容器的端口 -p 8080:8080</span><br><span class="line">  	-p ip:主机端口:容器端口</span><br><span class="line">  	-p 主机端口:容器端口 （最常使用方式）</span><br><span class="line">  	-p 容器端口</span><br><span class="line">  	容器端口</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 测试：启动并进入容器</span></span></span><br><span class="line">[root@localhost ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@9dcaa54373de /]# ls  # 查看容器内的centos </span><br><span class="line">[root@9dcaa54373de /]# exit #退出容器</span><br></pre></td></tr></table></figure>

<p><strong>列出所有运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps      # 列出当前正在运行的容器</span><br><span class="line">docker ps -a   # 列出所有运行的容器，包括历史运行过的容器</span><br><span class="line">docker ps -aq  # 只列出所有运行的容器的编号，包括历史运行过的容器</span><br></pre></td></tr></table></figure>

<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit  # 直接退出容器</span><br><span class="line">Ctrl + p + q  # 容器不停止退出</span><br></pre></td></tr></table></figure>

<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器ID    # 删除指定容器，不能删除正在运行的容器。如果要强制删除使用rm -f</span><br><span class="line">docker rm -f $(docker ps -aq) # 删除全部容器</span><br><span class="line">docker ps -a -q|xargs docker rm  # 删除全部容器</span><br></pre></td></tr></table></figure>

<p><strong>启动和停止容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器ID     # 启动容器</span><br><span class="line">docker restart 容器ID   # 重启容器</span><br><span class="line">docker stop 容器ID      # 停止当前正在运行容器</span><br><span class="line">docker kill 容器ID      # 强制停止当前容器 </span><br></pre></td></tr></table></figure>

<h3 id="3-4常用其他命令"><a href="#3-4常用其他命令" class="headerlink" title="3.4常用其他命令"></a>3.4常用其他命令</h3><p>后台启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker run -d 镜像名</span></span><br><span class="line">docker run -d centos</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--问题是docker ps 后发现centos停止了</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#--常见的坑：docker 容器使用后台运行，就必须要有一个前台进程。Docker发现没有应用，就会自动停止</span></span></span><br></pre></td></tr></table></figure>

<p>查看日志命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -tf --tail 显示日志条数  # 容器，没有日志</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自己编写一段shell脚本</span></span><br><span class="line">docker run -d centos /bin/bash -c &quot;while true;do echo Hello World;sleep 1;done&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line">---</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                   CREATED         STATUS         PORTS     NAMES</span><br><span class="line">e2e8c5e2d761   centos    &quot;/bin/bash -c &#x27;while…&quot;   5 seconds ago   Up 4 seconds             cool_neumann</span><br><span class="line">---</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示日志</span></span><br><span class="line">-tf   # 显示日志</span><br><span class="line">-tail number  # 显示日志条数</span><br><span class="line">docker logs -tf --tail 10 e2e8c5e2d761</span><br></pre></td></tr></table></figure>

<p>查看容器中的进程信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure>

<p>查看镜像元数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

<p>进入当前正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常容器都是使用后台方式运行的，有时候需要进入到容器，修改一些配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式一</span></span><br><span class="line">docker exec -it 容器id bashshell</span><br><span class="line">docker exec -it e2e8c5e2d761 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二</span></span><br><span class="line">docker attach 容器id  # 显示正在执行的当前代码</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 二者区别：</span></span></span><br><span class="line">docker exec   # 进入容器后开启一个新的终端，可以在里面进行操作</span><br><span class="line">docker attach  # 进入容器正在执行的专断，不会启动新的进程</span><br></pre></td></tr></table></figure>

<p>从容器内拷贝文件到主机上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器id:容器内路径 目的主机路径</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 示例：</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">[root@localhost ~]# docker exec -it e2e8c5e2d761 /bin/bash</span><br><span class="line">[root@e2e8c5e2d761 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在容器中创建test.java</span></span><br><span class="line">[root@e2e8c5e2d761 /]# touch test.java</span><br><span class="line">[root@e2e8c5e2d761 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  test.java  tmp  usr  var</span><br><span class="line">[root@e2e8c5e2d761 /]# pwd</span><br><span class="line">/</span><br><span class="line">[root@e2e8c5e2d761 /]# mv test.java /home</span><br><span class="line">[root@e2e8c5e2d761 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@e2e8c5e2d761 /]# cd /home</span><br><span class="line">[root@e2e8c5e2d761 home]# ls</span><br><span class="line">test.java</span><br><span class="line">[root@e2e8c5e2d761 home]# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg  Desktop  initial-setup-ks.cfg  公共  模板  视频  图片  文档  下载  音乐</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将容器中的test.java拷贝到主机上</span></span><br><span class="line">[root@localhost Desktop]# docker cp e2e8c5e2d761:/home/test.java /home</span><br><span class="line">Successfully copied 1.54kB to /home</span><br><span class="line">[root@localhost Desktop]# cd /home</span><br><span class="line">[root@localhost home]# ls</span><br><span class="line">mysql  qinwei  test.java</span><br></pre></td></tr></table></figure>

<h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/70.png" alt="img"></p>
<p><strong>作业练习</strong></p>
<p><strong>1.使用Docker安装Nginx</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.搜索Nginx</span></span><br><span class="line">docker search nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.下载镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.运行测试</span></span><br><span class="line">docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#参数说明：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## -d 后台运行</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## --name 给容器重命名</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## -p 宿主机端口:容器内部端口</span></span></span><br></pre></td></tr></table></figure>

<p>端口暴露概念：</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240108141601418.png" alt="image-20240108141601418" style="zoom: 33%;" />

<p><strong>🤔️思考问题</strong>：对于部署在容器中的Nginx，每次修改配置都需要进入到容器中去修改，能否在容器外部对容器内的Nginx配置文件进行修改？</p>
<p><strong>2.使用Docker安装tomcat</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式一：官方的使用</span></span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们之前的启动都是后台启动，停止容器后，还可以查询到。docker run -it --<span class="built_in">rm</span>，一般用来测试，用完就删除</span></span><br><span class="line">----------------</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载tomcat</span></span><br><span class="line">docker pull tomcat:9.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行tomcat</span></span><br><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat:9.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器查看tomcat目录</span></span><br><span class="line">docker exec -it tomcat01 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#发现问题：1.Linux命令少了；2.webapps目录下没有内容。原因：默认使用的是最小的镜像，所有不必要的内容都进行了剔除。保证最小可运行环境即可。</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可通过复制webapps.dist的内容到websapps实现访问内容呈现</span></span><br><span class="line">cp -r webapps.dist/* webapps</span><br></pre></td></tr></table></figure>

<p><strong>🤔️思考问题</strong>：以后部署项目，如果每次都进入到容器中十分麻烦，如果可以在容器外部提供一个映射路径，在外部放置项目，自动同步到内部就好了！</p>
<p><strong>3.部署es + kibana</strong></p>
<p>存在问题1：</p>
<ul>
<li>es 暴露的端口很多</li>
<li>es十分耗内存</li>
<li>es的数据一般需要放置在安全目录，通过挂载方式使用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 elasticsearch</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.8.0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># --net somenetwork 网络配置</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加内存限制，修改配置文件 -e 环境配置修改</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xms512m&quot; elasticsearch:7.8.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试是否运行成功</span></span><br><span class="line">curl localhost:9200</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240109101056368.png" alt="image-20240109101056368"></p>
<p>查看docker的CPU状态：<code>docker stats</code></p>
<p><strong>🤔️思考问题</strong>：使用kibana连接es?思考网络如何才能连接过去 </p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240109101535771.png" alt="image-20240109101535771"></p>
<h2 id="4-Docker可视化面板"><a href="#4-Docker可视化面板" class="headerlink" title="4.Docker可视化面板"></a>4.Docker可视化面板</h2><p><strong>portainer</strong></p>
<p>portainer是Doker的图形化界面管理工具，提供一个后台面板，方便操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /dockerData/portainer:/data --restart=always --name portainer portainer/portainer</span><br></pre></td></tr></table></figure>

<p>访问：http:ip地址:9000【首次登录需要设置密码】</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240109103445122.png" alt="image-20240109103445122" style="zoom:50%;" />

<p>PS：平时不会使用。</p>
<h2 id="5-Docker镜像讲解"><a href="#5-Docker镜像讲解" class="headerlink" title="5.Docker镜像讲解"></a>5.Docker镜像讲解</h2><h3 id="5-1-什么是镜像？"><a href="#5-1-什么是镜像？" class="headerlink" title="5.1 什么是镜像？"></a>5.1 什么是镜像？</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的所有内容，包括代码、运行时、库、环境变量和配置文件。<br>所有应用，直接打包docker镜像，就可以直接跑起来！<br>如何得到镜像：</p>
<ul>
<li>远程仓库下载</li>
<li>自行制作</li>
<li>拷贝别人制作 </li>
</ul>
<h3 id="5-2-UnionFS（联合文件系统）"><a href="#5-2-UnionFS（联合文件系统）" class="headerlink" title="5.2 UnionFS（联合文件系统）"></a>5.2 UnionFS（联合文件系统）</h3><p>UnionFS（联合文件系统）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特征：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<p><strong>镜像加载原理</strong></p>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级文件系统就是上述的UnionFS。接着，在内部又分为2部分：</p>
<ul>
<li><p>bootfs(boot file system)：docker镜像的最底层是bootfs，主要包含bootloader（加载器）和kernel（内核）。bootloader主要是引导加载kernel，linux刚启动时会加载bootfs文件系统。这一层与典型的linux/Unix系统一样，包含bootloader和kernel。当boot加载完成后，整个内核就在内存中了，此时内存的使用权已由bootfs转交给了内核，此时系统也会卸载bootfs。<br><em>这里的加载，可以理解为，我们windows电脑开机时候，从黑屏到进入操作系统的过程。</em></p>
</li>
<li><p>rootfs(root file system)：在bootfs之上，包含的就是典型linux系统中的<code>/dev、/proc、/bin、/etc</code>等标准目录和文件。<br>rootfs就是各种不同的操作系统发行版，比如Ubuntu、Centos等等。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/475fbb6fbeb7478da1bc38e94ef1b567~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240109110323515.png" alt="image-20240109110323515"></p>
<p>理解：</p>
<p>所有Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容的时候，就会在当前镜像层之上，创建新的镜像。</p>
<p>举一个简单的例子，加入基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p>
<p>该镜像层当前已经包含3个镜像层，如下图所示。</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240109111525949.png" alt="image-20240109111525949" style="zoom: 67%;" />

<p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。</p>
<p>🌰例子：每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110101432615.png" alt="image-20240110101432615"></p>
<p>上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。</p>
<p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110102007568.png" alt="image-20240110102007568"></p>
<p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p>
<p>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p>
<p>Linux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的 文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p>
<p>Docker在Windows 上仅支持 windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW［1］。 </p>
<p>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110102334495.png" alt="image-20240110102334495"></p>
<blockquote>
<p>特点：Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层就是我们通常说的容器层，容器之下的都叫镜像层。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110103749189.png" alt="image-20240110103749189"></p>
<h3 id="5-3-commit镜像"><a href="#5-3-commit镜像" class="headerlink" title="5.3 commit镜像"></a>5.3 commit镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker commit 提交容器称为一个新的副本，命令和git原理一致</span></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[tag]</span><br></pre></td></tr></table></figure>

<p>实战流程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.启动一个默认的tomcat</span> </span><br><span class="line">docker run -d -p 8080:8080 tomcat:9.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.发现这个tomcat的webapps中没有内容，拷贝进去基本文件</span></span><br><span class="line">docker exec -it cd75bd66e53d /bin/bash</span><br><span class="line">cp -r webapps.dist/* webapps</span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.将操作过的容器通过commit提交为一个镜像</span></span><br><span class="line">docker commit -m=&quot;add webapps application&quot; -a=&quot;qinwei&quot; cd75bd66e53d tomcat_temp01</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110105847098.png" alt="image-20240110105847098"></p>
<h2 id="6-容器数据卷"><a href="#6-容器数据卷" class="headerlink" title="6.容器数据卷"></a>6.容器数据卷</h2><h3 id="6-1-什么是容器数据卷"><a href="#6-1-什么是容器数据卷" class="headerlink" title="6.1 什么是容器数据卷"></a>6.1 什么是容器数据卷</h3><p>数据存在于容器中，删除容器之后，数据就会丢失！</p>
<p><span style="color:red">需求：数据持久化</span></p>
<p>容器之间数据共享的技术——Docker容器中产生的数据，同步到本地——这就是卷技术。目录的挂载，将容器内的目录挂载到Linux上面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110143341757.png" alt="image-20240110143341757"></p>
<p><strong>容器数据卷的作用是容器持久化和数据同步操作，容器间也是可以数据共享的。</strong></p>
<h3 id="6-2-使用数据卷"><a href="#6-2-使用数据卷" class="headerlink" title="6.2 使用数据卷"></a>6.2 使用数据卷</h3><h5 id="方式一：使用命令挂载"><a href="#方式一：使用命令挂载" class="headerlink" title="方式一：使用命令挂载"></a>方式一：使用命令挂载</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过命令查看容器相关信息</span></span><br><span class="line">docker inspect f780ed985de9</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110144735141.png" alt="image-20240110144735141"></p>
<p>【此时主机内的/home/test目录和docker容器内/home目录是同步的关系】</p>
<p>测试：<br>1.停止容器<br>2.宿主机上修改文件<br>3.再次启动容器查看文件内容 – 文件内容已经同步</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110145834449.png" alt="image-20240110145834449"></p>
<h5 id="实战：安装Mysql"><a href="#实战：安装Mysql" class="headerlink" title="实战：安装Mysql"></a>实战：安装Mysql</h5><p>思考：Mysql的数据持久化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.安装Mysql</span></span><br><span class="line">docker pull mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.运行容器，需要做数据挂载；注意：安装启动mysql需要配置密码</span></span><br><span class="line">docker run -d -p 3310:3306 -v /home/mysql_docker/conf:/etc/mysql/conf.d -v /home/mysql_docker/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># -d 后台运行  -p 端口映射  -v 卷挂载  -e 环境配置</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动成功之后，在本地使用数据库管理软件进行测试</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Navicat-连接到服务器3307------3307和容器内的3306映射</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设将容器删除，发现挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能！</p>
<h5 id="具名挂载与匿名挂载"><a href="#具名挂载与匿名挂载" class="headerlink" title="具名挂载与匿名挂载"></a>具名挂载与匿名挂载</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匿名挂载：</span></span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看所有volume的情况</span></span></span><br><span class="line">docker volume ls</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110160706616.png" alt="image-20240110160706616"></p>
<p>【这里发现，VOLUME NAME是一串无规律的字符串，这种就是匿名挂载，因为在<code>-v</code>后只写了容器内路径，没有写容器外路径】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具名挂载</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming_nginx:/etc/nginx nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看所有volume的情况</span></span></span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110161021355.png" alt="image-20240110161021355" style="zoom:50%;" />

<p>【通过<code>-v 卷名:容器内路径</code>可以实现具名挂载】</p>
<p>查看jumping_nginx的具体位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume inspect juming_nginx</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110161334501.png" alt="image-20240110161334501"></p>
<p>✅如何确定是具名挂载还是匿名挂载，还是指定路径挂载？</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240110164021959.png" alt="image-20240110164021959"></p>
<p>拓展：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过-v 容器内路径，ro rw 改变读写权限</span></span><br><span class="line">ro   # read-only ，只读</span><br><span class="line">rw   # read-write，可读写</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一旦设置了容器权限，容器对我们挂载出来的内容就有限定了</span></span><br><span class="line">docker run -d -P --name nginx02 -v juming_nginx:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx02 -v juming_nginx:/etc/nginx:rw nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ro 只要看到ro就说明这个路径只能通过宿主机改变，容器内部无法改变</span></span><br></pre></td></tr></table></figure>

<h2 id="7-DockerFile"><a href="#7-DockerFile" class="headerlink" title="7.DockerFile"></a>7.DockerFile</h2><h3 id="7-1-初识DockerFile"><a href="#7-1-初识DockerFile" class="headerlink" title="7.1 初识DockerFile"></a>7.1 初识DockerFile</h3><p>DockerFile是用来构建docker镜像的构建文件！本质上就是一个命令脚本。</p>
<p>通过这个脚本就可以生成镜像，镜像是一层一层的，脚本的命令是一个一个的，每个命令都是一层。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个dockerfile文件，名字可以随意 建议 Dockerfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件中的内容 指令（大写）</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line"></span><br><span class="line">CMD echo &quot;----end------&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里的每个命令，就是镜像的一层</span></span><br></pre></td></tr></table></figure>

<p>启动自己的容器</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240111143913314.png" alt="image-20240111143913314"></p>
<p>这两个数据卷一定在外部存在同步目录。</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240111144117812.png" alt="image-20240111144117812" style="zoom:50%;" />

<p>在容器volume01中创建test.txt文件（用于测试同步目录是否存在）</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240111144344738.png" alt="image-20240111144344738"></p>
<p>查看容器的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect e3ca6f259ea4</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240111150742545.png" alt="image-20240111150742545"></p>
<p>(在本机上实验未成功)</p>
<h3 id="7-2-数据卷容器"><a href="#7-2-数据卷容器" class="headerlink" title="7.2 数据卷容器"></a>7.2 数据卷容器</h3><p>例子：多个mysql同步数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240111154405704.png" alt="image-20240111154405704"></p>
<p>命令：<code>docker run -it --name docker02 --volumes-from docker01 qw/centos:1.0</code></p>
<p>通过<code>--volumes-from</code>创建的<code>docker02</code> 可以同步<code>docker01</code>中数据卷内容的变化。</p>
<p>可以通过<code>--volumes-from</code>创建的多个容器，及时删除其中一个容器，数据卷volume依旧存在，不会被删除</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240111163103740.png" alt="image-20240111163103740"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240111163309494.png" alt="image-20240111163309494"></p>
<p>结论：容器之间配置的信息传递，数据卷容器的生命周期一直持续到没有容器使用为止。一旦持久化到本地，这个时候，本地的数据是不会删除的。</p>
<h3 id="7-3-DockerFile"><a href="#7-3-DockerFile" class="headerlink" title="7.3 DockerFile"></a>7.3 DockerFile</h3><p><strong>DockerFile介绍</strong></p>
<p>DockerFile是用来构建docker镜像的构建文件！本质上就是一个命令脚本。</p>
<p>构建步骤：</p>
<p>1.编写 dockerfile 文件</p>
<p>2.docker build构建成为一个镜像</p>
<p>3.docker run运行镜像</p>
<p>4.docker push发布镜像（dockerhub、阿里云镜像仓库）</p>
<p>👍 <strong>查看官方是如何做的</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240112094117083.png" alt="image-20240112094117083"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240112094603528.png" alt="image-20240112094603528"></p>
<p>很多官方的镜像都是基础包，很多功能都没有，我们通常会自己搭建自己的镜像。</p>
<p><strong>DockerFile构建过程</strong></p>
<p>基础知识：</p>
<p>1.每个保留关键字（指令）都必须是大写字母</p>
<p>2.执行时按照从上到下顺序执行</p>
<p>3.<code>#</code>表示注释</p>
<p>4.每一个指令都会创建提交一个新的镜像层并提交</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240112100406980.png" alt="image-20240112100406980"></p>
<p>步骤：开发、部署、运维</p>
<p>DockerFile：构建文件，定义了一切的步骤，源代码</p>
<p>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行的产品</p>
<p>Docker容器：容器就是镜像运行起来提供服务的</p>
<p><strong>DockerFile指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM          # 基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER    # 镜像是谁写的：姓名+邮箱</span><br><span class="line">RUN           # 镜像构建的时候需要运行的命令</span><br><span class="line">ADD           # 添加内容</span><br><span class="line">WORKDIR       # 镜像的工作目录</span><br><span class="line">VOLUME        # 挂载的目录</span><br><span class="line">EXPOSE        # 指定暴露端口</span><br><span class="line">CMD           # 指定这个容器启动的时候要运行的命令</span><br><span class="line">ENTRYPOINT    # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line">ONBUILD       # 当构建一个被继承DockerFile这个时候就会运行ONBUILD 的指令，触发指令。</span><br><span class="line">COPY          # 类似ADD，将我们的文件拷贝到镜像中</span><br><span class="line">ENV           # 构建的时候设置环境变量</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/955fa81e43433b623b0cab1eac39edc8.jpeg" alt="img"></p>
<p><strong>实战：构建自己的CentOS</strong></p>
<p>Docker Hub中99%的镜像都是从<code>FROM scratch</code>开始的，然后配置需要的软件和配置来进行构建。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.编写配置文件</span></span><br><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER qinwei&lt;qinweirz@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;------Finished--------------&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.通过上述文件构建镜像</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 命令：docker build -f dockerfile文件路径 -t 镜像名:(ta g) .</span></span></span><br><span class="line">docker build -f dockerFileofCentOS -t mycentos:1.0 .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用命令：<code>docker history 容器名称/容器ID</code>，可以查看容器的构建过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240112162843125.png" alt="image-20240112162843125"></p>
<blockquote>
<p>CMD 和 ENTRYPOINT 区别</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CMD           # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT    # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br></pre></td></tr></table></figure>
</blockquote>
<p>测试CMD</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost dockerFile]# vim dockerfile-cmd-test </span><br><span class="line">-----</span><br><span class="line">FROM centos:7</span><br><span class="line">CMD [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line">-----</span><br><span class="line">[root@localhost dockerFile]# docker build -f dockerfile-cmd-test -t cmdtest .</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240116095946392.png" alt="image-20240116095946392"></p>
<p>想追加一个命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240116100218001.png" alt="image-20240116100218001"></p>
<p>报错原因：</p>
<p>CMD情况下，-l 替换了 CMD[“ls”,”-a”]命令，-l不是命令所以报错！</p>
<p>执行：<code>docker run 43232a86a7907f1 ls -al</code>正确</p>
<p>测试ENTRYPOINT</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost dockerFile]# vim dockerfile-entrypoint-test</span><br><span class="line"></span><br><span class="line">[root@localhost dockerFile]# docker build -f dockerfile-entrypoint-test -t entrypoint .</span><br><span class="line">[+] Building 0.0s (5/5) FINISHED                                         docker:default</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                  0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load build definition from dockerfile-entrypoint-test               0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 147B                                               0.0s</span><br><span class="line"> =&gt; [internal] load metadata for docker.io/library/centos:latest                   0.0s</span><br><span class="line"> =&gt; CACHED [1/1] FROM docker.io/library/centos                                     0.0s</span><br><span class="line"> =&gt; exporting to image                                                             0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                            0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:9f1a36acb55321d87fe7400634a6d558f473f6905d4caf1c6734e  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/entrypoint    </span><br><span class="line"> </span><br><span class="line"> [root@localhost dockerFile]# docker run 9f1a36acb5532</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">lost+found</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">var</span><br></pre></td></tr></table></figure>

<p>追加命令是直接在ENTRYPOINT命令之后</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240116101824238.png" alt="image-20240116101824238"></p>
<p><strong>实战：构建自己的Tomcat镜像</strong></p>
<p>1、准备镜像文件 tomcat压缩包、JDK压缩包</p>
<p>2、编写dockerfile文件【该文件名称采用官方命名<code>Dockerfile</code>，原因：<code>build</code>时会自动寻找这个文件，不需要<code>-f</code>指定】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER qinwei&lt;qinweirz@qq.com&gt;</span><br><span class="line"></span><br><span class="line">COPY readme.txt /usr/local/readme.txt</span><br><span class="line">ADD jdk-8u391-linux-aarch64.tar.gz /usr/local</span><br><span class="line">ADD apache-tomcat-9.0.85.tar.gz /usr/local</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_391</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"></span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.85</span><br><span class="line">ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.85</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.85/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.85/bin/logs/catalina.out</span><br></pre></td></tr></table></figure>

<p>3、构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t mytomcat .</span><br></pre></td></tr></table></figure>

<p>4、启动镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9090:8080 -v /home/qinwei/build/tomcat/test:/usr/local/apache-tomcat-9.0.85/webapps/test -v /home/qinwei/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.85/logs mytomcat</span><br></pre></td></tr></table></figure>

<p>5、访问测试</p>
<p>6、发布项目（由于做了卷加载，我们直接在本地编写项目就可以发布）</p>
<p>tomcat文件夹下创建test目录（包含文件 WEB- INF/web.xml 和 index.jsp）</p>
<p>web.xml内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee </span></span></span><br><span class="line"><span class="string"><span class="tag">http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.jsp内容如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;beandemo.jsp&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        用户名:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">        密码:&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;b&gt;测试网页成功！！！&lt;/b&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>访问时通过<code>http://ip地址:9090/test</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240116154727076.png" alt="image-20240116154727076"></p>
<h3 id="7-4-发布镜像"><a href="#7-4-发布镜像" class="headerlink" title="7.4 发布镜像"></a>7.4 发布镜像</h3><h4 id="7-4-1-发布镜像到docker-hub"><a href="#7-4-1-发布镜像到docker-hub" class="headerlink" title="7.4.1 发布镜像到docker hub"></a>7.4.1 发布镜像到docker hub</h4><p>1、在<a href="https://hub.docker.com/">Docker Hub</a>网站注册账号</p>
<p>2、在自己的服务器上提交镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录账号  docker login -u 用户名</span></span><br><span class="line">docker login -u qwrz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为镜像添加tag</span></span><br><span class="line">docker tag 85dc2bf3ea1d qwrz/diytomcat:1.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">push镜像到dockerHub  /  docker push 作者名（作者名一定和dockerhub用户名保持一致）/镜像名:tag</span></span><br><span class="line">docker push qwrz/diytomcat:1.0</span><br></pre></td></tr></table></figure>

<p>3、发布成功后可在个人主页查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240116161612751.png" alt="image-20240116161612751"></p>
<h4 id="7-4-2-发布镜像到阿里云仓库"><a href="#7-4-2-发布镜像到阿里云仓库" class="headerlink" title="7.4.2 发布镜像到阿里云仓库"></a>7.4.2 发布镜像到阿里云仓库</h4><p>— 缺少阿里云账号—</p>
<h2 id="8-Docker的全流程小结"><a href="#8-Docker的全流程小结" class="headerlink" title="8. Docker的全流程小结"></a>8. Docker的全流程小结</h2><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/008i3skNly1gsy8qkirb0j30zw0tiwh9.jpg" alt="docker command" style="zoom:50%;" />




<h2 id="9-Docker网络原理"><a href="#9-Docker网络原理" class="headerlink" title="9.Docker网络原理"></a>9.Docker网络原理</h2><h3 id="9-1-理解Docker0"><a href="#9-1-理解Docker0" class="headerlink" title="9.1 理解Docker0"></a>9.1 理解Docker0</h3><p>前置处理：清空所有环境</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240116165034251.png" alt="image-20240116165034251"></p>
<p>三个网络代表三种环境</p>
<blockquote>
<p>问题：docker是如何处理容器网络访问的？</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240117094226887.png" alt="image-20240117094226887" style="zoom:50%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9090:8080 --name tomcat01 tomcat:7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器内部的网络地址，发现容器启动的时候会得到一个eth0的ip地址，这个地址是由docker分配的</span></span><br><span class="line">docker exec -it tomcat01 ip addr</span><br><span class="line">---</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">136: eth0@if137: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思考：Linux能不能ping通容器内部？</p>
<p>Linux可以ping通 docker 容器内部</p>
<p>原理：每启动一个docker容器，docker就会给docker容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0「<em>这个网卡是桥接模式，使用evth-pair技术</em>」</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240117102951805.png" alt="image-20240117102951805" style="zoom:50%;" />

<p>发现容器的网卡都是一对一对的，<code>evth-pair</code>就是一堆的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连，正是有了这种特性，<code>evth-pair</code>充当一个桥梁。 </p>
<p>结论：容器之间是可以互相ping通的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240117110415707.png" alt="image-20240117110415707"></p>
<p>结论：tomcat01和tomcat02共用一个路由器docker0。</p>
<p>所有的容器在不指定网络的情况下，都是共用路由器docker0。docker会为每个容器分配一个默认可用的IP。</p>
<blockquote>
<p>小结：Docker使用的是Linux的桥接模式，宿主机中是一个Docker容器的网桥docker0。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240117111351178.png" alt="image-20240117111351178"></p>
<p>Docker中所有的网络接口都是虚拟的，虚拟的转发效率高！！</p>
<p>只要容器删除，对应的网桥也会被删除。</p>
<h3 id="9-2-–link"><a href="#9-2-–link" class="headerlink" title="9.2 –link"></a>9.2 –link</h3><blockquote>
<p>思考一个场景：我们编写了一个微服务，database url = ip:3306，在项目不重启的情况下，当数据库ip更换后，仍能够正常访问。</p>
<p>希望能够通过容器名称来实现容器之间的关联。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker exec -it tomcattest01 ping tomcattest</span><br><span class="line">ping: tomcattest: Name or service not known</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过--<span class="built_in">link</span>可以解决tomcattest02连接tomcattest01的网络连接</span> </span><br><span class="line">[root@localhost ~]# docker run -d -p 9092:8080 --name tomcattest02 --link tomcattest01 tomcat:7</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker exec -it tomcattest02 ping tomcattest01</span><br><span class="line">PING tomcattest01 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcattest01 (172.17.0.3): icmp_seq=1 ttl=64 time=0.215 ms</span><br><span class="line">64 bytes from tomcattest01 (172.17.0.3): icmp_seq=2 ttl=64 time=0.117 ms</span><br><span class="line">64 bytes from tomcattest01 (172.17.0.3): icmp_seq=3 ttl=64 time=0.203 ms</span><br></pre></td></tr></table></figure>

<p>通过查看tomcattest02的host文件，发现在host文件中配置了访问tomcattest01(172.17.0.3) </p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240117142948095.png" alt="image-20240117142948095" style="zoom:50%;" />

<p>本质探究：<code>--link</code>就是我们在host配置中增加了一个<code>172.17.0.3      tomcattest01 efb32c50a670</code></p>
<p><strong>当前已经不在推荐使用此种方式，仅作了解即可。</strong></p>
<h3 id="9-3-自定义网络"><a href="#9-3-自定义网络" class="headerlink" title="9.3 自定义网络"></a>9.3 自定义网络</h3><p>查看所有的Docker网络：<code>docker network ls</code></p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240117144721961.png" alt="image-20240117144721961" style="zoom:50%;" />

<p><strong>网络模式</strong></p>
<p>bridge：桥接模式（自定义网络采用bridge模式）</p>
<p>none：不配置网络</p>
<p>host：主机模式，和宿主机共享网络</p>
<p>container：容器网络连通（用得少，局限性很大）</p>
<p><strong>测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们直接启动命令，默认就是 --net bridge，这个就是docker0[下面两个命令等价]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># docker0的特点：默认域名不能访问，--link可以打通连接</span></span> </span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自定义网络</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># --driver bridge</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># --subnet 192.168.0.0/16   192.168.0.2～192.168.255.255</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># --gateway 192.168.0.1</span></span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">ba9320597b8d   bridge    bridge    local</span><br><span class="line">c4132eafaa93   host      host      local</span><br><span class="line">fb808b9847b8   mynet     bridge    local</span><br><span class="line">356c1878d15f   none      null      local</span><br></pre></td></tr></table></figure>

<p>我们自己的网络就创建好了。</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240117151911420.png" alt="image-20240117151911420" style="zoom:50%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -d -P --name tomcat-net-01 --net mynet tomcat:7</span><br><span class="line">[root@localhost ~]# docker run -d -P --name tomcat-net-02 --net mynet tomcat:7</span><br></pre></td></tr></table></figure>

<p>再次查看自己创建的网络，发现下面已经有了两个容器</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240117152602710.png" alt="image-20240117152602710" style="zoom:50%;" />

<p>在自定义网络中，通过容器名称可以互相ping通</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240117152921402.png" alt="image-20240117152921402"></p>
<p>在自定义的网络中docker已经帮我们维护好了对应的关系，<strong>因此在使用时推荐使用自定义网络。</strong></p>
<h3 id="9-4-网络连通"><a href="#9-4-网络连通" class="headerlink" title="9.4 网络连通"></a>9.4 网络连通</h3><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240117162258659.png" alt="image-20240117162258659" style="zoom:50%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.创建tomcat01、tomcat02</span></span><br><span class="line">docker run -d -P --name tomcat01 tomcat:7</span><br><span class="line">docker run -d -P --name tomcat02 tomcat:7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.创建mynet</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.创建tomcat-net-01、tomcat-net-02</span></span><br><span class="line">docker run -d -P --name tomcat-net-01 --net mynet tomcat:7</span><br><span class="line">docker run -d -P --name tomcat-net-02 --net mynet tomcat:7\</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.tomcat01连接mynet</span></span><br><span class="line">docker network connect mynet tomcat01</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试：tomcat01 ping tomcat-net-01</span></span><br><span class="line">[root@localhost ~]# docker exec -it tomcat01 ping tomcat-net-01</span><br><span class="line">PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.246 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.227 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.134 ms</span><br></pre></td></tr></table></figure>

<p>结论：假设要跨网络操作，就需要使用<code>docker network connect</code>连通。</p>
<h3 id="9-5-实战：部署Redis集群"><a href="#9-5-实战：部署Redis集群" class="headerlink" title="9.5 实战：部署Redis集群"></a>9.5 实战：部署Redis集群</h3><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240117164052910.png" alt="image-20240117164052910" style="zoom:50%;" />

<p>【图中r-m1、r-m2、r-m3为主机，r-s1、r-s2、r-s3为备用机】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建网卡</span></span><br><span class="line">docker network create redis --subnet 172.38.0.0/16</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过脚本创建六个redis配置</span></span><br><span class="line">for port in $(seq 1 6);</span><br><span class="line">do</span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf</span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt;&gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1$&#123;port&#125;</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动6个docker容器</span></span><br><span class="line">for port in $(seq 1 6);</span><br><span class="line">do</span><br><span class="line">docker run -p 637$&#123;port&#125;:6379 -p 1637$&#123;port&#125;:16379 --name redis-$&#123;port&#125; -v /mydata/redis/node-$&#123;port&#125;/data:/data -v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf -d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到redis-1中</span></span><br><span class="line">docker exec -it redis-1 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建集群</span></span><br><span class="line">redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13</span><br><span class="line">:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-6-SpringBoot微服务打包Docker镜像"><a href="#9-6-SpringBoot微服务打包Docker镜像" class="headerlink" title="9.6  SpringBoot微服务打包Docker镜像"></a>9.6  SpringBoot微服务打包Docker镜像</h3><p>1.构建Spring Boot项目</p>
<p>2.打包应用生成jar包</p>
<p>3.编写Dockerfile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者：FROM java:8</span></span><br><span class="line">LABEL authors=&quot;qinwei&quot;</span><br><span class="line"></span><br><span class="line">COPY *.jar /app.jar</span><br><span class="line"></span><br><span class="line">CMD [&quot;--server.port=8080&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure>

<p>4.上传jar包和Dockerfile到指定目录</p>
<p>5.在Dockerfile所在目录下构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t springbootdemo .</span><br></pre></td></tr></table></figure>

<p>5.发布运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9090:8080 --name webdemo springbootdemo</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做好技术调研</title>
    <url>/2024/01/03/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="一、了解需求"><a href="#一、了解需求" class="headerlink" title="一、了解需求"></a>一、了解需求</h2><p>【本阶段特别容易出现的问题】</p>
<ul>
<li>新人畏畏缩缩，担心一开始问太多会显得自己很无知</li>
<li>只听到关键字，而忽略了对方说的细节</li>
<li>对需求存有疑惑，没有沟通，继续硬着头皮做</li>
<li>没有分阶段跟需求方沟通，<strong>可能快要完成才发现需求理解错误</strong></li>
</ul>
<p>解决方案：</p>
<ol>
<li><p>接到需求时，认真听对方讲，对对方所讲内容有疑惑的是可以在对方讲完后提问的。<span style="color:red;"><strong>千万不要听的时候是懂非懂，想着待会私底下自己查（当然提问也要有技巧，这个自己琢磨去）</strong></span> 。</p>
</li>
<li><p>假如不了解的东西太多（例如一上来就给新人分配一个陌生业务模块的任务，的确会一脸懵逼），又不想围着需求方各种打扰，完全可以请教下熟悉相应模块的同事。</p>
</li>
<li><p>假如是复杂的需求，可以在做的过程中，分步跟需求方确认。</p>
</li>
</ol>
<hr>
<p>这里举个例子：</p>
<blockquote>
<p>一天，小明正热火朝天地写着代码，突然肩膀被人一拍，回头一看老大正站在背后。</p>
<p>小明，这有个调研工作你去做一下？</p>
<p>没问题，具体是做什么呢？</p>
<p>是这样，我们需要做一个 A 功能以支撑 B 模块，这块功能 iOS 端已经完成，可以与他们讨论下。</p>
<p>好的，没问题。</p>
</blockquote>
<p>于是小明屁颠屁颠开始调研 A 功能是怎么实现，耗费了几天时间后，老大过来一看，诶，你这实现不是我想要的呀。</p>
<p>原来虽然小明选取的技术方案是业界知名的 A 功能实现方案，但却没法用到 B 模块上。而且需求隐含的意思是，<span style="color:green;"><strong>既然 iOS 端已经实现了，需求的具体情况可以去询问 iOS 端对应开发。</strong></span></p>
<hr>
<h2 id="二、进行调研"><a href="#二、进行调研" class="headerlink" title="二、进行调研"></a>二、进行调研</h2><p>进行调研需要注意<strong>合理安排时间</strong>，调研过程中存在大量的新知识，但注意“别沉迷于学习”，工作的内容是完成调研，而并非学习。</p>
<p>调研步骤：</p>
<ol>
<li>尽量多得收集各种方案和资料</li>
<li>迅速粗略得过一遍，大体上总结出几种可能合适的方案</li>
<li>针对几种方案，一边分别调研每种方案，一边做笔记</li>
<li>最后拿着笔记做最后的横向对比</li>
<li>得出结论，同时因为做了笔记，反馈的素材也有了</li>
</ol>
<p>⚠️<span style="color:red;">注意：</span><strong>不要埋头苦干，不要埋头苦干，及时沟通</strong></p>
<p>Q：该如何沟通，以及沟通些什么呢？</p>
<p>A：【如何沟通】–&gt;阶段性跟需求方和有经验的同事进行讨论，每次必须要产生实质性的干货内容</p>
<p>【沟通什么】–&gt; 1.对需求细节部分确认；2.将自己工作进度汇报给对方（让对方知道当下你已经做到哪一个阶段了；另外如果路走偏了也能够及时得到纠正）；3.将当前成果汇报给对方</p>
<h2 id="三、反馈"><a href="#三、反馈" class="headerlink" title="三、反馈"></a>三、反馈</h2><p><strong>做完调研一定要有成果。</strong></p>
<p>可以是调研之后<span style="color:red;">发现“某个方案是最佳的”</span>，也可以调研之后<span style="color:red;">发现“尚无解决方案”</span>，还可以<span style="color:red;">调研后对需求本身提出质疑</span>，但<span style="color:red;">一定不能做着做着无声无息得做没了（不是所有技术调研都有需求方催促或跟进）</span>。</p>
<p>反馈的具体展现方式：</p>
<ul>
<li>PPT展示</li>
<li>文档形式（推荐markdown、Github/GitLab直接展示）【推荐】</li>
<li>邮件/口头汇报</li>
</ul>
<p>反馈的内容要考虑如下几点：</p>
<ol>
<li>简要说明调研需求</li>
<li>介绍与需求相关的前置知识</li>
<li>目前的方案有哪些？分析各个方案的优缺点、适用场景</li>
<li>技术调研的结果是什么？不可行的话原因是什么？可行的话最终决定哪个方案？（无法决定可以开展分享讨论会）并说明该方案与其他方案相比的优势</li>
<li>假如是新库的引进，需要简要介绍下该库的使用及内部原理</li>
<li>调研过程中碰到了哪些问题，如何解决</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总而言之，<span style="color:red;">把一次技术调研当成一次绝佳的学习机会来做，那反馈的内容就不会显得空洞</span>。</p>
<p>反馈的时机的话，在保证质量的前提下，尽量主动、提前向需求方或组内其他同事提出。一方面是你的反馈对别人而言也是一个学习机会，另一方面主动推送一件事也是一个优秀的表现。</p>
<hr>
<p>作者：光源_Android<br>链接：<a href="https://juejin.cn/post/6844903458722545678">https://juejin.cn/post/6844903458722545678</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
]]></content>
      <tags>
        <tag>工作经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidity学习笔记📒</title>
    <url>/2023/12/29/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%F0%9F%93%92/</url>
    <content><![CDATA[<h2 id="1-Solidity是什么？"><a href="#1-Solidity是什么？" class="headerlink" title="1.Solidity是什么？"></a>1.Solidity是什么？</h2><ol>
<li>Solidity是一种面向对象（合约）的，为实现智能合约而创建的高级编程语言；</li>
<li>Solidity是一种针对以太坊虚拟机（EVM）设计的语言，它受C++、Python和JavaScript的影响；</li>
<li>Solidity是一种静态类型语言，支持复杂的用户定义编程，支持库和集继承。</li>
</ol>
<p><strong>合约样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 版本许可：版本许可位于源文件的第一行，用于定义合约的版权许可标识。虽然不是强制的，但是建议每个源文件中都以这样的代码开始，来说明合约的版本许可。</span><br><span class="line">// SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.1; //版本标识</span><br><span class="line"></span><br><span class="line">// 第一个合约</span><br><span class="line">contract HelloWorld&#123;</span><br><span class="line">	// 状态变量</span><br><span class="line">	string public str = &quot;Hello World&quot;;</span><br><span class="line">	</span><br><span class="line">	// set函数</span><br><span class="line">	function set(string memory s) public&#123;</span><br><span class="line">		str = s;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//get函数</span><br><span class="line">	function get() public view returns(string memory)&#123;</span><br><span class="line">		return str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>版本标识的说明</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20240102110415767.png" alt="image-20240102110415767"></p>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Solidity中关于数据类型的定义如下：</p>
<ul>
<li>Solidity是一种静态类型的语言，这意味着每个变量都需要在编译时指定变量的类型；</li>
<li>Solidity中新声明的变量总是有一个默认值，具体默认值跟类型有关，例如boolean类型的默认值为false.</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p><strong>布尔类型</strong></p>
<p><code>bool</code>：可接受<code>true</code>和<code>false</code>两个值，默认值是<code>false</code></p>
<p><strong>整型</strong></p>
<p><code>int</code>和<code>uint</code>：分别表示有符号和无符号的整数，默认为0。支持关键字<code>int8</code>到<code>int256</code>，以及<code>uint8</code>到<code>uint256</code>，从8位到256位，以8位为步长递增，<code>int</code>和<code>uint</code>分别是<code>int256</code>和<code>uint256</code>的别名。</p>
<p><strong>地址类型</strong></p>
<p><code>address</code>：包含一个20字节的值（代表一个以太坊地址的大小）。一个地址可以用来获取余额，也可以通过转账的方式来转移余额。</p>
<p><strong>字节类型</strong></p>
<p><code>bytes1</code> <code>bytes2</code> ……<code>bytes32</code>：字节用于存储固定大小的字符集，长度范围是1-32。字节的一个优点是它使用更少的Gas，所以当我们知道数据的长度的时，最好使用它。</p>
<p><strong>字符串类型</strong></p>
<p><code>string</code>：字符串用于存储等于或大于一个字节的字符集，字符串的长度是动态的。</p>
<p><strong>枚举类型</strong></p>
<p><code>enum</code>：创建用户定义的数据类型，用于为一个整型常量分配一个名称，这使得合约具有可读性、可维护性和更不容易出错。枚举的选项可以用从0开始的无符号整数值表示。</p>
<p>语法：<code>enum &lt;enum_name&gt; &#123;element1, element2, ...&#125;</code></p>
<h4 id="例子🌰"><a href="#例子🌰" class="headerlink" title="例子🌰"></a>例子🌰</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.13;//版本标识</span><br><span class="line"></span><br><span class="line">// 值类型</span><br><span class="line">contract DataTypes&#123;</span><br><span class="line">    // 布尔类型</span><br><span class="line">    bool public boo = true;</span><br><span class="line"></span><br><span class="line">    // 整型</span><br><span class="line">    uint8 public u8 = 123;</span><br><span class="line">    uint256 public u256 = 456;</span><br><span class="line">    uint public u = 789;</span><br><span class="line"></span><br><span class="line">    int8 public i8 = -1;</span><br><span class="line">    int256 public i256 = -456;</span><br><span class="line">    int public i = -789;</span><br><span class="line"></span><br><span class="line">    // 整型的最大值和最小值</span><br><span class="line">    int public minInt = type(int).min;</span><br><span class="line">    int public maxInt = type(int).max;</span><br><span class="line"></span><br><span class="line">    // 地址类型</span><br><span class="line">    address public addr = 0xB5893179159A988f19B900A0f264cf2e5fBff829;</span><br><span class="line">    uint public balance = addr.balance;</span><br><span class="line"></span><br><span class="line">    // 字节类型</span><br><span class="line">    bytes1 public b1 = 0x1a;</span><br><span class="line">    bytes2 public b2 = 0x1a2b;</span><br><span class="line"></span><br><span class="line">    // 字符串类型</span><br><span class="line">    string public str = &quot;this is a string&quot;;</span><br><span class="line"></span><br><span class="line">    // 默认值</span><br><span class="line">    bool public defaultBoo;</span><br><span class="line">    uint public defaultUint;</span><br><span class="line">    int public defaultInt;  </span><br><span class="line">    address public defaultAddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 枚举类型</span><br><span class="line">// SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity &gt;=0.5.10;//版本标识</span><br><span class="line"></span><br><span class="line">contract Enum&#123;</span><br><span class="line">    // 定义一个枚举类型</span><br><span class="line">    enum Action &#123;up,down,left,right&#125;</span><br><span class="line"></span><br><span class="line">    // 定义变量，默认值为第一个元素，即up的值</span><br><span class="line">    Action public action;</span><br><span class="line"></span><br><span class="line">    // 设置默认值</span><br><span class="line">    function setDefault() public &#123;</span><br><span class="line">        action = Action.up;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置传递一个uint的值</span><br><span class="line">    function set(Action _action) public &#123;</span><br><span class="line">        action = _action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取值，返回一个uint值</span><br><span class="line">    function get() public view returns(Action) &#123;</span><br><span class="line">        return action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取最小值</span><br><span class="line">    function getMinValue() public pure returns(Action) &#123;</span><br><span class="line">        return type(Action).min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取最大值</span><br><span class="line">    function getMaxValue() public pure returns(Action) &#123;</span><br><span class="line">        return type(Action).max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用类型变量存储数据的位置。在引用类型的定义中，两个不同的变量可以引用同一个位置，其中一个变量的任何更改都会影响另一个变量。引用类型包括数组、结构和映射。</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p><strong>基本概念</strong></p>
<p>solidity中关于数组的定义如下：</p>
<ul>
<li>数组是存储相同数据类型的固定元素集合的数据结构；</li>
<li>数组可以在声明时指定长度，也可以动态调整大小（长度）；</li>
<li>数组具有连续的内存位置，通过索引访问数组中的元素，索引从0开始；</li>
<li>数组元素可以是任何有效的Solidity数据类型，包括映射和结构体。</li>
</ul>
<p><strong>创建数组</strong></p>
<p>语法：<code>&lt;data type&gt;[size] &lt;array name&gt; = &lt;initialization&gt;</code></p>
<p><strong>数组类型</strong></p>
<p>1⃣️定长数组：数组的大小在声明时预定义，元素的总数不应该超过数组的大小。如果数组在声明时没有进行初始化，则数组中的元素为默认值（如对于存储整型的数组，其元素的默认值为0）</p>
<p>定长数组的声明与初始化有两种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint[] a = [1,2,3]</span><br><span class="line">uint[3] b;</span><br></pre></td></tr></table></figure>

<p>数组a定义了3个元素，并初始化为[1,2,3]</p>
<p>数组b定义了3个元素，所有元素的初始化为0</p>
<p>2⃣️动态数组：声明数组时，数组的大小没有预定义。数组的大小会随着元素的添加、删除而改变，在运行时数组的大小将被确定。</p>
<p>动态数组的声明如下：<code>uint[] a;</code></p>
<p>动态数组由于没有指定数组长度，所以没有初始化值。</p>
<p>3⃣️内存数组：可使用关键字<code>new</code>在内存中（memory）中基于运行时动态创建固定长度的数组。与存储（storage）数组相反的是，不能通过修改成员变量<code>.push</code>改变内存数组的大小，即内存数组创建后的长度是固定的。</p>
<p>创建内存数组的语法如下：<code>unit[] memory a = new uint[](5);</code></p>
<p>动态数组中的元素总是以默认值初始化</p>
<p><strong>数组成员</strong></p>
<p><strong>length</strong></p>
<p>数组的<code>length</code>变量用于检查数组中存在的元素的数量。定长数组的大小在声明时是固定的，而如果动态数组是在定义时定义的，则需要操作长度。</p>
<p><strong>push(x)</strong></p>
<p>用于在动态数组中添加新元素。新元素总是添加在数组的最后一个位置。如果带<code>x</code>参数则向动态数组添加定值元素，并且没有返回。如果不带参数<code>x</code>，则向数组添加初始化元素，并返回元素的引用。</p>
<p><strong>pop()</strong></p>
<p>用于从动态数组末尾移除元素，并在移除的元素上隐含调用<code>delete</code></p>
]]></content>
      <tags>
        <tag>Solidity笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Web3.0 DeFi项目实战开发</title>
    <url>/2023/12/19/Web3-0DeFi%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV14A411178x/?share_source=copy_web&vd_source=f3ff8a2761a3e07339584c4852cdd504">视频地址</a></p>
<h1 id="Web3-0-简介"><a href="#Web3-0-简介" class="headerlink" title="Web3.0 简介"></a>Web3.0 简介</h1><ul>
<li>web1.0 时代：只能读，不能写，没有互动功能方法</li>
<li>web2.0 时代：可读可写，内容由全体网民产生，中心化（数据储存在服务器、易产生垄断）</li>
<li>web3.0 时代：去中心化（最大的特点）、web3.0 的基础是区块链技术（区块链技术是元宇宙等时髦概念的底层架构和逻辑基础）、数据掌握在生产者手中。</li>
</ul>
<p>web3.0 能够实现去中心化得益于区块链催生的智能合约技术，它不仅可以记录信息，还可以运行应用程序。</p>
<p>去中心化的应用 - DAPP</p>
<p>区块链支撑的 web3.0<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312191534592.png"></p>
<h1 id="元宇宙"><a href="#元宇宙" class="headerlink" title="元宇宙"></a>元宇宙</h1><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312191510341.png"></p>
<h1 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h1><p>NFT（Non-fungible token）非同质化代币、不可互换的代币<br>数字藏品</p>
<h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><p><a href="https://github.com/anders94/blockchain-demo">区块链 Demo 地址</a></p>
<p><strong>定义</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312191538680.png"></p>
<p><strong>特征</strong><br>去中心化、共识机制、不可篡改<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312191543547.png"></p>
<p><strong>应用场景</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312191606112.png"></p>
<p><strong>类型</strong><br>公链、私链、联盟链、混合链<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312191607904.png"></p>
<p><strong>hash 算法</strong></p>
<ul>
<li>从 hash 值不可以反向推导出原始数据</li>
<li>输入数据的微小变化会得到完全不同的 hash 值</li>
<li>相同的数据会得到相同的值</li>
<li>执行效率高效，长的文本也能很快地计算出哈希值</li>
<li>hash 算法的冲突概率很小</li>
</ul>
<p><strong>区块的概念</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312191623512.png"></p>
<p>第 n 块的 Hash 值 = Hash(第 n-1 块的 Hash 值+第 n 块的账本数据)</p>
<p><strong>P2P 网络</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312191630511.png"></p>
<p><strong>记账与挖矿</strong></p>
<p>为什么会有人愿意花费精力来记账？<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312191634252.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312191635640.png"></p>
<p>以谁记录的账本为准？<br>比特币采取的是工作量证明法（POW），也就是让记账的人去解一道运算量很大的数学题，谁能够最先解出来，就用谁的账本，同时谁也就获得了比特币的奖励，这个解数学题的过程就叫做挖矿，所以挖矿比拼的就是矿机 CPU 的运算能力。</p>
<p><strong>共识机制</strong><br>广泛应用的共识机制：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312191641728.png"></p>
<h2 id="比特币-第一个区块链的应用"><a href="#比特币-第一个区块链的应用" class="headerlink" title="比特币 - 第一个区块链的应用"></a>比特币 - 第一个区块链的应用</h2><p>比特币是区块链的一个应用。</p>
<h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>以太坊作为一种基于区块链技术的去中心化应用平台，与比特币仅支持货币交易不同，可以在以太坊上开发和运行去中心化的应用程序。以太坊背后的核心思想是开发人员可以在分布式网络中创建和运行程序代码，而不受中心化控制。以太坊使用以太币（Ether，代码为 ETH）作为交易货币。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312201005448.png"></p>
<p>以太币干什么用？<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312201008445.png"></p>
<p>以太坊-区块链钱包：<br>钱包里存储的是数字资产的账户信息和密钥信息，而不是实际资产。<br>热钱包（HotWallet）、冷钱包（Cold Wallet），其中冷钱包是脱离网络连接的离线钱包，热钱包需要联网才能够使用。</p>
<p>钱包的概念：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312201029737.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312201032861.png"><br>一组助记词可以产生很多账号</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312201116899.png"></p>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>什么是智能合约？<br>智能合约是一种自动执行合约的协议，其中的条款和条件以计算机代码的形式编写。它们运行在区块链技术之上，如以太坊。智能合约允许在没有第三方的情况下进行可靠的交易和协议执行。</p>
<p>智能合约的主要特点包括：</p>
<ol>
<li><strong>自动执行</strong>：一旦设定条件被满足，合约就会自动执行。</li>
<li><strong>透明和不可篡改</strong>：所有的交易和操作都被记录在区块链上，任何人都可以查看，但无法更改。</li>
<li><strong>安全性</strong>：智能合约的代码一经部署，就无法更改，确保了合约的可靠性和一致性。</li>
<li><strong>去中心化</strong>：智能合约运行在区块链上，没有中央管理者，使得合约的执行更为公正和透明。</li>
</ol>
<p>智能合约可以应用于许多场景，例如资金转移、资产交易、供应链管理、投票系统等。它们的出现为许多传统的合约和交易提供了新的、更高效的解决方案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312201126869.png"></p>
<h1 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h1><h2 id="web3-连接到以太坊网络（测试网、主网）"><a href="#web3-连接到以太坊网络（测试网、主网）" class="headerlink" title="web3 连接到以太坊网络（测试网、主网）"></a>web3 连接到以太坊网络（测试网、主网）</h2><h3 id="1-什么是-web3"><a href="#1-什么是-web3" class="headerlink" title="1.什么是 web3"></a>1.什么是 web3</h3><p>web3 是以太坊官方提供的一个连接以太坊区块链的模块，允许使用 HTTP 或 IPC 与本地或远程以太坊节点进行交互，它包含以太坊生态系统几乎所有的功能。web3 模块主要连接以太坊暴露出来的 RPC 层。开发者利用 web3 连接 RPC 层，可以连接任何暴露了 RPC 接口的节点，从而与区块链交互。web3 是一个集合库，支持多种开发语言使用 web3，其中的 JavaScript API 叫做 web3.js，另外还有 web3.py，web3j。</p>
<p>web3.eth：用于与以太坊区块链和智能合约之间的交互。</p>
<p>web3.utils：包含一些辅助方法。</p>
<p>web3.shh：用于协议进行通信的 P2P 和广播。</p>
<p>web3.bzz：用于与群网络交互的 Bzz 模块。</p>
<p>web3.js 开发文档：<a href="https://web3js.readthedocs.io/en/v1.8.1/">https://web3js.readthedocs.io/en/v1.8.1/</a></p>
<p>web3.js 中文文档 : <a href="https://learnblockchain.cn/docs/web3.js/">https://learnblockchain.cn/docs/web3.js/</a></p>
<h3 id="2-实例化-web3"><a href="#2-实例化-web3" class="headerlink" title="2.实例化 web3"></a>2.实例化 web3</h3><p>web3 要与以坊节点进行交互，需要创建一个 web3 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Web3</span> = <span class="built_in">require</span>(<span class="string">&quot;web3&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;Web3.providers.givenProvider&quot; will be set if in an Ethereum supported browser.</span></span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>(</span><br><span class="line">  <span class="title class_">Web3</span>.<span class="property">givenProvider</span> || <span class="string">&quot;ws://some.local-or-remote.node:8546&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>根据 API 可知需要指定节点地址，我们将<code>ws://some.local-or-remote.node:8546</code>换成其它连接到以太坊网络的节点的地址，以此来确定连接的以太坊的网络。<br>那么连接到以太坊网络的节点的地址是多少呢？这里我们需要使用到 infura。</p>
<h3 id="3-获取连接到以太坊网络的节点地址"><a href="#3-获取连接到以太坊网络的节点地址" class="headerlink" title="3.获取连接到以太坊网络的节点地址"></a>3.获取连接到以太坊网络的节点地址</h3><p>infura 提供公开的 Ethereum 主网和测试网络节点，到 infura.io 网站注册后即可获取各个网络的地址。请按照如下步骤获取地址。</p>
<p>第一步：打开 <a href="https://infura.io/dashboard">infura 网站地址</a>，使用邮箱注册后登陆。</p>
<p>第二步：点击上图标记的“create new project”按钮创建一个新项目。然后弹出如下弹框，在输入框输入项目名，如”MyEtherWallet“，然后点击“create project”按钮创建。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312251507913.png"></p>
<p>第三步：然后会显示如下界面，点击下图中的选择框，可以看到提供主网、Kovan测试网络、Ropsten测试网络、GoerLi测试网络的节点地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312251510130.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312251511763.png"></p>
<p>第四步：选择GoerLi测试网络，然后复制地址<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312251512187.png"></p>
<p>连接到以太坊GoerLi测试网络<br>现在将复制的地址替换掉实例化web对象的地址，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Web3</span> = <span class="built_in">require</span>(<span class="string">&quot;web3&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> <span class="title class_">Web3</span>(<span class="title class_">Web3</span>.<span class="property">givenProvider</span> || <span class="string">&#x27;wss://goerli.infura.io/ws/v3/cb7e63cf28244e4499b4b6fb6162e746&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Web3:&quot;</span>, web3)</span><br></pre></td></tr></table></figure>
<p>连接到以太坊主网与GoerLi测试网络一样的，只需复制主网节点的地址去实例化web3即可。由于在主网上交易需要花费gas，因此我们基于GoerLi测试网络进行开发，后续开发完成后可再切换到主网。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312251515346.png"></p>
<h2 id="web3-js-高频API"><a href="#web3-js-高频API" class="headerlink" title="web3.js 高频API"></a>web3.js 高频API</h2><h3 id="1-账号创建"><a href="#1-账号创建" class="headerlink" title="1.账号创建"></a>1.账号创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="title function_">create</span>([entropy]);</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<p>entropy - String (可选): 它是一个可选项，是一个随机字符串，将作为解锁账号的密码。如果没有传递字符串，则使用random生成随机字符串。</p>
<p>返回值：</p>
<p>Object：包含以下字段的一个帐户对象：</p>
<p>address- string：帐户地址。</p>
<p>privateKey- string：帐户私钥。前端永远不应该在localstorage中以未加密的方式共享或存储！</p>
<p>signTransaction(tx [, callback])- Function：签名交易的方法。</p>
<p>sign(data)- Function：签名二进制交易的方法。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建账号</span></span><br><span class="line"><span class="keyword">const</span> account = web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="title function_">create</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;account=&#x27;</span>,account);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312251549225.png"></p>
<h3 id="2-获取地址"><a href="#2-获取地址" class="headerlink" title="2.获取地址"></a>2.获取地址</h3><p>使用API <code>web3.eth.accounts.create()</code>创建了新账户后生成了一个账户对象，在该对象中拥有<code>address</code>属性，即账户的私钥。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取地址</span></span><br><span class="line"><span class="keyword">let</span> addr = account.<span class="property">address</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;address = &#x27;</span>,addr);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312251610782.png"></p>
<h3 id="3-获取私钥"><a href="#3-获取私钥" class="headerlink" title="3.获取私钥"></a>3.获取私钥</h3><p>使用API <code>web3.eth.accounts.create()</code>创建了新账户后生成了一个账户对象，在该对象中拥有<code>privateKey</code>属性，即账户的私钥。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取私钥</span></span><br><span class="line"><span class="keyword">let</span> privateKey = account.<span class="property">privateKey</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;privateKey = &#x27;</span>,privateKey);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312251613169.png"></p>
<h3 id="4-余额获取"><a href="#4-余额获取" class="headerlink" title="4.余额获取"></a>4.余额获取</h3><p>根据地址获取以wei为单位余额</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 获取余额</span></span><br><span class="line">  web3.<span class="property">eth</span>.<span class="title function_">getBalance</span>(addr).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-单位转换"><a href="#5-单位转换" class="headerlink" title="5.单位转换"></a>5.单位转换</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.Eth 转为 wei</span></span><br><span class="line"><span class="keyword">const</span> num1 = web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">&#x27;0.3&#x27;</span>, <span class="string">&#x27;ether&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;num1=&#x27;</span>,num1);</span><br><span class="line"><span class="comment">// 300000000000000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. wei 转为Eth</span></span><br><span class="line"><span class="keyword">const</span> balance = <span class="title class_">Web3</span>.<span class="property">utils</span>.<span class="title function_">fromWei</span>(<span class="string">&quot;300000&quot;</span>, <span class="string">&quot;ether&quot;</span>);</span><br><span class="line"><span class="comment">// balance= 0.0000000000003</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="6-Eth转账-⚠️存在问题"><a href="#6-Eth转账-⚠️存在问题" class="headerlink" title="6.Eth转账[⚠️存在问题]"></a>6.Eth转账[⚠️存在问题]</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendSignedTransaction</span>(signedTransactionData [, callback])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><p><code>signedTransactionData</code>-<code>String</code>：以HEX格式签名的交易数据。</p>
<p>交易数据对象可以包含如下字段：</p>
<ul>
<li><code>from</code>- <code>String|Number</code>：发送帐户的地址。如果未指定，则使用web3.eth.defaultAccount属性。或web3.eth.accounts.wallet中本地钱包的地址。</li>
<li><code>to</code>- <code>String</code>:(可选）消息的目标地址，若未定义则为合同发送消息。</li>
<li><code>value</code>- <code>Number|String|BN|BigNumber</code>:(可选）为wei中的交易转移的数量，如果是合约发送消息，则是捐赠给合约地址。</li>
<li><code>gas</code> - <code>Number</code>:(可选，默认：待定）用于交易的gas（未使用的gas会退还）。</li>
<li><code>gasPrice</code>- <code>Number|String|BN|BigNumber</code>:(可选）此交易的gas价格，以wei为单位，默认为<a href="https://web3js.readthedocs.io/en/1.0/web3-eth.html#eth-gasprice">web3.eth.gasPrice</a>。</li>
<li><code>data</code>- <code>String</code>:(可选）包含合同上函数调用数据的<a href="http://solidity.readthedocs.io/en/latest/abi-spec.html">ABI字节字符串</a>。</li>
<li><code>nonce</code>- <code>Number</code>:(可选）随机数的整数。</li>
</ul>
</li>
<li><p><code>callback</code>-<code>Function</code>：（可选）可选回调，将错误对象作为第一个参数返回，结果作为第二个参数返回。</p>
</li>
</ul>
<p><strong>返回</strong></p>
<p><code>PromiEvent</code>：promise组合的事件，将在交易完成时调用。包含以下事件</p>
<ul>
<li><code>&quot;transactionHash&quot;</code>返回<code>String</code>：在发送事务并且事务哈希可用之后立即触发。</li>
<li><code>&quot;receipt&quot;</code>返回<code>Object</code>：在交易确认时触发。</li>
<li><code>&quot;confirmation&quot;</code>返回<code>Number</code>，<code>Object</code>：每次确认都会被调用，直到第12次确认。接收确认编号作为第一个参数，将数据作为第二个参数。</li>
<li><code>&quot;error&quot;</code>返回<code>Error</code>：如果在发送过程中发生错误，则会触发。</li>
</ul>
<ol>
<li><p>构建转账参数</p>
<p>区块链转账和支付宝转账类似，需要 <code>发送方</code> 、<code>接收方</code>、<code>金额</code>、<code>密码</code></p>
<p>另外需要添加部分区块链参数：<code>矿工费gas</code>、<code>地址转账交易次数</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取账户交易次数</span></span><br><span class="line"> <span class="keyword">let</span> nonce = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getTransactionCount</span>(fromaddress);</span><br><span class="line"> <span class="comment">// 获取预计转账gas费</span></span><br><span class="line"> <span class="keyword">let</span> gasPrice = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getGasPrice</span>();</span><br><span class="line"> <span class="comment">// 转账金额以wei为单位</span></span><br><span class="line"> <span class="keyword">let</span> balance = <span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(number);</span><br><span class="line"> <span class="keyword">var</span> rawTx = &#123;</span><br><span class="line">   <span class="attr">from</span>: fromaddress,</span><br><span class="line">   <span class="attr">nonce</span>: nonce,</span><br><span class="line">   <span class="attr">gasPrice</span>: gasPrice,</span><br><span class="line">   <span class="attr">to</span>: toaddress,</span><br><span class="line">   <span class="attr">value</span>: balance,</span><br><span class="line">   <span class="attr">data</span>: <span class="string">&quot;0x00&quot;</span>, <span class="comment">//转Token代币会用到的一个字段</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>通过转账参数计算最终gas费用，并将通过私钥将转账参数进行编码加密<br><strong>⚠️注意：ethereumjs-tx目前已经处于停用状态</strong></p>
<blockquote>
<p>ethereumjs-tx 第三方库请选择1.3.7版本</p>
</blockquote>
</li>
</ol>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Tx</span> <span class="keyword">from</span> <span class="string">&quot;ethereumjs-tx&quot;</span>;  </span><br><span class="line"><span class="comment">// 将私钥去除“ox”后进行hex转化</span></span><br><span class="line">      <span class="keyword">var</span> privateKey = <span class="keyword">new</span> <span class="title class_">Buffer</span>(privatekey.<span class="title function_">slice</span>(<span class="number">2</span>), <span class="string">&quot;hex&quot;</span>);</span><br><span class="line">      <span class="comment">//需要将交易的数据进行预估gas计算，然后将gas值设置到数据参数中</span></span><br><span class="line">      <span class="keyword">let</span> gas = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">estimateGas</span>(rawTx);</span><br><span class="line">      rawTx.<span class="property">gas</span> = gas;</span><br><span class="line">     <span class="comment">// 通过 ethereumjs-tx 实现私钥加密Ï</span></span><br><span class="line">      <span class="keyword">var</span> tx = <span class="keyword">new</span> <span class="title class_">Tx</span>(rawTx);</span><br><span class="line">      tx.<span class="title function_">sign</span>(privateKey);</span><br><span class="line">      <span class="keyword">var</span> serializedTx = tx.<span class="title function_">serialize</span>();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>通过 <code>sendSignedTransaction</code> api发送转账交易，并且获取交易id</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">web3.<span class="property">eth</span></span><br><span class="line">  .<span class="title function_">sendSignedTransaction</span>(<span class="string">&quot;0x&quot;</span> + serializedTx.<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>))</span><br><span class="line">  .<span class="title function_">on</span>(<span class="string">&quot;transactionHash&quot;</span>, <span class="function">(<span class="params">txid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;交易成功,请在区块链浏览器查看&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;交易id&quot;</span>, txid);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`https://goerli.etherscan.io/tx/<span class="subst">$&#123;txid&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// .on(&#x27;receipt&#x27;, (ret)=&gt;&#123;console.log(&#x27;receipt&#x27;)&#125;)</span></span><br><span class="line">  <span class="comment">// .on(&#x27;confirmation&#x27;, (ret)=&gt;&#123;console.log(&#x27;confirmation&#x27;)&#125;)</span></span><br><span class="line">  .<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;error:&quot;</span> + err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>区块链浏览器或者目标钱包产看转账结果</p>
<p>goerli区块链浏览器 <a href="https://goerli.etherscan.io/tx/%E4%BA%A4%E6%98%93id">https://goerli.etherscan.io/tx/交易id</a></p>
</li>
</ol>
<hr>
<h1 id="账户系统"><a href="#账户系统" class="headerlink" title="账户系统"></a>账户系统</h1><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a><code>密码</code></h2><p>密码不是私钥，它是在创建账户时候的密码（可以修改）<br>密码在以下情况下会使用到：</p>
<ol>
<li>作为转账的支付密码</li>
<li>用keystore导入钱包的时候需要输入的密码，用来解锁keystore的</li>
</ol>
<h2 id="私钥-Private-Key"><a href="#私钥-Private-Key" class="headerlink" title="私钥 Private Key"></a><code>私钥 Private Key</code></h2><p>私钥由64位长度的十六进制的字符组成，比如：<code>0xA4356E49C88C8B7AB370AF7D5C0C54F0261AAA006F6BDE09CD4745CF54E0115A</code>，一个账户只有一个私钥且不能修改。<br>通常一个钱包中私钥和公钥是成对出现的，有了私钥，我们就可以通过一定的算法生成公钥，再通过公钥经过一定的算法生成地址，这一过程都是不可逆的。私钥一定要妥善保管，若被泄漏别人可以通过私钥解锁账号转出你的该账号的数字货币。</p>
<h2 id="公钥-Public-Key"><a href="#公钥-Public-Key" class="headerlink" title="公钥 Public Key"></a><code>公钥 Public Key</code></h2><p>公钥(Public Key)是和私钥成对出现的，和私钥一起组成一个密钥对，保存在钱包中。<em>公钥由私钥生成，但是无法通过公钥倒推得到私钥。公钥能够通过一系列算法运算得到钱包的地址，因此可以作为拥有这个钱包地址的凭证。</em></p>
<h2 id="Keystore"><a href="#Keystore" class="headerlink" title="Keystore"></a><code>Keystore</code></h2><p>Keystore常见于以太坊钱包，它是将私钥以加密的方式保存为一份 JSON 文件，这份 JSON 文件就是 keystore，所以它就是加密后的私钥。Keystore必须配合钱包密码才能导入并使用该账号。当黑客盗取 Keystore 后，在没有密码情况下, 有可能通过暴力破解 Keystore 密码解开 Keystore，所以建议使用者在设置密码时稍微复杂些，比如带上特殊字符，至少 8 位以上，并安全存储。</p>
<h2 id="助记词-Mnemonic"><a href="#助记词-Mnemonic" class="headerlink" title="助记词 Mnemonic"></a><code>助记词 Mnemonic</code></h2><p>私钥是64位长度的十六进制的字符，不利于记录且容易记错，所以用算法将一串随机数转化为了一串12 ~ 24个容易记住的单词，方便保存记录。注意：</p>
<ol>
<li>助记词是私钥的另一种表现形式</li>
<li>助记词=私钥，这是不正确的说法，通过助记词可以获取相关联的多个私钥，但是通过其中一个私钥是不能获取助记词的，因此<strong>助记词≠私钥</strong>。</li>
</ol>
<h2 id="BIP"><a href="#BIP" class="headerlink" title="BIP"></a><code>BIP</code></h2><p>要弄清楚助记词与私钥的关系，得清楚BIP协议，是<code>Bitcoin Improvement Proposals</code>的缩写，意思是Bitcoin 的改进建议，用于提出 Bitcoin 的新功能或改进措施。BIP协议衍生了很多的版本，主要有BIP32、BIP39、BIP44。</p>
<p><strong>BIP32</strong></p>
<p>BIP32是 HD钱包的核心提案，通过种子来生成主私钥，然后派生海量的子私钥和地址，种子是一串很长的随机数。</p>
<p><strong>BIP39</strong></p>
<p>由于种子是一串很长的随机数，不利于记录，所以我们用算法将种子转化为一串12 ~ 24个的单词，方便保存记录，这就是BIP39，它扩展了 HD钱包种子的生成算法。</p>
<p><strong>BIP44</strong></p>
<p>BIP44 是在 BIP32 和 BIP43 的基础上增加多币种，提出的层次结构非常全面，它允许处理多个币种，多个帐户，每个帐户有数百万个地址。</p>
<p>在BIP32路径中定义以下5个级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m/purpose&#x27;/coin_type&#x27;/account&#x27;/change/address_index</span><br></pre></td></tr></table></figure>

<ul>
<li>purpose：在BIP43之后建议将常数设置为44’。表示根据BIP44规范使用该节点的子树。</li>
<li>Coin_type：币种，代表一个主节点（种子）可用于无限数量的独立加密币，如比特币，Litecoin或Namecoin。此级别为每个加密币创建一个单独的子树，避免重用已经在其它链上存在的地址。开发人员可以为他们的项目注册未使用的号码。</li>
<li>Account：账户，此级别为了设置独立的用户身份可以将所有币种放在一个的帐户中，从0开始按顺序递增。</li>
<li>Change：常量0用于外部链，常量1用于内部链，外部链用于钱包在外部用于接收和付款。内部链用于在钱包外部不可见的地址，如返回交易变更。</li>
<li>Address_index：地址索引，按顺序递增的方式从索引0开始编号。</li>
</ul>
<p>BIP44的规则使得 HD钱包非常强大，用户只需要保存一个种子，就能控制所有币种，所有账户的钱包，因此由BIP39 生成的助记词非常重要，所以一定安全妥善保管，那么会不会被破解呢？如果一个 HD 钱包助记词是 12 个单词，一共有 2048 个单词可能性，那么随机的生成的助记词所有可能性大概是<code>5e+39</code>，因此几乎不可能被破解。</p>
<h2 id="HD钱包"><a href="#HD钱包" class="headerlink" title="HD钱包"></a><code>HD钱包</code></h2><p>通过BIP协议生成账号的钱包叫做HD钱包。这个HD钱包，并不是Hardware Wallet硬件钱包，这里的 HD 是<code>Hierarchical Deterministic</code>的缩写，意思是分层确定性，所以HD钱包的全称为比特币分成确定性钱包 。</p>
<h2 id="密码、私钥、keystore与助记词的关系"><a href="#密码、私钥、keystore与助记词的关系" class="headerlink" title="密码、私钥、keystore与助记词的关系"></a>密码、私钥、keystore与助记词的关系</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312261553646.png"></p>
<h2 id="钱包的核心：私钥"><a href="#钱包的核心：私钥" class="headerlink" title="钱包的核心：私钥"></a>钱包的核心：私钥</h2><p>基于以上的分析，我们对以太坊钱包的账号系统有了一个很好的认识，那么我们在使用钱包的过程中，该如何保管自己的钱包呢？主要包含以下几种方式：</p>
<ul>
<li>私钥（Private Key）</li>
<li>Keystore+密码（Keystore+Password）</li>
<li>助记词（Mnemonic code）</li>
</ul>
<p>通过以上三种中的一种方式都可以解锁账号，然后掌控它，所以对于每种方式中的数据都必须妥善包括，如有泄漏，请尽快转移数字资产。</p>
<p>我们可以得到以下总结：</p>
<ul>
<li>通过私钥+密码可以生成keystore，即加密私钥；</li>
<li>通过keystore+密码可以获取私钥，即解密keystore。</li>
<li>通过助记词根据不同的路径获取不同的私钥，即使用HD钱包将助记词转化成种子来生成主私钥，然后派生海量的子私钥和地址。</li>
</ul>
<h2 id="通过助记词-创建账户"><a href="#通过助记词-创建账户" class="headerlink" title="通过助记词 - 创建账户"></a>通过助记词 - 创建账户</h2><p>需要使用<code>bip39</code>协议将助记词转换成种子，再通过<code>ethereumjs-wallet</code>库生成hd钱包，根据路径的不同从hd钱包中获取不同的keypair，keypair中就包含有公钥、私钥，再通过<code>ethereumjs-util</code>库将公钥生成地址，从而根据助记词获取所有关联的账号，能获取到公钥、私钥、地址等数据信息。</p>
<p><strong>1.依赖库</strong><br>需要用到三个库：bip39、ethereumjs-wallet/hdkey、ethereumjs-util。先安装依赖库，<code>cd</code>到项目跟路径运行命令<code>npm i bip39 ethereumjs-wallet ethereumjs-util</code>。</p>
<ul>
<li><a href="https://github.com/bitcoinjs/bip39">bip39</a>：随机产生新的 mnemonic code，并可以将其转成 binary 的 seed。</li>
<li><a href="https://github.com/ethereumjs/ethereumjs-wallet">ethereumjs-wallet</a>：生成和管理公私钥，下面使用其中 hdkey 子套件来创建 HD 钱包。</li>
<li><a href="https://github.com/ethereumjs/ethereumjs-util">ethereumjs-util</a>：Ethereum 的一个工具库。</li>
<li><a href="https://iancoleman.io/bip39/">https://iancoleman.io/bip39/</a></li>
</ul>
<p><strong>2.通过助记词创建账号</strong></p>
<ul>
<li><p>创建助记词</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入bip39模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bip39 <span class="keyword">from</span> <span class="string">&quot;bip39&quot;</span>;</span><br><span class="line"><span class="comment">// 创建助记词 </span></span><br><span class="line"><span class="keyword">let</span> mnemonic = bip39.<span class="title function_">generateMnemonic</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mnemonic);</span><br><span class="line"><span class="comment">// 结果 12位助记词</span></span><br><span class="line"><span class="comment">// vote select solar shy embrace immense lizard stamp scrub vague negative forward</span></span><br></pre></td></tr></table></figure></li>
<li><p>根据助记词生成密钥对 keypair</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入分层钱包模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; hdkey &#125; <span class="keyword">from</span> <span class="string">&quot;ethereumjs-wallet&quot;</span>;</span><br><span class="line"><span class="comment">//1.将助记词转成seed</span></span><br><span class="line"><span class="keyword">let</span> seed = <span class="keyword">await</span> bip39.<span class="title function_">mnemonicToSeed</span>(<span class="string">&quot;12位助记词&quot;</span>);</span><br><span class="line"><span class="comment">//3.通过hdkey将seed生成HD Wallet</span></span><br><span class="line"><span class="keyword">let</span> hdWallet = hdkey.<span class="title function_">fromMasterSeed</span>(seed);</span><br><span class="line"><span class="comment">//4.生成钱包中在m/44&#x27;/60&#x27;/0&#x27;/0/i路径的keypair</span></span><br><span class="line"><span class="keyword">let</span> keypair = hdWallet.<span class="title function_">derivePath</span>(<span class="string">&quot;m/44&#x27;/60&#x27;/0&#x27;/0/0&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keypair);</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>keypair 密钥对<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202312291458907.png"></p>
</li>
</ul>
<p><strong>3. 由keypair 获取钱包地址和私钥</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取钱包对象</span></span><br><span class="line"><span class="keyword">let</span> wallet = keypair.<span class="title function_">getWallet</span>();</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.<span class="title function_">getAddressString</span>();</span><br><span class="line"><span class="comment">// 获取钱包校验地址</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">CheckSumAddress</span> = wallet.<span class="title function_">getChecksumAddressString</span>();</span><br><span class="line"><span class="comment">// 获取私钥</span></span><br><span class="line"><span class="keyword">let</span> prikey = wallet.<span class="title function_">getPrivateKey</span>().<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;lowerCaseAddress&quot;</span>, lowerCaseAddress);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CheckSumAddress&quot;</span>, <span class="title class_">CheckSumAddress</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prikey&quot;</span>, prikey);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">lowerCaseAddress 0xd9fc0fd4412616c7075e68b151ab3a7bcb9a3f54</span></span><br><span class="line"><span class="comment">CheckSumAddress 0xd9fC0FD4412616c7075E68b151ab3A7bcB9A3f54</span></span><br><span class="line"><span class="comment">prikey 3fc11495517f1f015bbcb6c311da66e3b26b23e4c91c1285ccc4b69d9d274002</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="导出账户"><a href="#导出账户" class="headerlink" title="导出账户"></a>导出账户</h2><blockquote>
<p>一个已经存在的账户导出 私钥 和 keystore</p>
</blockquote>
<ol>
<li>通过分层钱包对象 + 密码 创建keystore<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> keystore = <span class="keyword">await</span> wallet.<span class="title function_">toV3</span>(data.<span class="property">pass1</span>); <span class="comment">// 参数必须为 字符串</span></span><br></pre></td></tr></table></figure></li>
<li>通过私钥和密码创建 keystore <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> keystore = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="title function_">encrypt</span>(<span class="string">&quot;账户私钥&quot;</span>,<span class="string">&quot;密码&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟keystore数据</span></span><br><span class="line"><span class="keyword">const</span> keystoreJsonV3 = &#123;</span><br><span class="line">        <span class="attr">version</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;dbb70fb2-52ad-4e1f-9c19-0b50329f89c3&quot;</span>,</span><br><span class="line">        <span class="attr">address</span>: <span class="string">&quot;445b469888528dacd9b87246c5ce70407adaa411&quot;</span>,</span><br><span class="line">        <span class="attr">crypto</span>: &#123;</span><br><span class="line">          <span class="attr">ciphertext</span>:</span><br><span class="line">            <span class="string">&quot;1e53e7e775644422600188b8134907992db40d278064ea3a966da4dcdf80db64&quot;</span>,</span><br><span class="line">          <span class="attr">cipherparams</span>: &#123; <span class="attr">iv</span>: <span class="string">&quot;f9d2b047019674eee449b316f4a21491&quot;</span> &#125;,</span><br><span class="line">          <span class="attr">cipher</span>: <span class="string">&quot;aes-128-ctr&quot;</span>,</span><br><span class="line">          <span class="attr">kdf</span>: <span class="string">&quot;scrypt&quot;</span>,</span><br><span class="line">          <span class="attr">kdfparams</span>: &#123;</span><br><span class="line">            <span class="attr">dklen</span>: <span class="number">32</span>,</span><br><span class="line">            <span class="attr">salt</span>: <span class="string">&quot;153e074d78d0ba36fae3e46e582c42e53f61653cb5d4f1a3a3f68094e6ca0160&quot;</span>,</span><br><span class="line">            <span class="attr">n</span>: <span class="number">8192</span>,</span><br><span class="line">            <span class="attr">r</span>: <span class="number">8</span>,</span><br><span class="line">            <span class="attr">p</span>: <span class="number">1</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">mac</span>: <span class="string">&quot;e91456c59b2505c16b80c2495ab7b4633273c2ae366cb6953f27de8cfebad629&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line"> <span class="keyword">const</span> res = web3.<span class="property">eth</span>.<span class="property">accounts</span>.<span class="title function_">decrypt</span>(keystoreJsonV3, <span class="string">&quot;1235&quot;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure></li>
<li>通过keystore解密私钥<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">&quot;ethereumjs-wallet&quot;</span>;  </span><br><span class="line">   <span class="keyword">let</span> pass = <span class="title function_">prompt</span>(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">       <span class="keyword">let</span> wallet;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         wallet = <span class="keyword">await</span> ethwallet.<span class="title function_">fromV3</span>(keystore, pass);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">         <span class="title function_">alert</span>(<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">let</span> key = wallet.<span class="title function_">getPrivateKey</span>().<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="导入账户"><a href="#导入账户" class="headerlink" title="导入账户"></a>导入账户</h2><blockquote>
<p>通过 私钥、助记词、keystore 导入一个已经存在的钱包账户 地址 和 私钥</p>
</blockquote>
<ol>
<li>通过keystore获取 私钥和地址 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">&quot;ethereumjs-wallet&quot;</span>;  </span><br><span class="line">  <span class="keyword">let</span> pass = <span class="title function_">prompt</span>(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">      <span class="keyword">let</span> wallet;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        wallet = <span class="keyword">await</span> ethwallet.<span class="title function_">fromV3</span>(keystore, pass);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">let</span> key = wallet.<span class="title function_">getPrivateKey</span>().<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> address = wallet.<span class="title function_">getAddressString</span>()</span><br></pre></td></tr></table></figure></li>
<li>通过助记词 获取地址和私钥<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mnemonic=<span class="title function_">prompt</span>(<span class="string">&quot;请输入助记词&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> seed = bip39.<span class="title function_">mnemonicToSeed</span>(mnemonic)</span><br><span class="line"><span class="keyword">let</span> hdwallet = hdkey.<span class="title function_">fromMasterSeed</span>(seed)</span><br><span class="line"><span class="keyword">let</span> keypair = hdWallet.<span class="title function_">derivePath</span>(<span class="string">&quot;m/44&#x27;/60&#x27;/0&#x27;/0/0&quot;</span>);</span><br><span class="line"><span class="comment">// 获取钱包对象</span></span><br><span class="line"><span class="keyword">let</span> wallet = keypair.<span class="title function_">getWallet</span>();</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.<span class="title function_">getAddressString</span>();</span><br><span class="line"><span class="comment">// 获取钱包校验地址</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">CheckSumAddress</span> = wallet.<span class="title function_">getChecksumAddressString</span>();</span><br><span class="line"><span class="comment">// 获取私钥</span></span><br><span class="line"><span class="keyword">let</span> prikey = wallet.<span class="title function_">getPrivateKey</span>().<span class="title function_">toString</span>(<span class="string">&quot;hex&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>通过私钥获取 地址<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ethwallet <span class="keyword">from</span> <span class="string">&quot;ethereumjs-wallet&quot;</span>;     </span><br><span class="line"><span class="keyword">let</span> privatekey=<span class="keyword">new</span> <span class="title class_">Buffer</span>( <span class="title function_">prompt</span>(<span class="string">&quot;请输入私钥&quot;</span>), <span class="string">&#x27;hex&#x27;</span> )</span><br><span class="line"><span class="keyword">let</span> wallet = ethwallet.<span class="title function_">fromPrivateKey</span>(privatekey)</span><br><span class="line"><span class="comment">// 获取钱包地址</span></span><br><span class="line"><span class="keyword">let</span> lowerCaseAddress = wallet.<span class="title function_">getAddressString</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>web3</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装Mysql5.7（ARM架构）</title>
    <url>/2023/11/29/CentOS7%E5%AE%89%E8%A3%85Mysql5-7%EF%BC%88ARM%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    <content><![CDATA[<p><strong>第一步：下载 arm 版本离线 mysql 5.7 安装包</strong><br><a href="https://obs.cn-north-4.myhuaweicloud.com/obs-mirror-ftp4/database/mysql-5.7.27-aarch64.tar.gz">arm 版本离线 mysql 5.7 安装包</a></p>
<p><strong>第二步：查询并卸载 CentOS 自带的数据库 Mariadb</strong><br>找到数据库 mariadb，如果有会给出一个结果，结果是 mariadb 名称<br><code>rpm -qa | grep mariadb</code><br>如果存在就卸载<br><code>rpm -e --nodeps [查询到的mariadb名称]</code></p>
<p><strong>第三步：创建用户和用户组</strong><br>先检查 mysql 用户和用户组有没有被使用<br><code>cat /etc/group | grep mysql</code><br><code>cat /etc/passwd | grep mysql</code><br>添加 mysql 用户组 <code>groupadd mysql</code><br>添加 mysql 用户并加入用户组 <code>useradd -g mysql mysql</code><br>修改 mysql 用户的登陆密码(这里根据需要设置，可以略过)<br><code>passwd mysql</code><br><code>12345678</code></p>
<p><strong>第四步：上传文件至服务器的/usr/local 后解压、改名、授权</strong><br><code>cd /usr/local</code><br>上传文件<br>解压安装包 mysql-5.7.27-aarch64.tar.gz<br><code>tar -xvf mysql-5.7.27-aarch64.tar.gz</code></p>
<p>将解压后的目录改名为 mysql<br><code>mv mysql-5.7.27-aarch64 mysql</code></p>
<p>目录授权操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">按照下面的操作执行</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/local/</span><br><span class="line"><span class="built_in">chown</span> -R mysql mysql/</span><br><span class="line"><span class="built_in">chgrp</span> -R mysql mysql/</span><br><span class="line"><span class="built_in">cd</span> mysql/</span><br><span class="line"><span class="built_in">mkdir</span> data</span><br><span class="line"><span class="built_in">chown</span> -R mysql:mysql data</span><br></pre></td></tr></table></figure>

<p><strong>第五步：安装 mysql 数据库【目录：/usr/local/mysql/bin】</strong><br><code>mysqld --initialize --user=mysql --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data/</code></p>
<p>安装成功输出的日志如下:<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311300927353.png"><br>(红线部分即为 root 密码)</p>
<hr>
<p>报错：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311300928948.png"><br>解决方案：<br>原因是因为没有修改环境变量</p>
<p><code>vi /etc/profile</code><br>在文件最后一行添加：<code>export PATH=$PATH:/usr/local/mysql/bin</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311300929299.png"></p>
<p>退出后使用命令<br><code>source /etc/profile</code></p>
<hr>
<p>报错：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311300929212.png"><br>解决方案：<br>yum install libatomic</p>
<hr>
<p>报错：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311300930521.png"><br>解决方案：<br>原因：因为 <code>CentOS7</code> 当前版本默认的 <code>GCC</code> 的版本太老，里面的动态链接库没有 <code>GLIBCXX_3.4.20</code> 和 <code>GLIBCXX_3.4.21</code>。</p>
<p>1.执行命令检查动态库：<code>strings /usr/lib64/libstdc++.so.6 | grep GLIBC</code><br>输出：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311300931321.png"><br>可以看出最高版本是 3.4.19</p>
<p>2.查看 libstdc++.so.6 的位置：<code>find / -name libstdc++.so.6\*</code><br>输出：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311300931360.png"><br>最高版本文件是 <code>libstdc++.so.6.0.19</code></p>
<p>3.下载 GCC 源码，选择合适的版本，本文以 gcc-13.2.0 为例<br>gcc 各版本下载地址： <a href="https://ftp.gnu.org/gnu/gcc/">https://ftp.gnu.org/gnu/gcc/</a><br>安装编译环境：<br><code>yum groupinstall &quot;Development Tools&quot;</code><br><code>yum install glibc-static libstdc++-static</code></p>
<p>解压上传的 gcc-13.2.0：<code>tar -Jxvf gcc-13.2.0.tar.xz</code> 【在上传目录中运行】</p>
<p>进入源码目录进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> gcc-13.2.0</span><br><span class="line">./contrib/download_prerequisites</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure>

<p>生成 make 文件并且编译（ps:此处编译时间比较久)<br><code>../configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</code><br><code>make</code><br>编译完成后安装：<code>make install</code><br>安装完成后查看版本是否更新：<code>strings /usr/lib64/libstdc++.so.6 | grep GLIBC</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311300933026.png"><br>发现并没有更新到最新的动态库</p>
<p>查找编译 gcc 时生成的最新动态库：<code>find / -name &quot;libstdc++.so\*&quot;</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311300934751.png"><br>可以看到生成的最新版本文件在：<code>/usr/local/mysql/extra/libstdc++.so.6.0.24</code><br>下面拷贝文件到 lib 目录，并重新建立软链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/mysql/extra/libstdc++.so.6.0.24 /usr/lib64/</span><br><span class="line"><span class="built_in">cd</span> /usr/lib64</span><br><span class="line"><span class="built_in">rm</span> libstdc++.so.6</span><br><span class="line"><span class="built_in">ln</span> -sf /usr/lib64/libstdc++.so.6.0.24 /usr/lib64/libstdc++.so.6</span><br></pre></td></tr></table></figure>

<p>最后再确认 GLIBCxx 的版本: <code>strings /usr/lib64/libstdc++.so.6 |grep GLIBC</code></p>
<p><strong>第六步：安装成功后设置文件和目录权限：</strong><br>此时 root 用户 还是在 mysql 目录下执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> ./support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line"><span class="built_in">chown</span> 777 my.cnf</span><br><span class="line"><span class="built_in">chmod</span> +x /etc/init.d/mysqld</span><br></pre></td></tr></table></figure>

<p><strong>第七步：修改配置文件</strong><br>将 <code>/etc/init.d/mysqld</code> 里面的 所有的 <code>mysql-5.7.27-aarch64</code> 改为 <code>mysql</code><br>将 <code>/usr/local/mysql/my.cnf</code> 里面所有的 <code>“socket =”</code> 后面改为 <code>/tmp/mysql.sock</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311300936543.png"></p>
<p><strong>第八步：创建日志文件</strong><br>创建日志目录<br><code>mkdir /usr/local/mysql/logs</code><br>创建错误日志文件<br><code>echo “” &gt; /usr/local/mysql/logs/mysql-error.log</code><br>授权<br><code>chown -R mysql:mysql /usr/local/mysql/logs/mysql-error.log</code></p>
<p><strong>第九步：启动脚本</strong><br><code>/etc/init.d/mysqld restart</code></p>
<p><strong>第十步：登录并修改 root 密码</strong><br><code>mysql -uroot -p</code><br>输入密码（上面操作 bin/mysqld –initialize xxx 生成）</p>
<p><strong>第十一步：设置开机自启动</strong> 1.先将<code>/usr/local/mysql/support-files/</code> 文件夹下的 <code>mysql.server</code> 文件复制到 <code>/etc/rc.d/init.d/</code> 目录下 <code>mysqld</code><br>命令: <code>cp /usr/local/mysql/support-files/mysql.server /etc/rc.d/init.d/mysqld</code></p>
<p>赋予可执行权限：<code>chmod +x /etc/init.d/mysqld</code></p>
<p>添加为服务: <code>chkconfig --add mysqld</code></p>
<p>查看服务列表: <code>chkconfig --list</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311300941574.png"><br>看到 3、4、5 状态为开或者为 on 则表示成功。如果是 关或者 off 则执行一下：<code>chkconfig --level 345 mysqld on</code></p>
<p>重启计算机:<code>reboot</code></p>
]]></content>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql本地数据上传至服务器</title>
    <url>/2023/11/14/Mysql%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="1-任务："><a href="#1-任务：" class="headerlink" title="1 任务："></a>1 任务：</h2><p>将本地 Mysql 中的数据迁移至线上服务器<br>线上 Mysql 服务器创建具有相关权限的用户<br>本地程序更换线上 Mysql 地址</p>
<h2 id="2-实现："><a href="#2-实现：" class="headerlink" title="2 实现："></a>2 实现：</h2><p><strong>安装 Mysql 并配置远程访问</strong></p>
<ol>
<li>第一步下载对应系统版本的 mysql，并解压<br><a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311141033139.png"><br>【其中 data 和 my.ini 是手动创建】</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## my.ini文件</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port=3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=E://software_qw//mysql-5.7.43-winx64</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir=E://software_qw//mysql-5.7.43-winx64//data</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=200</span><br><span class="line"># 允许连接失败的次数。</span><br><span class="line">max_connect_errors=10</span><br><span class="line">wait_timeout=31536000</span><br><span class="line">interactive_timeout=31536000</span><br><span class="line"># 服务端使用的字符集默认为UTF8</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"># 默认使用“mysql_native_password”插件认证</span><br><span class="line">#mysql_native_password</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[client]</span><br><span class="line"># 设置mysql客户端连接服务端时默认使用的端口</span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>

<p>data 是空文件夹</p>
<ol start="2">
<li>用管理员运行 cmd 进入解压目录的 bin 目录</li>
</ol>
<p>运行命令 <code>mysqld --initialize --console</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311141035726.png"><br>【红框的位置是 root 用户的密码】</p>
<p>运行命令 安装服务 <code>mysqld --install</code></p>
<ol start="3">
<li>第三步 启动 mysql 服务</li>
</ol>
<p><code>net start mysql</code></p>
<ol start="4">
<li>第四步 登录 mysql</li>
</ol>
<p><code>mysql -u root -p  上面红框中的密码（或者直接回车，等到出现 password: 再输入）</code></p>
<ol start="5">
<li>第五步 修改 root 密码</li>
</ol>
<p><code>ALTER USER &quot;root&quot;@&quot;localhost&quot; IDENTIFIED  BY &quot;root1&quot;;</code><br>这里将密码设置成了 root1</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311141036382.png"></p>
<ol start="6">
<li>第六步 创建一个新用户用于远程访问</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select user,host,plugin from user;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311141037773.png"></p>
<p>创建新用户：<code>CREATE USER &#39;new_user&#39;@&#39;%&#39; IDENTIFIED BY &#39;passwd&#39;;</code></p>
<p>例如：<code>CREATE USER &#39;icrt&#39;@&#39;%&#39; IDENTIFIED BY &#39;icrt123!@#&#39;;</code><br>用户：icrt 密码：icrt123!@#</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311141038672.png"><br>【这里 host 是 % 代表可以任意 ip 访问 plugin 一定是 mysql_native_password 不然客户端连接不了】</p>
<ol start="7">
<li>为用户赋予权限<br>给用户赋权限 操作数据库的权限，这里赋的是全部的权限：<code>GRANT ALL ON *.* TO &#39;new_user&#39;@&#39;%&#39;;</code></li>
</ol>
<p>例如：<code>GRANT ALL ON *.* TO &#39;icrt&#39;@&#39;%&#39;;</code></p>
<p><code>GRANT SELECT ON test.* TO &#39;icrt&#39;@&#39;%&#39;; // 给用户icrt赋予test数据库的只读权限</code></p>
<p>grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant select on testdb.* to common_user@&#x27;%&#x27;;</span><br><span class="line">grant insert on testdb.* to common_user@&#x27;%&#x27;;</span><br><span class="line">grant update on testdb.* to common_user@&#x27;%&#x27;;</span><br><span class="line">grant delete on testdb.* to common_user@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>🌟 刷新权限【重要，否则不生效】 flush privileges;</li>
</ol>
<p>可以通过 Navicat / Dbeaver 远程连接<br>Url: <code>jdbc:mysql://服务器IP:3306/</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311141039233.png"><br>本地程序更换 datasource 的 url 为上述 ur l 即可</p>
<p><strong>本地库表上传至服务器 Mysql 数据库</strong></p>
<p>方法一： 使用 Navicat 的数据传输</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311141040913.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311141040652.png"><br>可能的报错，ERROR 1153 传输的文件内容太大<br>解决方法：</p>
<p>在终端中使用 MySQL 的 root 用户登录 MySQL;（本地和服务器的 mysql 都要配置以下的内容）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global max_allowed_packet=1000000000;</span><br><span class="line">set global net_buffer_length=1000000;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>方法二： 本地导出 SQL 文件，复制到服务器导入</p>
]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT认证登录小Demo</title>
    <url>/2023/11/10/JWT%E8%AE%A4%E8%AF%81%E7%99%BB%E5%BD%95%E5%B0%8FDemo/</url>
    <content><![CDATA[<h2 id="Token-认证"><a href="#Token-认证" class="headerlink" title="Token 认证"></a>Token 认证</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311100955887.png"></p>
<p><strong>Token 认证流程</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311100956226.png"></p>
<p><strong>Token 认证的特点</strong></p>
<p>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。</p>
<p>用解析 token 的时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库。</p>
<p>token 完全由应用管理，所以它可以避开同源策略。</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311100959862.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101000448.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101000897.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101000499.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101000886.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101001022.png"></p>
<p><strong>JWT 特点</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101001776.png"></p>
<p><strong>JWT 实现</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101002221.png"></p>
<p>生成 Token<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101002562.png"></p>
<p>解析 Token<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101003112.png"></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><strong>项目结构</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101034576.png"></p>
<p><strong>User.java</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101034810.png"></p>
<p><strong>JwtUtils.java</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101035218.png"></p>
<p><strong>Result.java</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101036558.png"></p>
<p><strong>ResultCode.java</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101036759.png"></p>
<p><strong>UserController.java</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101037480.png"></p>
<h2 id="接口测试结果"><a href="#接口测试结果" class="headerlink" title="接口测试结果"></a>接口测试结果</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202311101037067.png"></p>
<p>🌟 <a href="https://github.com/qw-null/loginDemo">github 仓库</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger2集成到SpringBoot</title>
    <url>/2023/10/26/Swagger2%E9%9B%86%E6%88%90%E5%88%B0SpringBoot/</url>
    <content><![CDATA[<p><code>swagger</code>是当下比较流行的实时接口文文档生成工具。接口文档是当前前后端分离项目中必不可少的工具，在前后端开发之前，后端要先出接口文档，前端根据接口文档来进行项目的开发，双方开发结束后在进行联调测试。</p>
<h2 id="SpringBoot-集成-swagger2"><a href="#SpringBoot-集成-swagger2" class="headerlink" title="SpringBoot 集成 swagger2"></a>SpringBoot 集成 swagger2</h2><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 在pom.xml文件中加入swagger2使用的依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-swagger-配置"><a href="#2-swagger-配置" class="headerlink" title="2.swagger 配置"></a>2.swagger 配置</h3><p>swagger 的使用需要对其进行配置，一般是在项目的根目录下配置<code>SwaggerConfig</code>文件【<code>config</code>包下的<code>SwaggerConfig</code>】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//告诉Spring容器，这个类是一个配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span><span class="comment">//启用Swagger2功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置swagger2相关的bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com&quot;</span>))<span class="comment">//com包下的所有API都交给Swagger2管理</span></span><br><span class="line">                .paths(PathSelectors.any()).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处主要是API文档页面显示信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;演示项目API&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;演示项目&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-其他配置"><a href="#3-其他配置" class="headerlink" title="3.其他配置"></a>3.其他配置</h3><p>此时启动项目，项目会报错（SpringBoot 版本：<code>2.7.17</code>）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202310261025523.png"><br>出错原因：SpringBoot 版本与 Swagger 版本不匹配导致。Spring Boot 2.6.X 及以上使用 PathPatternMatcher 匹配路径，Swagger 引用的 Springfox 使用的路径匹配是基于 AntPathMatcher 的。<br>解决方法：<br>在 springBoot 配置文件中添加配置：<br><code>spring.mvc.pathmatch.matching-strategy=ANT_PATH_MATCHER</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202310261028695.png"><br>再次启动问题解决。</p>
<p>访问地址： ip:端口号/swagger-ui.html</p>
<p>问题解决！！！</p>
<h3 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4.使用示例"></a>4.使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserController文件</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(value = &quot;用户接口&quot;,tags=&#123;&quot;用户接口&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据ID查询用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;根据ID获取用户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;添加用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;添加用户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;修改用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;更新用户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据ID删除用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteById</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;根据ID删除用户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL必知必会</title>
    <url>/2023/08/21/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<p>书籍下载地址：<a href="https://qinweirz-my.sharepoint.com/:b:/g/personal/qinwei_qinweirz_onmicrosoft_com/ERvXFKVNW0dErHJc5EWtOhIBrjFcFVd-Va13QWYN2_WyJQ?e=PZfkdX">《MySQL 必知必会》</a><br>书籍《MySQL 必知必会》阅读笔记</p>
<h1 id="第-1-章-了解-SQL"><a href="#第-1-章-了解-SQL" class="headerlink" title="第 1 章 了解 SQL"></a>第 1 章 了解 SQL</h1><h2 id="1-1-了解-SQL"><a href="#1-1-了解-SQL" class="headerlink" title="1.1 了解 SQL"></a>1.1 了解 SQL</h2><h3 id="1-1-1-什么是数据库？"><a href="#1-1-1-什么是数据库？" class="headerlink" title="1.1.1 什么是数据库？"></a>1.1.1 什么是数据库？</h3><p><i style="color:red;">数据库（database）</i>:保存有组织的数据的容器（通常是一个文件或者是一组文件）<br><strong>注意：</strong> 人们常用数据库这个术语来代表他们使用的数据库软件，这是不正确的。数据库软件应该称为 DBMS（数据库管理系统）。数据库是通过 DBMS 创建和操纵的容器。通常是我们使用 DBMS，它替我们访问数据库。</p>
<h3 id="1-1-2-表"><a href="#1-1-2-表" class="headerlink" title="1.1.2 表"></a>1.1.2 表</h3><p><i style="color:red;">表（table）</i>：某种特定类型数据的结构化清单。</p>
<p>数据库中的，每个表都有一个名字，用来标识自己。<b style="background:yellow;">此名字是唯一的</b>，这表示数据库中没有其他表具有相同的名字。</p>
<p>在相同数据库中不能出现相同的表名。</p>
<p><i style="color:red;">模式（schema）</i>：关于数据库和表的布局及特性的信息。【表具有一些特性，这些特性定义了数据在表中如何存储，如 可以存储什么样的信息，数据如何分解，各部分信息如何命名 等等，描述表的这组信息就是所谓的模式】</p>
<h3 id="1-1-3-列和数据类型"><a href="#1-1-3-列和数据类型" class="headerlink" title="1.1.3 列和数据类型"></a>1.1.3 列和数据类型</h3><p>表由列组成，列中存储着表中某部分的信息。</p>
<p><i style="color:red;">列（column）</i>：表中的一个字段。所有表都是由一个或多个列组成的。</p>
<p><i style="color:red;">数据类型（datatype）</i>：所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。</p>
<h3 id="1-1-4-行"><a href="#1-1-4-行" class="headerlink" title="1.1.4 行"></a>1.1.4 行</h3><p>表中的数据是按行存储的，所保存的每个记录存储在自己的行内。</p>
<p><i style="color:red;">行（row）</i>：表中的一个记录。</p>
<p>你可能听到用户在提到行时将其成为记录（record）。在很大程度上，这两个术语是可以相互替代的，但从技术上来说，行才是正确的术语。</p>
<h3 id="1-1-5-主键"><a href="#1-1-5-主键" class="headerlink" title="1.1.5 主键"></a>1.1.5 主键</h3><p><i style="color:red;">主键（primary key）</i>：一列（或一组列），其值能够唯一区分表中每个行。唯一标识表中每行的这个列（或这组列）成为主键。主键用来表示一个特定的行。没有主键，更新或者删除表中特定行很困难。</p>
<p><strong>注意：</strong> 虽然并不是都需要主键，但大多数数据库设计人员都应该保证他们创建的每个表具有一个主键，以便于以后数据操纵和管理。</p>
<p>表中的任何列都可以作为主键，只要满足以下两个条件：</p>
<ul>
<li>任意两行都不具有相同的主键值</li>
<li>每个行都必须具有一个主键值（主键列不允许 NULL 值）</li>
</ul>
<p>主键最好习惯：除了 MySQL 强制实施的规则外，应该坚持的几个普遍认可的好习惯：</p>
<ol>
<li>不更新主键列中的值</li>
<li>不重用主键列的值</li>
<li>不在主键列中使用可能会更改的值</li>
</ol>
<h2 id="1-2-什么是-SQL"><a href="#1-2-什么是-SQL" class="headerlink" title="1.2 什么是 SQL"></a>1.2 什么是 SQL</h2><p>SQL 是结构化查询语言（Structure Query Language）的缩写。SQL 是一种专门用来与数据库通信的语言。</p>
<h1 id="第-2-章-MySQL-简介"><a href="#第-2-章-MySQL-简介" class="headerlink" title="第 2 章 MySQL 简介"></a>第 2 章 MySQL 简介</h1><h2 id="2-1-什么是-MySQL"><a href="#2-1-什么是-MySQL" class="headerlink" title="2.1 什么是 MySQL"></a>2.1 什么是 MySQL</h2><p>数据的所有存储、检索、管理和处理实际上是由数据库软件————DBMS（数据库管理软件）完成的。MySQL 是一种 DBMS，即它是一种数据库软件。</p>
<h2 id="2-1-1-客户机-服务器软件"><a href="#2-1-1-客户机-服务器软件" class="headerlink" title="2.1.1 客户机 - 服务器软件"></a>2.1.1 客户机 - 服务器软件</h2><p>DBMS 可以分为两类：一类为基于共享文件系统的 DBMS，另一类是基于客户机-服务器的 DBMS。</p>
<h1 id="第-3-章-使用-MySQL"><a href="#第-3-章-使用-MySQL" class="headerlink" title="第 3 章 使用 MySQL"></a>第 3 章 使用 MySQL</h1><h2 id="3-1-连接"><a href="#3-1-连接" class="headerlink" title="3.1 连接"></a>3.1 连接</h2><p>为了连接到 MySQL，需要以下信息：</p>
<ul>
<li>主机名（计算机名）- 如果连接到本地 MySQL 服务器，为<code>localhost</code></li>
<li>端口（如果使用默认端口 3306 之外的端口）</li>
<li>一个合法的用户名</li>
<li>用户口令（如果需要）</li>
</ul>
<h2 id="3-2-选择数据库"><a href="#3-2-选择数据库" class="headerlink" title="3.2 选择数据库"></a>3.2 选择数据库</h2><p>为了使用名字为<code>crashcourse</code>数据库，应该输入以下内容： <code>USE crashcourse</code><br><strong>记住：</strong> 必须使用<code>USE</code>打开数据库，才能读取其中的数据。</p>
<h2 id="3-3-了解数据库和表"><a href="#3-3-了解数据库和表" class="headerlink" title="3.3 了解数据库和表"></a>3.3 了解数据库和表</h2><p>数据库、表、列、用户、权限等的信息被存储在数据库和表中（MySQL 使用 MySQL 来存储这些信息）。不过，内部的表一般不直接访问。可以使用 MySQL 的<code>SHOW</code>命令来显示这些信息。</p>
<p>输入：<code>SHOW DATABASES;</code></p>
<p>分析：返回可用数据库的一个列表，包含在这个列表中的可能是 MySQL 内部使用的数据库。</p>
<hr>
<p>为了获得一个数据库内的表的列表，使用<code>SHOW TABLES;</code></p>
<p>输入：<code>SHOW TABLES;</code></p>
<p>分析：返回当前选择的数据库内可用表的列表</p>
<hr>
<p><code>SHOW</code>也可以用来显示表列：</p>
<p>输入：<code>SHOW COLUMNS FROM customers;</code></p>
<p>分析：<code>SHOW COLUMNS</code>要求给出一个表名，它对每个字段返回一行，行中包含字段名、数据类型、是否允许 NULL、键信息、默认值以及其他信息。</p>
<hr>
<p>其他<code>SHOW</code>语句：</p>
<ul>
<li><code>SHOW STATUS</code>，用于显示广泛的服务器状态信息；</li>
<li><code>SHOW CREATE DATABASE</code> 和 <code>SHOW CREATE TABLE</code>，分别用来显示创建特定的数据库或表的 MySQL 语句；</li>
<li><code>SHOW GRANTS</code>，用来显示授予用户（所有用户或特定用户）的安全权限；</li>
<li><code>SHOW ERRORS</code>和<code>SHOW WARNINGS</code>，用来显示服务器错误或警告信息</li>
</ul>
<h1 id="第-4-章-检索数据"><a href="#第-4-章-检索数据" class="headerlink" title="第 4 章 检索数据"></a>第 4 章 检索数据</h1><h2 id="4-1-select-语句"><a href="#4-1-select-语句" class="headerlink" title="4.1 select 语句"></a>4.1 select 语句</h2><p><code>select</code>语句的作用是从一个或者多个表中检索信息。</p>
<h2 id="4-2-检索单个列"><a href="#4-2-检索单个列" class="headerlink" title="4.2 检索单个列"></a>4.2 检索单个列</h2><p>输入：<code>SELECT prod_name FROM products;</code><br>分析：上述语句利用<code>SELECT</code>语句从<code>products</code>表中检索一个名为<code>prod_name</code>的列。所需的列名在<code>SELECT</code>关键字之后给出，<code>FROM</code>关键字指出从其中检索数据的表名。</p>
<p><strong>注意：</strong> <code>SQL</code>语句不区分大小写，但是许多开发人员喜欢对所有<code>SQL</code>关键字使用大写，而对所有列和表名使用小写，这样做便于代码的阅读和调试。</p>
<h2 id="4-3-检索多个列"><a href="#4-3-检索多个列" class="headerlink" title="4.3 检索多个列"></a>4.3 检索多个列</h2><p>要想从一个表中检索出多个列，使用相同的<code>SELECT</code>语句。唯一不同的是必须在<code>SELECT</code>关键字之后给出多个列名，列名之间必须以逗号分隔。</p>
<p>输入：<code>SELECT prod_id,prod_name,prod_price FROM products;</code></p>
<h2 id="4-4-检索所有列"><a href="#4-4-检索所有列" class="headerlink" title="4.4 检索所有列"></a>4.4 检索所有列</h2><p><code>SELECT</code>语句可以检索所有列，而不必将所有列名都列出，可以通过在实际列名的位置使用星号（*）通配符来达到。</p>
<p>输入：<code>SELECT * FROM products;</code><br>分析：如果给定一个通配符（*），则返回表中的所有列。列的顺序一般是列在表定义中出现的顺序。但有时候并不是这样的，表的模式的变化（如添加或删除列）可能会导致顺序的变化。</p>
<h2 id="4-5-检索不同行"><a href="#4-5-检索不同行" class="headerlink" title="4.5 检索不同行"></a>4.5 检索不同行</h2><p>正如所见，<code>SELECT</code>返回所有匹配的行。但是如果不想要每个值每次都出现，怎么办？<br>使用语句<code>SELECT vend_id FROM products;</code>会列出所有产品的供货商 id，即使存在相同的供货商也会将其全部列出（存在大量重复）。<br>解决办法是使用<code>DISTINCT</code>关键字，顾名思义，此关键字指示<code>MySQL</code>只返回不同的值。</p>
<p>输入：<code>SELECT DISTINCT vend_id FROM products;</code><br>分析：<code>SELECT DISTINCT vend_id</code>告诉<code>MySQL</code>只返回不同（唯一）的<code>vend_id</code>行。<code>DISTINCT</code>关键字必须直接放在列名的前面。</p>
<h2 id="4-6-限制结果"><a href="#4-6-限制结果" class="headerlink" title="4.6 限制结果"></a>4.6 限制结果</h2><p><code>SELECT</code>语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或者前几行，可以使用<code>LIMIT</code>子句。<br>输入：<code>SELECT prod_name FROM products LIMIT 5;</code><br>分析：此语句使用<code>SELECT</code>语句检索单个列。<code>LIMIT 5</code>指示<code>MySQL</code>返回不多于 5 行。</p>
<p>输入：<code>SELECT prod_name FROM products LIMIT 5,5;</code><br>分析：<code>LIMIT 5,5</code>指示<code>MySQL</code>返回从第 5 行开始的后续 5 行。第一个数为开始位置，第二个数为要检索的行数。</p>
<p><strong>注意：</strong> <span style="color:red;">行 0 </span> 检索出来的第一行为行 0 而不是行 1。因此，<code>LIMIT 1,1</code>将检索出第二行而不是第一行。</p>
<h2 id="4-7-使用完全限定的表名"><a href="#4-7-使用完全限定的表名" class="headerlink" title="4.7 使用完全限定的表名"></a>4.7 使用完全限定的表名</h2><p>迄今为止使用的<code>SQL</code>例子只<i style="color:red">通过列名引用列</i>。也可能会<i style="color:red">使用完全限定的名字来引用列（同时使用表名和列名）</i>。</p>
<p>输入：<code>SELECT products.prod_name FROM crashcourse.products;</code></p>
<h1 id="第-5-章-排序检索数据"><a href="#第-5-章-排序检索数据" class="headerlink" title="第 5 章 排序检索数据"></a>第 5 章 排序检索数据</h1><h2 id="5-1-排序数据"><a href="#5-1-排序数据" class="headerlink" title="5.1 排序数据"></a>5.1 排序数据</h2><p>在上一章中，通过<code>SELECT</code>语句检索出的数据并没有按照顺序输出。其实检索出的数据并不是完全随机显示，如果不对其进行排序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的顺序，但是如果数据后来进行过更新或者删除，则此顺序将会受到<code>MySQL</code>重用回收存储空间的影响。</p>
<p><strong><i style="color:red">子句（clause）</i></strong> <code>SQL</code>语句由子句构成，有些子句是必需的，而有的是可选的。一个子句通常由一个关键字和所提供的数据组成。子句的例子有<code>SELECT</code>语句的<code>FROM</code>子句。</p>
<p>为了明确地排序用<code>SELECT</code>语句检索出的数据，可以使用<code>ORDER BY</code>子句。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>分析：这条语句除了指示<code>MySQL</code>对<code>prod_name</code>列以字母顺序排列数据的<code>ORDER BY</code>子句外，与前面的语句相同。</p>
<h2 id="5-2-按多个列排序"><a href="#5-2-按多个列排序" class="headerlink" title="5.2 按多个列排序"></a>5.2 按多个列排序</h2><p>为了按照多个列排序，只要指定列名，列名之间用逗号分开即可。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price,prod_name;</span><br></pre></td></tr></table></figure>

<p>分析：上述代码检索 3 个列，并按照其中两个列对结果进行排序——先按价格，然后再按名称排序。</p>
<h2 id="5-3-指定排序方向"><a href="#5-3-指定排序方向" class="headerlink" title="5.3 指定排序方向"></a>5.3 指定排序方向</h2><p>数据排序不限于升序排序（从<code>A</code>到<code>Z</code>），这只是默认的排序顺序，还可以使用<code>ORDER BY</code>子句以降序（从<code>Z</code>到<code>A</code>）顺序排序。为了进行降序排序，必须指定<code>DESC</code>关键字。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>分析：按照价格以降序排序产品（最贵的排在最前面）</p>
<p>如果打算用多个列进行排序怎么办？下面例子以降序排序产品（最贵的在最前面），然后再对产品名排序。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>,prod_name</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 如果想在多个列上进行降序排序，必须对每个列指定<code>DESC</code>关键字。</p>
<p>与<code>DESC</code>相反的关键字是<code>ASC</code>，在升序排序时可以指定它。但实际上，<code>ASC</code>没有多大用处，因为升序是默认的。</p>
<p>使用<code>ORDER BY</code>和<code>LIMIT</code>的组合，能够找出一个列中最高或者最低值。<br>下面例子是如何找出最昂贵的物品的值：<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h1 id="第-6-章-过滤数据"><a href="#第-6-章-过滤数据" class="headerlink" title="第 6 章 过滤数据"></a>第 6 章 过滤数据</h1><h2 id="6-1-使用-WHERE-子句"><a href="#6-1-使用-WHERE-子句" class="headerlink" title="6.1 使用 WHERE 子句"></a>6.1 使用 WHERE 子句</h2><p>数据库表一般包含大量的数据，很少需要检索表中的所有行。通常只会根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指定 搜索条件 ，搜索条件也称为 过滤条件。<br>在<code>SELECT</code>语句中，数据根据<code>WHERE</code>子句中指定的搜索条件进行过滤。<code>WHERE</code>子句在表名（<code>FROM</code>子句）之后给出。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">=</span> <span class="number">2.50</span>;</span><br></pre></td></tr></table></figure>

<p>分析：这条语句从<code>products</code>表中检索两个列，但不返回所有行，只返回<code>prod_price</code>值为 2.50 的行。</p>
<blockquote>
<p><strong>WHERE 子句的位置</strong> 在同时使用 ORDER BY 和 WHERE 子句时，应该让 ORDER BY 位于 WHERE 之后，否则会产生错误。</p>
</blockquote>
<h2 id="6-2-WHERE-子句操作符"><a href="#6-2-WHERE-子句操作符" class="headerlink" title="6.2 WHERE 子句操作符"></a>6.2 WHERE 子句操作符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在指定两个值之间</td>
</tr>
</tbody></table>
<h3 id="6-2-1-检查单个值"><a href="#6-2-1-检查单个值" class="headerlink" title="6.2.1 检查单个值"></a>6.2.1 检查单个值</h3><p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="operator">=</span> <span class="string">&#x27;fuses&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分析：检查<code>WHERE prod_name = &#39;fuses&#39;</code>语句，它返回<code>prod_name</code>的值为<code>fuses</code>的一行。</p>
<hr>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>分析：列出价格小于 10 美元的所有产品。</p>
<h3 id="6-2-2-不匹配检查"><a href="#6-2-2-不匹配检查" class="headerlink" title="6.2.2 不匹配检查"></a>6.2.2 不匹配检查</h3><p>列出不是由供货商 1003 制造的所有产品：<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">①</span><br><span class="line"><span class="keyword">SELECT</span> vend_id,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">&lt;&gt;</span> <span class="number">1003</span>;</span><br><span class="line">②</span><br><span class="line"><span class="keyword">SELECT</span> vend_id,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">!=</span> <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-3-范围检查"><a href="#6-2-3-范围检查" class="headerlink" title="6.2.3 范围检查"></a>6.2.3 范围检查</h3><p>检索价格在 5 美元和 10 美元之间的所有产品：<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>分析：在使用<code>BETWEEN</code>时，必须指定两个值——所需范围低端值和高端值，这两个值之间必须使用<code>AND</code>关键字分割。</p>
<h3 id="6-2-4-空值检查"><a href="#6-2-4-空值检查" class="headerlink" title="6.2.4 空值检查"></a>6.2.4 空值检查</h3><p>在创建表时，表设计人员可以指定其中的列是否可以不包含空值。在一个列不包含值的时候，称其为包含空值<code>NULL</code>。</p>
<p><code>SELECT</code>语句有一个特殊的<code>WHERE</code>子句，可用来检查具有<code>NULL</code>值的列。这个<code>WHERE</code>子句就是<code>IS NULL</code>子句。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>分析：返回没有价格（空<code>prod_price</code>字段，不是价格为<code>0</code>）的所有产品。</p>
<h1 id="第-7-章-数据过滤"><a href="#第-7-章-数据过滤" class="headerlink" title="第 7 章 数据过滤"></a>第 7 章 数据过滤</h1><h2 id="7-1-组合-WHERE-子句"><a href="#7-1-组合-WHERE-子句" class="headerlink" title="7.1 组合 WHERE 子句"></a>7.1 组合 WHERE 子句</h2><p>为了进行更强的过滤控制，<code>MySQL</code>允许给出多个<code>WHERE</code>子句。这些子句可以两种方式使用：以<code>AND</code>子句的方式或<code>OR</code>子句的方式使用。</p>
<h3 id="7-1-1-AND-操作符"><a href="#7-1-1-AND-操作符" class="headerlink" title="7.1.1 AND 操作符"></a>7.1.1 AND 操作符</h3><p>为了通过不止一列进行过滤，可使用<code>AND</code>操作符给<code>WHERE</code>子句附加条件。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="number">1003</span> <span class="keyword">AND</span> prod_price <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>分析：检索由供应商 1003 制造且价格小于等于 10 美元的所有产品的名称和价格。</p>
<h3 id="7-1-2-OR-操作符"><a href="#7-1-2-OR-操作符" class="headerlink" title="7.1.2 OR 操作符"></a>7.1.2 OR 操作符</h3><p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="number">1002</span> <span class="keyword">AND</span> vend_id <span class="operator">=</span> <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>

<p>分析：检索 1002 供货商和 1003 供货商的所有产品。</p>
<h3 id="7-1-3-计算次序"><a href="#7-1-3-计算次序" class="headerlink" title="7.1.3 计算次序"></a>7.1.3 计算次序</h3><p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="number">1002</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="number">1003</span> <span class="keyword">AND</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>分析：上述<code>SQL</code>语句可以理解为由供应商 1003 制造的任何价格为 10 美元（含）以上的产品，或者由供应商 1002 制造的任何产品。</p>
<p><code>SQL</code>语句在处理<code>OR</code>操作符前，优先处理<code>AND</code>操作符。</p>
<p>若想要检索<span style="background:yellow;">由供货商 1002 或者 1003 制造的且价格都在 10 美元（含）以上的任何产品</span>，则需要通过使用圆括号明确地分组相应的操作符。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> (vend_id <span class="operator">=</span> <span class="number">1002</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="number">1003</span>) <span class="keyword">AND</span> prod_price <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-IN-操作符"><a href="#7-2-IN-操作符" class="headerlink" title="7.2 IN 操作符"></a>7.2 IN 操作符</h2><p>圆括号在<code>WHERE</code>子句还有另一种用法。<code>IN</code>操作符用来指定条件范围，范围中的每个条件都可以进行匹配。<code>IN</code>取合法值的由逗号分隔的清单，全部括在圆括号中。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1002</span>,<span class="number">1003</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>分析：此<code>SELECT</code>语句检索供应商 1002 和 1003 制造的所有产品。</p>
<h2 id="7-3-NOT-操作符"><a href="#7-3-NOT-操作符" class="headerlink" title="7.3 NOT 操作符"></a>7.3 NOT 操作符</h2><p><code>WHERE</code>子句中的<code>NOT</code>操作符有且只有一个功能，那就是否定它之后所跟的任何条件。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1002</span>,<span class="number">1003</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>分析：列出除 1002 和 1003 之外的所有供应商制造的产品。</p>
<h1 id="第-8-章-用通配符进行过滤"><a href="#第-8-章-用通配符进行过滤" class="headerlink" title="第 8 章 用通配符进行过滤"></a>第 8 章 用通配符进行过滤</h1><h2 id="8-1-LIKE-操作符"><a href="#8-1-LIKE-操作符" class="headerlink" title="8.1 LIKE 操作符"></a>8.1 LIKE 操作符</h2><p><strong>通配符：</strong> 用来匹配值的一部分的特殊字符。</p>
<p>为了搜索子句中使用通配符，必须使用<code>LIKE</code>操作符。<code>LIKE</code>指示<code>MySQL</code>，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。</p>
<h3 id="8-1-1-百分号（-）通配符"><a href="#8-1-1-百分号（-）通配符" class="headerlink" title="8.1.1 百分号（%）通配符"></a>8.1.1 百分号（%）通配符</h3><p>在搜索串中，<code>%</code>表示任何字符出现任意次数。例如，为了找出所有以词<code>jet</code>起头的产品，可以使用以下<code>SELECT</code>语句：<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;jet%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分析：此例子使用了搜索模式<code>jet%</code>。在执行这条子句时，将检索任意以<code>jet</code>起头的单词。<code>%</code>告诉 MySQL 接受 jet 之后的任意字符，不管它有多少字符。</p>
<p>通配符可在搜索模式中任意位置使用，并且可以使用多个通配符。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;%anvil%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分析：搜索模式<code>&#39;%anvil%&#39;</code>表示匹配任何位置包含文本<code>anvil</code>的值，而不论它之前或之后出现什么字符。</p>
<hr>
<p>输入:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;s%e&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分析：上述例子是找出以<code>s</code>起头以<code>e</code>结尾的所有产品。</p>
<p>**<span style="background:yellow;"><code>%</code>代表搜索模式中给定位置的 0 个、1 个或多个字符</span>**。</p>
<p><strong>注意 NULL</strong> 虽然似乎<code>%</code>通配符可以匹配任何东西，但有一个例外，即<code>NULL</code>。即使<code>WHERE prod_name LIKE &#39;%&#39;</code>也不能匹配用值<code>NULL</code>作为产品名的行。</p>
<h3 id="8-1-2-下划线（-）通配符"><a href="#8-1-2-下划线（-）通配符" class="headerlink" title="8.1.2 下划线（_）通配符"></a>8.1.2 下划线（_）通配符</h3><p>下划线的用途与<code>%</code>一样，但下划线只匹配单个字符而不是多个字符。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;_ ton anvil&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分析：此<code>WHERE</code>子句中的搜素模式给出了后面跟有文本的两个通配符。对于<code>.5 ton anvil</code>产品没有匹配，因为搜索模式要求匹配一个通配符而不是两个。</p>
<h1 id="第-9-章-用正则表达式进行搜索"><a href="#第-9-章-用正则表达式进行搜索" class="headerlink" title="第 9 章 用正则表达式进行搜索"></a>第 9 章 用正则表达式进行搜索</h1><h2 id="9-1-使用-MySQL-正则表达式"><a href="#9-1-使用-MySQL-正则表达式" class="headerlink" title="9.1 使用 MySQL 正则表达式"></a>9.1 使用 MySQL 正则表达式</h2><h3 id="9-1-1-基本字符匹配"><a href="#9-1-1-基本字符匹配" class="headerlink" title="9.1.1 基本字符匹配"></a>9.1.1 基本字符匹配</h3><p>下面语句检索列<code>prod_name</code>包含文本 1000 的所有行：</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;1000&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<hr>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;.000&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>分析：这里使用了正则表达式<code>.000</code>。<code>.</code>是正则表达式语言中的一个特殊的字符，它表示匹配任意一个字符。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308231121556.png"></p>
<blockquote>
<p><strong>匹配不区分大小写</strong> MySQL 中的正则表达式匹配（自版本 3.23.4 后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用<code>BINARY</code>关键字，如<code>WHERE prod_name REGEXP BINARY &#39;JetPack .000&#39;</code>。</p>
</blockquote>
<h3 id="9-1-2-使用OR匹配"><a href="#9-1-2-使用OR匹配" class="headerlink" title="9.1.2 使用OR匹配"></a>9.1.2 使用<code>OR</code>匹配</h3><p>为搜索两个串之一（或者为这个串，或者为另一个串），使用<code>|</code>。<br>输入:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;1000|2000&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>分析：<code>|</code>为正则表达式的<code>OR</code>操作符，它表示匹配其中之一。</p>
<h3 id="9-1-3-匹配几个字符之一"><a href="#9-1-3-匹配几个字符之一" class="headerlink" title="9.1.3 匹配几个字符之一"></a>9.1.3 匹配几个字符之一</h3><p>匹配任何单一字符，可以通过指定一组<code>[</code>和<code>]</code>括起来的字符来完成。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP `[<span class="number">123</span>] Ton`</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>分析：这里，使用了正则表达式<code>[123] Ton</code>。<code>[123]</code>定义一组字符，它的意思是匹配 1 或 2 或 3，因此，数据<code>1 ton</code>、<code>2 Ton</code>和<code>3 Ton</code>都会被匹配。【MySQL 不区分大小写】。</p>
<p>正如所见，<code>[]</code>是另一种形式的<code>OR</code>语句。事实上，正则表达式<code>[123] Ton</code>。事实上，正则表达式<code>[123] Ton</code>为<code>[1|2|3] Ton</code>的缩写。</p>
<p><code>[^123] Ton</code>匹配除了字符<code>1</code>、<code>2</code>、<code>3</code>之外的任何字符。</p>
<h3 id="9-1-4-匹配范围"><a href="#9-1-4-匹配范围" class="headerlink" title="9.1.4 匹配范围"></a>9.1.4 匹配范围</h3><p>集合可以用来定义要匹配的一个或多个字符。</p>
<p>匹配数字 0 到 9：<code>[0123456789]</code> 或者 <code>[0-9]</code><br>匹配任意字母字符：<code>[a-z]</code></p>
<h3 id="9-1-5-匹配特殊字符"><a href="#9-1-5-匹配特殊字符" class="headerlink" title="9.1.5 匹配特殊字符"></a>9.1.5 匹配特殊字符</h3><p>为了匹配特殊字符，必须用<code>\\</code>为前导。例如：<code>\\-</code>表示查找<code>-</code>，<code>\\.</code>表示查找<code>.</code>。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">WHERE</span> vend_name REGEXP <span class="string">&#x27;\\.&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>

<p><code>\\</code>也用来引用元字符（具有特殊含义的字符）。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308231450883.png"></p>
<blockquote>
<p>*<em>匹配 \*</em> 为了匹配反斜杠（\）字符本身，需要使用<code>\\\</code></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308231526883.png"></p>
<h3 id="9-1-6-匹配字符类"><a href="#9-1-6-匹配字符类" class="headerlink" title="9.1.6 匹配字符类"></a>9.1.6 匹配字符类</h3><p>存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集，成为字符类。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308231541472.png"></p>
<h3 id="9-1-7-匹配多个实例"><a href="#9-1-7-匹配多个实例" class="headerlink" title="9.1.7 匹配多个实例"></a>9.1.7 匹配多个实例</h3><p>到目前为止，使用的所有正则表达式都试图匹配单次出现。如果存在一个匹配，该行被检索出来，如果不存在，检索不出任何行。但有时需要对匹配的数目进行更强的控制，需要限制字符出现的次数。可以通过重复元字符来实现。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308231550477.png"></p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;\\([0-9] sticks?\\)&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308231552346.png"><br>分析：正则表达式<code>\\([0-9] sticks?\\)</code>解说如下，<code>\\(</code>匹配<code>)</code>，<code>[0-9]</code>匹配任意数字（这个例子中为 1 和 5），<code>sticks?</code>匹配<code>stick</code>和<code>sticks</code>（<code>s</code>后的<code>?</code>使得<code>s</code>可选，因为<code>?</code>匹配它前面的任何字符的 0 次或 1 次出现），<code>\\)</code>匹配<code>)</code>。没有<code>?</code>，匹配<code>stick</code>和<code>sticks</code>会非常困难。</p>
<p>匹配连在一起的 4 位数字：<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;[[:digit:]]&#123;4&#125;&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>分析：<code>[[:digit:]]</code>匹配任意数字，因而它为数字的一个集合。<code>&#123;4&#125;</code>确切的要求它前面的字符（任意数字）出现 4 次。</p>
<h3 id="9-1-8-定位符"><a href="#9-1-8-定位符" class="headerlink" title="9.1.8 定位符"></a>9.1.8 定位符</h3><p>目前为止所给出的例子都是匹配一个字符串中的任意位置的文本。为了匹配特定位置的文本，需要使用定位符。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308231606264.png"></p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">&#x27;^[0-9\\.]&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name；</span><br></pre></td></tr></table></figure>

<p>分析：<code>^</code>匹配串的开始。因此，<code>^[0-9\\.]</code>只在<code>.</code>或者任意数字为串中第一个字符时才匹配它们。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308231614247.png"></p>
<h1 id="第-10-章-创建计算字段"><a href="#第-10-章-创建计算字段" class="headerlink" title="第 10 章 创建计算字段"></a>第 10 章 创建计算字段</h1><h2 id="10-1-计算字段"><a href="#10-1-计算字段" class="headerlink" title="10.1 计算字段"></a>10.1 计算字段</h2><p><i style="color:red;">字段（filed）</i> 基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。</p>
<p>只有数据库知道<code>SELECT</code>语句中哪些列是实际的表列，哪些列是计算字段。</p>
<h2 id="10-2-拼接字段"><a href="#10-2-拼接字段" class="headerlink" title="10.2 拼接字段"></a>10.2 拼接字段</h2><p>【需求】需要将数据库中的供货商信息按照<code>name(location)</code>的形式返回。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(vend_name,<span class="string">&#x27;(&#x27;</span>,vend_country,<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308231627912.png"><br>分析：<code>Concat()</code>拼接串，即把多个串连接起来形成一个较长的串。</p>
<blockquote>
<p><strong>Trim 函数</strong> 该函数的作用是去除掉串两边的空格，除了该函数外，还有<code>RTrim()</code>去除串右边的空格、<code>LTrim()</code>去除掉串左边的空格。</p>
</blockquote>
<p><strong>使用别名</strong><br>从上面的案例中可以发现，<code>SELECT</code>语句拼接地址字段的工作做得很好，但是新计算得到的列的名字十分冗长，如果想要替换这个冗长的列名，可以通过别名来实现。</p>
<p><i style="color:red;">别名（alias）</i> 一个字段或值的替换。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Concat(RTrime(vend_name),<span class="string">&#x27;(&#x27;</span>,RTrime(vend_country),<span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span></span><br><span class="line">vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308240941666.png"></p>
<h2 id="10-3-执行算数计算"><a href="#10-3-执行算数计算" class="headerlink" title="10.3 执行算数计算"></a>10.3 执行算数计算</h2><p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity<span class="operator">*</span>item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">2005</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308240947204.png"><br>分析：上述<code>sql</code>语句功能是汇总物品的价格（单价乘以订购数量）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308240948788.png"></p>
<h1 id="第-11-章-使用数据处理函数"><a href="#第-11-章-使用数据处理函数" class="headerlink" title="第 11 章 使用数据处理函数"></a>第 11 章 使用数据处理函数</h1><h2 id="11-1-函数"><a href="#11-1-函数" class="headerlink" title="11.1 函数"></a>11.1 函数</h2><p>与其他大多数计算机语言一样，<code>SQL</code>支持利用函数来处理数据。函数一般是在数据上执行的，它给数据的转换和处理提供方便。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308240951598.png"></p>
<h2 id="11-2-使用函数"><a href="#11-2-使用函数" class="headerlink" title="11.2 使用函数"></a>11.2 使用函数</h2><p>大多数<code>SQL</code>实现以下类型的函数：文本处理函数、日期和时间处理函数、数值处理函数</p>
<h3 id="11-2-1-文本处理函数"><a href="#11-2-1-文本处理函数" class="headerlink" title="11.2.1 文本处理函数"></a>11.2.1 文本处理函数</h3><p>常见的文本处理函数：<br>| 函数 | 说明 |<br>| ———– | ———– |<br>| Left( ) | 返回串左边的字符 |<br>| Length( ) | 返回串的长度 |<br>| Locate( ) | 找出串的一个子串 |<br>| Lower( ) | 将串转换为小写 |<br>| LTrim( ) | 去掉串左边的空格 |<br>| RTrim( ) | 去掉串右边的空格 |<br>| Soundex( ) | 返回串的 SOUNDEX 值 |<br>| SubString( ) | 返回子串的字符 |<br>| Upper( ) | 将串转换为大写 |</p>
<p>说明：<code>SOUNDEX</code>是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。<code>SOUNDEX</code>考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。<br><code>SOUNDEX()</code>函数的主要目的是根据声音比较字符串之间的相似性。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241006421.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241006695.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241011238.png"></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241536140.png"></p>
<h3 id="11-2-2-日期和时间处理函数"><a href="#11-2-2-日期和时间处理函数" class="headerlink" title="11.2.2 日期和时间处理函数"></a>11.2.2 日期和时间处理函数</h3><p>日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效地排序或过滤，并节省物理存储空间。<br>一般应用程序不能使用用来存储日期和时间的格式，因此日期和时间函数就用来读取、统计和处理这些值。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241018885.png"></p>
<p><code>MySQL</code>使用的日期格式必须为<code>yyyy-mm-dd</code>，这种格式排除了多义性。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id,order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="operator">=</span> <span class="string">&#x27;2005-09-01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分析：此<code>SELECT</code>语句检索订单记录，检索出的订单记录的<code>order_date</code>为<code>2005-09-01</code>。</p>
<p>但是如果表中的订单记录的<code>oeder_date</code>是日期与时间的组合（即<code>2005-09-01 11:31:56</code>），那么通过上述<code>SQL</code>语句就无法匹配该天的订单记录，因此就要使用<code>Date()</code>函数去提取日期部分。<br>更加可靠的输入应为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id,order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">Date</span>(order_date) <span class="operator">=</span> <span class="string">&#x27;2005-09-01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>匹配当前月份内的所有订单，可以使用<code>BETWEEN</code>。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">① 需要了解当前月份多少天</span><br><span class="line"><span class="keyword">SELECT</span> cust_id,order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">Date</span>(order_date) <span class="keyword">BETWEEN</span> <span class="string">&#x27;2005-09-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2005-09-30&#x27;</span>;</span><br><span class="line"></span><br><span class="line">② 不需要了解当前月份多少天</span><br><span class="line"><span class="keyword">SELECT</span> cust_id,order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Year</span>(order_date) <span class="operator">=</span> <span class="number">2005</span>  <span class="keyword">AND</span> <span class="keyword">Month</span>(order_date) <span class="operator">=</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-3-数值处理函数"><a href="#11-2-3-数值处理函数" class="headerlink" title="11.2.3 数值处理函数"></a>11.2.3 数值处理函数</h3><p>数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241038467.png"></p>
<h1 id="第-12-章汇总数据"><a href="#第-12-章汇总数据" class="headerlink" title="第 12 章汇总数据"></a>第 12 章汇总数据</h1><h2 id="12-1-聚集函数"><a href="#12-1-聚集函数" class="headerlink" title="12.1 聚集函数"></a>12.1 聚集函数</h2><p>我们经常需要汇总数据而不是把它们实际检索出来，为此<code>MySQL</code>提供了专门的函数。<br>这种类型的检索例子一般包括：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241040168.png"></p>
<p><i style="color:red;">聚集函数（aggregate function）</i> 运行在行组上，计算和返回单个值的函数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241042023.png"></p>
<h3 id="12-1-1-AVG-函数"><a href="#12-1-1-AVG-函数" class="headerlink" title="12.1.1 AVG( ) 函数"></a>12.1.1 AVG( ) 函数</h3><p><code>AVG( )</code>通过对表中行数计数并计算特定列值之和，求得该列的平均值。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>只用于单个列</strong> <code>AVG( )</code>只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个<code>AVG( )</code>函数。</p>
</blockquote>
<blockquote>
<p><strong>NULL 值</strong> <code>AVG( )</code>函数忽略列值为<code>NULL</code> 的行。</p>
</blockquote>
<h3 id="12-1-2-COUNT（-）函数"><a href="#12-1-2-COUNT（-）函数" class="headerlink" title="12.1.2 COUNT（ ）函数"></a>12.1.2 COUNT（ ）函数</h3><p><code>COUNT( )</code>函数用于计数。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241105231.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241107050.png"></p>
<blockquote>
<p><strong><code>NULL</code>值</strong> 如果指定列名，则指定列的值为空的行被 <code>COUNT（）</code> 函数忽略，但如果<code>COUNT（）</code> 函数 中用的是星号（*）， 则不忽略。</p>
</blockquote>
<h3 id="12-1-3-MAX-函数"><a href="#12-1-3-MAX-函数" class="headerlink" title="12.1.3 MAX( )函数"></a>12.1.3 MAX( )函数</h3><p><code>MAX( )</code>返回指定列中的最大值，<code>MAX( )</code>要求指定列名。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241111012.png"></p>
<blockquote>
<p><strong>对非数值数据使用 MAX（）</strong> 虽然<code>MAX( )</code>一般用来找出最大的数值或日期值。但<code>MySQL</code>允许将它用于返回任意列值最大的值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则<code>MAX()</code>返回最后一行。</p>
</blockquote>
<p>对于<code>NULL</code>值，<code>MAX( )</code>函数忽略列值为<code>NULL</code>的行。</p>
<h3 id="12-1-4-MIN-函数"><a href="#12-1-4-MIN-函数" class="headerlink" title="12.1.4 MIN( ) 函数"></a>12.1.4 MIN( ) 函数</h3><p>与<code>MAX( )</code>函数的用法一致。</p>
<h3 id="12-1-5-SUM-函数"><a href="#12-1-5-SUM-函数" class="headerlink" title="12.1.5 SUM( )函数"></a>12.1.5 SUM( )函数</h3><p><code>SUM( )</code>用来返回指定列值的和（总计）。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> items_ordered</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">2005</span>;</span><br></pre></td></tr></table></figure>

<p>分析：函数<code>SUM(quantity)</code> 返回订单中所有物品数量之和。</p>
<h2 id="12-2-聚集不同值"><a href="#12-2-聚集不同值" class="headerlink" title="12.2 聚集不同值"></a>12.2 聚集不同值</h2><p>以上 5 个聚集函数都可以如下使用：</p>
<ul>
<li>对所有的行执行计算，指定<code>ALL</code>参数或不给参数（因为<code>ALL</code>是默认行为）</li>
<li>只包含不同的值，指定<code>DISTINCT</code>参数</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241123668.png"></p>
<p><strong>⚠️ 注意：</strong> 如果指定列名，则<code>DISTINCT</code> 只能用于<code>COUNT( )</code>。<code>DISTINCT</code>不能用于<code>COUNT(*)</code>，因此不允许使用<code>COUNT(DISTINCT)</code>，否则会产生错误。</p>
<h2 id="12-3-组合聚集函数"><a href="#12-3-组合聚集函数" class="headerlink" title="12.3 组合聚集函数"></a>12.3 组合聚集函数</h2><p>到目前为止，所有聚集函数的例子都只涉及单个函数。但实际上<code>SELECT</code>语句可根据需要包含多个聚集函数。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_items,</span><br><span class="line">       <span class="built_in">MIN</span>(prod_price) <span class="keyword">AS</span> price_min,</span><br><span class="line">       <span class="built_in">MAX</span>(prod_price) <span class="keyword">AS</span> price_max,</span><br><span class="line">       <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> price_avg</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241130927.png"></p>
<h1 id="第-13-章-分组数据"><a href="#第-13-章-分组数据" class="headerlink" title="第 13 章 分组数据"></a>第 13 章 分组数据</h1><h2 id="13-1-数据分组"><a href="#13-1-数据分组" class="headerlink" title="13.1 数据分组"></a>13.1 数据分组</h2><p>从上一章中可以知道<code>SQL</code>聚集函数可以用来汇总数据。到目前为止，所有的计算都是在表的所有数据或者匹配特定的<code>WHERE</code>子句的数据上进行的。<br>例如，返回供应商 1003 提供的产品数据，<code>SQL</code>语句如下所示：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241509894.png"></p>
<p>但如果要返回每个供应商提供的产品数目怎么办？或者返回只提供单项产品的供应商所提供的产品。此时就需要使用到分组。</p>
<p><i style="color:red;">分组：</i> 分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。</p>
<h2 id="13-2-创建分组"><a href="#13-2-创建分组" class="headerlink" title="13.2 创建分组"></a>13.2 创建分组</h2><p>分组是在<code>SELECT</code>语句的<code>GROUP BY</code>子句中建立的。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241557344.png"><br>分析：上面的<code>SELECT</code>语句指定了两个列，<code>vend_id</code>包含产品供应商的 ID，<code>num_prods</code> 为计算字段（用<code>COUNT(*)</code>函数建立）。<code>GROUP BY</code>子句指示<code>MySQL</code>按照<code>vend_id</code>排序并进行分组数据。这导致对每个<code>vend_id</code>而不是整个表计算<code>nums_prods</code>一次。从输出中可以看到，供应商 1001 有 3 个产品，供应商 1002 有 2 个产品，供应商 1003 有 7 个产品，供应商 1005 有 2 个产品。</p>
<p>因为使用<code>GROUP BY</code>，就不必指定要计算和估值的每个组了。系统会自动完成。<code>GROUP BY</code>子句指示<code>MySQL</code>分组数据，然后对每个组而不是整个结果进行聚集。</p>
<p>使用<code>GROUP BY</code>子句的一些重要规定：</p>
<ol>
<li><p><span style="color:red;"><code>GROUP BY</code>子句可以包含任意数目的列</span>。这使得能对分组进行嵌套，为数据分组提供了更加细致的控制。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308250950812.png"></p>
</li>
<li><p><span style="color:red;">如果在<code>GROUP BY</code>子句中嵌套了分组，数据将在最后规定的分组上进行汇总。</span> 换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别列中取回数据）。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308250959999.png"></p>
</li>
<li><p><span style="color:red;"><code>GROUP BY</code>子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）</span>。如果在<code>SELECT</code>中使用表达式，则必须在<code>GROUP BY</code>子句中指定相同的表达式。不能使用别名。</p>
</li>
<li><p><span style="color:red;">除聚集计算语句外，<code>SELECT</code>语句中的每个列都必须在<code>GROUP BY</code>子句中给出</span>。</p>
</li>
<li><p><span style="color:red;">如果分组列中具有<code>NULL</code>值，则 NULL 将作为一个分组返回。如果列中有多行<code>NULL</code>值，它们将分为一组</span>。</p>
</li>
</ol>
<p>6.<span style="color:red;"><code>GROUP BY</code>子句必须出现在<code>WHERE</code>子句之后，<code>ORDER BY</code>子句之前</span>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308241618103.png"></p>
<h2 id="13-3-过滤分组"><a href="#13-3-过滤分组" class="headerlink" title="13.3 过滤分组"></a>13.3 过滤分组</h2><p>除了能用<code>GROUP BY</code>分组数据之外，<code>MySQL</code>还允许过滤分组，规定包括哪个分组，排除哪个分组。<br><i>例如，可能要列出至少有 2 个订单的顾客。</i><br>我们在第 6 章中了解了<code>WHERE</code>子句的作用。但是在这个例子中<code>WHERE</code>不能完成任务，<span style="color:red;">因为<code>WHERE</code>过滤的是行，而不是分组</span>。事实上，<code>WHERE</code>没有分组的概念。</p>
<p><code>MySQL</code>提供了<code>HAVING</code>子句，用于过滤分组。到目前为止，所学习的<code>WHERE</code>子句的功能都能使用<code>HAVING</code> 子句来进行替代。</p>
<p><strong><span style="color:red;">WHERE 过滤行，HAVING 过滤分组。</span></strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308251014805.png"><br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>分析：这条<code>SELECT</code>语句的前 3 行类似于上面的语句。最后一行增加了<code>HAVING</code>子句，它过滤<code>COUNT(*) &gt;= 2</code>（两个及以上的订单）的那些分组。</p>
<blockquote>
<p><strong><code>HAVING</code> 和 <code>WHERE</code>的差别</strong> <code>WHERE</code>在数据分组前进行过滤，<code>HAVING</code>在数据分组后进行过滤。</p>
</blockquote>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span><span class="number">10</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>分析：上述<code>SQL</code>语句列出 2 个（含）以上、价格为 10（含）以上的产品的供应商。</p>
<h2 id="13-4-分组和排序"><a href="#13-4-分组和排序" class="headerlink" title="13.4 分组和排序"></a>13.4 分组和排序</h2><p>虽然<code>GROUP BY</code>和<code>ORDER BY</code>经常完成相同的工作，但是它们是非常不同的。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308251036753.png"><br>我们经常发现用<code>GROUP BY</code>分组的数据确实是以分组顺序输出，但是结果并不总是这样的，它并不是<code>SQL</code>规范所要求的。</p>
<blockquote>
<p><strong>不要忘记 <code>ORDER BY</code></strong> 一般在使用<code>GROUP BY</code>子句时，应该也给出<code>ORDER BY</code>子句。这是保证数据正确排序的唯一方法。千万不要依赖<code>GROUP BY</code>排序数据。</p>
</blockquote>
<p>为说明 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的使用方法， 请看一个例子。 下面的 <code>SELECT</code>语句类似于前面那些例子。它检索总计订单价格大于等于 50 的订 单的订单号和总计订单价格：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308251045284.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308251046686.png"></p>
<h2 id="13-5-SELECT子句顺序"><a href="#13-5-SELECT子句顺序" class="headerlink" title="13.5 SELECT子句顺序"></a>13.5 <code>SELECT</code>子句顺序</h2><p><code>SELECT</code>子句及其顺序：<br>| 子句 | 说明 | 是否必须使用 |<br>| —- | —- |—- |<br>| <code>SELECT</code> | 要返回的列或者表达式 | 是 |<br>| <code>FROM</code> | 从中检索数据的表 | 仅在从表选择数据时使用 |<br>| <code>WHERE</code> | 行级过滤 | 否 |<br>| <code>GROUP BY</code> | 分组说明 | 仅在按组计算聚集时使用 |<br>| <code>HAVING</code> | 组级过滤 | 否 |<br>| <code>ORDER BY</code> | 输出排序顺序 | 否 |<br>| <code>LIMIT</code> | 要检索的行数 | 否 |</p>
<h1 id="第-14-章-使用子查询"><a href="#第-14-章-使用子查询" class="headerlink" title="第 14 章 使用子查询"></a>第 14 章 使用子查询</h1><h2 id="14-1-子查询"><a href="#14-1-子查询" class="headerlink" title="14.1 子查询"></a>14.1 子查询</h2><p><i style="color:red;">查询（query）</i> 任何<code>SQL</code>语句都是查询。但此术语一般指<code>SELECT</code>语句。</p>
<p><code>SQL</code> 还允许创建子查询（subquery），即嵌套在其他查询中的查询。</p>
<h2 id="14-2-利用子查询进行过滤"><a href="#14-2-利用子查询进行过滤" class="headerlink" title="14.2 利用子查询进行过滤"></a>14.2 利用子查询进行过滤</h2><p>在此之前所学习的<code>SQL</code>语句都是在同一个数据库表中进行操作，并未跨表操作。<br>现有三个数据库表格：<br>① <code>orders</code>表：包含订单号、客户 ID、订单日期<br>② <code>orderitems</code>表：各订单物品<br>③ <code>customers</code>表：实际的客户信息</p>
<p>需求：列出订购物品<code>TNT2</code>的所有客户。</p>
<p>实现步骤：<br>（1） 检索包含物品<code>TNT2</code>的所有订单的编号。<br>（2） 检索具有前一步骤列出的订单编号的所有客户的 ID。<br>（3） 检索前一个步骤返回的所有客户 ID 的客户信息。</p>
<hr>
<p>分开检索：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)  检索`prod_id`为`TNT2`的所有订单物品</span><br><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308251133678.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>) 查询具有订单 <span class="number">2005</span> 和 <span class="number">2007</span> 的客户 ID</span><br><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="number">2005</span>,<span class="number">1007</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308251134343.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">（<span class="number">3</span>）检索这些客户 ID 的客户信息</span><br><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="number">10001</span>,<span class="number">10004</span>);</span><br></pre></td></tr></table></figure>

<p>合并检索：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308251420912.png"><br>子查询中的<code>WHERE</code>子句与前面使用的<code>WHERE</code>子句稍有不同，因为它使用了完全限定列名。<br>下面的语句告诉<code>SQL</code>比较<code>orders</code>表中的<code>cust_id</code> 与当前正从<code>customer</code>表中检索的<code>cust_id</code>：<code>WHERE orders.cust_id = customers.cust_id</code></p>
<p><i style="color:red;">相关子查询（correlated subquery）</i> 涉及外部查询的子查询。任何时候只要列名可能有多义性，就必须使用这种语法（表名和列名由一个句号分隔）。</p>
<h1 id="第-15-章-联结表"><a href="#第-15-章-联结表" class="headerlink" title="第 15 章 联结表"></a>第 15 章 联结表</h1><h2 id="15-1-联结"><a href="#15-1-联结" class="headerlink" title="15.1 联结"></a>15.1 联结</h2><p><code>SQL</code>最强大的功能之一就是能在数据检索查询的执行中联结（join）表。联结是利用<code>SQL</code>的<code>SELECT</code>能执行的最重要的操作。</p>
<p>在能够有效地使用联结前，必须了解关系表以及关系数据库设计的一些基础知识。</p>
<h3 id="15-1-1-关系表"><a href="#15-1-1-关系表" class="headerlink" title="15.1.1 关系表"></a>15.1.1 关系表</h3><p>关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的 关系（relational））互相关联。</p>
<p><i style="color:red;"> 外键（foreign key）:</i> 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p>
<p>关系数据可以有效地存储和方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。</p>
<p><i style="color:red;">可伸缩性（scale）:</i>能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为 可伸缩性好（scale well）。</p>
<h3 id="15-1-2-为什么使用联结"><a href="#15-1-2-为什么使用联结" class="headerlink" title="15.1.2 为什么使用联结"></a>15.1.2 为什么使用联结</h3><p>正如所述，分解数据为多个表能更有效地存储，更方便地处理，并且具有更大地可伸缩性。但这些好处是有代价的。如果数据存储在多个表中，怎样使用单条<code>SELECT</code>语句检索出数据？</p>
<p>答案是使用联结。简单来说，联结是一种机制，用来在一条<code>SELECT</code>语句中关联表。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p>
<h2 id="15-2-创建联结"><a href="#15-2-创建联结" class="headerlink" title="15.2 创建联结"></a>15.2 创建联结</h2><p>联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors,products</span><br><span class="line"><span class="keyword">WHERE</span> vendors.vend_id <span class="operator">=</span> products.vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name,prod_name</span><br></pre></td></tr></table></figure>

<h3 id="15-2-1-WHERE-子句的重要性"><a href="#15-2-1-WHERE-子句的重要性" class="headerlink" title="15.2.1 WHERE 子句的重要性"></a>15.2.1 WHERE 子句的重要性</h3><p>在数据库表的定义中，不存在能指示 MySQL 如何对表进行联结的东西。在联结两个表时，你实际上做的是讲第一个表中的每一行与第二个表中的没一行进行配对。<code>WHERE</code>子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有<code>WHERE</code>子句，第一个表的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配对在一起。</p>
<p><i style="color:red;">笛卡尔积（cartesian product）：</i>由没有联结条件的表关系返回的结果为笛卡尔积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308251645031.png"></p>
<h3 id="15-2-2-内部联结"><a href="#15-2-2-内部联结" class="headerlink" title="15.2.2 内部联结"></a>15.2.2 内部联结</h3><p>到目前为止，所用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内部联结。<br>其实，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> vnedors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id <span class="operator">=</span> products.vend_id;</span><br></pre></td></tr></table></figure>

<p>分析：此语句中的<code>SELECT</code>子句与前面相同，不同的是<code>FROM</code>子句。在这里，两个表之间的关系是<code>FROM</code>子句的组成部分，以<code>INNER JOIN</code>指定。在使用这种语法时，联结条件用特定的<code>ON</code>子句而不是<code>WHERE</code>子句给出。传递给<code>ON</code>的实际条件与传递给<code>WHERE</code> 的相同。</p>
<h3 id="15-2-3-联结多个表"><a href="#15-2-3-联结多个表" class="headerlink" title="15.2.3 联结多个表"></a>15.2.3 联结多个表</h3><p><code>SQL</code>对一条<code>SELECT</code>语句中可以联结多少个表的数目没有限制。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,vend_name,prod_price,quantity</span><br><span class="line"><span class="keyword">FROM</span> orderitems,products,vendors</span><br><span class="line"><span class="keyword">WHERE</span> products.vend_id <span class="operator">=</span> vendors.vend_id</span><br><span class="line">   <span class="keyword">AND</span> orderitems.prod_id <span class="operator">=</span> products.prod_id</span><br><span class="line">   <span class="keyword">AND</span> order_num <span class="operator">=</span> <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>

<p>分析：这个例子显示编号为 20005 的订单中的物品。订单物品存储在<code>orderitems</code>表中。每个产品按其产品<code>ID</code>存储，它引用<code>products</code>表中的产品。这些产品通过供应商<code>ID</code>联结到<code>vendors</code>表中相应的供应商。</p>
<blockquote>
<p><strong>性能考虑</strong> <code>MySQL</code>在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此，应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。</p>
</blockquote>
<p>正如 14 章所述，子查询并不总是执行复杂<code>SELECT</code>操作的最有效方法，对于下面的查询输入，<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308251420912.png"><br>使用联结可以同样进行实现：<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers,orders,orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line">  <span class="keyword">AND</span> orderitems.order_num <span class="operator">=</span> orders.order_num</span><br><span class="line">  <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分析：在这个查询中返回数据需要使用 3 个表。在这里我们没有在嵌套子查询中使用它们，而是使用了两个联结。</p>
<h1 id="第-16-章-创建高级联结"><a href="#第-16-章-创建高级联结" class="headerlink" title="第 16 章 创建高级联结"></a>第 16 章 创建高级联结</h1><p>本章将介绍如何对被联结的表使用表别名和聚集函数。</p>
<h2 id="16-1-使用表别名"><a href="#16-1-使用表别名" class="headerlink" title="16.1 使用表别名"></a>16.1 使用表别名</h2><p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customer <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o,orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line">   <span class="keyword">AND</span> oi.order_num <span class="operator">=</span> o.order_num</span><br><span class="line">   <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分析：可以看到<code>FROM</code>子句中 3 个表都具有别名，表的别名用于<code>WHERE</code>子句。</p>
<p><strong>应该注意：</strong> 表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。</p>
<h2 id="16-2-使用不同类型的联结"><a href="#16-2-使用不同类型的联结" class="headerlink" title="16.2 使用不同类型的联结"></a>16.2 使用不同类型的联结</h2><p>到目前为止，我们使用的只是成为“内部联结（等值联结）”的简单联结。还有另外其他 3 中联结：自联结、自然联结和外部联结。</p>
<h3 id="16-2-1-自联结"><a href="#16-2-1-自联结" class="headerlink" title="16.2.1 自联结"></a>16.2.1 自联结</h3><p>现在存在这样一个问题：假如你发现某物品（其<code>ID</code>为<code>DTNTR</code>）存在问题，因此想要知道生产该物品的供应商生产的其他物品是否也存在这些问题。<br>此查询需要先找到生产 <code>ID</code>为<code>DTNTR</code> 的物品的供应商，然后找到这个供应商生产的其他物品。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> 方法一：</span><br><span class="line"> <span class="keyword">SELECT</span> prod_id,prod_name</span><br><span class="line"> <span class="keyword">FROM</span> products</span><br><span class="line"> <span class="keyword">WHERE</span> vend_id <span class="operator">=</span> (<span class="keyword">SELECT</span> vend_id</span><br><span class="line">                  <span class="keyword">FROM</span> products</span><br><span class="line">                  <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span>);</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">SELECT</span> p1.prod_id,p1.prod_name</span><br><span class="line"><span class="keyword">FROM</span> products <span class="keyword">AS</span> p1,products <span class="keyword">AS</span> p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.vend_id <span class="operator">=</span> p2.vend_id</span><br><span class="line">   <span class="keyword">AND</span> p2.prod_id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分析：方法二中需要的两个表实际上是相同的表，因此<code>products</code>表在<code>FROM</code>子句中出现了两次，为了解决<code>products</code>表的引用具有二义性的问题，使用了表别名。</p>
<blockquote>
<p><strong>用自联结而不用子查询：</strong> 自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。</p>
</blockquote>
<h3 id="16-2-2-自然联结"><a href="#16-2-2-自然联结" class="headerlink" title="16.2.2 自然联结"></a>16.2.2 自然联结</h3><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使得每个列只返回一次。<br>但是<code>SQL</code>不提供这项功能,自然联结的功能是需要你自己去完成的,自然联结要求你只能选择哪些唯一的列,一般通过对一个表使用通配符(<code>SELECT *</code>),而对其他表的列使用明确的子集来完成。</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.<span class="operator">*</span>,o.order_num,o.order_date,oi.prod_id,oi.quantity,oi.item_price</span><br><span class="line"><span class="keyword">FROM</span> customer <span class="keyword">AS</span> c,<span class="keyword">order</span> <span class="keyword">AS</span> o,orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line">  <span class="keyword">AND</span> oi.order_num <span class="operator">=</span> o.order_num</span><br><span class="line">  <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;FB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分析：在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。<br>事实上，迄今为止我们建立的每个内部联结都是自然联结。</p>
<h3 id="16-2-3-外部联结"><a href="#16-2-3-外部联结" class="headerlink" title="16.2.3 外部联结"></a>16.2.3 外部联结</h3><p>外部联结是指联结包含在那些表中没有关联行的行。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id,orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>分析：类似于内部联结，这条<code>SELECT</code>语句 使用了关键字<code>OUTER JOIN</code>来指定联结的类型（而不是在<code>WHERE</code> 子句中指定）。但是与内部联结两个表中的行不同的是，外部联结还包括没有关联的行。</p>
<p>在使用<code>OUTER JOIN</code> 语法时，必须使用<code>RIGHT</code>或者<code>LEFT</code>关键字指定包括其包含所有行的表（<code>RIGHT</code> 指出的是<code>OUTER JOIN</code>右边的表，而<code>LEFT</code>指出的是<code>OUTER JOIN</code> 左边的表）。上面的例子使用<code>LEFT OUTER JOIN</code> 从<code>FROM</code> 子句的左边表（<code>customers</code>表）中选择所有行。</p>
<h2 id="16-3-使用带聚集函数的联结"><a href="#16-3-使用带聚集函数的联结" class="headerlink" title="16.3 使用带聚集函数的联结"></a>16.3 使用带聚集函数的联结</h2><p>聚集函数是用来汇总数据，虽然至今为止聚集函数的所有例子只是从单个表汇总数据，但这些函数也可以与联结一起使用。<br>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_name,customers.cust_id,<span class="built_in">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure>

<p>分析：此条<code>SELECT</code> 语句使用<code>INNER JOIN</code> 将<code>customers</code>和<code>orders</code>表相互关联。<code>GROUP BY</code> 子句按客户分组数据，因此，函数调用<code>COUNT(orders.order_num)</code>对每个客户的订单计数，将它作为<code>num_ord</code>返回。</p>
<h2 id="16-4-使用联结和联结条件"><a href="#16-4-使用联结和联结条件" class="headerlink" title="16.4 使用联结和联结条件"></a>16.4 使用联结和联结条件</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202308281456699.png"></p>
<h1 id="第-17-章-组合查询"><a href="#第-17-章-组合查询" class="headerlink" title="第 17 章 组合查询"></a>第 17 章 组合查询</h1><p><em>本章讲述如何利用 UNION 操作符将多条 SELECT 语句组合成一个结果集</em></p>
<h2 id="17-1-组合查询"><a href="#17-1-组合查询" class="headerlink" title="17.1 组合查询"></a>17.1 组合查询</h2><p>多数<code>SQL</code>语句都只包含从一个或多个表中返回数据的单条<code>SELECT</code>语句。<code>MySQL</code>也允许执行多个查询（多条<code>SELECT</code>语句），并将结果作为单个查询结果集返回。这些组合查询通常称为 并（union） 或 复合查询（compound query）。</p>
<p>有两种基本情况，其中需要使用组合查询：</p>
<ul>
<li>在单个查询中从不同的表返回类似结构的数据</li>
<li>对单个表执行多个查询，按单个查询返回数据</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202309102037167.png"></p>
<h2 id="17-2-创建组合查询"><a href="#17-2-创建组合查询" class="headerlink" title="17.2 创建组合查询"></a>17.2 创建组合查询</h2><p>可以使用<code>UNION</code>操作符来组合数条<code>SQL</code>查询。利用<code>UNION</code>，可给出多条<code>SELECT</code>语句，将它们的结果组合成单个结果集。</p>
<h3 id="17-2-1-使用UNION"><a href="#17-2-1-使用UNION" class="headerlink" title="17.2.1 使用UNION"></a>17.2.1 使用<code>UNION</code></h3><p><code>UNION</code>的使用很简单。所需要做的只是给出每条<code>SELECT</code>语句，在各条语句之间放上关键字<code>UNION</code>。</p>
<p>举一个例子，假如</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记</title>
    <url>/2023/08/16/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1PE411i7CV/?share_source=copy_web&vd_source=f3ff8a2761a3e07339584c4852cdd504">课程地址</a></p>
<p>s</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记</title>
    <url>/2023/04/21/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1bS4y1b7NV/?share_source=copy_web&vd_source=f3ff8a2761a3e07339584c4852cdd504">视频链接</a></p>
<p>课程代码：链接: <a href="https://pan.baidu.com/s/16hEN7j4hLDpd7NoFiS8dHw?pwd=4gxv">https://pan.baidu.com/s/16hEN7j4hLDpd7NoFiS8dHw?pwd=4gxv</a> 提取码: 4gxv 复制这段内容后打开百度网盘手机 App，操作更方便哦。</p>
<p><a href="https://www.lilichao.com/index.php/2022/05/10/react%e8%a7%86%e9%a2%91%e6%95%99%e7%a8%8b%ef%bc%88alpha%e7%89%88%ef%bc%89/">课程大纲介绍</a></p>
<h1 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h1><p>网页是B/S架构，传统网页中用户每点击一次链接就会加载一个新的页面，加载全部内容。但是许多情况只需要局部刷新就可以满足需求，例如购物网站加入购物车的操作，此时网页不需要全部刷新，只需要局部发生变化。 </p>
<p>AJAX+DOM使得局部刷新成为可能，但是DOM操作仍然很麻烦，且存在兼容性问题。DOM操作本身十分占用系统资源，DOM的API十分繁复，使得各种操作十分的不优雅。</p>
<p>React是一个用于构建用户界面的JavaScript库。<br>React特点：</p>
<ul>
<li>虚拟DOM</li>
<li>声明式</li>
<li>基于组件</li>
<li>支持服务器端渲染</li>
<li>快速、简单、易学</li>
</ul>
<h2 id="1-HelloWorld"><a href="#1-HelloWorld" class="headerlink" title="1.HelloWorld"></a>1.HelloWorld</h2><p>React.createElement()</p>
<ul>
<li>用来创建一个React元素</li>
<li>参数：1.元素名（组件名），例如：<code>div</code>、<code>span</code>等； 2.元素中的属性，例如：<code>id</code>、<code>class</code>、<code>style</code>等 / ① 在设置事件时，属性名需要修改驼峰命名法 ② class属性需要使用className来设置； 3.元素的子元素（内容）</li>
</ul>
<p>ReactDOM.createRoot()用来创建React根元素，需要一个DOM元素作为参数.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入react的核心库--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--https://unpkg.com/react@18.2.0/umd/react.development.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入react-dom的核心库--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 通过react向页面中添加div</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> div = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>,&#123;&#125;,<span class="string">&#x27;我是React创建的div&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(div)</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取跟元素对应的React元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// ReactDOM.createRoot()用来创建React根元素，需要一个DOM元素作为参数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//将div渲染到根元素</span></span></span><br><span class="line"><span class="language-javascript">    root.<span class="title function_">render</span>(div);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> btn = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>,&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">id</span>:<span class="string">&#x27;btn&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">type</span>:<span class="string">&#x27;button&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">className</span>:<span class="string">&#x27;hello_btn&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">onClick</span>:<span class="function">()=&gt;</span>&#123;<span class="title function_">alert</span>(<span class="string">&#x27;点击了按钮&#x27;</span>)&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,<span class="string">&#x27;点击一下&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> btnRoot = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;button&quot;</span>));</span></span><br><span class="line"><span class="language-javascript">    btnRoot.<span class="title function_">render</span>(btn);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>⚠️ 注意：</p>
<ol>
<li>React元素最总会将虚拟DOM准换为真实DOM</li>
<li>React元素一旦创建就无法修改，只能通过新创建的元素进行替换</li>
<li>当重复调用render()方法时，React会采用差分算法进行高效更新</li>
</ol>
<h2 id="2-JSX"><a href="#2-JSX" class="headerlink" title="2.JSX"></a>2.JSX</h2><p>命令式编程<br><code>const button = React.createElement(&#39;button&#39;,&#123;&#125;,&#39;我是按钮&#39;);</code></p>
<p>声明式编程 - 结果导向编程<br>在React中可以通过JSX（JS拓展）来创建React元素，JSX需要被翻译为JS代码，才能被React执行</p>
<p>在React中使用JSX，必须引进Babel来完成翻译工作</p>
<blockquote>
<p>JSX 就是 React.createElement()的语法糖<br>JSX在执行之前都会被babel转换为js代码</p>
</blockquote>
<h3 id="2-1-JSX的补充"><a href="#2-1-JSX的补充" class="headerlink" title="2.1 JSX的补充"></a>2.1 JSX的补充</h3><p>使用React需要在页面中引入三个库 <code>react.js</code> <code>react-dom.js</code> <code>babel.js</code>（三者载入顺序不能变）</p>
<p><strong>JSX注意事项：</strong></p>
<ol>
<li>JSX不是字符串，不要加引号</li>
<li>JSX中的html标签应该小写，React组件应该大写开头</li>
<li>JSX中有且只有一个根标签，只能使用一个div包裹</li>
<li>JSX的标签必须正确结束 （自结束标签必须写/）</li>
<li>在JSX中可以用{}嵌入表达式</li>
<li>如果表达式是空值，布尔值，undefined这些值，将不会显示</li>
<li>在JSX中，属性可以直接在标签中显示</li>
</ol>
<ul>
<li>注意：</li>
<li>lass需要使用className代替</li>
<li>style需要使用对象设置</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;孙悟空&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> div = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123; alert(&quot;HaHa&quot;) &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  style=&#123;&#123;backgroundColor:&#x27;yellow&#x27;,border:&#x27;5px red solid&#x27;&#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">  我是一个div</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#123;name&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#123;fn()&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">  root.<span class="title function_">render</span>(div)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202403211011932.png"></p>
<h3 id="2-2-列表渲染"><a href="#2-2-列表渲染" class="headerlink" title="2.2 列表渲染"></a>2.2 列表渲染</h3><p>{}只能用来放js表达式，而不能放语句（if for）</p>
<p>在语句中是可以去操作JSX</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div;</span><br><span class="line"><span class="keyword">if</span>(lang===<span class="string">&#x27;en&#x27;</span>)&#123;</span><br><span class="line">  div=<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello &#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(lang===<span class="string">&#x27;cn&#x27;</span>)&#123;</span><br><span class="line">  div = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>你好 &#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>]</span><br><span class="line"><span class="comment">// JSX 会自动将数组中的元素在页面中显示</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;arr&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>结果是：aabbcc</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data=[];</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 arr</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">   data.<span class="title function_">push</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;arr[i]&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line"> &#125;</span><br><span class="line">---------------</span><br><span class="line"><span class="keyword">const</span> data = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)</span><br><span class="line"><span class="keyword">const</span> list = <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line"><span class="keyword">const</span> list = &#123;arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-创建React项目"><a href="#3-创建React项目" class="headerlink" title="3.创建React项目"></a>3.创建React项目</h2><blockquote>
<p>约定优于配置</p>
</blockquote>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用笔记</title>
    <url>/2023/02/22/Git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前市面上存在的两种版本管理工具<code>Git</code>和<code>Svn</code>，<code>Git</code>具有优越的版本管理能力，被广泛应用于 github、gitlab 等开源平台。</p>
<h3 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h3><p>Git 分为 4 个工作区域：</p>
<ul>
<li>工作区：指在本地仓库中的全部代码区域</li>
<li>暂存区：指在本地仓库中通过 git add 后的代码区域</li>
<li>本地仓库：指在本地仓库中的 git commit 后的代码区域</li>
<li>远程仓库：指托管代码的服务器</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202302220954268.png"></p>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h4><p>git clone 命令用于将存储库克隆到本地<br><code>git clone [url]</code></p>
<h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>git init 命令用于在目录中创建新的 git 仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init  //创建新的git仓库，在当前路径下生成.git目录</span><br></pre></td></tr></table></figure>

<h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><p>git remote 用于管理跟踪远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v //查看链接的远程仓库的地址</span><br><span class="line">git remote add origin [gitUrl] //为本地仓库添加远程仓库地址</span><br><span class="line">git push -u origin master //将本地仓库的master和远程仓库的master进行关联</span><br><span class="line">git remote origin set-url [gitUrl] //为本地仓库修改远程仓库的地址</span><br><span class="line">git remote rm origin //为本地仓库删除远程仓库连接</span><br></pre></td></tr></table></figure>

<h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h4><p>git checkout 命令用于切换分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout [branchName] //切换分支</span><br><span class="line">git checkout -b [branchName] //新建分支并切换到该分支</span><br></pre></td></tr></table></figure>

<h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><p>git branch 命令用于查看、创建、删除分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch //查看本地分支</span><br><span class="line">git branch -r //查看远程分支</span><br><span class="line">git branch -a //查看本地和远程分支</span><br><span class="line">git branch [branchName] //新建本地分支但是不切换</span><br><span class="line">git branch -D [branchName] //删除本地分支</span><br><span class="line">git branch -m [oldBranchName] [newBranchName] //重命名分支</span><br></pre></td></tr></table></figure>

<h4 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h4><p>git tag 用于创建、删除、查看标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag [tagName] //新建标签</span><br><span class="line">git tag //查看标签列表</span><br><span class="line">git tag -d [tagName] //删除标签</span><br><span class="line">git push origin [tagName] //推送标签到远程仓库</span><br></pre></td></tr></table></figure>

<h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><p>git add 命令用于将本地文件添加到暂存区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add [file1] [file2] //添加指定文件到暂存区</span><br><span class="line">git add [dir] //添加指定目录到暂存区</span><br><span class="line">git add . //添加当前目录下所有文件至暂存区</span><br><span class="line">git add -A //添加当前仓库下的所有文件改动到暂存区</span><br></pre></td></tr></table></figure>

<h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>git commit 命令用于将暂存区内容添加到本地仓库中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;xxx&#x27; //将暂存区文件添加到本地仓库，并记录下备注</span><br><span class="line">git commit -m &#x27;xxx&#x27; -n //将暂存区文件添加到本地仓库，并记录下备注，同时跳过husky hooks 设置的规则校验</span><br><span class="line">git commit -am &#x27;xxx&#x27; //将文件添加到暂存区，再添加到本地仓库，并记录下备注</span><br></pre></td></tr></table></figure>

<h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>git push 命令用于将本地分支推送到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push [remoteName] [branchName] //推送分支(当处于需要推送的分支时，branchName可省略)</span><br><span class="line">git push --set-upstream [remoteName] [branchName] // 推送分支并建立关联关系(当处于需要推送的分支时，branchName可省略)</span><br></pre></td></tr></table></figure>

<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>git pull 命令用于从远程仓库拉取代码并合并到本地当前分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull //从远程仓库拉取代码合并到本地，等同于 git fetch &amp;&amp; git merge</span><br><span class="line">git pull --rebase //使用rebase的模式进行合并</span><br></pre></td></tr></table></figure>

<h4 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h4><p>git fetch 命令用于从远程获取代码库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch //从所有远程仓库拉取当前分支代码</span><br><span class="line">git fetch [remoteName] // 从指定远程仓库拉取当前分支代码</span><br><span class="line">git fetch --all // 获取所有远程仓库的所有分支的更新</span><br></pre></td></tr></table></figure>

<h4 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h4><p>git cherry-pick 命令用于获取指定的 commit，可以将分支 a 上的 commit 1，复制到分支 b 上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git cherry-pick [commitId] // 获取指定的commit</span><br></pre></td></tr></table></figure>

<h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><p>git merge 命令用于分支合并，将其他分支的内容合并到当前分支中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge [branchName]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202302221100094.png"></p>
<h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><p>git rebase 用于分支变基</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase master // 将当前分支变基到 master 分支上</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202302221115099.png"><br>git rebase -i 交互模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i [commitId] // 基于 commitId 进行 rebase，交互式变基，可以重新编辑 commit，比如压缩合并</span><br></pre></td></tr></table></figure>

<h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><p>git reset 命令用于回退版本，可以指定退回某一次提交的版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD^ //回退所有内容到上一个版本</span><br><span class="line">git reset HEAD^ [filename] //回退某文件到上一个版本</span><br><span class="line">git reset [commitId] //回退所有内容到指定版本</span><br><span class="line"></span><br><span class="line">git reset --soft HEAD~1 //回退本地仓库到上一个版本</span><br><span class="line">git reset --hard HEAD~1 //回退本地仓库到上一个版本，并删除工作区所有未提交的修改内容</span><br></pre></td></tr></table></figure>

<h4 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h4><p>git revert 指令用于回滚提交，可以回滚某一次提交记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert [commitId] // 回滚某次提交</span><br><span class="line">git revert [commitId] -m 1 // 回滚某次 merge 的 commit，1 代表保留主分支代码</span><br></pre></td></tr></table></figure>

<h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><p>git stash 用于暂存文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash // 暂存文件</span><br><span class="line">git stash save &#x27;aa&#x27; // 暂存文件，添加备注</span><br><span class="line">git stash pop // 应用最近一次暂存文件，并删除暂存记录</span><br><span class="line">git stash apply // 应用最近一次暂存，但不删除该暂存记录</span><br><span class="line">git stash apply stash@&#123;第几次暂存的代码，例如0&#125; // 应用某一次暂存，但不删除该暂存记录；</span><br><span class="line">git stash list // 暂存记录</span><br><span class="line">git stash clear // 删除所有暂存记录</span><br></pre></td></tr></table></figure>

<h4 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h4><p>git reflog 记录了所有的 commit 操作记录，便于错误操作后找回<br><code>git reflog</code></p>
<h4 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h4><p>git rm 用于从 git 仓库删除指定文件或目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm [filname]</span><br><span class="line">git rm [dir]</span><br></pre></td></tr></table></figure>

<h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p>git log 命令用于查看 git commit 记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log // 查看所有 commit 记录</span><br><span class="line">git log --grep  瀑布流 // 搜索 commit msg 有瀑布流关键字的 记录</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS学习笔记</title>
    <url>/2022/11/22/NodeJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一、初识Node-js"><a href="#一、初识Node-js" class="headerlink" title="一、初识Node.js"></a>一、初识Node.js</h2><h3 id="1-Node-js简介"><a href="#1-Node-js简介" class="headerlink" title="1 Node.js简介"></a>1 Node.js简介</h3><blockquote>
<p>Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine.<br>Node.js是一个基于Chrome V8引擎的JavaScript运行环境。</p>
</blockquote>
<p><strong>Node.js中的JavaScript运行环境</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20221122205249.png"><br><em>⚠️注意点：</em><br>① 浏览器是JavaScript的前端运行环境；<br>② Node是JavaScript的后端运行环境；<br>③ Node.js中无法调用DOM和BOM等浏览器内置API；</p>
<h3 id="2-Node-js学习路线"><a href="#2-Node-js学习路线" class="headerlink" title="2 Node.js学习路线"></a>2 Node.js学习路线</h3><p>JavaScript基础语法 + Node.js内置API模块（fs、path、http等）+ 第三方API模块（express、mysql等）</p>
<h3 id="3-Node-js环境安装"><a href="#3-Node-js环境安装" class="headerlink" title="3 Node.js环境安装"></a>3 Node.js环境安装</h3><p>安装包见 <a href="https://nodejs.org/">Node.js官网</a><br><strong>LTS版本和Current版本区别：</strong> LTS版本为稳定版、Current版本为测试版<br>通过查看版本号确定Node.js是否安装成功：<code>node -v</code></p>
<h2 id="二、fs文件系统模块"><a href="#二、fs文件系统模块" class="headerlink" title="二、fs文件系统模块"></a>二、fs文件系统模块</h2><h3 id="1-什么是fs文件系统模块"><a href="#1-什么是fs文件系统模块" class="headerlink" title="1 什么是fs文件系统模块"></a>1 什么是fs文件系统模块</h3><p><code>fs模块</code> 是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。例如：</p>
<ul>
<li><code>fs.readFile()</code>方法，用来读取指定文件中的内容</li>
<li><code>fs.writeFile()</code>方法，用来向指定的文件中写入内容</li>
</ul>
<p>如果在JavaScript代码中，使用fs模块来操作文件，则需要使用如下的方式先导入它：<code>const fs = require(&#39;fs&#39;)</code></p>
<h3 id="2-fs-readFile-的语法格式"><a href="#2-fs-readFile-的语法格式" class="headerlink" title="2 fs.readFile()的语法格式"></a>2 fs.readFile()的语法格式</h3><p><code>fs.readFile(path[, options], callback)</code></p>
<ul>
<li>path：必选参数，表示文件的路径</li>
<li>options：可选参数，表示用什么编码格式来读取文件</li>
<li>callback：必选参数，文件读取完成后，通过回调函数拿到读取的结果</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211222124055.png"></p>
<h3 id="3-fs-writeFile-的语法格式"><a href="#3-fs-writeFile-的语法格式" class="headerlink" title="3 fs.writeFile()的语法格式"></a>3 fs.writeFile()的语法格式</h3><p><code>fs.writeFile(file, data[, options], callback)</code></p>
<ul>
<li>file：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径</li>
<li>data：必选参数，表示要写入的内容</li>
<li>options：可选参数，表示用什么编码格式来写入文件，默认值是utf-8</li>
<li>callback：必选参数，文件写入完成后的回调函数</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211222149089.png"></p>
<h3 id="4-fs模块-动态路径拼接错误的问题"><a href="#4-fs模块-动态路径拼接错误的问题" class="headerlink" title="4 fs模块-动态路径拼接错误的问题"></a>4 fs模块-动态路径拼接错误的问题</h3><p>在使用fs模块操作文件时，如果提供的操作路径是以<code>./</code>或者<code>../</code>开头的相对路径，很容易出现路径动态拼接错误的问题。<br>原因：代码在运行时，会以执行node命令所处的目录，动态拼接出被操作文件的完整路径。</p>
<p>解决方法：<br>⭕️ 直接提供一个完整的文件存放路径（缺点：移植性差，不利于维护）<br>⭕️ 使用<code>__dirname</code> 【表示当前文件所处的目录】</p>
<h2 id="三、path路径模块"><a href="#三、path路径模块" class="headerlink" title="三、path路径模块"></a>三、path路径模块</h2><h3 id="1-什么是path路径模块"><a href="#1-什么是path路径模块" class="headerlink" title="1 什么是path路径模块"></a>1 什么是path路径模块</h3><p>path模块是Node.js官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对于路径处理的需求。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211231937336.png"></p>
<p>在JavaScript代码中，使用path模块来处理路径，需要先导入：<code>const path = require(&#39;path&#39;)</code></p>
<h3 id="2-path-join-语法格式"><a href="#2-path-join-语法格式" class="headerlink" title="2 path.join()语法格式"></a>2 path.join()语法格式</h3><p>使用path.join()方法可以把多个路径片段拼接为完整的路径字符串：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211231948158.png"><br><em>⚠️注意：今后涉及路径拼接，使用path.join()方法</em></p>
<h3 id="3-path-basename-语法格式"><a href="#3-path-basename-语法格式" class="headerlink" title="3 path.basename()语法格式"></a>3 path.basename()语法格式</h3><p>使用path.basename()方法，可以从一个文件路径中获取到文件的名称部分<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211232010996.png"></p>
<h3 id="4-path-extname-语法格式"><a href="#4-path-extname-语法格式" class="headerlink" title="4 path.extname()语法格式"></a>4 path.extname()语法格式</h3><p>使用path.extname()方法可以获取路径文件中的拓展名部分<br>语法格式：<code>path.extname(path)</code><br>参数解读：</p>
<ul>
<li>path：&lt;string&gt;必选参数，表示一个路径的字符串</li>
</ul>
<p>返回：&lt;string&gt;返回得到的拓展名字符串<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211232127536.png"></p>
<h2 id="三、http模块"><a href="#三、http模块" class="headerlink" title="三、http模块"></a>三、http模块</h2><h3 id="1-什么是http模块"><a href="#1-什么是http模块" class="headerlink" title="1 什么是http模块"></a>1 什么是http模块</h3><p>http模块是Node.js官方提供的、用来创建web服务器的模块。通过http模块提供的<code>http.createServer()</code>方法，就能方便的把一台普通电脑变成一台Web服务器，从而对外提供Web资源服务。<br>导入http模块：<code>const http = require(&#39;http&#39;)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211241035474.png"></p>
<h3 id="2-创建web服务器的基本步骤"><a href="#2-创建web服务器的基本步骤" class="headerlink" title="2 创建web服务器的基本步骤"></a>2 创建web服务器的基本步骤</h3><h4 id="①-导入http模块"><a href="#①-导入http模块" class="headerlink" title="① 导入http模块"></a>① 导入http模块</h4><p><code>const http = require(&#39;http&#39;);</code></p>
<h4 id="②-创建web服务器实例"><a href="#②-创建web服务器实例" class="headerlink" title="② 创建web服务器实例"></a>② 创建web服务器实例</h4><p><code>const server = http.createServer()</code></p>
<h4 id="③-为服务器实例绑定request事件，监听客户端的请求"><a href="#③-为服务器实例绑定request事件，监听客户端的请求" class="headerlink" title="③ 为服务器实例绑定request事件，监听客户端的请求"></a>③ 为服务器实例绑定request事件，监听客户端的请求</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用创建服务器实例的.on()方法，为服务器绑定一个request事件</span><br><span class="line"></span><br><span class="line">server.on(&#x27;request&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">  console.log(&#x27; Someone visit our web server.&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="④-启动服务器"><a href="#④-启动服务器" class="headerlink" title="④ 启动服务器"></a>④ 启动服务器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用server.listen(端口号,cb回调)方法，即可启动web服务器</span><br><span class="line">server.listen(80,()=&gt;&#123;</span><br><span class="line">  console.log(&#x27; http server running at http://127.0.0.1&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-根据不同的URL响应不同的html内容"><a href="#3-根据不同的URL响应不同的html内容" class="headerlink" title="3 根据不同的URL响应不同的html内容"></a>3 根据不同的URL响应不同的html内容</h3><p>核心实现步骤：<br>① 获取请求的url地址<br>② 设置默认的响应内容为404 Not Found<br>③ 判断用户请求的是否为 <code>/</code> 或 <code>/index.html</code>首页<br>④ 判断用户请求是否为<code>/about.html</code>关于页面<br>⑤ 设置Content-Type响应头，防止中文乱码<br>⑥ 使用<code>res.end()</code>把内容响应给客户端<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211241629075.png"></p>
<h2 id="四、模块化"><a href="#四、模块化" class="headerlink" title="四、模块化"></a>四、模块化</h2><h3 id="1-什么是模块化？"><a href="#1-什么是模块化？" class="headerlink" title="1 什么是模块化？"></a>1 什么是模块化？</h3><p>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。</p>
<p><strong>代码进行模块化拆分的好处：</strong><br>a.提高了代码的复用性；b.提高了代码的可维护性；c.可以实现按需加载；</p>
<p>模块化规范就是对代码进行模块化拆分和组合时，需要遵循的规范。<br>好处：降低沟通成本，极大方便各个模块之间的相互调用。</p>
<p><strong>Node.js中的模块化规范</strong><br>Node.js中根据模块来源不同，将模块分为3类：</p>
<ul>
<li>内置模块</li>
<li>自定义模块</li>
<li>第三方模块</li>
</ul>
<p><strong>加载模块</strong><br>使用<code>require()</code>方法进行模块加载<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211251522118.png"><br><em>⚠️注意：使用<code>require()</code>方法加载其他模块时，会执行被加载模块中的代码</em></p>
<h3 id="2-什么是模块作用域？"><a href="#2-什么是模块作用域？" class="headerlink" title="2 什么是模块作用域？"></a>2 什么是模块作用域？</h3><p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。</p>
<p>好处：防止全局变量污染的问题</p>
<h3 id="3-module对象"><a href="#3-module对象" class="headerlink" title="3 module对象"></a>3 module对象</h3><p>在每个<code>.js</code>自定义模块中都有一个模块对象，它存储了和当前模块相关的信息。</p>
<p><code>module.exports()</code>对象：在自定义模块中，可以使用<code>module.exports</code>对象，将模块内的成员共享出去，供外界使用。外界使用<code>require()</code>方法导入自定义模块时，得到的就是<code>module.exports</code>所指向的对象。</p>
<h3 id="4-exports对象"><a href="#4-exports对象" class="headerlink" title="4 exports对象"></a>4 exports对象</h3><p>由于<code>module.exports</code>写起来比较复杂，为了简化向外共享成员的代码，<code>Node</code>提供了<code>exports</code>对象。默认情况下，<code>exports</code>和<code>module.exports</code>指向同一个对象。最终共享的结果，还是以<code>module.exports</code>指向的对象为准。</p>
<p><strong>时刻谨记，<code>require()</code>模块时，得到的永远是<code>module.exports</code>指向的对象</strong></p>
<h3 id="5-Node-js中的模块化规范"><a href="#5-Node-js中的模块化规范" class="headerlink" title="5 Node.js中的模块化规范"></a>5 Node.js中的模块化规范</h3><p>Node.js遵循了<code>CommonJS</code>模块化规范，<code>CommonJS</code>规定了模块的特性和各模块之间如何相互依赖。</p>
<p><strong>CommonJS规定：</strong></p>
<ol>
<li>每个模块内部，module变量代表当前模块</li>
<li>module变量是一个对象，它的exports属性（即module.exports）是对外接口</li>
<li>加载某个模块，其实是加载该模块的<code>module.exports</code>属性。<code>require()</code>方法用于加载模块</li>
</ol>
<h3 id="6-npm与包"><a href="#6-npm与包" class="headerlink" title="6 npm与包"></a>6 npm与包</h3><h4 id="6-1-什么是包？"><a href="#6-1-什么是包？" class="headerlink" title="6.1 什么是包？"></a>6.1 什么是包？</h4><p>Node.js中的第三方模块又叫做包。</p>
<h4 id="6-2-包的来源"><a href="#6-2-包的来源" class="headerlink" title="6.2 包的来源"></a>6.2 包的来源</h4><p>不同于Node.js中的内置模块与自定义模块，包是由第三方个人或者团队开发出来的，免费供所有人使用。<br><strong>注意：</strong>Node.js中的包都是免费且开源的，不需要付费即可免费下载使用。 </p>
<h4 id="6-3-为什么需要包？"><a href="#6-3-为什么需要包？" class="headerlink" title="6.3 为什么需要包？"></a>6.3 为什么需要包？</h4><p>由于Node.js的内置模块仅提供了一些底层的API，导致在基于内置模块进行项目开发的时候，效率很低，保湿基于内置模块封装出来的，提供了更高级、更方便的API，极大的提高了开发效率。</p>
<h4 id="6-4-从哪里下载包？"><a href="#6-4-从哪里下载包？" class="headerlink" title="6.4 从哪里下载包？"></a>6.4 从哪里下载包？</h4><p>全球最大的包共享平台<a href="https://www.npmjs.com/">npm</a></p>
<h2 id="五、Express"><a href="#五、Express" class="headerlink" title="五、Express"></a>五、Express</h2><h3 id="1-什么是Express"><a href="#1-什么是Express" class="headerlink" title="1 什么是Express"></a>1 什么是Express</h3><p>Express是基于Node.js平台，快速、开放、极简的Web开发框架。<br>Express的本质就是一个npm上的第三方包，提供了快速创建Web服务器的便捷方法。</p>
<h3 id="2-使用Express"><a href="#2-使用Express" class="headerlink" title="2 使用Express"></a>2 使用Express</h3><ol>
<li>安装：<code>npm i express</code></li>
<li>创建基本web服务器：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211291556805.png"></li>
<li>监听GET请求<br>通过app.get()方法，可以监听客户端的GET请求，具体的语法格式如下：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211291617985.png"></li>
<li>监听POST请求<br>通过app.post()方法，可以监听客户端的POST请求，具体语法格式如下：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211291619970.png"></li>
<li>把内容响应给客户端<br>通过res.send()方法，可以把处理好的内容，发送给客户端：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211292048453.png"></li>
<li>获取url中携带的查询参数<br>通过req.query对象，可以访问到客户端通过查询字符串形式，发送到服务器的参数：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202211301140020.png"></li>
<li>获取URL中的动态参数<br>通过req.params对象，可以访问到URL中，通过:匹配到的动态参数：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202212011435073.png"></li>
<li>托管静态资源<br>express提供了一个非常好用的函数，叫做<code>express.static()</code>，通过它可以非常方便地创建一个静态资源服务器。<br>例如，通过如下代码就可以将public目录下的图片、CSS文件、JavaScript文件对外开放访问：<br><code>app.use(express.static(&#39;public&#39;))</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202212011452558.png"><br>如果要托管多个静态资源目录，请多次调用express.static()函数：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/202212011510078.png"></li>
</ol>
<p><strong>挂在路径前缀</strong><br>如果希望在托管的静态资源访问路径之前，挂载路径前缀，可使用如下方式：<br><code>app.use(&#39;/public&#39;,express.static(&#39;public&#39;))</code></p>
<ol start="9">
<li>使用<code>nodemon</code><br>安装命令：<code>npm install -g nodemon</code><br>作用：修改代码后无需手动重启node服务器，可自动实现热更新</li>
</ol>
<h3 id="3-Express路由"><a href="#3-Express路由" class="headerlink" title="3 Express路由"></a>3 Express路由</h3><p>在Express中，路由指的是客户端的请求与服务器处理函数之间的映射关系。<br>Express中路由分为3部分，分别是<span style="color:red">请求类型、请求的URL地址、处理函数</span></p>
]]></content>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>理解低代码平台</title>
    <url>/2022/09/23/%E7%90%86%E8%A7%A3%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<p><strong>低代码平台的核心在于<mark>模型设计，包括控件模型、组件模型、画布模型</mark>等等</strong><br>通过本文可以了解：</p>
<ul>
<li>低代码平台核心的底层逻辑是什么？</li>
<li>为何常见低代码平台都包含“控件区”、“布局区”和“属性编辑区”？</li>
<li>低代码平台的控件、组件、画布的本质是什么？</li>
<li>如何让低代码平台支持跨平台？</li>
<li>如何让低代码平台支持自定义数据源？</li>
</ul>
<h2 id="一、目前市面上的低代码平台"><a href="#一、目前市面上的低代码平台" class="headerlink" title="一、目前市面上的低代码平台"></a>一、目前市面上的低代码平台</h2><p>近几年国内纷纷出现各种低代码产品，在<strong>降本｜增效｜提质</strong>方面发挥重要作用。<br>大代码平台的业务场景设计越来越广泛：自定义表单、页面制作、活动详情页、工作流场景、数据报表、大屏数据报表、数据表格、白板笔记等等。<br>成熟的低代码产品：阿里宜搭、腾讯云搭、百度爱速搭、轻流、Jeecg Boot、码良等等。</p>
<p>常见的低代码平台的布局方式：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220923100243.png"></p>
<p>其中包括三个核心模块：</p>
<ul>
<li><strong>控件区：</strong>展示平台内支持的控件，用户通过拖拽控件到布局区，即可展示控件对应的UI组件样式；</li>
<li><strong>布局区：</strong>用来承载控件对应的UI组件，用户可以对每个UI组件进行布局，并且直观查看页面效果；</li>
<li><strong>属性编辑区：</strong>用来展示该控件支持的配置内容，可以更加灵活的对每个控件对应的UI组件进行自定义设置。</li>
</ul>
<p>WHY？为何各个产品都采用这种布局？</p>
<h2 id="二、换个角度思考低代码平台设计"><a href="#二、换个角度思考低代码平台设计" class="headerlink" title="二、换个角度思考低代码平台设计"></a>二、换个角度思考低代码平台设计</h2><p>我们在解决问题时，经常会使用两种方法：</p>
<ul>
<li>自顶向上法：从目标出发，拆解和细化问题，找到解决方法；</li>
<li>自底向上法：汇总各种零散信息，得到正确的方法和结论；</li>
</ul>
<p>我们试着用<strong>自顶向下法</strong>思考一下低代码平台的设计：</p>
<p>通常在团队确定是否需要开发低代码平台前，都会通过头脑风暴、灵感讨论、业务需求情况分析，然后确定低代码平台的原始需求。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220923151312.png"></p>
<p>以掘金社区为例：<br>掘金社区的主页布局比较单一，当需要增加或者调整部分模块时，需要改动项目代码、打包、提测、发布，这时候如果能有一个主页设计平台，让运营人员自由调整页面布局，还可以针对不同节日、活动调整出不同的主页布局。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220923152024.png"></p>
<p>基于这样的场景，我们使用<strong>自顶向下法</strong>，从目标出发，拆分和细化问题，找出解决方法。</p>
<h3 id="1-确定目标"><a href="#1-确定目标" class="headerlink" title="1.确定目标"></a>1.确定目标</h3><p>我们的目标需求是能够灵活的布局社区主页：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20221006133437.png"></p>
<h3 id="2-拆分和细化问题"><a href="#2-拆分和细化问题" class="headerlink" title="2.拆分和细化问题"></a>2.拆分和细化问题</h3><p>如果要实现灵活布局的掘金主页，就需要将主页中的模块抽成每个独立的控件：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20221006133600.png"><br>如果每个控件需要能够灵活配置，我们还需要能够配置控件的任意部分：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20221006133654.png"></p>
<h3 id="3-找到解决办法"><a href="#3-找到解决办法" class="headerlink" title="3.找到解决办法"></a>3.找到解决办法</h3><p>按照前面两个步骤的分析，我们可以确定大致的解决方法：</p>
<ol>
<li>需要实现一个支持自由拖拽布局的设计平台；</li>
<li>该平台支持拖拽不同控件到页面中；</li>
<li>每个控件支持不同的自定义配置；</li>
<li>设计器支持导出页面结构，渲染器支持渲染页面内容；</li>
</ol>
<p>于是我们就有了下面的方案：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20221006134454.png"><br>这就是为什么常见的低代码平台都会有“控件区”，“布局区”和“属性编辑区”。</p>
<p>通常的交互逻辑如下：</p>
<ol>
<li>从【控件区】拖拽一个控件进入【布局区】，将控件渲染成对于组件；</li>
<li>选中组件，在【属性配置区】显示该组件所有支持配置的属性；</li>
<li>修改【属性配置区】的属性，更新【布局区】中该组件的样式。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20221006134803.png"></p>
<h2 id="三、思考更加通用的低代码模型"><a href="#三、思考更加通用的低代码模型" class="headerlink" title="三、思考更加通用的低代码模型"></a>三、思考更加通用的低代码模型</h2><p>低代码平台的创建的页面，本质上不一定是单页面，也可以是由多个页面组成的一个web应用，因此，我们可以把上面示例，抽象成更加通用的低代码平台模型：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20221006141830.png"><br>该模型定义了低代码平台创建的页面结构，最终渲染是由对应渲染器渲染页面。<br>这就有点VNode树的味道了。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20221008090952.png"><br>对于Vue而言，<strong>核心要解决的就是“如何创建VNode”和“如何渲染VNode”</strong>*</p>
<p>接下来我们通过TypeScript接口形式定义下面结构：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20221008091741.png"><br>可以发现，单页应用和多页应用的关系在于，通过为单页面应用增加<code>path</code>配置，将多个单页应用组合成多页应用。<br>到这里我们就有一个更加通用的低代码模型，并且使用TypeScript接口定义了每一层的结构。</p>
<p>可以看出：<strong>低代码平台的核心在于模型设计，定义每个部分的模型</strong>。</p>
<h2 id="四、控件区的控件没这么简单"><a href="#四、控件区的控件没这么简单" class="headerlink" title="四、控件区的控件没这么简单"></a>四、控件区的控件没这么简单</h2><h3 id="1-控件是什么？"><a href="#1-控件是什么？" class="headerlink" title="1.控件是什么？"></a>1.控件是什么？</h3><p>控件本质是一个<strong>标准的JSONSchema对象，用来描述最终渲染出来的组件</strong>。在低代码平台中，将控件拖拽到布局区才会显示对应的组件样式。</p>
<p>以【用户信息控件】为例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">UserInfo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;用户信息控件&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;UserInfoComponent&#x27;</span>,<span class="comment">//指定渲染的组件的名称</span></span><br><span class="line">  <span class="attr">config</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">label</span>:<span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">      <span class="attr">type</span>:<span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">      <span class="attr">value</span>:<span class="string">&#x27;https://a.com&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">label</span>:<span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">      <span class="attr">type</span>:<span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">      <span class="attr">value</span>:<span class="string">&#x27;panda123&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常我们会在控件对象中定义一个type（也可能是其他名称），用来<strong>指定控件所渲染的组件名称</strong>。比如Vue中，就可以通过该type值，使用动态组件<code>&lt;component :is=&#123;type&#125;/&gt;</code>形式动态渲染组件。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20221008095244.png"><br>控件就好比是组件的说明书，只是对组件进行描述，描述了它是什么样子、有哪些行为、配置等信息。</p>
<h3 id="2-控件还有什么优点？"><a href="#2-控件还有什么优点？" class="headerlink" title="2.控件还有什么优点？"></a>2.控件还有什么优点？</h3>]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue面试题</title>
    <url>/2022/09/22/Vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-Vue-单页应用与多页应用的区别"><a href="#1-Vue-单页应用与多页应用的区别" class="headerlink" title="1. Vue 单页应用与多页应用的区别?"></a>1. Vue 单页应用与多页应用的区别?</h2><p><strong>概念：</strong></p>
<ul>
<li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li>
<li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li>
</ul>
<p><strong>区别：</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220922094352.png"></p>
<h2 id="2-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#2-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="2.Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>2.Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h2><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p>
<h2 id="3-描述下Vue自定义指令？"><a href="#3-描述下Vue自定义指令？" class="headerlink" title="3.描述下Vue自定义指令？"></a>3.描述下Vue自定义指令？</h2><p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p>
<p>一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;</p>
<h4 id="（1）自定义指令基本内容"><a href="#（1）自定义指令基本内容" class="headerlink" title="（1）自定义指令基本内容"></a>（1）自定义指令基本内容</h4><ul>
<li>全局定义：<code>Vue.directive(&quot;focus&quot;,&#123;&#125;)</code></li>
<li>局部定义：<code>directives:&#123;focus:&#123;&#125;&#125;</code></li>
<li>钩子函数：指令定义对象提供钩子函数</li>
</ul>
<p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
<p>inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p>
<p>update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</p>
<p>ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。</p>
<p>unbind：只调用一次，指令与元素解绑时调用。</p>
<p>钩子函数参数<br>el：绑定元素 / bing：指令核心对象，描述指令全部信息属性 / name / value / oldValue / expression / arg / modifers / vnode  虚拟节点 / oldVnode：上一个虚拟节点（更新钩子函数中才有用）</p>
<h4 id="（2）使用场景"><a href="#（2）使用场景" class="headerlink" title="（2）使用场景"></a>（2）使用场景</h4><ul>
<li>普通DOM元素进行底层操作的时候，可以使用自定义指令</li>
<li>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</li>
</ul>
<h4 id="（3）使用案例"><a href="#（3）使用案例" class="headerlink" title="（3）使用案例"></a>（3）使用案例</h4><p>初级应用：<br>鼠标聚焦 / 下拉菜单 / 相对时间转换 / 滚动动画</p>
<p>高级应用：<br>自定义指令实现图片懒加载 / 自定义指令集成第三方插件</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN加速原理</title>
    <url>/2022/09/21/CDN%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-什么是CDN？"><a href="#1-什么是CDN？" class="headerlink" title="1.什么是CDN？"></a>1.什么是CDN？</h2><p><code>CDN的</code>全称是(<code>Content Delivery Network</code>)，即内容分发网络。<br>其目的是通过在现有的<code>Internet</code>中增加一层新的<code>CACHE</code>(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。<br>🪐 简单的说，CDN的工作原理就是将源站的资源缓存到位于全球各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220921211208.png"></p>
<p>CDN对网络的优化作用：</p>
<ul>
<li>解决服务器端的“第一公里”问题</li>
<li>缓解甚至消除了不同运营商之间互联的瓶颈造成的影响</li>
<li>减轻了各省的出口带宽压力</li>
<li>缓解了骨干网的压力</li>
<li>优化了网上热点内容的分布</li>
</ul>
<h2 id="2-CDN工作原理"><a href="#2-CDN工作原理" class="headerlink" title="2.CDN工作原理"></a>2.CDN工作原理</h2><p>传统访问过程：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220921215533.png"></p>
<p>由上图可见，用户访问未使用CDN缓存网站的过程为:<br>1.用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址.<br>2.LocalDns向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期)<br>3.ROOT DNS将域名授权dns记录回应给 LocalDns<br>4.LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址<br>5.域名授权dns 查询域名记录后，回应给 LocalDns<br>6.LocalDns 将得到的域名ip地址，回应给 用户端<br>  -上述过程为DNS解析<br>7.用户得到域名ip地址后，访问站点服务器<br>8.站点服务器应答请求，将内容返回给客户端.</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220921222606.png"><br>通过上图，我们可以了解到，使用了CDN缓存后的网站的访问过程变为：<br>1.用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址.<br>2.LocalDns向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期)<br>3.ROOT DNS将域名授权dns记录回应给 LocalDns<br>4.LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址<br>5.域名授权dns 查询域名记录后(一般是CNAME)，回应给 LocalDns<br>6.LocalDns 得到域名记录后,向智能调度DNS查询域名的ip地址<br>7.智能调度DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给 LocalDns<br>8.LocalDns 将得到的域名ip地址，回应给 用户端<br>9.用户得到域名ip地址后，访问站点服务器<br>10.CDN节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)</p>
<p><strong>CDN网络的组成元素：</strong><br>对于普通的Internet用户，每个CDN节点就相当于一个放置在它周围的网站服务器. 通过对dns的接管，用户的请求被透明地指向离他最近的节点，节点中CDN服务器会像网站的原始服务器一样，响应用户的请求. 由于它离用户更近，因而响应时间必然更快.</p>
<p>从上面图中 虚线圈起来的那块，就是CDN层,这层是位于 用户端 和 站点服务器 之间.</p>
<ul>
<li><p>智能调度DNS(比如f5的3DNS)<br>智能调度DNS是CDN服务中的关键系统.当用户访问加入CDN服务的网站时，域名解析请求将最终由 “智能调度DNS”负责处理。它通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户可以得到快速的服务。同时它需要与分布在各地的CDN节点保持通信，跟踪各节点的健康状态、容量等信息，确保将用户的请求分配到就近可用的节点上.</p>
</li>
<li><p>缓存功能服务<br>负载均衡设备(如lvs,F5的BIG/IP)<br>内容Cache服务器(如squid）<br>共享存储</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise的面试题</title>
    <url>/2022/09/19/Promise%E7%9A%84%E6%89%8B%E5%86%99%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-Promise-all-和-Promise-allSettled-有什么区别？"><a href="#1-Promise-all-和-Promise-allSettled-有什么区别？" class="headerlink" title="1.Promise.all 和 Promise.allSettled 有什么区别？"></a>1.Promise.all 和 Promise.allSettled 有什么区别？</h3><p>一句话概括<code>Promise.allSettled</code>和<code>Promise.all</code>的最大不同：<code>Promise.allSettled</code>永远不会被<code>reject</code>。<br><strong>🌟 Promise.all的痛点</strong><br>当需要处理多个Promise并行时，大多数情况下Promise.all用起来是非常顺手的，比如下面这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = n =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, n));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line"><span class="comment">// 最终输出： [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>可是，是一旦有一个promise出现了异常，被reject了，情况就会变的麻烦。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line"><span class="comment">// 最终输出： Uncaught (in promise) 3</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line"><span class="comment">// 加入catch语句后，最终输出：3</span></span><br></pre></td></tr></table></figure>
<p><mark>尽管能用catch捕获其中的异常，但你会发现其他执行成功的Promise的消息都丢失了，仿佛石沉大海一般。</mark></p>
<p>要么全部成功，要么全部重来，这是<code>Promise.all</code>本身的强硬逻辑，也是痛点的来源，不能说它错，但这的确给<code>Promise.allSettled</code>留下了立足的空间。</p>
<p>使用<code>Promise.allSettled</code>处理上述代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line"><span class="comment">// 最终输出： </span></span><br><span class="line"><span class="comment">//    [</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 1&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 2&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;rejected&quot;, value: 3&#125;,</span></span><br><span class="line"><span class="comment">//    ]</span></span><br></pre></td></tr></table></figure>
<p>可以看到所有promise的数据都被包含在then语句中，且每个promise的返回值多了一个status字段，表示当前promise的状态，没有任何一个promise的信息被丢失。</p>
<p>因此，当用Promise.allSettled时，我们只需专注在then语句里，当有promise被异常打断时，我们依然能妥善处理那些已经成功了的promise，不必全部重来。</p>
<h2 id="2-实现mergePromise函数"><a href="#2-实现mergePromise函数" class="headerlink" title="2.实现mergePromise函数"></a>2.实现mergePromise函数</h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">time</span> = (<span class="params">timer</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax1</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">2000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax2</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax3</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergePromise</span> () &#123;</span><br><span class="line">  <span class="comment">// 在这里写代码</span></span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mergePromise</span>([ajax1, ajax2, ajax3]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求分别输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h4><p>解题思路：</p>
<ul>
<li>定义一个数组data用于保存所有异步操作的结果</li>
<li>初始化一个<code>const promise = Promise.resolve()</code>，然后循环遍历数组，在promise后面添加执行ajax任务，同时要将添加的结果重新赋值到promise上。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergePromise</span> (ajaxArray) &#123;</span><br><span class="line">  <span class="comment">// 存放每个ajax的结果</span></span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">  ajaxArray.<span class="title function_">forEach</span>(<span class="function"><span class="params">ajax</span> =&gt;</span> &#123;</span><br><span class="line">  	<span class="comment">// 第一次的then为了用来调用ajax</span></span><br><span class="line">  	<span class="comment">// 第二次的then是为了获取ajax的结果</span></span><br><span class="line">    promise = promise.<span class="title function_">then</span>(ajax).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      data.<span class="title function_">push</span>(res);</span><br><span class="line">      <span class="keyword">return</span> data; <span class="comment">// 把每次的结果返回</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最后得到的promise它的值就是data</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-使用Promise实现红绿灯交替重复亮"><a href="#3-使用Promise实现红绿灯交替重复亮" class="headerlink" title="3.使用Promise实现红绿灯交替重复亮"></a>3.使用Promise实现红绿灯交替重复亮</h2><p>题目描述：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220919195841.png"></p>
<p>参考答案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">red</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">green</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">yellow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> light = <span class="keyword">function</span> (<span class="params">timer, cb</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cb</span>()</span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> step = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">light</span>(<span class="number">3000</span>, red)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">light</span>(<span class="number">2000</span>, green)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">light</span>(<span class="number">1000</span>, yellow)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">step</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">step</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-使用Promise实现：限制异步操作的并发个数，并尽可能快的完成全部"><a href="#4-使用Promise实现：限制异步操作的并发个数，并尽可能快的完成全部" class="headerlink" title="4.使用Promise实现：限制异步操作的并发个数，并尽可能快的完成全部"></a>4.使用Promise实现：限制异步操作的并发个数，并尽可能快的完成全部</h2><p>🌟 题目描述：<br>有8个图片资源的url，已经存储在数组urls中。<br>urls类似于[‘<a href="https://image1.png&/#39;">https://image1.png&#39;</a>, ‘<a href="https://image2.png&/#39;">https://image2.png&#39;</a>, ….]<br>而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。<br>但有一个要求，任何时刻同时下载的链接数量不可以超过3个。<br>请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = [</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png&quot;</span>,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadImg</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;一张图片加载完成&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Could not load image at&#x27;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">src</span> = url;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>🌟参考答案：<br>既然题目的要求是保证每次并发请求的数量为3，那么我们可以先请求urls中的前面三个(下标为0,1,2)，并且请求的时候使用Promise.race()来同时请求，三个中有一个先完成了，我们就把这个当前数组中已经完成的那一项(第1项)换成还没有请求的那一项(urls中下标为3)。</p>
<p>直到urls已经遍历完了，然后将最后三个没有完成的请求(也就是状态没有改变的Promise)用Promise.all()来加载它们。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">limitLoad</span>(<span class="params">urls, handler, limit</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sequence = [].<span class="title function_">concat</span>(urls); <span class="comment">// 复制urls</span></span><br><span class="line">  <span class="comment">// 这一步是为了初始化 promises 这个&quot;容器&quot;</span></span><br><span class="line">  <span class="keyword">let</span> promises = sequence.<span class="title function_">splice</span>(<span class="number">0</span>, limit).<span class="title function_">map</span>(<span class="function">(<span class="params">url, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">handler</span>(url).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 返回下标是为了知道数组中是哪一项最先完成</span></span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 注意这里要将整个变量过程返回，这样得到的就是一个Promise，可以在外面链式调用</span></span><br><span class="line">  <span class="keyword">return</span> sequence</span><br><span class="line">    .<span class="title function_">reduce</span>(<span class="function">(<span class="params">pCollect, url</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> pCollect</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>(promises); <span class="comment">// 返回已经完成的下标</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">fastestIndex</span> =&gt;</span> &#123; <span class="comment">// 获取到已经完成的下标</span></span><br><span class="line">        	<span class="comment">// 将&quot;容器&quot;内已经完成的那一项替换</span></span><br><span class="line">          promises[fastestIndex] = <span class="title function_">handler</span>(url).<span class="title function_">then</span>(</span><br><span class="line">            <span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> fastestIndex; <span class="comment">// 要继续将这个下标返回，以便下一次变量</span></span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()) <span class="comment">// 初始化传入</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 最后三个用.all来调用</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">limitLoad</span>(urls, loadImg, <span class="number">3</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;图片全部加载完毕&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-实现有并行限制的Promise调度器"><a href="#5-实现有并行限制的Promise调度器" class="headerlink" title="5.实现有并行限制的Promise调度器"></a>5.实现有并行限制的Promise调度器</h2><p>参考答案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">maxCount</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">runCounts</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">promiseCreator</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(promiseCreator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">taskStart</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">maxCount</span>; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">request</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">queue</span> || !<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> || <span class="variable language_">this</span>.<span class="property">runCounts</span> &gt;= <span class="variable language_">this</span>.<span class="property">maxCount</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">runCounts</span>++;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">runCounts</span>--;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">request</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">timeout</span> = time =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> scheduler = <span class="keyword">new</span> <span class="title class_">Scheduler</span>();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addTask</span> = (<span class="params">time,order</span>) =&gt; &#123;</span><br><span class="line">  scheduler.<span class="title function_">add</span>(<span class="function">() =&gt;</span> <span class="title function_">timeout</span>(time).<span class="title function_">then</span>(<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(order)))</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">1000</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">500</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">300</span>, <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"><span class="title function_">addTask</span>(<span class="number">400</span>, <span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">scheduler.<span class="title function_">taskStart</span>()</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="6-promisify"><a href="#6-promisify" class="headerlink" title="6.promisify"></a>6.promisify</h2><p>🌰 适用场景：</p>
<ul>
<li>原生回调函数 callBack：存在回调地狱问题</li>
<li>函数加上返回 Promise 对象构造成异步函数：每次都需要重新构造，重复工作</li>
<li>使用 Promisify 做 Promise 的封装：减少构造 Promise 的重复工作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promisify</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> callback = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(args)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 给func函数主动塞入一个callback，这样在func中调用callback的时候实际执行的时候就是</span></span><br><span class="line">      <span class="comment">// 我们这里定义的callback函数，然后在我们的callback中调用resolve,</span></span><br><span class="line">      <span class="comment">// 这样一来，本来想要通过回调执行的操作就可以放在then函数中进行执行了</span></span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="literal">null</span>, [...args, callback])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">v</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(v+<span class="number">1</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一般调用方式</span></span><br><span class="line"><span class="title function_">hello</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个promisefy函数，使得能使用以下方式调用</span></span><br><span class="line"><span class="keyword">var</span> newFn = <span class="keyword">new</span> <span class="title function_">promisify</span>(hello)</span><br><span class="line"><span class="title function_">newFn</span>(<span class="number">2</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>)=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220921125332.png"></p>
]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>前端手写-数组扁平化</title>
    <url>/2022/09/15/%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%99-%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    <content><![CDATA[<p>题目描述：<br>已有多级嵌套数组 : [1, [2, [3, [4, 5]]], 6] 将其扁平化处理 输出: [1,2,3,4,5,6]</p>
<p>题目考查的内容就是数组扁平化，什么是扁平化呢？<br><mark>扁平化：就是将多维数组变成一维数组，不存在数组的嵌套</mark></p>
<h3 id="扁平化的方法："><a href="#扁平化的方法：" class="headerlink" title="扁平化的方法："></a>扁平化的方法：</h3><ol>
<li>ES6 flat</li>
<li>toString</li>
<li>正则替换</li>
<li>循环递归：循环+concat+push / 使用参数控制扁平化深度 / reduce / generator</li>
<li>使用栈结构</li>
<li>while循环+some</li>
</ol>
<h4 id="1-ES6-flat"><a href="#1-ES6-flat" class="headerlink" title="1.ES6 flat"></a>1.ES6 flat</h4><p><code>flat(depth)</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。<br>🌟 参数：<code>depth</code>（可选）指定要提取嵌套数组的结构深度，默认值为1<br>🌟 返回值：返回一个新数组，可展开任意深度的嵌套数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-toString方法"><a href="#2-toString方法" class="headerlink" title="2.toString方法"></a>2.toString方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_flatten</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">parseFloat</span>(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-正则替换"><a href="#3-正则替换" class="headerlink" title="3.正则替换"></a>3.正则替换</h4><p>看到嵌套数组，从字符串的角度上看就是多了很多的<code>[</code>和<code>]</code>，将它们替换就可以实现简单的扁平化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_flatten</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr).<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  str = <span class="string">&#x27;[&#x27;</span>+str+<span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">  arr = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-循环递归"><a href="#4-循环递归" class="headerlink" title="4.循环递归"></a>4.循环递归</h4><h5 id="4-1-循环-concat-push"><a href="#4-1-循环-concat-push" class="headerlink" title="4.1 循环+concat+push"></a>4.1 循环+concat+push</h5><p>🌟思路：</p>
<ol>
<li>循环判断数组的每一项是否是数组: <code>Array.isArray(arr[i])</code></li>
<li>是数组就递归调用上面的扁平化一层的代码 <code>result = result.concat(flatten(arr[i]));</code></li>
<li>不是数组,直接通过<code>push</code>添加到返回值数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;</span><br><span class="line">      result = result.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(arr[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach版本</span></span><br><span class="line"><span class="comment">// 递归版本的反嵌套</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> flattend = [];</span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    array.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">el</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(el)) <span class="title function_">flat</span>(el);</span><br><span class="line">      <span class="keyword">else</span> flattend.<span class="title function_">push</span>(el);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)(array);</span><br><span class="line">  <span class="keyword">return</span> flattend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-2-使用参数控制扁平化深度"><a href="#4-2-使用参数控制扁平化深度" class="headerlink" title="4.2 使用参数控制扁平化深度"></a>4.2 使用参数控制扁平化深度</h5><p>🌟：手写flat()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach 遍历数组会自动跳过空元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">_flat</span> = (<span class="params">arr = [], depth = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []; <span class="comment">// 缓存递归结果</span></span><br><span class="line">  <span class="comment">// 开始递归</span></span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">    <span class="comment">// forEach 会自动去除数组空位</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 控制递归深度</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) &amp;&amp; depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归数组</span></span><br><span class="line">        <span class="title function_">flat</span>(item, depth - <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存元素</span></span><br><span class="line">        result.<span class="title function_">push</span>(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)(arr, depth)</span><br><span class="line">  <span class="comment">// 返回递归结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-巧用reduce"><a href="#4-3-巧用reduce" class="headerlink" title="4.3 巧用reduce"></a>4.3 巧用reduce</h5><p><code>reduce</code> 方法为数组中的每个元素按序执行一个reducer函数，每一次运行 reducer 会将先前元素的计算结构作为参数传入，最后将其结果汇总为单个返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>],<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">flatten</span> = (<span class="params">arr, deep = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (deep &lt;= <span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">res, curr</span>) =&gt;</span> res.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(curr) ? <span class="title function_">flatten</span>(curr, deep - <span class="number">1</span>) : curr), [])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// function flatten (arr,deep=1) &#123;</span></span><br><span class="line"><span class="comment">// return   arr.reduce((acc,val) =&gt; acc.concat(Array.isArray(val)? flatten(val,deep-1):val),[])</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr, <span class="title class_">Infinity</span>);</span><br><span class="line"><span class="comment">// 输出:[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<h5 id="4-4-使用Generator函数"><a href="#4-4-使用Generator函数" class="headerlink" title="4.4 使用Generator函数"></a>4.4 使用Generator函数</h5><p>GeneratorFunction是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。<br>构造器生成新的生成器函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">flatten</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">            <span class="keyword">yield</span>* <span class="title function_">flatten</span>(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-使用栈结构"><a href="#5-使用栈结构" class="headerlink" title="5.使用栈结构"></a>5.使用栈结构</h4><p>🪐 思路：</p>
<ol>
<li>把数组通过一个栈来维护</li>
<li>当栈不为空的时候循环执行处理</li>
<li>pop()将栈尾出栈</li>
<li>如果出栈的元素是数组,就将该元素解构后每一元素进行入栈操作</li>
<li>出栈的元素不是数组就push进返回值res</li>
<li>反转恢复原数组的顺序</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [...arr];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 pop 从 stack 中取出并移除值</span></span><br><span class="line">    <span class="keyword">const</span> next = stack.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(next)) &#123;</span><br><span class="line">      <span class="comment">// 使用 push 送回内层数组中的元素，不会改动原始输入</span></span><br><span class="line">      stack.<span class="title function_">push</span>(...next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 反转恢复原数组的顺序</span></span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">reverse</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">flatten</span>(arr1);<span class="comment">// [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="6-while循环-some方法"><a href="#6-while循环-some方法" class="headerlink" title="6.while循环+some方法"></a>6.while循环+some方法</h4><p>some :方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。</p>
<p>🪐 思路：<br>通过<code>some</code>来判断数组中是否用数组,通过<code>while</code>不断循环执行判断, 如果是数组的话可以使用 <code>拓展运算符...</code> 每次只能展开最外层的数组,加上<code>contact</code>来减少嵌套层数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span>=&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(...arr)</span><br><span class="line">    arr = [].<span class="title function_">concat</span>(...arr)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>那些必须了解的前端缓存知识</title>
    <url>/2022/09/15/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>大纲：</p>
<ol>
<li>什么是web缓存（前端缓存）</li>
<li>缓存可以解决什么问题？缺点是什么？</li>
<li>强制缓存原理讲解</li>
</ol>
<ul>
<li><ul>
<li>基于Expires字段实现的强缓存</li>
</ul>
</li>
<li><ul>
<li>基于Cache-control实现的强缓存</li>
</ul>
</li>
</ul>
<ol start="4">
<li>协商缓存原理讲解</li>
</ol>
<ul>
<li><ul>
<li>基于last-modified实现的协商缓存</li>
</ul>
</li>
<li><ul>
<li>基于ETag实现的协商缓存</li>
</ul>
</li>
</ul>
<h3 id="1-什么是web缓存"><a href="#1-什么是web缓存" class="headerlink" title="1.什么是web缓存?"></a>1.什么是web缓存?</h3><p>web缓存主要指的是两部分：浏览器缓存和http缓存。<br>其中http缓存是web缓存的核心，是最难懂的那一部分,也是最重要的那一部分。<br>浏览器缓存主要指sessionStorage、localStorage、cookie等等（具体不再详细描述）<br>http缓存：</p>
<blockquote>
<p>Web 缓存是可以自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这个文档。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915094336.png"><br>看图，问题就是出在，<strong>服务器需要处理http的请求，并且http去传输数据，需要带宽，带宽是要钱买的啊。而我们缓存，就是为了让服务器不去处理这个请求，客户端也可以拿到数据</strong>。</p>
</blockquote>
<blockquote>
<p>注意，我们的缓存主要是针对html,css,img等静态资源，常规情况下，我们不会去缓存一些动态资源，因为缓存动态资源的话，数据的实时性就不会不太好，所以我们一般都只会去缓存一些不太容易被改变的静态资源。</p>
</blockquote>
<h3 id="2-缓存可以解决什么问题？缺点是什么？"><a href="#2-缓存可以解决什么问题？缺点是什么？" class="headerlink" title="2. 缓存可以解决什么问题？缺点是什么？"></a>2. 缓存可以解决什么问题？缺点是什么？</h3><p>缓存解决的问题：</p>
<ul>
<li>减少不必要的网络传输，节约宽带（就是省钱）</li>
<li>更快的加载页面（就是加速）</li>
<li>减少服务器负载，避免服务器过载的情况出现（就是减载）</li>
</ul>
<p>缺点：</p>
<ul>
<li>占内存（有些缓存会被存到内存中）</li>
</ul>
<p><mark><strong>http缓存分为两种：强缓存 和 协商缓存</strong></mark></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915094840.png" alt="http缓存流程图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915095036.png"></p>
<h3 id="3-强制缓存-基于Expires字段实现的强缓存"><a href="#3-强制缓存-基于Expires字段实现的强缓存" class="headerlink" title="3. 强制缓存-基于Expires字段实现的强缓存"></a>3. 强制缓存-基于Expires字段实现的强缓存</h3><p>在以前，我们通常会使用响应头的Expires字段去实现强缓存。如下图↓<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915095113.png"><br><code>Expires</code>字段的作用是，设定一个强缓存时间。在此时间范围内，则从内存（或磁盘）中读取缓存返回。<br>但是，<strong>Expires已经被废弃了</strong>。对于强缓存来说，Expires已经不是实现强缓存的首选。</p>
<p>因为Expires判断强缓存是否过期的机制是:获取本地时间戳，并对先前拿到的资源文件中的Expires字段的时间做比较。来判断是否需要对服务器发起请求。这里有一个巨大的漏洞：“如果我本地时间不准咋办？”是的,<mark>Expires过度依赖本地时间，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况</mark>。所以，Expires字段几乎不被使用了。现在的项目中，我们并不推荐使用Expires，强缓存功能通常使用cache-control字段来代替Expires字段。</p>
<h3 id="3-强制缓存-基于Cache-control实现的强缓存"><a href="#3-强制缓存-基于Cache-control实现的强缓存" class="headerlink" title="3. 强制缓存-基于Cache-control实现的强缓存"></a>3. 强制缓存-基于Cache-control实现的强缓存</h3><p><code>Cache-control</code>这个字段在<code>http1.1</code>中被增加，<code>Cache-control</code>完美解决了<code>Expires</code>本地时间和服务器时间不同步的问题。是当下的项目中实现强缓存的最常规方法。<br><code>Cache-control</code>的使用方法页很简单，只要在资源的响应头上写上需要缓存多久就好了，单位是秒。比如↓</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//往响应头中写入需要缓存的时间</span></span><br><span class="line">res.<span class="title function_">writeHead</span>(<span class="number">200</span>,&#123;</span><br><span class="line">    <span class="string">&#x27;Cache-Control&#x27;</span>:<span class="string">&#x27;max-age=10&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下图的意思就是，从该资源第一次返回的时候开始，往后的10秒钟内如果该资源被再次请求，则从缓存中读取。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915095431.png"></p>
<p><strong>Cache-Control:max-age=N，N就是需要缓存的秒数。从第一次请求资源的时候开始，往后N秒内，资源若再次请求，则直接从磁盘（或内存中读取），不与服务器做任何交互。</strong><br><code>Cache-control</code>中因为<code>max-age</code>后面的值是一个滑动时间，从服务器第一次返回该资源时开始倒计时。所以也就不需要比对客户端和服务端的时间，解决了<code>Expires</code>所存在的巨大漏洞。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915095611.png"></p>
<blockquote>
<p>注意，no-cache和no-store是一组互斥属性，这两个属性不能同时出现在Cache-Control中。<br>public和private也是一组互斥属性。他们两个不能同时出现在响应头的cache-control字段中。</p>
</blockquote>
<p>Expires难道就一点用都没有了吗？也不是，虽然Cache-control是Expires的完全替代品，但是如果要考虑向下兼容的话，在Cache-control不支持的时候，还是要使用Expires，这也是我们当前使用的这个属性的唯一理由。</p>
<h3 id="4-协商缓存原理讲解-基于last-modified实现的协商缓存"><a href="#4-协商缓存原理讲解-基于last-modified实现的协商缓存" class="headerlink" title="4.协商缓存原理讲解-基于last-modified实现的协商缓存"></a>4.协商缓存原理讲解-基于last-modified实现的协商缓存</h3><p>基于last-modified的协商缓存实现方式是:</p>
<ol>
<li>首先需要在服务器端读出文件修改时间，</li>
<li>将读出来的修改时间赋给响应头的last-modified字段。</li>
<li>最后设置Cache-control:no-cache<br>(三步缺一不可)</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915100104.png"><br>注意圈出来的三行。<br>第一行，读出修改时间。<br>第二行，给该资源响应头的last-modified字段赋值修改时间<br>第三行，给该资源响应头的Cache-Control字段值设置为:no-cache.(上文有介绍，Cache-control:no-cache的意思是跳过强缓存校验，直接进行协商缓存。)<br>还没完。到这里还无法实现协商缓存<br>当客户端读取到last-modified的时候，会在下次的请求标头中携带一个字段:If-Modified-Since。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915100223.png"><br>而这个请求头中的If-Modified-Since就是服务器第一次修改时候给他的时间，也就是上图中的<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915100354.png"><br>这一行</p>
<p>那么之后每次对该资源的请求，都会带上If-Modified-Since这个字段，而务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915100441.png"></p>
<p>使用以上方式的协商缓存已经存在两个非常明显的漏洞。这两个漏洞都是基于文件是通过比较修改时间来判断是否更改而产生的。</p>
<p>1.因为是更具文件修改时间来判断的，所以，在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。</p>
<p>2.当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会 返回新的文件。</p>
<p>为了解决上述的这两个问题。从http1.1开始新增了一个头信息，ETag(Entity 实体标签)</p>
<h3 id="4-协商缓存原理讲解-基于ETag实现的协商缓存"><a href="#4-协商缓存原理讲解-基于ETag实现的协商缓存" class="headerlink" title="4.协商缓存原理讲解-基于ETag实现的协商缓存"></a>4.协商缓存原理讲解-基于ETag实现的协商缓存</h3><p>ETag就是将原先协商缓存的比较时间戳的形式修改成了比较文件指纹。</p>
<blockquote>
<p>文件指纹:根据文件内容计算出的唯一哈希值。文件内容一旦改变则指纹改变。</p>
</blockquote>
<p>我们来看一下流程↓</p>
<ol>
<li>第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的etag字段中跟资源一起返回给客户端。</li>
<li>第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的ETag也就是文件指纹。并赋给请求头的if-None-Match字段，让上一次的文件指纹跟随请求一起回到服务端。</li>
<li>服务端拿到请求头中的is-None-Match字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并return。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的ETag中并返回给客户端</li>
</ol>
<p>代码示例：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915100652.png"></p>
<p>流程示意图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915100718.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915100806.png"></p>
<blockquote>
<p>值得注意的一点是，不同于cache-control是expires的完全替代方案(说人话:能用cache-control就不要用expiress)。ETag并不是last-modified的完全替代方案。而是last-modified的补充方案（说人话：项目中到底是用ETag还是last-modified完全取决于业务场景，这两个没有谁更好谁更坏）。</p>
</blockquote>
<h3 id="5-在vue项目中设置，解决项目升级的缓存问题"><a href="#5-在vue项目中设置，解决项目升级的缓存问题" class="headerlink" title="5.在vue项目中设置，解决项目升级的缓存问题"></a>5.在vue项目中设置，解决项目升级的缓存问题</h3><h5 id="5-1-直接在index-html中加入了这几行代码"><a href="#5-1-直接在index-html中加入了这几行代码" class="headerlink" title="5.1 直接在index.html中加入了这几行代码"></a>5.1 直接在index.html中加入了这几行代码</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>缺点：升级时缓存问题倒解决了，但直接导致了用户每次访问你的程序时都要重新请求服务器，所有的静态资源都无法用缓存了，浪费流量，网络压力变大。</p>
<h5 id="5-2-Nginx-配合-vue-config-js-进行配置"><a href="#5-2-Nginx-配合-vue-config-js-进行配置" class="headerlink" title="5.2 Nginx 配合 vue.config.js 进行配置"></a>5.2 Nginx 配合 vue.config.js 进行配置</h5><p>由于打包后的js、css和图片，一般名称都带有hash值，名称中的hash变了，自然会拉取新文件，所以我们可以将这类文件设置为强制缓存，只要文件名不变，就一直缓存，比如缓存100天或者一年。<br>而html文件则不能设为强制缓存，一般html名称是没法带hash值的，所以html如果设置了强制缓存，则永远也没法更新，html不更新，其引用的js、css等名称也不会更新，则整个服务都没有更新，只能让用户清除缓存了。所以针对html文件，我们可以设置协商缓存或者直接不使用缓存。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Nginx配置</span></span><br><span class="line">location /udaam-ui &#123;</span><br><span class="line">       root  /usr/local/ui-workspace;</span><br><span class="line">       index index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">       try_files $uri $uri/ <span class="regexp">/udaam-ui/i</span>ndex.<span class="property">html</span>;</span><br><span class="line">       <span class="keyword">if</span> ($request_filename ~* .*\.(js|css|woff|png|jpg|jpeg)$)&#123;</span><br><span class="line">            expires    100d;  #js、css、图片缓存<span class="number">100</span>天</span><br><span class="line">            #add_header <span class="title class_">Cache</span>-<span class="title class_">Control</span> <span class="string">&quot;max-age = 8640000&quot;</span>; #或者设置max-age</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($request_filename ~* .*\.(?:htm|html)$)&#123;</span><br><span class="line">            add_header <span class="title class_">Cache</span>-<span class="title class_">Control</span> <span class="string">&quot;no-cache, no-store&quot;</span>;  #html不缓存</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>no-cache浏览器会缓存，但刷新页面或者重新打开时 会请求服务器，服务器可以响应304，如果文件有改动就会响应200</li>
<li>no-store浏览器不缓存，刷新页面需要重新下载页面</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js 配置</span></span><br><span class="line"><span class="keyword">const</span> timeStamp = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"> <span class="attr">configureWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">output</span>: &#123;</span><br><span class="line">            <span class="comment">// 输出重构  打包编译后的 文件名称  【模块名称.版本号.时间戳】</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">`js/[name].[chunkhash].<span class="subst">$&#123;timeStamp&#125;</span>.js`</span>,</span><br><span class="line">          <span class="attr">chunkFilename</span>: <span class="string">`js/[id].[chunkhash].<span class="subst">$&#123;timeStamp&#125;</span>.js`</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  修改output的filename和chunkFilename</span><br></pre></td></tr></table></figure>

<ul>
<li>filename 指列在entry 中，打包后输出的文件的名称。</li>
<li>chunkFilename 指未列在entry 中，却又需要被打包出来的文件的名称。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改打包后的css</span></span><br><span class="line"><span class="keyword">const</span> timeStamp = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">extract</span>: &#123; <span class="comment">// 打包后css文件名称添加时间戳</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">`css/[name].<span class="subst">$&#123;timeStamp&#125;</span>.css`</span>,</span><br><span class="line">      <span class="attr">chunkFilename</span>: <span class="string">`css/chunk.[id].<span class="subst">$&#123;timeStamp&#125;</span>.css`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Provide和Inject的原理分析</title>
    <url>/2022/09/15/Vue%E4%B8%ADProvide%E5%92%8CInject%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>provide和inject主要用于开发高阶插件和组件时使用。</p>
<p>🌰 举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件提供foo 子组件注入</span></span><br><span class="line"><span class="comment">//父 </span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Provider</span> = &#123;</span><br><span class="line">  <span class="attr">provide</span>:&#123;</span><br><span class="line">    <span class="attr">foo</span>:<span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Child</span> = &#123;</span><br><span class="line">  <span class="attr">inject</span>:[<span class="string">&#x27;foo&#x27;</span>],</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">foo</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>优点：</mark></p>
<ol>
<li>祖先组件不需要知道哪些后代组件使用它提供的属性；</li>
<li>后代组件不需要知道被注入的属性来自哪里；<br><mark>缺点：</mark></li>
<li>数据来源不明确</li>
<li>重名问题</li>
</ol>
<h3 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915091703.png"><br>组件实例初始化的时候会调用<code>Vue.prototype._init</code>，<code>vm._init</code>中在<code>data/props</code>前面调用了<code>initInjections</code>，在<code>data/props</code>后面调用了<code>initProvide</code>。</p>
<h4 id="initInjections"><a href="#initInjections" class="headerlink" title="initInjections"></a>initInjections</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915092011.png"><br>该方法主要做了以下两件事：</p>
<ol>
<li>获取vm.$options.inject，通过resolveInject方法找到对应的key集合；</li>
<li>遍历key集合，对其进行响应式监听；</li>
</ol>
<p><mark>➡️ resolveInject</mark><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915092221.png"><br>该方法实现了通过$parent向上查找祖先节点数据：是通过遍历source.$parent逐级向上查找的，知道找到为止。</p>
<h4 id="initProvide"><a href="#initProvide" class="headerlink" title="initProvide"></a>initProvide</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220915092332.png"><br>该方法单纯把组件注册的provide值，赋值给vm._provided，resolveInject中有使用到</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>对vue中mixin的理解</title>
    <url>/2022/09/13/vue%E4%B8%ADmixin%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Q：说一说你对vue中mixin的理解，以及有哪些应用场景？"><a href="#Q：说一说你对vue中mixin的理解，以及有哪些应用场景？" class="headerlink" title="Q：说一说你对vue中mixin的理解，以及有哪些应用场景？"></a>Q：说一说你对vue中mixin的理解，以及有哪些应用场景？</h2><h3 id="一、mixin是什么？"><a href="#一、mixin是什么？" class="headerlink" title="一、mixin是什么？"></a>一、mixin是什么？</h3><p><code>Mixin</code>是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问<code>mixin</code>类的方法而不必成为其子类。<code>Mixin</code>类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂。</p>
<h4 id="Vue中的mixin"><a href="#Vue中的mixin" class="headerlink" title="Vue中的mixin"></a>Vue中的mixin</h4><p>官方定义：</p>
<blockquote>
<p>mixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。<br>本质其实就是一个JS对象，它可以包含我们组件中任意功能选项，如<code>data</code>、<code>components</code>、<code>methods</code>、<code>created</code>、<code>computed</code>等。我们只要将共用的功能以对象的方式传入<code>mixins</code>选项中，当组件使用<code>mixins</code>对象时，所有<code>mixins</code>对象的选项都将被混入该组件本身的选项中来。</p>
</blockquote>
<p>在Vue中我们可以<mark>局部混入</mark>和<mark>全局混入</mark></p>
<h4 id="局部混入"><a href="#局部混入" class="headerlink" title="局部混入"></a>局部混入</h4><p>定义一个<code>mixin</code>对象，有组件<code>options</code>的<code>data</code>、<code>methods</code>属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMixin = &#123;</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">hello</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">hello</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello from mixin!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组件通过<code>mixins</code>属性调用<code>mixin</code>对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;componentA&#x27;</span>,&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>该组件在使用的时候，混合了<code>mixin</code>里面的方法，在自动执行<code>created</code>生命钩子，执行<code>hello()</code>方法</p>
<h4 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h4><p>通过<code>Vue.mixin()</code>进行全局的混入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全局混入&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件）<br><em>PS：全局混入常用于插件的编写</em><br><strong>注意事项：</strong><br>当组件存在与<code>mixin</code>对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖<code>mixin</code>的选项<br>但如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行<code>mixin</code>的钩子，再执行组件的钩子</p>
<h3 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h3><p>在日常开发过程中，我们经常会遇到在不同组件中经常需要用到 一些相同或者相似的代码 ，这些代码的功能相对独立。这时，可以通过<code>Vue</code>的<code>mixin</code>功能 将相同或者相似的代码提取出来。</p>
<p>🌰 举个例子<br>👀 1.定义一个<code>modal</code>弹窗组件，内部通过<code>isShowing</code>来控制显示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Modal</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;#modal&#x27;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">isShowing</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">toggleShow</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isShowing</span> = !<span class="variable language_">this</span>.<span class="property">isShowing</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>👀 2.定义一个<code>tooltip</code>提示框，内部通过<code>isShowing</code>来控制显示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Tooltip</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;#tooltip&#x27;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">isShowing</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">toggleShow</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isShowing</span> = !<span class="variable language_">this</span>.<span class="property">isShowing</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过观察上面两个组件，发现两者的逻辑是相同，代码控制显示也是相同的，这时候<code>mixin</code>就派上用场了</p>
<p>🌟 首先抽出共同代码，编写<code>mixin</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toggle = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">isShowing</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">toggleShow</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">isShowing</span> = !<span class="variable language_">this</span>.<span class="property">isShowing</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>🌟 两个组件在使用上，只需要引入<code>mixin</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Modal</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;#modal&#x27;</span>,</span><br><span class="line">  <span class="attr">mixins</span>: [toggle]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Tooltip</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;#tooltip&#x27;</span>,</span><br><span class="line">  <span class="attr">mixins</span>: [toggle]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><p>首先从<code>Vue.mixin</code>入手（源码位置：<code>/src/core/global-api/mixin.js</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initMixin</span> (<span class="title class_">Vue</span>: <span class="title class_">GlobalAPI</span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">mixin</span> = <span class="keyword">function</span> (<span class="params">mixin: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = <span class="title function_">mergeOptions</span>(<span class="variable language_">this</span>.<span class="property">options</span>, mixin)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要调用<code>mergeOptions</code>方法（源码位置：<code>/src/core/util/options.js</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mergeOptions</span> (</span><br><span class="line">  <span class="attr">parent</span>: <span class="title class_">Object</span>,</span><br><span class="line">  <span class="attr">child</span>: <span class="title class_">Object</span>,</span><br><span class="line">  vm?: <span class="title class_">Component</span></span><br><span class="line">): <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child.<span class="property">mixins</span>) &#123; <span class="comment">// 判断有没有mixin 也就是mixin里面挂mixin的情况 有的话递归进行合并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.<span class="property">mixins</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    parent = <span class="title function_">mergeOptions</span>(parent, child.<span class="property">mixins</span>[i], vm)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = &#123;&#125; </span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    <span class="title function_">mergeField</span>(key) <span class="comment">// 先遍历parent的key 调对应的strats[XXX]方法进行合并</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">hasOwn</span>(parent, key)) &#123; <span class="comment">// 如果parent已经处理过某个key 就不处理了</span></span><br><span class="line">      <span class="title function_">mergeField</span>(key) <span class="comment">// 处理child中的key 也就parent中没有处理过的key</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mergeField</span> (key) &#123;</span><br><span class="line">    <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">    options[key] = <span class="title function_">strat</span>(parent[key], child[key], vm, key) <span class="comment">// 根据不同类型的options调用strats中不同的方法进行合并</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码，可以得到以下几点信息：</p>
<ul>
<li>优先递归处理<code>mixins</code></li>
<li>先遍历合并<code>parent</code>中的<code>key</code>，调用<code>mergeField</code>方法进行合并，然后保存在变量<code>options</code></li>
<li>再遍历<code>child</code>，合并补上<code>parent</code>中没有的<code>key</code>，调用<code>mergeField</code>方法进行合并，保存在变量<code>options</code></li>
<li>通过<code>mergeField</code>函数进行了合并</li>
</ul>
<p>下面是关于<code>vue</code>的几种类型的合并策略</p>
<ul>
<li>替换型</li>
<li>合并型</li>
<li>队列型</li>
<li>叠加型</li>
</ul>
<h4 id="替换型"><a href="#替换型" class="headerlink" title="替换型"></a>替换型</h4><p>替换型合并有<code>props</code> <code>methods</code> <code>inject</code> <code>computed</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">strats.<span class="property">props</span> =</span><br><span class="line">strats.<span class="property">methods</span> =</span><br><span class="line">strats.<span class="property">inject</span> =</span><br><span class="line">strats.<span class="property">computed</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  parentVal: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  childVal: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  vm?: Component,</span></span><br><span class="line"><span class="params">  key: string</span></span><br><span class="line"><span class="params"></span>): ?<span class="title class_">Object</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal <span class="comment">// 如果parentVal没有值，直接返回childVal</span></span><br><span class="line">  <span class="keyword">const</span> ret = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>) <span class="comment">// 创建一个第三方对象 ret</span></span><br><span class="line">  <span class="title function_">extend</span>(ret, parentVal) <span class="comment">// extend方法实际是把parentVal的属性复制到ret中</span></span><br><span class="line">  <span class="keyword">if</span> (childVal) <span class="title function_">extend</span>(ret, childVal) <span class="comment">// 把childVal的属性复制到ret中</span></span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line">strats.<span class="property">provide</span> = mergeDataOrFn</span><br></pre></td></tr></table></figure>
<p>同名的<code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code>会被后来者代替</p>
<h4 id="合并型"><a href="#合并型" class="headerlink" title="合并型"></a>合并型</h4><p>合并型有<code>data</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">strats.<span class="property">data</span> = <span class="keyword">function</span>(<span class="params">parentVal, childVal, vm</span>) &#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mergeDataOrFn</span>(</span><br><span class="line">        parentVal, childVal, vm</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeDataOrFn</span>(<span class="params">parentVal, childVal, vm</span>) &#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">mergedInstanceDataFn</span>(<span class="params"></span>) &#123;        </span><br><span class="line">        <span class="keyword">var</span> childData = childVal.<span class="title function_">call</span>(vm, vm) <span class="comment">// 执行data挂的函数得到对象</span></span><br><span class="line">        <span class="keyword">var</span> parentData = parentVal.<span class="title function_">call</span>(vm, vm)        </span><br><span class="line">        <span class="keyword">if</span> (childData) &#123;            </span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">mergeData</span>(childData, parentData) <span class="comment">// 将2个对象进行合并                                 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            <span class="keyword">return</span> parentData <span class="comment">// 如果没有childData 直接返回parentData</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeData</span>(<span class="params">to, <span class="keyword">from</span></span>) &#123;    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">from</span>) <span class="keyword">return</span> to    </span><br><span class="line">    <span class="keyword">var</span> key, toVal, fromVal;    </span><br><span class="line">    <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="keyword">from</span>);   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        key = keys[i];</span><br><span class="line">        toVal = to[key];</span><br><span class="line">        fromVal = <span class="keyword">from</span>[key];    </span><br><span class="line">        <span class="comment">// 如果不存在这个属性，就重新设置</span></span><br><span class="line">        <span class="keyword">if</span> (!to.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            <span class="title function_">set</span>(to, key, fromVal);</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="comment">// 存在相同属性，合并对象</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> toVal ==<span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> fromVal ==<span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">            <span class="title function_">mergeData</span>(toVal, fromVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mergeData</code>函数遍历了要合并的 <code>data</code> 的所有属性，然后根据不同情况进行合并：</p>
<ul>
<li>当目标 <code>data</code> 对象不包含当前属性时，调用 <code>set</code> 方法进行合并（<code>set</code>方法其实就是一些合并重新赋值的方法）</li>
<li>当目标 <code>data</code> 对象包含当前属性并且当前值为纯对象时，递归合并当前对象值，这样做是为了防止对象存在新增属性</li>
</ul>
<h4 id="队列型"><a href="#队列型" class="headerlink" title="队列型"></a>队列型</h4><p>队列型合并有 全部生命周期和<code>watch</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeHook</span> (</span><br><span class="line">  <span class="attr">parentVal</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">Function</span>&gt;,</span><br><span class="line">  <span class="attr">childVal</span>: ?<span class="title class_">Function</span> | ?<span class="title class_">Array</span>&lt;<span class="title class_">Function</span>&gt;</span><br><span class="line">): ?<span class="title class_">Array</span>&lt;<span class="title class_">Function</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> childVal</span><br><span class="line">    ? parentVal</span><br><span class="line">      ? parentVal.<span class="title function_">concat</span>(childVal)</span><br><span class="line">      : <span class="title class_">Array</span>.<span class="title function_">isArray</span>(childVal)</span><br><span class="line">        ? childVal</span><br><span class="line">        : [childVal]</span><br><span class="line">    : parentVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">LIFECYCLE_HOOKS</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">  strats[hook] = mergeHook</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// watch</span></span><br><span class="line">strats.<span class="property">watch</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  parentVal,</span></span><br><span class="line"><span class="params">  childVal,</span></span><br><span class="line"><span class="params">  vm,</span></span><br><span class="line"><span class="params">  key</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// work around Firefox&#x27;s Object.prototype.watch...</span></span><br><span class="line">  <span class="keyword">if</span> (parentVal === nativeWatch) &#123; parentVal = <span class="literal">undefined</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (childVal === nativeWatch) &#123; childVal = <span class="literal">undefined</span>; &#125;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (!childVal) &#123; <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">create</span>(parentVal || <span class="literal">null</span>) &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="title function_">assertObjectType</span>(key, childVal, vm);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!parentVal) &#123; <span class="keyword">return</span> childVal &#125;</span><br><span class="line">  <span class="keyword">var</span> ret = &#123;&#125;;</span><br><span class="line">  <span class="title function_">extend</span>(ret, parentVal);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key$1 <span class="keyword">in</span> childVal) &#123;</span><br><span class="line">    <span class="keyword">var</span> parent = ret[key$1];</span><br><span class="line">    <span class="keyword">var</span> child = childVal[key$1];</span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; !<span class="title class_">Array</span>.<span class="title function_">isArray</span>(parent)) &#123;</span><br><span class="line">      parent = [parent];</span><br><span class="line">    &#125;</span><br><span class="line">    ret[key$1] = parent</span><br><span class="line">      ? parent.<span class="title function_">concat</span>(child)</span><br><span class="line">      : <span class="title class_">Array</span>.<span class="title function_">isArray</span>(child) ? child : [child];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>生命周期钩子和<code>watch</code>被合并为一个数组，然后正序遍历一次执行</p>
<h4 id="叠加型"><a href="#叠加型" class="headerlink" title="叠加型"></a>叠加型</h4><p>叠加型合并有<code>component</code>、<code>directives</code>、<code>filters</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">strats.<span class="property">components</span>=</span><br><span class="line">strats.<span class="property">directives</span>=</span><br><span class="line"></span><br><span class="line">strats.<span class="property">filters</span> = <span class="keyword">function</span> <span class="title function_">mergeAssets</span>(<span class="params"></span></span><br><span class="line"><span class="params">    parentVal, childVal, vm, key</span></span><br><span class="line"><span class="params"></span>) &#123;    </span><br><span class="line">    <span class="keyword">var</span> res = <span class="title class_">Object</span>.<span class="title function_">create</span>(parentVal || <span class="literal">null</span>);    </span><br><span class="line">    <span class="keyword">if</span> (childVal) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> childVal) &#123;</span><br><span class="line">            res[key] = childVal[key];</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>叠加型主要是通过原型链进行层层的叠加</p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><ul>
<li>替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数</li>
<li>合并型策略是data, 通过set方法进行合并和重新赋值</li>
<li>队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行</li>
<li>叠加型策略有component、directives、filters，通过原型链进行层层的叠加</li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack面试题</title>
    <url>/2022/09/11/webpack%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-什么是Webpack？"><a href="#1-什么是Webpack？" class="headerlink" title="1.什么是Webpack？"></a>1.什么是Webpack？</h2><p><code>webpack</code> 是一个用于现代 <code>JavaScript</code> 应用程序的静态模块打包工具。宗旨是<mark>一切静态资源皆可打包</mark>。<br>有人就会问为什么要webpack？webpack是现代前端技术的基石，常规的开发方式，比如jquery,html,css静态网页开发已经落后了。现在是MVVM的时代，数据驱动界面。<br>webpack做的事情是，<mark><strong>分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用</strong></mark>。<br>当 webpack 处理应用程序时,它会递归地构建一个依赖关系图(dependency graph),其中包含应用程序需要的每个模块,然后将所有这些模块打包成一个或多个 bundle。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220912151111.png"></p>
<h2 id="2-Webpack的核心概念"><a href="#2-Webpack的核心概念" class="headerlink" title="2.Webpack的核心概念"></a>2.Webpack的核心概念</h2><p>一共5个核心概念：<code>Entry（入口）</code>、<code>Output（出口）</code>、<code>Loader（模块转换器）</code>、<code>Plugins（插件）</code>、<code>Module(模块)</code>。</p>
<p><strong>1.Entry（入口）</strong>：指示 webpack 应该使用哪个模块来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。<br><strong>2.Output（出口）</strong>：告诉webpack在哪里输出它所创建的结果文件，以及如何命名这些文件，默认值为<code>./dist</code>。<br><strong>3.Loader（模块转换器）</strong>：将所有类型的文件转换为webpack能够处理的有效模块，然后就可以利用webpack的打包能力，对它们进行处理。<br><strong>4.Plugins（插件）</strong>：在webpack构建流程中的特定时机注入拓展逻辑来改变构建结果或你想要做的事情。<br>**5.Module(模块)**：开发者将程序分解成离散功能块，并称之为模块。在webpack里一个模块对应着一个文件，webpack会从配置的<code>Entry</code>开始递归找出所有依赖的模块。</p>
<h2 id="3-webpack工作的原理是什么？工作流程是什么？"><a href="#3-webpack工作的原理是什么？工作流程是什么？" class="headerlink" title="3.webpack工作的原理是什么？工作流程是什么？"></a>3.webpack工作的原理是什么？工作流程是什么？</h2><p><code>webpack</code> 读取配置，根据入口开始遍历文件，解析依赖，使用<code>loader</code>处理各模块，然后将文件打包成<code>bundle</code>后输出到<code>output</code>指定的目录中。</p>
<p>webpack的工作流程是：<br>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<ol>
<li><code>初始化参数</code>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li>
<li><code>开始编译</code>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li>
<li><code>确定入口</code>：根据配置中的 entry 找出所有的入口文件</li>
<li><code>编译模块</code>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>
<li><code>完成模块编译</code>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li>
<li><code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>
<li><code>输出完成</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>
</ol>
<p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p>
<h2 id="4-常见的Loader有哪些？"><a href="#4-常见的Loader有哪些？" class="headerlink" title="4.常见的Loader有哪些？"></a>4.常见的Loader有哪些？</h2><p><code>raw-loader</code>：加载文件原始内容（utf-8）<br><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)<br><code>url-loader</code>：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)<br><code>source-map-loader</code>：加载额外的 Source Map 文件，以方便断点调试<br><code>svg-inline-loader</code>：将压缩后的 SVG 内容注入代码中<br><code>image-loader</code>：加载并且压缩图片文件<br><code>json-loader</code>：加载 JSON 文件（默认包含）<br><code>babel-loader</code>：把 ES6 转换成 ES5<br><code>ts-loader</code>: 将 TypeScript 转换成 JavaScript<br><code>awesome-typescript-loader</code>：将 TypeScript 转换成 JavaScript，性能优于 ts-loader<br><code>sass-loader</code>：将SCSS/SASS代码转换成CSS<br><code>css-loader</code>：加载 CSS，支持模块化、压缩、文件导入等特性<br><code>style-loader</code>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS<br><code>postcss-loader</code>：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀<br><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码<br><code>tslint-loader</code>：通过 TSLint检查 TypeScript 代码<br><code>coverjs-loader</code>：计算测试的覆盖率<br><code>vue-loader</code>：加载 Vue.js 单文件组件<br><code>i18n-loader</code>: 国际化<br><code>cache-loader</code>: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</p>
<h2 id="5-常见的Plugin有哪些？"><a href="#5-常见的Plugin有哪些？" class="headerlink" title="5.常见的Plugin有哪些？"></a>5.常见的Plugin有哪些？</h2><p><code>define-plugin</code>：定义环境变量 (Webpack4 之后指定 mode 会自动配置)<br><code>ignore-plugin</code>：忽略部分文件<br><code>html-webpack-plugin</code>：简化 HTML 文件创建 (依赖于 html-loader)<br><code>web-webpack-plugin</code>：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用<br><code>uglifyjs-webpack-plugin</code>：不支持 ES6 压缩 (Webpack4 以前)<br><code>terser-webpack-plugin</code>: 支持压缩 ES6 (Webpack4)<br><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度<br><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)<br><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能<br><code>clean-webpack-plugin</code>: 目录清理<br><code>ModuleConcatenationPlugin</code>: 开启 Scope Hoisting<br><code>speed-measure-webpack-plugin</code>: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)<br><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</p>
<h2 id="6-说一说Loader和Plugin的区别？"><a href="#6-说一说Loader和Plugin的区别？" class="headerlink" title="6.说一说Loader和Plugin的区别？"></a>6.说一说Loader和Plugin的区别？</h2><ul>
<li><p><code>Loader</code> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。因为 <code>Webpack</code> 只认识 <code>JavaScript</code>，所以 <code>Loader</code> 就成了翻译官，对其他类型的资源进行转译的预处理工作。（webpack是基于 <code>node</code> 的，只能处理 <code>JS</code>和 <code>JSON</code> 文件，<code>loader</code> 的作用是用来处理其他类型的文件（<code>less\vue....</code>等） 可以将 <code>less</code> 转成 <code>css</code> 文件，将 <code>jsx</code>处理成 <code>JS</code>文件，将其他版本的 <code>ES</code> 处理成浏览器能识别的 <code>ES</code> 版本）</p>
</li>
<li><p><code>Plugin</code> 就是插件，基于事件流框架 <code>Tapable</code>，插件可以扩展 <code>Webpack</code> 的功能，在 <code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过 <code>Webpack</code> 提供的 <code>API</code> 改变输出结果。</p>
</li>
<li><p><code>Loader</code> 在 <code>module.rules</code> 中配置，作为模块的解析规则，类型为数组。每一项都是一个 <code>Object</code>，内部包含了 <code>test(类型文件)</code>、<code>loader</code>、<code>options (参数)</code>等属性。</p>
</li>
<li><p><code>Plugin</code> 在 <code>plugins</code> 中单独配置，类型为数组，每一项是一个 <code>Plugin</code> 的实例，参数都通过构造函数传入。</p>
</li>
</ul>
<h2 id="7-模块打包原理知道吗？"><a href="#7-模块打包原理知道吗？" class="headerlink" title="7.模块打包原理知道吗？"></a>7.模块打包原理知道吗？</h2><p>webpack实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。</p>
<h2 id="8-文件监听的原理？"><a href="#8-文件监听的原理？" class="headerlink" title="8.文件监听的原理？"></a>8.文件监听的原理？</h2><p>在发现源码发生变化时，自动重新构建出新的输出文件。</p>
<p>Webpack开启监听模式，有两种方式：</p>
<ol>
<li>启动webpack命令，带上<code>--watch</code>参数 </li>
<li>在配置<code>webpack.config.js</code>中设置<code>watch:true</code></li>
</ol>
<p>缺点：每次需要手动刷新浏览器</p>
<p>原理：轮询判断文件的最后编辑时间是否发生变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等<code>aggregateTimeout</code>后再执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">export</span> = &#123;</span><br><span class="line">    <span class="comment">// 默认false,也就是不开启</span></span><br><span class="line">    <span class="attr">watch</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 只有开启监听模式时，watchOptions才有意义</span></span><br><span class="line">    <span class="attr">watchOptions</span>: &#123;</span><br><span class="line">        <span class="comment">// 默认为空，不监听的文件或者文件夹，支持正则匹配</span></span><br><span class="line">        <span class="attr">ignored</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="comment">// 监听到变化发生后会等300ms再去执行，默认300ms</span></span><br><span class="line">        <span class="attr">aggregateTimeout</span>:<span class="number">300</span>,</span><br><span class="line">        <span class="comment">// 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次</span></span><br><span class="line">        <span class="attr">poll</span>:<span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-说一说Webpack的热更新原理？"><a href="#9-说一说Webpack的热更新原理？" class="headerlink" title="9.说一说Webpack的热更新原理？"></a>9.说一说Webpack的热更新原理？</h2><p>webpack的热更新又称为热替换（<code>Hot Module Replacement</code>，缩写为<code>HMR</code>）。这个机制可以做到不用刷新浏览器而将新更新的模块替换掉旧的模块。</p>
<p>HMR的核心就是客户端从服务器端拉取更新后的文件，准确的说是<code>chunk diff</code>（<code>chunk</code>需要更新的部分），实际上<code>Webpack-dev-server</code>(<code>WDS</code>)与浏览器之间维护了一个<code>Websocket</code>，当本地资源发生变化时，<code>WDS</code>会向浏览器推送更新，并带上构建时的hash，让客户端与上一次的资源进行对比。客户端对比出差异后会向<code>WDS</code>发起<code>Ajax</code>请求来获取更新内容（文件列表、hash），这样客户端就可以再借助这些信息继续向<code>WDS</code>发起<code>jsonp</code>请求获取该<code>chunk</code>的增量更新。</p>
<p>后续的部分（拿到增量更新之后如何处理？哪些状态应该保留？哪些又需要更新？）由<code>HotModulePlugin</code>来完成，提供了相关的API以供开发者针对自身场景进行处理，像<code>vue-loader</code>和<code>react-hot-loader</code>都是借助这些API来实现HMR。</p>
<p>在webpack中开启热模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 开启 HMR 特性</span></span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// hotOnly: true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-文件指纹是什么？怎么用？"><a href="#10-文件指纹是什么？怎么用？" class="headerlink" title="10.文件指纹是什么？怎么用？"></a>10.文件指纹是什么？怎么用？</h2><p>文件指纹是打包后输出的文件名的后缀。</p>
<ul>
<li><code>Hash</code>：和整个项目的构建相关，只要项目文件有修改，整个项目构建的hash值就会更改</li>
<li><code>Chunkhash</code>：和webpack打包的chunk有关，不同的<code>entry</code>会生出不同的chunkhash</li>
<li><code>Contenthash</code>：根据文件内容来定义<code>hash</code>，文件内容不变，则<code>Contenthash</code>不变<h4 id="JS的文件指纹设置"><a href="#JS的文件指纹设置" class="headerlink" title="JS的文件指纹设置"></a>JS的文件指纹设置</h4>设置<code>output</code>的<code>filname</code>，用<code>chunkhash</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">app</span>: <span class="string">&#x27;./scr/app.js&#x27;</span>,</span><br><span class="line">        <span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name][chunkhash:8].js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>:__dirname + <span class="string">&#x27;/dist&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CSS的文件指纹设置"><a href="#CSS的文件指纹设置" class="headerlink" title="CSS的文件指纹设置"></a>CSS的文件指纹设置</h4>设置 <code>MiniCssExtractPlugin</code> 的 <code>filename</code>，使用 <code>contenthash</code>。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">app</span>: <span class="string">&#x27;./scr/app.js&#x27;</span>,</span><br><span class="line">        <span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name][chunkhash:8].js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>:__dirname + <span class="string">&#x27;/dist&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">`[name][contenthash:8].css`</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="图片的文件指纹设置"><a href="#图片的文件指纹设置" class="headerlink" title="图片的文件指纹设置"></a>图片的文件指纹设置</h4>设置<code>file-loader</code>的<code>name</code>，使用<code>hash</code><br>占位符名称及含义：</li>
<li>ext：资源后缀名</li>
<li>name：文件名称</li>
<li>path：文件的相对路径</li>
<li>folder：文件所在的文件夹</li>
<li>contenthash：文件的内容hash，默认是md5生成</li>
<li>hash：文件内容的hash，默认是md5生成</li>
<li>emoji：一个随机的指代文件内容的emoj<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>:path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>:&#123;</span><br><span class="line">        <span class="attr">rules</span>:[&#123;</span><br><span class="line">            <span class="attr">test</span>:<span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">            <span class="attr">use</span>:[&#123;</span><br><span class="line">                <span class="attr">loader</span>:<span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                <span class="attr">options</span>:&#123;</span><br><span class="line">                    <span class="attr">name</span>:<span class="string">&#x27;img/[name][hash:8].[ext]&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号保持用户登录的状态</title>
    <url>/2022/09/07/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BF%9D%E6%8C%81%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>公众号内网页涉及到登录，保证一次登录，下次用户进来不用登录。<br>流程图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220907110147.png"></p>
<p>微信开发离不开<code>openid</code>(为了识别用户，每个用户针对每个公众号会产生一个安全的<code>openid</code>)。而通常我们获取<code>openid</code>，以及获取用户的基本信息是通过用户授权的方式进行获取。那么ok,怎样通过授权方式获取呢，看上面的流程图中的<code>code</code>(此<code>code</code>是由微信为我们提供，只能使用一次)，并且该<code>code</code>只有当我们点配置的菜单时（配置菜单要使用用户授权的方式配置），才能获取到。所以当用户点击菜单时：</p>
<p>一：我们先判断该<code>code</code>，如果不为null,通过该<code>code</code>获取<code>openid</code>。</p>
<p>二:拿到<code>openid</code>后，我们去数据库通过<code>openid</code>查询用户信息，如果返回有结果说明该用户已经登录过，将用户信息放置<code>session</code>中，跳转到登录后的页面</p>
<p>三：拿到<code>openid</code>后，如果我们去数据库没有查询到用户信息，说明该用户没有登录过，跳转到登录页面，让用户登录，登录完将<code>openid</code>与用户信息插入到数据库，并放置<code>session</code>中，跳转到登录后的页面。</p>
<p>四：如果<code>code</code>为<code>null</code>,我们从<code>session</code>中直接取用户信息（注意<code>session</code>过期的处理），如果取到用户信息，进入到登录后的页面</p>
<p>五：如果<code>code</code>为<code>null</code>,并且<code>session</code>过期，或者没有获取到用户的信息，跳转到微信授权的地址，重新走流程，形成循环。</p>
<p>这样，我们就能保证用户一次登录，永久不用登录的效果了，其实最主要还是要搞清openid，每个用户针对同一个公众号，此openid是永远不会变的，哪怕是你取消了重新关注。</p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JS手写:利用 XMLHttpRequest 手写 AJAX 实现</title>
    <url>/2022/09/06/JS%E6%89%8B%E5%86%99:%E5%88%A9%E7%94%A8%20XMLHttpRequest%20%E6%89%8B%E5%86%99%20AJAX%20%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>题目：利用 XMLHttpRequest 手写 AJAX 实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getAjax</span> (url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">false</span>);</span><br><span class="line">        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span> || xhr.<span class="property">status</span> ===<span class="number">304</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(xhr.<span class="property">responseText</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="title function_">send</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="title function_">getAjax</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220906095813.png"></p>
]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一谈对页面声明周期的理解</title>
    <url>/2022/09/06/%E8%B0%88%E4%B8%80%E8%B0%88%E5%AF%B9%E9%A1%B5%E9%9D%A2%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>HTML页面的生命周期包含以下4个事件：</p>
<ol>
<li><code>DOMContentLoaded</code>事件：浏览器已经完全加载<code>HTML</code>，并构建了<code>DOM</code>树，但像<code>&lt;img&gt;</code>和样式表之类的外部资源可能尚未加载完成。【<code>DOM</code>已经就绪，因此处理程序可以查找<code>DOM</code>节点，并初始化接口】</li>
<li><code>load</code>事件：浏览器不仅加载完成了<code>HTML</code>，还加载完成了所有外部资源：图片、样式等。【外部资源加载完成，样式已被应用，图片大小已知】</li>
<li><code>beforeunload</code>事件：用户正在离开页面：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</li>
<li><code>unload</code>事件：用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</li>
</ol>
<h4 id="DOMContentLoaded和脚本"><a href="#DOMContentLoaded和脚本" class="headerlink" title="DOMContentLoaded和脚本"></a>DOMContentLoaded和脚本</h4><p>当浏览器处理一个<code>HTML</code>文档，并在文档中遇到<code>&lt;script&gt;</code>标签时，就会在继续构建<code>DOM</code>之前运行它。这是一种防范措施，因为脚本可能想要修改<code>DOM</code>，甚至对其执行<code>document.write</code>操作，所以<code>DOMContentLoaded</code>必须等待脚本执行结束后才能执行。</p>
<p>此规则有两个例外：</p>
<ul>
<li>具有<code>async</code>特性的脚本不会阻塞<code>DOMContentLoaded</code></li>
<li>使用<code>document.createElement(&#39;script&#39;)</code>动态生产并添加到网页的脚本也不会阻塞<code>DOMContentLoaded</code></li>
</ul>
<h4 id="DOMContentLoaded和样式"><a href="#DOMContentLoaded和样式" class="headerlink" title="DOMContentLoaded和样式"></a>DOMContentLoaded和样式</h4><p>外部样式表不会影响DOM，因此DOMContentLoaded不会等待它们。<br>但是这里有一个值得<mark>⚠️注意的点：<strong>如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成。原因是：脚本可能想要获取元素的坐标和其他与样式相关的属性，因此它必须等待样式加载完成。</strong> </mark><br><em>（此时当<code>DOMContentLoaded</code>等待脚本时，它现在也在等待脚本前面的样式）</em></p>
<h4 id="浏览器内建的自动填充"><a href="#浏览器内建的自动填充" class="headerlink" title="浏览器内建的自动填充"></a>浏览器内建的自动填充</h4><p>当我们在使用浏览器访问网页时，会使用到浏览器自动填充表单的功能。自动填充表单是在<code>DOMContentLoaded</code>中执行的。因此，如果<code>DOMContentLoaded</code>被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。</p>
<h4 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h4><p>当整个页面，包括样式、图片和其他资源被加载完成时，会触犯<code>window</code>对象上的<code>load</code>事件。通过<code>load</code>属性获取此事件。</p>
<h4 id="window-onunload"><a href="#window-onunload" class="headerlink" title="window.onunload"></a>window.onunload</h4><p>当访问者离开页面时，<code>window</code>对象上的<code>unload</code>事件就会被触发。我们可以在此事件上做一些不涉及延迟的操作，例如关闭相关的弹出窗口。</p>
<p>有一个值得注意的特殊情况是发送分析数据：<br>假设我们收集有关页面使用情况的数据：鼠标点击，滚动，被查看的页面区域等。自然地，当用户要离开的时候，我们希望通过 unload 事件将数据保存到我们的服务器上<b style="color:red;">(该操作涉及到延迟问题)</b>。<br>有一个特殊的 <code>navigator.sendBeacon(url, data) </code>方法可以满足这种需求。它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 <code>sendBeacon</code>。当 <code>sendBeacon</code> 请求完成时，浏览器可能已经离开了文档，所以就无法获取服务器响应（对于分析数据来说通常为空）。还有一个 <code>keep-alive</code> 标志，该标志用于在 <code>fetch</code> 方法中为通用的网络请求执行此类“离开页面后”的请求。<br>如果我们要取消跳转到另一页面的操作，在这里做不到。但是我们可以使用另一个事件 —— <code>onbeforeunload</code>。</p>
<h4 id="window-onbeforeunload"><a href="#window-onbeforeunload" class="headerlink" title="window.onbeforeunload"></a>window.onbeforeunload</h4><p>如果访问者触发了离开页面的导航（<code>navigation</code>）或试图关闭窗口，<code>beforeunload</code> 处理程序将要求进行更多确认。如果我们要取消事件，浏览器会询问用户是否确定。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>页面的生命周期事件：</p>
<ul>
<li><p>当 DOM 准备就绪时，<code>document</code> 上的 <code>DOMContentLoaded</code> 事件就会被触发。<mark><em>在这个阶段，我们可以将 <code>JavaScript</code> 应用于元素。诸如 <code>&lt;script&gt;...&lt;/script&gt;</code> 或 <code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 之类的脚本会阻塞 <code>DOMContentLoaded</code>，浏览器将等待它们执行结束。图片和其他资源仍然可以继续被加载。</em></mark></p>
</li>
<li><p>当页面和所有资源都加载完成时，<code>window</code> 上的 <code>load</code> 事件就会被触发。我们很少使用它，因为通常无需等待那么长时间。</p>
</li>
<li><p>当用户想要离开页面时，<code>window</code> 上的 <code>beforeunload</code> 事件就会被触发。如果我们取消这个事件，浏览器就会询问我们是否真的要离开（例如，我们有未保存的更改）。</p>
</li>
<li><p>当用户最终离开时，<code>window</code> 上的 <code>unload</code> 事件就会被触发。在处理程序中，我们只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。我们可以使用 <code>navigator.sendBeacon</code> 来发送网络请求。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一谈浏览器垃圾回收机制</title>
    <url>/2022/09/05/%E8%B0%88%E4%B8%80%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><mark> <strong>JS会在创建变量时自动分配内存，在不使用时会自动周期性的释放内存，释放的过程就叫“垃圾回收”。</strong></mark></p>
<p>一方面自动分配内存减轻了开发者的负担，开发者不用过多的去关注内存的使用，但是一方面，正是因为自动回收，所以不清楚回收机制，很容易造成混乱，而混乱就容易造成“内存泄漏”。<br>由于是自动回收，所以就存在一个“内存是否需要被回收”的问题，但是这个问题的判定在程序中意味着无法通过某个算法去准确完整的解决。</p>
<h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><p>垃圾回收对是否需要回收的问题主要依赖对于变量的判定是否可访问，由此衍生出两种主要的回收算法：</p>
<ul>
<li>标记清理</li>
<li>引用计数</li>
</ul>
<h4 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h4><p><mark>标记清理是JS最常用的回收策略</mark>，2012年后所有浏览器都使用了这种策略，此后对于回收策略的改进也是基于这个策略进行改进的。</p>
<p>其策略是：</p>
<ul>
<li>变量进入上下文（也可以理解为作用域），会加上标记，证明其存在于该上下文【逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们】<code>flag = 存活</code>；</li>
<li>变量使用完成之后，将非活跃的变量标记为准备删除的变量，等待垃圾回收器回收<code>flag = 可回收</code>；</li>
<li>执行内存清理，销毁带<code>可回收</code>标记的变量并回收之前被占用的内存<code>flag = 未使用</code>；</li>
</ul>
<p>局限：</p>
<ul>
<li>由于是从根对象（全局对象）开始查找，对于那些无法从根对象查询到的对象都将被清除；</li>
<li>回收后会形成内存碎片，影响后面申请大的连续内存空间</li>
</ul>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数策略相对而言不常用，因为弊端较多。其思路是对每个值记录它被引用的次数，通过最后对次数的判断（引用数为0）来决定是否保留。<br>具体规则：</p>
<ul>
<li>声明一个变量，赋予它一个引用值时，计数+1；</li>
<li>同一个值被赋予另外一个变量时，引用+1；</li>
<li>当引用该值的变量被其他值覆盖时，引用-1；</li>
<li>引用为0时，回收内存；</li>
</ul>
<p>局限：<br>最重要的问题就是 <mark><strong>相互引用问题</strong></mark></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">refProblem</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  a.<span class="property">c</span> = b;</span><br><span class="line">  b.<span class="property">c</span> = a; <span class="comment">//相互引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据之前提到的规则，两个都相互引用了，引用计数不为0，所以两个变量都无法回收。如果频繁的调用该函数，则会造成严重的内存泄漏。</p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一谈对浏览器中进程和线程的理解</title>
    <url>/2022/09/05/%E8%B0%88%E4%B8%80%E8%B0%88%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><mark><strong>重点：浏览器是多进程的</strong></mark></p>
<p>主要包括以下进程：</p>
<ul>
<li>Browser进程：浏览器的主进程，唯一，负责创建和销毁其他进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。</li>
<li>GPU进程：用于3D绘制等，最多一个。</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li>
<li>浏览器渲染进程（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</li>
</ul>
<h3 id="渲染进程（浏览器内核）"><a href="#渲染进程（浏览器内核）" class="headerlink" title="渲染进程（浏览器内核）"></a>渲染进程（浏览器内核）</h3><p>浏览器的渲染进程是多线程的，页面的渲染、JavaScript的执行、事件的循环，都在这个进程内进行：</p>
<ul>
<li><code>GUI渲染线程</code>：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，该线程就会执行。</li>
<li><code>JavaScript引擎线程</code>：也称为JavaScript内核，负责处理JavaScript脚本程序、解析JavaScript脚本、运行代码等。（例如V8引擎）</li>
<li><code>事件触发线程</code>：用来控制浏览器事件循环，注意这不归JavaScript引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待JavaScript引擎处理。</li>
<li><code>定时触发器线程</code>：传说中的<code>setInterval</code>与<code>setTimeout</code>所在线程，注意，W3C在HTML标准中规定，规定要求<code>setTimeout</code>中低于4ms的时间间隔算为4ms。</li>
<li><code>异步http请求线程</code>：在<code>XMLHttpRequest</code>连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由<code>JavaScript</code>引擎执行。</li>
</ul>
<p>⚠️ 注意：GUI渲染线程与JavaScript引擎线程是互斥的，当JavaScript引擎执行时GUI线程会被挂起（相当于被冻结），GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。所以如果JavaScript执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<h3 id="单线程的JavaScript"><a href="#单线程的JavaScript" class="headerlink" title="单线程的JavaScript"></a>单线程的<code>JavaScript</code></h3><p>所谓的单线程，是指在JavaScript引擎中负责解释和执行JavaScript代码的线程单一，同一时间只能执行一件任务。</p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>WebWorker简介与使用</title>
    <url>/2022/09/05/WebWorker%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-什么是Web-Worker？"><a href="#1-什么是Web-Worker？" class="headerlink" title="1.什么是Web Worker？"></a>1.什么是Web Worker？</h3><p>H5提供了JS分线程的实现，取名为：Web Workers，<mark><strong>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能，我们可以将一些大计算量的代码交由web Worker 运行而不冻结用户界面</strong></mark>。你可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。<b style="background:pink">但是子线程完全受主线程控制，且不操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质</b>。</p>
<h3 id="2-Web-Worker的作用"><a href="#2-Web-Worker的作用" class="headerlink" title="2.Web Worker的作用"></a>2.Web Worker的作用</h3><p><code>Web Worker</code> 的作用：就是为 <code>JavaScript</code> 创造多线程环境，允许主线程创建 <code>Worker</code> 线程，将一些任务分配给后者运行。在主线程运行的同时，<code>Worker</code> 线程在后台运行，两者互不干扰。等到 <code>Worker</code> 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 <code>Worker</code> 线程负担了，主线程（通常负责 <code>UI</code> 交互）就会很流畅，不会被阻塞或拖慢。</p>
<p><mark><code>Worker</code> 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断</mark>。这样有利于随时响应主线程的通信。但是，<mark>这也造成了 <code>Worker</code> 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭</mark>。</p>
<h3 id="3-WebWorker的缺点"><a href="#3-WebWorker的缺点" class="headerlink" title="3.WebWorker的缺点"></a>3.WebWorker的缺点</h3><ol>
<li><code>Worker</code>内代码不能操作<code>DOM</code>（更新<code>UI</code>）</li>
<li>不能跨域加载<code>JS</code></li>
<li>不是每个浏览器都支持这个新特性</li>
<li>速度慢</li>
</ol>
<h3 id="4-WebWorker的应用"><a href="#4-WebWorker的应用" class="headerlink" title="4.WebWorker的应用"></a>4.WebWorker的应用</h3><p>相关API：</p>
<ul>
<li><code>Worker</code>：构造函数，加载分线程执行的JS文件</li>
<li><code>Worker.prototype.onmessage</code>：用于<strong>接收</strong>另一个线程的回调函数</li>
<li><code>Worker.prototype.postMessage</code>：向另一个线程<strong>发送</strong>消息</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;number&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> number = input.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建一个Worker对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;work.js&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 绑定接收消息的监听</span></span></span><br><span class="line"><span class="language-javascript">    worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;主线程接收分线程返回的数据&#x27;</span> + event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 向分线程发送消息</span></span></span><br><span class="line"><span class="language-javascript">    worker.<span class="title function_">postMessage</span>(number);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;主线程向分线程发送数据&#x27;</span> + number);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// work.js文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="title function_">fn</span>(n - <span class="number">1</span>) + <span class="title function_">fn</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> onmessage = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;分线程接收主线程发送的数据&#x27;</span> + event.<span class="property">data</span>);</span><br><span class="line">  <span class="keyword">var</span> result = <span class="title function_">fn</span>(event.<span class="property">data</span>);</span><br><span class="line">  <span class="title function_">postMessage</span>(result);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;分线程向主线程发送数据&#x27;</span> + result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142438.png"><br>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142359.png"></p>
<p><strong>流程图：</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142107.png"></p>
<p><mark>主线程中的<code>this</code>是<code>window</code>，而<code>work</code>线程中的<code>this</code>是一个专门为 <code>Worker</code> 定制的全局对象。</mark></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>手写jsonp</title>
    <url>/2022/09/04/%E6%89%8B%E5%86%99jsonp/</url>
    <content><![CDATA[<h3 id="手写jsonp的步骤"><a href="#手写jsonp的步骤" class="headerlink" title="手写jsonp的步骤"></a>手写jsonp的步骤</h3><ol>
<li>创建script元素，设置src属性，并插入文档中，同时触发AJAX请求。</li>
<li>返回Promise对象，then函数才行继续，回调函数中进行数据处理。</li>
<li>script元素删除清理。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">url,data=&#123;&#125;,callback=<span class="string">&quot;callback&quot;</span></span>)&#123;</span><br><span class="line">  <span class="comment">// 处理json对象，拼接url</span></span><br><span class="line">  data.<span class="property">callback</span> = callback;</span><br><span class="line">  <span class="keyword">let</span> params = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">      params.<span class="title function_">push</span>(key+<span class="string">&#x27;=&#x27;</span>+data[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url+<span class="string">&#x27;?&#x27;</span>+params.<span class="title function_">join</span>(<span class="string">&#x27;&amp;&#x27;</span>))</span><br><span class="line">  <span class="comment">// 创建script元素</span></span><br><span class="line">  <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = url+<span class="string">&#x27;?&#x27;</span>+params.<span class="title function_">join</span>(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">  <span class="comment">//返回promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">window</span>[callback] = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="title function_">resolve</span>(data);</span><br><span class="line">          &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">              <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">              <span class="comment">// 移除script元素</span></span><br><span class="line">              script.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(script);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何调用：</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220904222504.png"></p>
<h3 id="jsonp的原理"><a href="#jsonp的原理" class="headerlink" title="jsonp的原理"></a>jsonp的原理</h3><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</p>
<h4 id="jsonp的优缺点"><a href="#jsonp的优缺点" class="headerlink" title="jsonp的优缺点"></a>jsonp的优缺点</h4><ul>
<li><strong>优点</strong>是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</li>
<li><strong>缺点</strong>是仅支持get方法具有局限性，不安全可能会遭受XSS攻击。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220904223501.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220904223531.png"></p>
]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>前端手写-扁平数组转树形结构</title>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%99-%E6%89%81%E5%B9%B3%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>输了就是输了，这说明什么呀，小朋友，还得练。</p>
</blockquote>
<p>前端面试中常见的一个题目：如何将一个扁平化数组转化为树形结构？</p>
<h3 id="情景一"><a href="#情景一" class="headerlink" title="情景一"></a>情景一</h3><p>例如，有数组<code>arr</code>结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">pid</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">pid</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">pid</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">pid</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">pid</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">pid</span>: <span class="number">3</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>将其转化为如下树形结构结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">&quot;id&quot;</span>: <span class="number">4</span></span><br><span class="line">                        &#125;,&#123;</span><br><span class="line">                            <span class="string">&quot;id&quot;</span>: <span class="number">5</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                    <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">&quot;id&quot;</span>: <span class="number">6</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解题思路：</strong></p>
<ol>
<li>先将数组元素转化成对象结构（hash结构）去存储<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220904161343.png"></li>
<li>将hash结构数据转化为树形结构数据</li>
</ol>
<p><strong>解题代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arr2Tree</span> (arr) &#123;</span><br><span class="line">  <span class="comment">// parentHash用于确定rootId,childHash用于构建树形结构</span></span><br><span class="line">  <span class="comment">//步骤一：转化数组数据称为hash结构数据</span></span><br><span class="line">  <span class="keyword">const</span> parentHash = &#123;&#125;, childHash = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id, pid &#125; = item;</span><br><span class="line">    parentHash[id] = pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!childHash[pid]) &#123;</span><br><span class="line">      childHash[pid] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    childHash[pid].<span class="title function_">push</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//步骤二：确定树形结构的根节点</span></span><br><span class="line">  <span class="keyword">let</span> rootId = arr[<span class="number">0</span>].<span class="property">id</span>;</span><br><span class="line">  <span class="keyword">while</span> (parentHash[rootId] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    rootId = parentHash[rootId];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(rootId)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//步骤三：将hash结构转化为树形结构</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">hash2Tree</span>(childHash, rootId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数作用：将hash结构转化为树形结构</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hash2Tree</span> (childHash, rootId) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123; <span class="attr">id</span>: rootId &#125;;</span><br><span class="line">  <span class="keyword">if</span> (childHash[rootId] &amp;&amp; childHash[rootId].<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    res.<span class="property">children</span> = childHash[rootId].<span class="title function_">map</span>(<span class="function">(<span class="params">cid</span>) =&gt;</span> <span class="title function_">hash2Tree</span>(childHash, cid))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220904182940.png"></p>
<h3 id="情景二：HTML转AST"><a href="#情景二：HTML转AST" class="headerlink" title="情景二：HTML转AST"></a>情景二：HTML转AST</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入:  <span class="keyword">let</span> str =<span class="string">&quot;&lt;div&gt;&lt;span&gt;tests&lt;/span&gt;&lt;/div&gt;&quot;</span></span><br><span class="line">输出 : &#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">tag</span>: <span class="string">&#x27;span&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解题代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 设置每个节点标签属性</span></span><br><span class="line"><span class="comment">// let attrRE = /\s([^&#x27;&quot;/\s&gt;&lt;]+?)[\s/&gt;]|([^\s=]+)=\s?(&quot;.*?&quot;|&#x27;.*?&#x27;)/g;</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">parseTag</span>(<span class="params">tag</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> res = &#123;</span><br><span class="line">     <span class="attr">type</span>: <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">     <span class="attr">voidElement</span>: <span class="literal">false</span>,</span><br><span class="line">     <span class="attr">attrs</span>: &#123;&#125;,</span><br><span class="line">     <span class="attr">children</span>: [],</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">let</span> tagMatch = tag.<span class="title function_">match</span>(<span class="regexp">/&lt;\/?([^\s]+?)[/\s&gt;]/</span>);</span><br><span class="line">   <span class="keyword">if</span> (tagMatch) &#123;</span><br><span class="line">     <span class="comment">// 标签名称为正则匹配的第2项</span></span><br><span class="line">     res.<span class="property">name</span> = tagMatch[<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">if</span> (tag.<span class="title function_">charAt</span>(tag.<span class="property">length</span> - <span class="number">2</span>) === <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">       <span class="comment">// 判断tag字符串倒数第二项是不是 / 设置为空标签。 例子：&lt;img/&gt;</span></span><br><span class="line">       res.<span class="property">voidElement</span> = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 匹配所有的标签正则</span></span><br><span class="line">   <span class="keyword">let</span> classList = tag.<span class="title function_">match</span>(<span class="regexp">/\s([^&#x27;&quot;/\s&gt;&lt;]+?)\s*?=\s*?(&quot;.*?&quot;|&#x27;.*?&#x27;)/g</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (classList &amp;&amp; classList.<span class="property">length</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; classList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">       <span class="comment">// 去空格再以= 分隔字符串  得到[&#x27;属性名称&#x27;,&#x27;属性值&#x27;]</span></span><br><span class="line">       <span class="keyword">let</span> c = classList[i].<span class="title function_">replace</span>(<span class="regexp">/\s*/g</span>, <span class="string">&quot;&quot;</span>).<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">       <span class="comment">// 循环设置属性</span></span><br><span class="line">       <span class="keyword">if</span> (c[<span class="number">1</span>]) res.<span class="property">attrs</span>[c[<span class="number">0</span>]] = c[<span class="number">1</span>].<span class="title function_">substring</span>(<span class="number">1</span>, c[<span class="number">1</span>].<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params">html</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> result = [];</span><br><span class="line">   <span class="keyword">let</span> current;</span><br><span class="line">   <span class="keyword">let</span> level = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">let</span> arr = [];</span><br><span class="line">   <span class="keyword">let</span> tagRE = <span class="regexp">/&lt;[a-zA-Z\-\!\/](?:&quot;[^&quot;]*&quot;[&#x27;&quot;]*|&#x27;[^&#x27;]*&#x27;[&#x27;&quot;]*|[^&#x27;&quot;&gt;])*&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">   html.<span class="title function_">replace</span>(tagRE, <span class="keyword">function</span> (<span class="params">tag, index</span>) &#123;</span><br><span class="line">     <span class="comment">// 判断第二个字符是不是&#x27;/&#x27;来判断是否open</span></span><br><span class="line">     <span class="keyword">let</span> isOpen = tag.<span class="title function_">charAt</span>(<span class="number">1</span>) !== <span class="string">&quot;/&quot;</span>;</span><br><span class="line">     <span class="comment">// 获取标签末尾的索引</span></span><br><span class="line">     <span class="keyword">let</span> start = index + tag.<span class="property">length</span>;</span><br><span class="line">     <span class="comment">// 标签之前的文本信息</span></span><br><span class="line">     <span class="keyword">let</span> text = html.<span class="title function_">slice</span>(start, html.<span class="title function_">indexOf</span>(<span class="string">&quot;&lt;&quot;</span>, start));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">let</span> parent;</span><br><span class="line">     <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">       level++;</span><br><span class="line">       <span class="comment">// 设置标签属性</span></span><br><span class="line">       current = <span class="title function_">parseTag</span>(tag);</span><br><span class="line">       <span class="comment">// 判断是否为文本信息，是就push一个text children  不等于&#x27;  &#x27;</span></span><br><span class="line">       <span class="keyword">if</span> (!current.<span class="property">voidElement</span> &amp;&amp; text.<span class="title function_">trim</span>()) &#123;</span><br><span class="line">         current.<span class="property">children</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">           <span class="attr">type</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">           <span class="attr">content</span>: text,</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果我们是根用户，则推送新的基本节点</span></span><br><span class="line">       <span class="keyword">if</span> (level === <span class="number">0</span>) &#123;</span><br><span class="line">         result.<span class="title function_">push</span>(current);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 判断有没有上层，有就push当前标签</span></span><br><span class="line">       parent = arr[level - <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">         parent.<span class="property">children</span>.<span class="title function_">push</span>(current);</span><br><span class="line">       &#125;</span><br><span class="line">       arr[level] = current;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果不是开标签，或者是空元素：&lt;/div&gt;&lt;img&gt;</span></span><br><span class="line">     <span class="keyword">if</span> (!isOpen || current.<span class="property">voidElement</span>) &#123;</span><br><span class="line">       <span class="comment">// level--</span></span><br><span class="line">       level--;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// test str:</span></span><br><span class="line"> <span class="keyword">let</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">             &lt;div class = &#x27;divClass&#x27; style=&#x27;backgroud:url(./src/asset/img.jpg)&#x27; type=&#x27;c&#x27;&gt;</span></span><br><span class="line"><span class="string">               朱文本</span></span><br><span class="line"><span class="string">               &lt;span&gt;文本1&lt;/span&gt;  </span></span><br><span class="line"><span class="string">               &lt;p class=&#x27;names&#x27;&gt;</span></span><br><span class="line"><span class="string">                 文本2</span></span><br><span class="line"><span class="string">                 &lt;div&gt;</span></span><br><span class="line"><span class="string">                   &lt;span class=&quot;span&quot;&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                 &lt;/div&gt;</span></span><br><span class="line"><span class="string">                 &lt;img/&gt;</span></span><br><span class="line"><span class="string">               &lt;/p&gt;</span></span><br><span class="line"><span class="string">             &lt;/div&gt;</span></span><br><span class="line"><span class="string">           `</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> ast = <span class="title function_">parse</span>(html);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(ast);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【14】简单实现async/await中的async函数</title>
    <url>/2022/08/31/14-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0async-await%E4%B8%AD%E7%9A%84async%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><code>async</code> 函数的实现原理，就是将 <code>Generator</code> 函数和自动执行器，包装在一个函数里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_async</span> (genF) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = <span class="title function_">genF</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">step</span> (nextF) &#123;</span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = <span class="title function_">nextF</span>();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next.<span class="property">done</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(next.<span class="property">value</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(next.<span class="property">value</span>).<span class="title function_">then</span>(</span><br><span class="line">        <span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">          <span class="title function_">step</span>(&#123;</span><br><span class="line">            <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> gen.<span class="title function_">next</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">          <span class="title function_">step</span>(&#123;</span><br><span class="line">            <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> gen.<span class="keyword">throw</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">step</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> gen.<span class="title function_">next</span>(<span class="literal">undefined</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass、Less知识</title>
    <url>/2022/08/31/Sass%E3%80%81Less%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="1-Sass、Less是什么？"><a href="#1-Sass、Less是什么？" class="headerlink" title="1.Sass、Less是什么？"></a>1.Sass、Less是什么？</h3><ul>
<li><code>Less</code> （<code>Leaner Style Sheets</code> 的缩写） 是一门向后兼容的 CSS 扩展语言。因为 Less 和 CSS 非常像，Less 仅对 CSS 语言增加了少许方便的扩展，学习很容易。 </li>
<li><code>Sass</code>，作为”世界上最成熟、最稳定、最强大的专业级CSS扩展语言”。兼容所有版本的css，且有无数框架使用Sass构建，如Compass，Bourbon，和Susy。</li>
</ul>
<p><span style="background:pink"> <code>Sass</code> 和 <code>Less</code> 这类语言，其实可以理解成 <code>CSS</code> 的超集，它们在<code>CSS</code>原本的语法格式基础上，增加了编程语言的特性，如变量的使用、逻辑语句的支持、函数等。让 <code>CSS</code> 代码更容易维护和复用。</span></p>
<p>例如，<code>Less</code>是一种动态样式语言，将CSS赋予了动态语言的特性，如变量、继承、运算、函数。<code>Less</code>既可以在客户端上运行（支持IE 6+、Webkit、Firefox），也可以在服务端运行（借助Node.js）</p>
<p><mark><strong>什么是CSS预处理器？</strong></mark><br>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编码工作。</p>
<h3 id="2-为什么要使用？"><a href="#2-为什么要使用？" class="headerlink" title="2.为什么要使用？"></a>2.为什么要使用？</h3><ul>
<li>结构清晰，便于拓展。可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理，减少无意义的编码</li>
<li>可以轻松实现多重继承。完全兼容CSS代码，可以方便地应用到老项目中。LESS只是在CSS语法上做了拓展，所以老的CSS代码也可以与Less代码一同编译</li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目中对Axios的封装</title>
    <url>/2022/08/30/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AF%B9Axios%E7%9A%84%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h3 id="一、axios是什么？"><a href="#一、axios是什么？" class="headerlink" title="一、axios是什么？"></a>一、axios是什么？</h3><p><code>axios</code>是一个轻量的<code>HTTP</code>客户端，基于<code>XMLHttpRequest</code>服务来执行<code>HTTP</code>请求，支持丰富的配置，支持<code>Promise</code>，支持浏览器端和<code>Node.js</code>端。自<code>Vue 2.0</code>起，尤大大宣布取消对<code>vue-resource</code>的官方推荐，转而推荐<code>axios</code>。现在<code>axios</code>已经成为大部分<code>Vue</code>开发者的首选</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li>从浏览器中创建<code>XMLHttpRequests</code></li>
<li>从<code>node.js</code>创建<code>http</code>请求</li>
<li>支持<code>Promise API</code></li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换<code>JSON</code>数据</li>
<li>客户端支持防御<code>XSRF</code></li>
</ul>
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p><strong>1.安装 &amp; 导入</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 项目中安装</span></span><br><span class="line">npm install axios --S</span><br><span class="line"><span class="comment">// cdn 引入</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.发送请求</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;xxx&#x27;</span>, <span class="comment">// 设置请求的地址</span></span><br><span class="line">  <span class="attr">method</span>:<span class="string">&#x27;GET&#x27;</span>, <span class="comment">//设置请求的方法</span></span><br><span class="line">  <span class="attr">params</span>:&#123; <span class="comment">// get请求使用params进行参数凭借，如果是post请求用data</span></span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">page</span>:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// res为后端返回的数据</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>并发请求<code>axios.all([])</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserAccount</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserPermission</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">all</span>([<span class="title function_">getUserAccount</span>(),<span class="title function_">getUserPermission</span>()])</span><br><span class="line">  .<span class="title function_">then</span>(axios.<span class="title function_">spread</span>(<span class="keyword">function</span>(<span class="params">res1,res2</span>)&#123;</span><br><span class="line">    <span class="comment">// res1第一个请求的返回的内容，res2第二个请求返回的内容</span></span><br><span class="line">    <span class="comment">// 两个请求都执行完成才会执行</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>

<h3 id="二、为什么要封装"><a href="#二、为什么要封装" class="headerlink" title="二、为什么要封装"></a>二、为什么要封装</h3><p><code>axios</code>的API很友好，可以轻松在项目中直接使用。</p>
<p>但是随着项目规模变大，如果每发起一次<code>HTTP</code>请求，就要把一些设置（如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等操作）都写一遍，这种重复的劳动不仅浪费时间，还会让代码变得冗余，难以维护。</p>
<p>为了提高代码的质量，应该在项目中对<code>axios</code>进行二次开发，再使用</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(<span class="string">&#x27;http://localhost:3000/data&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 配置代码</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="title class_">Authorization</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment">// 其他请求配置...</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// todo: 真正业务逻辑代码</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 错误处理代码  </span></span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">response</span>.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">  <span class="comment">// handle authorization error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">response</span>.<span class="property">status</span> === <span class="number">403</span>) &#123;</span><br><span class="line">  <span class="comment">// handle server forbidden error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他错误处理.....</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果每个页面都发送类似的请求，都要写一堆的配置与错误处理，就显得过于繁琐了<br>这时候我们就需要对<code>axios</code>进行二次封装，让使用更为便利</p>
<h3 id="三、如何封装"><a href="#三、如何封装" class="headerlink" title="三、如何封装"></a>三、如何封装</h3><p>封装的同时，你需要和后端协商好一些约定，请求头，状态码，请求超时时间……</p>
<p>设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分<br>请求头：来实现一些具体的业务，必须携带一些参数才可以请求（例如：会员业务）<br>状态码：根据接口返回不同的<code>status</code>，来执行不同的业务，这块需要和后端约定好<br>请求方法：根据<code>get</code>、<code>post</code>等方法进行一个再次封装，使用起来更加方便<br>请求拦截器：根据请求的请求头设定，来决定哪些请求可以访问<br>响应拦截器：这块就是根据后端返回的状态码来判定执行不同的业务</p>
<h4 id="设置接口请求前缀"><a href="#设置接口请求前缀" class="headerlink" title="设置接口请求前缀"></a>设置接口请求前缀</h4><p>利用<code>node</code>环境变量来作判断，用来区分开发、测试、生产环境 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://dev.xxx.com&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://prod.xxx.com&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在本地调试的时候，还需要在<code>vue.config.js</code>文件中配置<code>devServer</code>实现代理转发，从而实现跨域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/proxyApi&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://dev.xxx.com&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;/proxyApi&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="设置请求头与超时时间"><a href="#设置请求头与超时时间" class="headerlink" title="设置请求头与超时时间"></a>设置请求头与超时时间</h4><p>大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">30000</span>,  <span class="comment">// 请求 30s 超时</span></span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded;charset=utf-8&#x27;</span></span><br><span class="line">          <span class="comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">post</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">          <span class="comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span></span><br><span class="line">        &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="封装请求方法"><a href="#封装请求方法" class="headerlink" title="封装请求方法"></a>封装请求方法</h4><p>先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get 请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">httpGet</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  params = &#123;&#125;</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(url, &#123;</span><br><span class="line">      params</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(res.<span class="property">data</span>)</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// post请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">httpPost</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  data = &#123;&#125;,</span></span><br><span class="line"><span class="params">  params = &#123;&#125;</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">      url,</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">      <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">in</span> data) &#123;</span><br><span class="line">          ret += <span class="built_in">encodeURIComponent</span>(it) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(data[it]) + <span class="string">&#x27;&amp;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">      &#125;],</span><br><span class="line">      data, <span class="comment">// 发送的数据</span></span><br><span class="line">      params <span class="comment">// url参数</span></span><br><span class="line"></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(res.<span class="property">data</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把封装的方法放在一个<code>api.js</code>文件中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; httpGet, httpPost &#125; <span class="keyword">from</span> <span class="string">&#x27;./http&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getorglist</span> = (<span class="params">params = &#123;&#125;</span>) =&gt; <span class="title function_">httpGet</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;apps/api/org/list&#x27;</span>, params &#125;)</span><br></pre></td></tr></table></figure>
<p>在页面中就能直接调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; getorglist &#125; <span class="keyword">from</span> <span class="string">&#x27;@/assets/js/api&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">getorglist</span>(&#123; <span class="attr">id</span>: <span class="number">200</span> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样可以把<code>api</code>统一管理起来，以后维护修改只需要在<code>api.js</code>文件中操作即可</p>
<h4 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h4><p>请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每次发送请求之前判断是否存在token</span></span><br><span class="line">    <span class="comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span></span><br><span class="line">    hl-&amp;&amp; (config.<span class="property">headers</span>.<span class="property">Authorization</span> = token)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h4><p>响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span></span><br><span class="line">  <span class="comment">// 否则的话抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">511</span>) &#123;</span><br><span class="line">      <span class="comment">// 未授权调取授权接口</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">510</span>) &#123;</span><br><span class="line">      <span class="comment">// 未登录跳转登录页</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(response)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 我们可以在这里对异常状态作统一处理</span></span><br><span class="line">  <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">status</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理请求失败的情况</span></span><br><span class="line">    <span class="comment">// 对不同返回码对相应处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error.<span class="property">response</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>封装是编程中很有意义的手段，简单的axios封装，就可以让我们可以领略到它的魅力</li>
<li>封装 <code>axios</code> 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案</li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>页面响应式适配</title>
    <url>/2022/08/30/%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<h3 id="1-响应式设计是什么？"><a href="#1-响应式设计是什么？" class="headerlink" title="1.响应式设计是什么？"></a>1.响应式设计是什么？</h3><p>响应式网站设计（Responsive Web Design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相应的响应和调整。</p>
<p>描述响应式界面最著名的一句话是“<mark>Content is like water</mark>”（如果将屏幕看作是容器，那么内容就像水一样）。</p>
<p>常见的响应式网站的特点：</p>
<ul>
<li>同时适配PC + 平板 + 手机等</li>
<li>标签导航在接近手持终端设备时改变为经典的抽屉式导航</li>
<li>网站的布局会根据视口大小来调整模块的大小和位置</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220830105058.png"></p>
<h3 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2.实现方式"></a>2.实现方式</h3><p>响应式设计的基本原理是 <b style="background:pink">通过媒体查询检测不同的设备屏幕尺寸做处理</b> ，为了处理移动端，页面头部必须有<code>meta</code>声明<code>viewport</code></p>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;</code><br>属性对应如下：</p>
<ul>
<li><code>width=device-width</code>：是自适应手机屏幕的尺寸宽度</li>
<li><code>maximum-scale</code>：是缩放比例的最大值</li>
<li><code>initial-scale</code>：是缩放的初始化</li>
<li><code>user-scalable</code>：是用户的可以缩放的操作</li>
</ul>
<p>实现响应式布局的方式有如下：</p>
<ul>
<li>媒体查询</li>
<li>百分比</li>
<li>vw / vh</li>
<li>rem </li>
</ul>
<h4 id="方式一：媒体查询"><a href="#方式一：媒体查询" class="headerlink" title="方式一：媒体查询"></a>方式一：媒体查询</h4><p>使用<code>@media</code>查询，可以针对不同的媒体类型定义不同的样式，如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">1920px</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>当视口在375px~600px之间，设置特定的字体大小18px</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen (<span class="attribute">min-width</span>:<span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">600px</span>)&#123;</span><br><span class="line">  <span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">18px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式布局 （<em>比如为不同的分辨率屏幕，设置不同的背景图片 、 比如给小屏幕的手机设置@2x图，给大屏幕手机设置@3x图</em>）</p>
<h4 id="方式二：百分比"><a href="#方式二：百分比" class="headerlink" title="方式二：百分比"></a>方式二：百分比</h4><p>通过百分比单位`%``来实现响应式的效果</p>
<p>比如当浏览器的宽度或者高度发生变化时，通过百分比单位，可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果</p>
<p><code>height</code>、<code>width</code>属性的百分比依托于父标签的宽高，但是其他盒子属性则完全不依赖父元素：</p>
<ul>
<li>子元素的<code>top/left</code>和<code>bottom/right</code>如果设置百分比，则相对于直接非<code>static</code>定位(默认定位)的父元素的高度/宽度</li>
<li>子元素的<code>padding</code>如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的<code>width</code>，与父元素的<code>height</code>无关</li>
<li>子元素的<code>margin</code>如果设置成百分比，不论垂直方向或者是水平方向，都相对于直接父元素的<code>width</code></li>
<li><code>border-radius</code>不一样，如果设置<code>border-radius</code>为百分比，则是相对于自身的宽度</li>
</ul>
<p>可以看到每个属性都使用百分比，会造成布局的复杂度，所以不建议使用百分比来实现响应式</p>
<h4 id="方式三：vw-vh"><a href="#方式三：vw-vh" class="headerlink" title="方式三：vw / vh"></a>方式三：vw / vh</h4><p><code>vw</code>表示相对于视图窗口的宽度，<code>vh</code>表示相对于视图窗口高度。任意层级元素，在使用<code>vw</code>单位的情况下，<code>1vw</code>都等于视图宽度的1%</p>
<h4 id="方式四：rem"><a href="#方式四：rem" class="headerlink" title="方式四：rem"></a>方式四：rem</h4><p><code>rem</code>是相对于根元素<code>html</code>的<code>font-size</code>属性，默认情况下浏览器字体的大小为<code>16px</code>，此时<code>1rem = 16px</code></p>
<p>可以利用前面提到的媒体查询，针对不同设备分辨率改变<code>font-size</code>的值，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">414px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">375px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了更准确监听设备可视窗口变化，我们可以在<code>css</code>之前插入<code>script</code>标签，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态为根元素设置字体大小</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 获取屏幕宽度</span></span><br><span class="line">  <span class="keyword">var</span> width = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">  <span class="comment">// 设置根元素字体的大小，为宽的10等分</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = width / <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次加载应用，设置一次</span></span><br><span class="line"><span class="title function_">init</span>()</span><br><span class="line"><span class="comment">// 监听手机旋转事件的时机，重新设置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;orientationchange&#x27;</span>,init)</span><br><span class="line"><span class="comment">// 监听手机窗口变化，重新设置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,init)</span><br></pre></td></tr></table></figure>
<p>无论设备可视窗口如何变化，始终设置<code>rem</code>为<code>width</code>的1/10，实现了百分比布局</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p><mark><strong>响应式布局的优点：</strong></mark></p>
<ul>
<li>面对不同分辨率设备灵活性强</li>
<li>能够快捷解决多设备显示适应问题</li>
</ul>
<p><mark><strong>响应式布局的缺点：</strong></mark></p>
<ul>
<li>仅适用于布局、信息、狂简并不复杂的部门类型网站</li>
<li>兼容各种设备工作量大，效率低 </li>
<li>代码累赘，会出现隐藏无用的元素，加载时间长</li>
<li>这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li>
<li>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP和UDP的比较</title>
    <url>/2022/08/30/TCP%E5%92%8CUDP%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220830001405.png"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><mark><strong>TCP</strong></mark>：（Transmission Control Protocol）传输控制协议，是一种<b style="color:#2b64cf">面向连接的、可靠的、基于字节流</b>的传输层通信协议，是专门为了在不可靠的网络中提供一个可靠的端对端字节流而设计的，面向字节流。</p>
<p><mark><strong>UDP</strong></mark>：（User Datagram Protocol）用户数据报协议，是一种<b style="color:#2b64cf">无连接的、基于报文的</b>传输层协议，提供简单不可靠的非连接传输层服务，面向报文</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li>TCP是面向连接的，可靠性高；UDP是基于非连接的，可靠性低</li>
<li>由于TCP是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差，同时过程复杂，也使其易于攻击；UDP没有建立连接的过程，因而实时性较强，也稍安全</li>
<li>在传输相同大小的数据时，TCP首部开销20字节；UDP首部开销8字节，TCP报头比UDP复杂，故实际包含的用户数据较少。TCP在IP协议的基础上添加了序号机制、确认机制、超时重传机制等， 保证了传输的可靠性，不会出现丢包或乱序，而UDP有丢包，故TCP开销大，UDP开销较小</li>
<li>每条TCP连接只能时点到点的；UDP支持一对一、一对多、多对一、多对多的交互通信</li>
</ol>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ol>
<li>TCP的主要特点：<mark><strong>面向连接的</strong></mark>、<mark><strong>点对点</strong></mark>、<mark><strong>全双工通信</strong></mark>、<mark><strong>面向字节流</strong></mark></li>
<li>TCP可靠传输的原理：如果网络不好，我没有收到传输的数据，可以让发送方重新发送数据。如果我处理数据的速度有限，可以告诉发送方速度不要过快，在某个速度之下。</li>
<li>停止等待协议：停止等待，就是每发送完一个分组就停止发送，等待对方确认，收到确认后再发送下一个分组。如果按照这个策略，那么传输肯定是可靠的，因为每个数据对方都会确认是否收到。</li>
<li>超时时间选择：A向B发送了一个报文，但因为网络不好，B发送的确认报文A迟迟没有收到，A很着急，于是重发报文，但网络堵塞在那，A依然无法收到B的确认报文，反而因为A发了多次，导致网络更加堵塞了。所以，有个关键问题，超时时间该如何确定呢？太短会引起很多不必要的重传，太长也不行，会让网络的空闲时间增大，影响效率。TCP采用一种自适应算法。它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差不是报文段的往返时间RTT。</li>
<li>流量控制：网络的带宽有限，端处理数据速度有限，应该发送数据的速度应该要有限制，TCP使用滑动窗口来控制流量。</li>
<li>拥塞控制：假设端上处理能力非常强，有多少处理多少。那么发送端能无限制任意发送吗？明显是不行的，接收端处理能力强，不代表网络的带宽情况。如果网络拥堵的情况下，发送端发得过多，接收端依然收不到，还会导致大量的重发，效率相当低下。所以需要拥塞控制。</li>
</ol>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ol>
<li><b style="color:#2b64cf">UDP是传输层协议</b>，功能即为在IP的数据报服务之上增加了最基本的服务：复用和分用以及差错检测。</li>
<li>UDP无连接，时间上不存在建立连接需要的时延。空间上TCP需要在端系统中维护连接状态，需要一定的开销。</li>
<li>UDP没有拥塞控制，能容忍一些数据的丢失，但是不能允许有较大的时延（比如实时视频，直播等）。</li>
<li>UDP提供<mark>尽最大努力的交付</mark>，不保证可靠交付。</li>
<li>UDP常用一次性传输比较少量数据的网络应用，如DNS,SNMP等，因为对于这些应用，若是采用TCP，在连接的创建，维护和断开存在不小的开销。</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>对实时性要求高和高速传输的场合下使用UDP;在可靠性要求低，追求效率的情况下使用UDP</li>
<li>需要传输大量数据且对可靠性要求高的情况下使用TCP</li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP和HTTPS的区别</title>
    <url>/2022/08/29/HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829193338.png"></p>
<p><code>HTTPS</code>是在<code>HTTP</code>的基础上加入<code>SSL</code>协议，<code>SSL</code>依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密（在传输层）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220904205651.png"></p>
<p><mark><strong>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</strong></mark></p>
<ol>
<li><code>HTTPS</code>协议需要到<code>CA</code>申请证书，需要一定的费用</li>
<li><code>HTTP</code>的信息是明文传输；<code>HTTPS</code>是具有安全性的SSL加密传输协议</li>
<li><code>HTTP</code>是直接与<code>TCP</code>进行数据传输；而<code>HTTPS</code>运行在<code>SSL/TLS</code>(安全传输层协议)之上，<code>SSL/TLS</code>运行在<code>TCP</code>之上，用的端口也不一样，<code>HTTP</code>是80端口，<code>HTTPS</code>是443端口</li>
<li><code>HTTP</code>的连接很简单，是无状态的；<code>HTTPS</code>协议是由<code>SSL+HTTP</code>协议构建的，可进行加密传输、身份认证的网络协议，比<code>HTTP</code>协议安全</li>
<li><code>HTTP</code>响应比<code>HTTPS</code>快，是因为<code>HTTP</code>使用<code>TCP</code>三次握手建立连接，客户端与服务器之间只交换3个包。<code>HTTPS</code>除了<code>TCP</code>的三个包，还有<code>SSL</code>握手的9个包，<mark><strong>共12个包</strong></mark>。</li>
</ol>
<h4 id="some-questions"><a href="#some-questions" class="headerlink" title="some questions"></a>some questions</h4><ol>
<li><code>HTTP</code>是无状态协议，这个如何理解?<br>答：也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态(历史信息)，而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</li>
<li><code>HTTP</code> 属于哪一层的协议啊?<code>HTTPS</code>呢？<br>答：<code>HTTP</code> 是应用层协议，以 <code>TCP</code>(传输层)作为底层协议，默认端口为 <code>80</code>。<code>HTTPS</code>是应用层协议，运行在<code>SSL/TLS</code>(安全传输层协议)之上，<code>SSL/TLS</code>运行在<code>TCP</code>之上，默认端口为<code>443</code>。</li>
<li><code>HTTP</code>通信过程是什么？</li>
</ol>
<ul>
<li>服务器在 80 端口等待客户的请求</li>
<li>浏览器发起到服务器的 TCP 连接(创建套接字 Socket)</li>
<li>服务器接收来自浏览器的 TCP 连接</li>
<li>浏览器(HTTP 客户端)与 Web 服务器(HTTP 服务器)交换 HTTP 消息</li>
<li>关闭 TCP 连接</li>
</ul>
<ol start="4">
<li>使用 <code>SSL/TLS</code> 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，<code>SSL/TLS</code> 实际对消息的加密使用的是对称加密。</li>
<li>TLS握手过程<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829202914.png"></li>
</ol>
<p><em>（<strong>第1随机数</strong>：由客户端产生，随Client Hello过程发送给服务器端；<strong>第2随机数</strong>：由服务器端产生，随Server Hello过程发送给客户端；<strong>第3随机数（预主密钥）</strong>：由客户端产生，使用公钥加密后传递给服务器端，服务器端接收后使用自己的私钥解密得到预主密钥）</em></p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829214411.png" width="50%" />

<p><strong>步骤1</strong>： 客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。<br><strong>步骤2</strong>： 服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。<br><strong>步骤3</strong>： 之后服务器发送Certificate报文。报文中包含公开密钥证书。<br><strong>步骤4</strong>： 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。<br><strong>步骤5</strong>: SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。<br><strong>步骤6</strong>： 接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。<br><strong>步骤7</strong>： 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。<br><strong>步骤8</strong>： 服务器同样发送Change Cipher Spec报文。<br><strong>步骤9</strong>： 服务器同样发送Finished报文。<br><strong>步骤10</strong>： 服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。<br><strong>步骤11</strong>： 应用层协议通信，即发送HTTP响应。<br><strong>步骤12</strong>： 最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信。</p>
<p><mark>https的详细握手过程</mark><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829230757.png"></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP会加密URL吗？</title>
    <url>/2022/08/29/HTTP%E4%BC%9A%E5%8A%A0%E5%AF%86URL%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p>字节一面问题：<span style="color:#374ef4;font-weight:800">HTTP会加密URL吗？</span></p>
<p><span style="color:#374ef4;font-weight:800">答案是，会加密。</span></p>
<h3 id="HTTP加密URL原因分析"><a href="#HTTP加密URL原因分析" class="headerlink" title="HTTP加密URL原因分析"></a>HTTP加密URL原因分析</h3><p>因为<code>URL</code>的信息都是保存在<code>HTTP Header</code>中的，而<code>HTTPS</code>是会对<code>HTTP Header + HTTP Body</code>整个加密的，所以<code>URL</code>自然是会被加密的。</p>
<p>下图是<code>HTTP/1.1</code>的请求头部，可以看到是包含<code>URL</code>信息的。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829113351.png"></p>
<p>对应的实际的<code>HTTP/1.1</code>的请求头部：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829113827.png"></p>
<p><code>HTTP/1.1</code>请求的第一行包含请求方法和请求路径。<code>HTTP/2</code>用一系列伪头部（pseudo-header）替换了请求行，这五个伪头部很容易识别，因为他们在名称的开头用了一个冒号来表示。</p>
<p>比如请求方法和路径伪头字段如下：</p>
<ul>
<li><code>:method</code>伪头字段包含HTTP方法</li>
<li><code>:path</code>伪头字段包含目标URL的路径和查询部分</li>
</ul>
<p>如下图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829114347.png"><br><em>此时浏览器现实的信息是已经解密后的信息，并非URL没有加密</em></p>
<p>采用抓包工具抓包HTTPS的数据是什么都看不到的，只会显示<code>Application Data</code>，表示这是一个已经加密的HTTP应用数据<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829114559.png"></p>
<h3 id="HTTPS可以看到域名吗？"><a href="#HTTPS可以看到域名吗？" class="headerlink" title="HTTPS可以看到域名吗？"></a>HTTPS可以看到域名吗？</h3><p>从上面我们可以知道，<code>HTTPS</code> 是已经把  <code>HTTP Header + HTTP Body</code> 整个加密的，所以我们是无法从加密的 <code>HTTP</code> 数据中获取请求的域名的。<br>但是我们<span style="color:#374ef4;font-weight:800">可以在TLS握手的过程中看到域名信息</span></p>
<p>如下图，TLS第一次握手的“Client Hello” 消息中，有个<code>server name</code>字段，它就是请求的域名地址。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829115538.png"></p>
<h3 id="HTTPS的应用数据是如何保证完整性的？"><a href="#HTTPS的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS的应用数据是如何保证完整性的？"></a>HTTPS的应用数据是如何保证完整性的？</h3><p>很多人以为HTTP数据就是用对称加密密钥（TLS握手过程中协商出来的对称加密密钥）加密后就直接发送了，然后就疑惑HTTP 数据有没有通过摘要算法来保证完整性？</p>
<p>实际上，TLS在实现上分为 <mark><strong>握手协议</strong></mark>和<mark><strong>记录协议</strong></mark>两层：</p>
<ul>
<li>TLS握手协议就是我们说的TLS四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即HTTP数据）</li>
<li>TLS记录协议负责保护应用程序数据并验证其完整性和来源，所以对HTTP数据加密是使用记录协议</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829130424.png"><br>具体过程如下：</p>
<ul>
<li>首先，消息被分割成多个较短的片段，然后分别对每个片段进行压缩</li>
<li>接下来，经过压缩的片段会被<span style="color:#374ef4;font-weight:800">加上消息认证码（MAC值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</span>。通过附加消息认证码的MAC值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li>
<li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li>
<li>最后，上述经过加密的数据再加上数据类型、版本号、压缩后的长度组成的报头就是最终的加密报文数据。</li>
</ul>
<p>记录协议完成后，最终的加密报文数据将传递到传输控制协议（TCP）层进行传输。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax的原理及其实现</title>
    <url>/2022/08/27/Ajax%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h3><p><code>Ajax</code> 全称是 <code>Async JavaScript and XML</code>，即异步的<code>JavaScript</code>和<code>XML</code>，是一种创建交互式网页应用的网页开发技术，可以在不加载整个网页的情况下，与服务器交换数据，并且更新部分网页</p>
<p><code>Ajax</code> 的原理简单来说是通过<code>XMLHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>JavaScript</code>来操作<code>DOM</code>，从而更新页面</p>
<p>流程图如下：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220827232505.png"></p>
<blockquote>
<p>一个小例子：<br>领导想找小李汇报一下工作，就委托秘书去叫小李，自己接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作</p>
<p><code>Ajax</code>请求数据流程与 “领导想找小李汇报一下工作” 类似，上述的<code>秘书</code>相当于<code>XMLHttpRequest</code>对象，<code>领导</code>相当于<code>浏览器</code>，<code>小李</code>相当于<code>响应数据</code></p>
</blockquote>
<h3 id="二、实现过程"><a href="#二、实现过程" class="headerlink" title="二、实现过程"></a>二、实现过程</h3><p>实现<code>Ajax</code>异步交互需要服务器逻辑进行配合，需要完成以下步骤：</p>
<ul>
<li>创建<code>Ajax</code>的核心对象<code>XMLHttpRequest</code>对象</li>
<li>通过<code>XMLHttpRequest</code>对象的<code>open()</code>方法与服务端建立连接</li>
<li>构建请求所需的数据对象，并通过<code>XMLHttpRequest</code>对象的<code>send()</code>方法发送给服务器</li>
<li>通过<code>XMLHttpRequest</code>对象提供的<code>onreadystatechange</code>事件监听服务器端的通信状态</li>
<li>接受并处理服务器端向客户端响应的数据结果</li>
<li>将处理结果更新到<code>HTML</code>页面中</li>
</ul>
<h5 id="创建XMLHttpRequest对象"><a href="#创建XMLHttpRequest对象" class="headerlink" title="创建XMLHttpRequest对象"></a>创建<code>XMLHttpRequest</code>对象</h5><p>通过<code>XMLHttpRequest()</code>构造函数用于初始化一个<code>XMLHttpRequest</code>实例对象<br><code> const xhr = new XMLHttpRequest();</code></p>
<h5 id="与服务器建立连接"><a href="#与服务器建立连接" class="headerlink" title="与服务器建立连接"></a>与服务器建立连接</h5><p>通过<code>XMLHttpRequest</code>对象的<code>open()</code>方法与服务器建立连接<br><code>xhr.open(method, url, [async][, user][, password])</code><br>参数说明：</p>
<ul>
<li><code>method</code>：表示当前请求的方法，常见的有<code>GET</code>、<code>POST</code></li>
<li><code>url</code>：服务端地址</li>
<li><code>async</code>：布尔值，表示是否异步执行操作，默认为<code>true</code></li>
<li><code>user</code>：可选的用户名用于认证用途，默认为<code>null</code></li>
<li><code>password</code>：可选的密码用于认证用途，默认为<code>null</code></li>
</ul>
<h5 id="给服务端发送数据"><a href="#给服务端发送数据" class="headerlink" title="给服务端发送数据"></a>给服务端发送数据</h5><p>通过<code>XMLHttpRequest</code>对象的<code>send()</code>方法，将客户端页面的数据发送给服务器端<br><code>xhr.send([body])</code><br><code>body</code>：在<code>XHR</code>请求中要发送的数据体，如果不传递数据则为<code>null</code><br>如果使用<code>GET</code> 请求发送数据的时候，需要注意如下：</p>
<ul>
<li>将请求数据添加到<code>open()</code>方法中的<code>url</code>地址中，以<code>?</code>的形式分割，多个参数之间使用<code>&amp;</code>连接</li>
<li>发送请求数据中的<code>send()</code>方法中参数设置为<code>null</code></li>
</ul>
<h5 id="绑定onreadystatechange事件"><a href="#绑定onreadystatechange事件" class="headerlink" title="绑定onreadystatechange事件"></a>绑定<code>onreadystatechange</code>事件</h5><p><code>onreadystatechange</code>事件用于监听服务器端的通信状态，主要监听的属性为<code>XMLHttpRequest.readyState</code>。<br>关于<code>XMLHttpRequest.readyState</code>属性有五个状态，如下图显示<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829090249.png"><br>只要<code>readyState</code>属性值一发生变化，就会触发一次<code>readystatechange</code>事件<br><code>XMLHttpRequest.responseText</code>属性用于接收服务器端的响应结果</p>
<p><strong>一个小例子：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(request.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="comment">//整个请求过程完毕</span></span><br><span class="line">    <span class="keyword">if</span>(request.<span class="property">status</span>&gt;=<span class="number">200</span> &amp;&amp; request.<span class="property">status</span>&lt;=<span class="number">300</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">responseText</span>) <span class="comment">//服务端返回的结果</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request.<span class="property">status</span>&gt;=<span class="number">400</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误信息：&#x27;</span>+request.<span class="property">status</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://xxx&#x27;</span>)</span><br><span class="line">request.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure>

<h3 id="三、封装"><a href="#三、封装" class="headerlink" title="三、封装"></a>三、封装</h3><p>通过上面对<code>XMLHttpRequest</code>对象的描述，简单封装一个简单的<code>Ajax</code>请求 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个ajax请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">options</span>)&#123;</span><br><span class="line">  <span class="comment">//创建XMLHttpRequest对象</span></span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化参数的内容</span></span><br><span class="line">  options = options||&#123;&#125;</span><br><span class="line">  options.<span class="property">type</span> = (options.<span class="property">type</span>||<span class="string">&#x27;GET&#x27;</span>).<span class="title function_">toUpperCase</span>()</span><br><span class="line">  options.<span class="property">dataType</span> = options.<span class="property">dataType</span> || <span class="string">&#x27;json&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> params = options.<span class="property">data</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送请求 </span></span><br><span class="line">  <span class="keyword">if</span>(options.<span class="property">type</span> === <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,options.<span class="property">url</span>+<span class="string">&#x27;?&#x27;</span>+params,<span class="literal">true</span>)</span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(options.<span class="property">type</span> === <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>,options.<span class="property">url</span>,<span class="literal">true</span>)</span><br><span class="line">    xhr.<span class="title function_">send</span>(params)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收请求</span></span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> status = xhr.<span class="property">status</span></span><br><span class="line">      <span class="keyword">if</span>(status&gt;=<span class="number">200</span> &amp;&amp; status&lt;<span class="number">300</span>)&#123;</span><br><span class="line">        options.<span class="property">success</span> &amp;&amp; options.<span class="title function_">success</span>(xhr.<span class="property">responseText</span>,xhr.<span class="property">responseXML</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        options.<span class="property">fail</span> &amp;&amp; options.<span class="title function_">fail</span>(status)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">dataType</span>:<span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>:&#123;&#125;,</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;http://xxxx&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">text,xml</span>)&#123;</span><br><span class="line">    <span class="comment">//请求成功后的回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(text)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">fail</span>:<span class="keyword">function</span>(<span class="params">status</span>)&#123;</span><br><span class="line">    <span class="comment">//请求失败的回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(status)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>柯里化实现函数连续调用计算累加和</title>
    <url>/2022/08/24/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E8%B0%83%E7%94%A8%E8%AE%A1%E7%AE%97%E7%B4%AF%E5%8A%A0%E5%92%8C/</url>
    <content><![CDATA[<p>神策数据一面手写题：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220824202349.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> parmas = args;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>)&#123;</span><br><span class="line">    parmas = [...parmas,...<span class="variable language_">arguments</span>];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">  sum.<span class="property">sumOf</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> parmas.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p+c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">10</span>)(<span class="number">10</span>, <span class="number">20</span>).<span class="title function_">sumOf</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220824205528.png"></p>
]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex布局</title>
    <url>/2022/08/23/Flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="1-Flex布局"><a href="#1-Flex布局" class="headerlink" title="1.Flex布局"></a>1.Flex布局</h3><p>Flexible Box简称flex，意为“弹性布局”，可以简便、完整、响应式地实现各种页面布局。<br>采用flex布局的元素，称为flex容器<code>container</code>，它的所有子元素自动成为容器成员，称为flex项目<code>item</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220823153358.png"><br>容器中默认存在两条轴，主轴和交叉轴，呈90度关系。项目默认沿主轴排列，通过<code>flex-direction</code>来决定主轴的方向。</p>
<p>每根轴线都有起点和终点，这对于元素的对齐非常重要。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220826142440.png"></p>
<h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h3><p>关于<code>flex</code>常用属性，我们可以划分为<mark>容器属性</mark>和<mark>容器成员属性</mark></p>
<p><strong><span style="background:pink">容器属性有：</span></strong></p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<p><strong><span style="background:pink">容器成员属性有：</span></strong></p>
<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h4 id="容器属性-flex-direction"><a href="#容器属性-flex-direction" class="headerlink" title="容器属性  flex-direction"></a>容器属性  flex-direction</h4><p>决定主轴的方向（即项目的排列方向）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;   </span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>属性对应如下：</p>
<ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿</li>
<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220824103150.png"></p>
<h4 id="容器属性-flex-wrap"><a href="#容器属性-flex-wrap" class="headerlink" title="容器属性  flex-wrap"></a>容器属性  flex-wrap</h4><p>弹性元素永远沿主轴排列，那么如果主轴排不下，通过<code>flex-wrap</code>决定容器内项目是否可换行</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;  </span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>属性对应如下：</p>
<ul>
<li>nowrap（默认值）：不换行</li>
<li>wrap：换行，第一行在上方</li>
<li>wrap-reverse：换行，第一行在下方</li>
</ul>
<p>默认情况是不换行，但这里也不会任由元素直接溢出容器，会涉及到元素的弹性伸缩</p>
<blockquote>
<p>容器属性  flex-flow<br>是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></p>
</blockquote>
<h4 id="容器属性-justify-content"><a href="#容器属性-justify-content" class="headerlink" title="容器属性  justify-content"></a>容器属性  justify-content</h4><p>定义了项目在主轴上的对齐方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性对应如下：</p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center：居中</li>
<li>space-beteen：两端对齐，项目之间的间隔相等</li>
<li>space-around：两个项目两侧间隔相等</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220824140715.png"></p>
<h4 id="容器属性-align-items"><a href="#容器属性-align-items" class="headerlink" title="容器属性  align-items"></a>容器属性  align-items</h4><p>定义项目在交叉轴上如何对齐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性对应如下：</p>
<ul>
<li>flex-start：交叉轴的起点对齐</li>
<li>flex-end：交叉轴的终点对齐</li>
<li>center：交叉轴的中点对齐</li>
<li>baseline：项目的第一行文字的基线对齐</li>
<li>stretch（默认值）：如果项目未设置高度或者设为auto，将占满整个容器的高度</li>
</ul>
<h4 id="容器属性-align-content"><a href="#容器属性-align-content" class="headerlink" title="容器属性 align-content"></a>容器属性 align-content</h4><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性对应如下：</p>
<ul>
<li>flex-start：与交叉轴的起点对齐</li>
<li>flex-end：与交叉轴的终点对齐</li>
<li>center：与交叉轴的中点对齐</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li>
<li>stretch（默认值）：轴线占满整个交叉轴</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220826084437.png"></p>
<h4 id="容器成员属性-order"><a href="#容器成员属性-order" class="headerlink" title="容器成员属性 order"></a>容器成员属性 order</h4><p>定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容器成员属性-flex-grow"><a href="#容器成员属性-flex-grow" class="headerlink" title="容器成员属性 flex-grow"></a>容器成员属性 flex-grow</h4><p>上面讲到当容器设为<code>flex-wrap:nowrap;</code>不换行的时候，容器宽度有不够分的情况，弹性元素会根据<code>flex-grow</code>来决定定义项目的放大比例（容器宽度&gt;元素总宽度时如何伸展）<br>默认为0，即如果存在剩余空间，也不放大</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220826090002.png"><br>如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220826090156.png"></p>
<p>弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论<code>flex-grow</code>是什么值都不会生效</p>
<h4 id="容器成员属性-flex-shrink"><a href="#容器成员属性-flex-shrink" class="headerlink" title="容器成员属性 flex-shrink"></a>容器成员属性 flex-shrink</h4><p>定义了项目的缩小比例（容器元素&lt;元素总宽度时如何收缩），默认为1，如果空间不足，该项目将缩小</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小<br>如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小<br>![](<a href="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220826092204.png">https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220826092204.png</a><br>在容器宽度有剩余时，<code>flex-shrink</code>也是不会生效的</p>
<h4 id="容器成员属性-flex-basis"><a href="#容器成员属性-flex-basis" class="headerlink" title="容器成员属性 flex-basis"></a>容器成员属性 flex-basis</h4><p>设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在<code>flex-grow</code>和<code>flex-shrink</code>生效前的尺寸</p>
<p>浏览器根据这个属性，计算主轴是否有多余空间，默认值为<code>auto</code>，即项目的本来大小，如设置<code>width</code>则元素尺寸由<code>width/height</code>决定（主轴方向），没有设置则由内容决定</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">   <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当设置为0时，会根据内容撑开<br>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px）,则项目将占据固定空间</p>
<blockquote>
<p>容器成员属性 flex</p>
<figure class="highlight plaintext"><figcaption><span>```flex-shrink``` 和 ```flex-basis```的简写，默认值为```0 1 auto```，也是比较难懂的一个复合属性</span></figcaption><table><tr><td class="code"><pre><span class="line">```css</span><br><span class="line">.item &#123;</span><br><span class="line"> flex: none | [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flex:1</code> 和 <code>flex:auto</code> 的区别，可以归结于<code>flex-basis:0</code>和<code>flex-basis:auto</code>的区别</p>
</blockquote>
<p>当设置为0时（绝对弹性元素），此时相当于告诉flex-grow和flex-shrink在伸缩的时候不需要考虑我的尺寸</p>
<p>当设置为auto时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑</p>
<p>注意：建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</p>
<h4 id="容器成员属性-align-self"><a href="#容器成员属性-align-self" class="headerlink" title="容器成员属性 align-self"></a>容器成员属性 align-self</h4><p>允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性<br>默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220826095744.png"></p>
]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2.0对于数组变化的监测</title>
    <url>/2022/08/19/Vue2%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96%E7%9A%84%E7%9B%91%E6%B5%8B/</url>
    <content><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>我们都知道，Vue2.0对于响应式数据的实现存在一些不足：</p>
<ul>
<li>无法检测 数组/对象 的新增</li>
<li>无法检测通过索引改变数组的操作</li>
</ul>
<h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h3><p>1.<b style="background:yellow;">无法检测 数组/对象 的新增？</b><br> vue检测数据的变动是通过<code>Object.defineProperty</code>实现的，所以无法监听数组的添加操作是可以理解的，因为是在构造函数中就已经为所有属性做了这个检测绑定操作。</p>
<p>2.<b style="background:yellow;">无法检测通过索引改变数组的操作。即<code>vm.items[indexOfItem] = newValue</code>?</b><br>官方文档中对于这两点都是简要的概括为“由于JavaScript的限制”无法实现，而<code>Object.defineProperty</code>是实现检测数据改变的方案，这个限制是指<code>Object.defineProperty</code></p>
<h3 id="3-思考"><a href="#3-思考" class="headerlink" title="3.思考"></a>3.思考</h3><p><mark><code>vm.items[indexOfItem] = newValue</code>真的不能被监听么？</mark></p>
<blockquote>
<p>Vue对数组的7个变异方法（push、pop、shift、unshift、splice、sort、reverse）实现了响应式。这里就不做测试。接下来测试一下通过索引改变数组的操作能不能被监听到。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历数组，用Object.definedProperty对每一项进行监测</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">data, key, value</span>) &#123;</span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">         <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">         <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">         <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">defineGet</span>(<span class="params"></span>) &#123;</span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get key: <span class="subst">$&#123;key&#125;</span> value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">             <span class="keyword">return</span> value</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">defineSet</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set key: <span class="subst">$&#123;key&#125;</span> value: <span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">             value = newVal</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(data, key, data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="title function_">observe</span>(arr)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220822140627.png"></p>
<h3 id="4-测试说明"><a href="#4-测试说明" class="headerlink" title="4.测试说明"></a>4.测试说明</h3><p>通过索引改变<code>arr[1]</code>，我们发现触发了<code>set</code>，也就是<code>Object.definedProperty</code>是可以检测到通过索引改变数组的操作的，那么Vue2.0为什么没有实现呢？</p>
<blockquote>
<p>看一下来自尤大大的回答：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220822145717.png"></p>
</blockquote>
<p><strong>小结</strong><br>处于对性能原因的考虑，没有去实现它，而不是不能实现。</p>
<p><mark>对于对象而言，每一次的数据变更都会对对对象的属性进行一次枚举，一般对象本身的属性数量有限，所以对于遍历枚举等方式产生的性能损耗可以忽略不计，但是对于数组而言呢？<b style="background:pink;">数组包含的元素是可能达到成千上万的，假设对于每一次数组元素的更新都触发枚举/遍历，其带来的性能的损耗将与获得的用户体验不成正比，故vue无法检测数组的变动。</b></mark></p>
<p>不过<code>Vue3.0</code>用<code>proxy</code>代替了<code>definedProperty</code>之后解决了这个问题。</p>
<h3 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5.解决方案"></a>5.解决方案</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>1.<code>this.$set(array, index, data)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是个深度的修改，某些情况下可能导致你不希望的结果，因此最好还是慎用</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">dataArr</span> = <span class="variable language_">this</span>.<span class="property">originArr</span></span><br><span class="line"><span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">dataArr</span>, <span class="number">0</span>, &#123;<span class="attr">data</span>: <span class="string">&#x27;修改第一个元素&#x27;</span>&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">dataArr</span>) </span><br><span class="line"><span class="comment">//同样的 源数组也会被修改 在某些情况下会导致你不希望的结果       </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">originArr</span>)   </span><br></pre></td></tr></table></figure>

<p>2.<code>splice</code><br>因为<code>splice</code>会被监听有响应式，而<code>splice</code>又可以做到增删改。</p>
<p>3.利用临时变量进行中转</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tempArr = [...<span class="variable language_">this</span>.<span class="property">targetArr</span>]</span><br><span class="line">tempArr[<span class="number">0</span>] = &#123;<span class="attr">data</span>: <span class="string">&#x27;test&#x27;</span>&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">targetArr</span> = tempArr</span><br></pre></td></tr></table></figure>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>1.<code>this.$set(obj, key ,value)</code><br>可实现增、改<br>2.<code>watch</code>时添加<code>deep：true</code>深度监听，只能监听到属性值的变化，新增、删除属性无法监听</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$watch(<span class="string">&#x27;blog&#x27;</span>, <span class="variable language_">this</span>.<span class="property">getCatalog</span>, &#123;</span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// immediate: true // 是否第一次触发</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.<code>watch</code>时直接监听某个<code>key</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;obj.name&#x27;</span>(curVal, oldVal) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>理解Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>刷新浏览器后，Vuex的数据是否存在？如何解决？</title>
    <url>/2022/08/19/Vuex%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在<code>vue</code>项目中用<code>vuex</code>来做全局的状态管理，发现当刷新网页后，保存在<code>vuex</code>实例<code>store</code>里的数据会丢失。<br>原因：因为<code>store</code>里面的数据是保存在运行内存中的，当页面刷新时，页面会重新加载<code>vue</code>实例，<code>store</code>里面的数据就会被重新赋值初始化。</p>
<p>解决方法有两种：</p>
<ul>
<li>使用<code>vuex-along</code></li>
<li>使用<code>localStorage</code>或者<code>sessionStorage</code></li>
</ul>
<h4 id="使用-vuex-along"><a href="#使用-vuex-along" class="headerlink" title="使用 vuex-along"></a>使用 vuex-along</h4><p>vuex-along 的实质也是将<code>vuex</code>中的数据存放到<code>localStorage</code>或者<code>sessionStorage</code>中，只不过这个存取过程组件会帮我们完成，我们只需要用<code>vuex</code>的读取数据方式操作就可以了。<br><strong>使用方法：</strong><br>安装<code>vuex-along</code>：<code>npm install vuex-along --save</code><br>配置<code>vuex-along</code>：在<code>store/index.js</code>中最后添加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VueXAlong</span> <span class="keyword">from</span> <span class="string">&#x27;vuex-along&#x27;</span> <span class="comment">//导入插件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="comment">//modules: &#123;</span></span><br><span class="line">        <span class="comment">//controler  //模块化vuex</span></span><br><span class="line">    <span class="comment">//&#125;,</span></span><br><span class="line">    <span class="attr">plugins</span>: [<span class="title class_">VueXAlong</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;store&#x27;</span>,     <span class="comment">//存放在localStroage或者sessionStroage 中的名字</span></span><br><span class="line">        <span class="attr">local</span>: <span class="literal">false</span>,      <span class="comment">//是否存放在local中  false 不存放 如果存放按照下面session的配置</span></span><br><span class="line">        <span class="attr">session</span>: &#123; <span class="attr">list</span>: [], <span class="attr">isFilter</span>: <span class="literal">true</span> &#125; <span class="comment">//如果值不为false 那么可以传递对象 其中 当isFilter设置为true时， list 数组中的值就会被过滤调,这些值不会存放在seesion或者local中</span></span><br><span class="line">    &#125;)]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="使用-localStorage-或者-sessionStorage"><a href="#使用-localStorage-或者-sessionStorage" class="headerlink" title="使用 localStorage 或者 sessionStorage"></a>使用 localStorage 或者 sessionStorage</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//在页面加载时读取sessionStorage里的状态信息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;store&quot;</span>)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">replaceState</span>(</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">          &#123;&#125;,</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>,</span><br><span class="line">          <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;store&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在页面刷新时将vuex里的信息保存到sessionStorage里</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;store&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScrip中的 call、apply和bind</title>
    <url>/2022/08/17/JavaScript%E5%AE%9E%E7%8E%B0call%E3%80%81apply%E5%92%8Cbind/</url>
    <content><![CDATA[<h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p>call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的<code>this</code>指向。</p>
<p>在什么情况下需要改变<code>this</code>指向呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name= <span class="string">&quot;lucy&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;martin&quot;</span>,</span><br><span class="line">    <span class="attr">say</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">say</span>(); <span class="comment">//martin，this指向obj对象</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">say</span>,<span class="number">0</span>); <span class="comment">//luck,this指向window对象</span></span><br></pre></td></tr></table></figure>
<p>从上面可以看到，正常情况<code>say</code>方法输出<code>martin</code></p>
<p>但是我们把<code>say</code>放在<code>setTimeout</code>方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候<code>this</code>指向<code>window</code>，所以输出<code>luck</code></p>
<p>我们实际需要的是<code>this</code>指向<code>obj</code>对象，这时候就需要该改变<code>this</code>指向了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">say</span>.<span class="title function_">bind</span>(obj),<span class="number">0</span>); <span class="comment">//martin，this指向obj对象</span></span><br></pre></td></tr></table></figure>

<h3 id="2-区别"><a href="#2-区别" class="headerlink" title="2.区别"></a>2.区别</h3><h4 id="apply、call、bind的用法："><a href="#apply、call、bind的用法：" class="headerlink" title="apply、call、bind的用法："></a>apply、call、bind的用法：</h4><p><strong>apply</strong><br>apply接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以数组的形式传入</p>
<p>改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">myname</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">apply</span>(obj,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// this会变成传入的obj，传入的参数必须是一个数组；</span></span><br><span class="line"><span class="title function_">fn</span>([<span class="number">1</span>,<span class="number">2</span>]) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>
<p>当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window(浏览器中)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// this指向window</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">undefined</span>,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>

<p><strong>call</strong><br>call方法的第一个参数也是<code>this</code>指向，后面传入的是一个参数列表<br>跟<code>apply</code>一样，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">myname</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">call</span>(obj,<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// this会变成传入的obj，传入的参数必须是一个数组；</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>
<p>同样地，当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window(浏览器中)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// this指向window</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">undefined</span>,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>

<p><strong>bind</strong><br>bind方法和call很相似，第一个参数也是<code>this</code>的指向，后面传入的也是一个参数列表（但是这个参数列表可以分多次传入）<br>改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">myname</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindFn = fn.<span class="title function_">bind</span>(obj); <span class="comment">// this 也会变成传入的obj ，bind不是立即执行需要执行一次</span></span><br><span class="line"><span class="title function_">bindFn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向obj</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>call、apply、bind三者的区别在于：</p>
<ul>
<li>三者都可以改变函数的<code>this</code>对象指向</li>
<li>三者第一个参数都是<code>this</code>要指向的对象，如果没有这个参数或者参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code></li>
<li>三者都可以传参，但是<code>apply</code>是数组，而<code>call</code>是参数列表，且<code>apply</code>和<code>call</code>是一次性传入参数，而<code>bind</code>可以分为多次传入</li>
<li><code>bind</code>是返回绑定<code>this</code>之后的函数，<code>apply</code>、<code>call</code>则是立即执行</li>
</ul>
<h3 id="3-手写实现"><a href="#3-手写实现" class="headerlink" title="3.手写实现"></a>3.手写实现</h3><h4 id="3-1-call"><a href="#3-1-call" class="headerlink" title="3.1 call"></a>3.1 call</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_call</span> = <span class="keyword">function</span>(<span class="params">ctx, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断上下文类型 如果是undefined或者 null 指向window；否则使用 Object() 将上下文包装成对象</span></span><br><span class="line">  <span class="keyword">const</span> o = (!ctx) ? <span class="variable language_">window</span> : <span class="title class_">Object</span>(ctx);</span><br><span class="line">  <span class="comment">// 如何把函数foo的this 指向 ctx这个上下文呢</span></span><br><span class="line">  <span class="comment">// 把函数foo赋值给对象o的一个属性  用这个对象o去调用foo  this就指向了这个对象o</span></span><br><span class="line">  <span class="comment">// 下面的this就是调用_call的函数foo  我们把this给对象o的属性fn 就是把函数foo赋值给了o.fn</span></span><br><span class="line">  <span class="comment">//给context新增一个独一无二的属性以免覆盖原有属性</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="title class_">Symbol</span>();</span><br><span class="line">  o[key] = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 立即执行一次</span></span><br><span class="line">  <span class="keyword">const</span> result = o[key](...args);</span><br><span class="line">  <span class="comment">// 删除这个属性</span></span><br><span class="line">  <span class="keyword">delete</span> o[key];</span><br><span class="line">  <span class="comment">// 把函数的返回值赋值给_call的返回值</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-apply"><a href="#3-2-apply" class="headerlink" title="3.2 apply"></a>3.2 apply</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只需要把第二个参数改成数组形式就可以了。</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_apply</span> = <span class="keyword">function</span>(<span class="params">ctx, array = []</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> o = (!ctx) ? <span class="variable language_">window</span> : <span class="title class_">Object</span>(ctx);</span><br><span class="line">  <span class="comment">//给context新增一个独一无二的属性以免覆盖原有属性</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="title class_">Symbol</span>();</span><br><span class="line">  o[key] = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> result = o[key](...array);</span><br><span class="line">  <span class="keyword">delete</span> o[key];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-bind"><a href="#3-3-bind" class="headerlink" title="3.3 bind"></a>3.3 bind</h4><p>实现bind的步骤，我们可以分解成为三部分：</p>
<ul>
<li>修改<code>this</code>指向</li>
<li>动态传递参数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：只在bind中传递函数参数</span></span><br><span class="line">fn.<span class="title function_">bind</span>(obj,<span class="number">1</span>,<span class="number">2</span>)()</span><br><span class="line"><span class="comment">// 方式二：在bind中传递函数参数，也在返回函数中传递参数</span></span><br><span class="line">fn.<span class="title function_">bind</span>(obj,<span class="number">1</span>)(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>兼容<code>new</code>关键字</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_bind</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">          fn = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="keyword">new</span> <span class="title function_">fn</span>(...<span class="variable language_">arguments</span>) : context, args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS使用Promise实现每隔1s输出123……</title>
    <url>/2022/08/17/JS%E4%BD%BF%E7%94%A8Promise%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%941s%E8%BE%93%E5%87%BA123%E2%80%A6%E2%80%A6/</url>
    <content><![CDATA[<p>使用Promise 实现每隔1s输出1，2，3……</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeCout</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">timeCout</span>();</span><br><span class="line">    <span class="title function_">main</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">r</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>())</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目实战：登录权限问题</title>
    <url>/2022/08/16/Vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9A%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一个管理项目一般需要将：<b>1.登录功能</b> <b>2.权限验证功能</b> 分离</p>
<ul>
<li><p>登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个<code>token</code>，拿到<code>token</code>之后（我会将这个<code>token</code>存到<code>cookie</code>中，保证刷新页面后能记住用户登录状态），前端会根据<code>token</code>再去拉取一个 <code>user_info</code> 的接口来获取用户的详细信息（如用户权限，用户名等等信息）</p>
</li>
<li><p>权限验证：通过<code>token</code>获取用户对应的 <code>role</code>，动态根据用户的 <code>role</code> 算出其对应有权限的路由，通过 <code>router.addRoutes</code> 动态挂载这些路由</p>
</li>
</ul>
<p>上述所有的数据和操作都是通过<code>vuex</code>全局管理控制的。(补充说明：刷新页面后 <code>vuex</code>的内容也会丢失，所以需要重复上述的那些操作)接下来。</p>
<h3 id="登录-获取用户信息"><a href="#登录-获取用户信息" class="headerlink" title="登录 + 获取用户信息"></a>登录 + 获取用户信息</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220816113733.png"></p>
<h3 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h3><p>权限控制的整体思路：</p>
<ol>
<li>前端有一张路由表，表示每一个路由可访问的权限。</li>
<li>用户登录之后，通过<code>token</code>获取用户的<code>role</code>，动态根据用户的<code>role</code>算出其对应的权限路由，再通过<code>router.addRoutes</code>动态挂载路由</li>
</ol>
<p><strong>但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是绝对安全的，后端的权限验证是逃不掉的。</strong></p>
<p>主流方式：</p>
<ul>
<li>前端控制页面级权限（不同用户显示不同的侧边栏、限制其能进入的页面）；</li>
<li>后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是 <code>get</code> 还是 <code>post</code> 都会让前端在请求 <code>header</code>里面携带用户的 <code>token</code><span style="background:yellow;">【<code>request.js</code>文件中请求拦截器中添加】</span>，后端会根据该 <code>token</code> 来验证用户是否有权限执行该操作。（若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作）</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol>
<li>创建<code>vue</code>实例的时候将<code>vue-router</code>挂载，但这个时候<code>vue-router</code>挂载一些登录或者不用权限的公用的页面。</li>
<li>当用户登录后，获取用<code>role</code>，将<code>role</code>和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。</li>
<li>调用<code>router.addRoutes(store.getters.addRouters)</code>添加用户可访问的路由。</li>
<li>使用<code>vuex</code>管理路由表，根据<code>vuex</code>中可访问的路由渲染侧边栏组件。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;../views/login/&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dashboard</span> = resolve =&gt; <span class="built_in">require</span>([<span class="string">&#x27;../views/dashboard/index&#x27;</span>], resolve);</span><br><span class="line"><span class="comment">//使用了vue-routerd的[Lazy Loading Routes</span></span><br><span class="line">](<span class="attr">https</span>:<span class="comment">//router.vuejs.org/en/advanced/lazy-loading.html)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有权限通用路由表 </span></span><br><span class="line"><span class="comment">//如首页和登录页和一些不用权限的公用页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> constantRouterMap = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Login</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/dashboard&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;首页&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;dashboard&#x27;</span>, <span class="attr">component</span>: dashboard &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化vue的时候只挂载constantRouter</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: constantRouterMap</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步挂载的路由</span></span><br><span class="line"><span class="comment">//动态需要根据权限加载的路由表 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> asyncRouterMap = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/permission&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;权限测试&#x27;</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">role</span>: [<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;super_editor&#x27;</span>] &#125;, <span class="comment">//页面需要的权限</span></span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">    &#123; </span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Permission</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;权限测试页&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123; <span class="attr">role</span>: [<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;super_editor&#x27;</span>] &#125;  <span class="comment">//页面需要的权限</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/404&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们根据 <code>vue-router官方推荐</code> 的方法通过<code>meta</code>标签来标示改页面能访问的权限有哪些。如<code>meta: &#123; role: [&#39;admin&#39;,&#39;super_editor&#39;] &#125;</code>表示该页面只有 <strong>admin</strong> 和 <strong>超级编辑</strong> 才能有资格进入。</p>
<p><span style="background:yellow;">注意事项：这里有一个需要非常注意的地方就是 404 页面 <strong>一定要最后加载</strong> ，如果放在constantRouterMap一同声明了404，后面的所以页面都会被拦截到404</span></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//permission.js</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Message</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NProgress</span> <span class="keyword">from</span> <span class="string">&#x27;nprogress&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;nprogress/nprogress.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isRelogin &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">NProgress</span>.<span class="title function_">configure</span>(&#123; <span class="attr">showSpinner</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">&#x27;/login&#x27;</span>, <span class="string">&#x27;/auth-redirect&#x27;</span>, <span class="string">&#x27;/bind&#x27;</span>, <span class="string">&#x27;/register&#x27;</span>]</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">NProgress</span>.<span class="title function_">start</span>()</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getToken</span>()) &#123;</span><br><span class="line">    to.<span class="property">meta</span>.<span class="property">title</span> &amp;&amp; store.<span class="title function_">dispatch</span>(<span class="string">&#x27;settings/setTitle&#x27;</span>, to.<span class="property">meta</span>.<span class="property">title</span>)</span><br><span class="line">    <span class="comment">/* has token*/</span></span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">next</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;)</span><br><span class="line">      <span class="title class_">NProgress</span>.<span class="title function_">done</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (store.<span class="property">getters</span>.<span class="property">roles</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        isRelogin.<span class="property">show</span> = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 判断当前用户是否已拉取完user_info信息</span></span><br><span class="line">        store.<span class="title function_">dispatch</span>(<span class="string">&#x27;GetInfo&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          isRelogin.<span class="property">show</span> = <span class="literal">false</span></span><br><span class="line">          store.<span class="title function_">dispatch</span>(<span class="string">&#x27;GenerateRoutes&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">accessRoutes</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 根据roles权限生成可访问的路由表</span></span><br><span class="line">            router.<span class="title function_">addRoutes</span>(accessRoutes) <span class="comment">// 动态添加可访问路由表</span></span><br><span class="line">            <span class="title function_">next</span>(&#123; ...to, <span class="attr">replace</span>: <span class="literal">true</span> &#125;) <span class="comment">// hack方法 确保addRoutes已完成</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            store.<span class="title function_">dispatch</span>(<span class="string">&#x27;LogOut&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="title class_">Message</span>.<span class="title function_">error</span>(err)</span><br><span class="line">              <span class="title function_">next</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有token</span></span><br><span class="line">    <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 在免登录白名单，直接进入</span></span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">`/login?redirect=<span class="subst">$&#123;to.fullPath&#125;</span>`</span>) <span class="comment">// 否则全部重定向到登录页</span></span><br><span class="line">      <span class="title class_">NProgress</span>.<span class="title function_">done</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">NProgress</span>.<span class="title function_">done</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="小提一下：按钮权限的控制"><a href="#小提一下：按钮权限的控制" class="headerlink" title="小提一下：按钮权限的控制"></a>小提一下：按钮权限的控制</h4><p>首先按钮的权限可以使用<code>v-if</code>进行判断，但是如果页面过多，每个页面都需要获取用户权限<code>role</code>和路由表里的<code>meta.btnPermissions</code>，然后再做判断。</p>
<p>①配置路由表中的<code>btnPermissions</code> (设置元信息)<br>②自定义权限指令<br>③在标签中使用<code>v-has</code></p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>js实现定时器的开启与暂停功能</title>
    <url>/2022/08/15/js%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%BC%80%E5%90%AF%E4%B8%8E%E6%9A%82%E5%81%9C%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h4 id="定时器类"><a href="#定时器类" class="headerlink" title="定时器类"></a>定时器类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myTime</span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; cb 回调函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; sec 执行间隔时间ms</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">cb,sec</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sec</span> = sec;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行</span></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="variable language_">this</span>.<span class="property">cb</span> , <span class="variable language_">this</span>.<span class="property">sec</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//暂停</span></span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用场景：页面倒计时"><a href="#使用场景：页面倒计时" class="headerlink" title="使用场景：页面倒计时"></a>使用场景：页面倒计时</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="keyword">new</span> <span class="title function_">myTime</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(count === <span class="number">0</span>)&#123;</span><br><span class="line">    timer.<span class="title function_">stop</span>();</span><br><span class="line">    timer = nul;;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">timer.<span class="title function_">run</span>()</span><br></pre></td></tr></table></figure>
<p>可以实现页面从10倒计时到1</p>
]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现红绿灯</title>
    <url>/2022/08/15/JS%E5%AE%9E%E7%8E%B0%E7%BA%A2%E7%BB%BF%E7%81%AF/</url>
    <content><![CDATA[<blockquote>
<p>输了就是输了，这说明什么呀，小朋友，还得练</p>
</blockquote>
<h3 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h3><p>实现红绿灯，黄灯亮1s，红灯亮2s，绿灯亮3s，一直循环改变颜色。</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>三种方法：①setTimeout ②Promise + async/await</p>
<h4 id="setTimeout方式"><a href="#setTimeout方式" class="headerlink" title="setTimeout方式"></a>setTimeout方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params">color</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;改变颜色为：&#x27;</span>,color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">changeColor</span>(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">changeColor</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">changeColor</span>(<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">      <span class="built_in">setTimeout</span>(main, <span class="number">3000</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>); </span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

<h4 id="Promise-async-await方式"><a href="#Promise-async-await方式" class="headerlink" title="Promise + async/await方式"></a>Promise + async/await方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params">color</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变颜色为&quot;</span>+color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params">color,delay</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">changeColor</span>(color);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">timer</span>(<span class="string">&#x27;yellow&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">timer</span>(<span class="string">&#x27;red&#x27;</span>,<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">timer</span>(<span class="string">&#x27;green&#x27;</span>,<span class="number">3000</span>);</span><br><span class="line">    <span class="title function_">main</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3了解过吗？</title>
    <url>/2022/08/12/Vue3%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="一、Vue3的介绍"><a href="#一、Vue3的介绍" class="headerlink" title="一、Vue3的介绍"></a>一、Vue3的介绍</h3><p>关于<code>vue3</code>的重构背景，尤大是这样说的：</p>
<blockquote>
<p>Vue新版本的理念成型于2018年末，当时Vue2的代码库已经有两岁半了。比起通用软件的生命周期这好像也没有那么久，但在这段时期，前端世界已经今非昔比了。<br>我们在更新（和重写）Vue的主要版本时，主要考虑两点因素：首先是<b style="background:yellow;">新的JavaScript语言特性在主流浏览器中的受支持水平</b>；其次是<b style="background:yellow;">当前代码库中随时间推移而逐渐暴露出来的一些设计和架构问题</b>。</p>
</blockquote>
<p>简要来说就是：</p>
<ul>
<li>利用新的语言特性（ES6）</li>
<li>解决架构问题</li>
</ul>
<h4 id="1-1-哪些变化？"><a href="#1-1-哪些变化？" class="headerlink" title="1.1 哪些变化？"></a>1.1 哪些变化？</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220812221706.png"></p>
<p>Vue3的新特性可以概括为：</p>
<ul>
<li>速度更快</li>
<li>体积更小</li>
<li>更易维护</li>
<li>更接近原生</li>
<li>更易使用</li>
</ul>
<h5 id="速度更快"><a href="#速度更快" class="headerlink" title="速度更快"></a>速度更快</h5><p>Vue3 相比 Vue2：</p>
<ul>
<li>重写了虚拟 <code>DOM </code> 实现</li>
<li>编译模板的优化</li>
<li>更高效的组件初始化</li>
<li>update性能提高 1.3～2倍</li>
<li>SSR速度提高了 2～3倍</li>
</ul>
<h5 id="体积更小"><a href="#体积更小" class="headerlink" title="体积更小"></a>体积更小</h5><p>通过<code>webpack</code>的<code>tree-shaking</code>功能，可以将无用模块“剪辑”，仅打包需要的能够<code>tree-shaking</code>，这样做有两大好处：</p>
<ul>
<li>对于开发人员，能够对<code>vue</code>实现更多其他功能，而不必担忧整体体积过大</li>
<li>对于使用者，打包出来的包体积变小了</li>
</ul>
<p>vue可以开发出更多其他的功能，而不必担忧<code>vue</code>打包出来的整体体积过多</p>
<h5 id="更易维护"><a href="#更易维护" class="headerlink" title="更易维护"></a>更易维护</h5><p><strong>Composition API</strong></p>
<ul>
<li>可与现有的<code>Options API</code>一起使用</li>
<li>灵活的逻辑组合与复合</li>
<li><code>Vue3</code>模块可以和其他框架搭配使用</li>
</ul>
<p><strong>更好的Typescipt支持</strong><br><code>Vue3</code>是基于<code>typescript</code>编写的，可以享受到自动的类型定义提示</p>
<p><strong>编译器重写</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220815203743.png"></p>
<h5 id="更接近原生"><a href="#更接近原生" class="headerlink" title="更接近原生"></a>更接近原生</h5><p>可以自定义渲染API<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220815204715.png"></p>
<h5 id="更易使用"><a href="#更易使用" class="headerlink" title="更易使用"></a>更易使用</h5><p>响应式<code>API</code>暴露出来<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220815204829.png"></p>
<p>轻松识别组件重新渲染原因<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220815204934.png"></p>
<h3 id="二、Vue3新增特性"><a href="#二、Vue3新增特性" class="headerlink" title="二、Vue3新增特性"></a>二、Vue3新增特性</h3><p>Vue3中需要关注的一些新功能包括：</p>
<ul>
<li>framents</li>
<li>Teleport</li>
<li>composition API</li>
<li>createRenderer</li>
</ul>
<h5 id="framents"><a href="#framents" class="headerlink" title="framents"></a>framents</h5><p>在<code>vue3.x</code>中，组件现在支持有多个根组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h5><p>Teleport是一种能够将我们的模板移动到DOM中的<code>Vue app</code>之外的其他位置的技术，有点像<code>position:absolute</code>完全跳出页面的限制。</p>
<p>在<code>vue2</code>中，像<code>modals</code>、<code>toast</code>等这样的元素，如果我们嵌套在<code>vue</code>的某个组件内部，那么处理嵌套组件的定位、<code>z-index</code>和样式就会变得很困难</p>
<p>通过<code>Teleport</code>，我们可以在组件的逻辑位置写模板代码，然后在<code>Vue</code>应用范围之外渲染它</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showToast&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>打开 toast<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- to 属性就是目标位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#teleport-target&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;visible&quot;</span> <span class="attr">class</span>=<span class="string">&quot;toast-wrap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toast-msg&quot;</span>&gt;</span>我是一个 Toast 文案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="createRenderer"><a href="#createRenderer" class="headerlink" title="createRenderer"></a>createRenderer</h5><p>通过<code>createRenderer</code>，我们能够构建自定义渲染器，我们能够将<code>vue</code>的开发模型扩展到其他平台<br>我们可以讲其生成在<code>canvas</code>画布上<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220815211353.png"></p>
<p>关于<code>createRenderer</code>，基本使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRenderer &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; render, createApp &#125; = <span class="title function_">createRenderer</span>(&#123;</span><br><span class="line">  patchProp,</span><br><span class="line">  insert,</span><br><span class="line">  remove,</span><br><span class="line">  createElement,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; render, createApp &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-core&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="composition-API"><a href="#composition-API" class="headerlink" title="composition API"></a>composition API</h5><p>composition API，也就是组合式<code>API</code>，通过这种形式，我们能够更加容易维护我们的代码，将相同功能的变量进行一个集中式的管理<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220815230531.png"></p>
<p>关于<code>composition API</code>的使用，这里以下图展开：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220815230704.png"></p>
<p>简单使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">            count.<span class="property">value</span>++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;component mounted!&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            increment</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、非兼容变更"><a href="#三、非兼容变更" class="headerlink" title="三、非兼容变更"></a>三、非兼容变更</h3><p><strong>Global API</strong></p>
<ul>
<li>全局<code>vue API</code>已更改为使用应用程序实例</li>
<li>全局和内部<code>API</code>已经被重构伟可<code>tree-shakable</code></li>
</ul>
<p><strong>模板指令</strong></p>
<ul>
<li>组件上<code>v-model</code>用法已更改</li>
<li><code>&lt;template v-for&gt;</code>和非<code>v-for</code>节点上<code>key</code>用法已更改</li>
<li>在同一元素上使用的<code>v-if</code>和<code>v-for</code>的优先级已更改</li>
<li><code>v-bind=&quot;object&quot;</code>现在排序敏感</li>
<li><code>v-for</code>中的<code>ref</code>不再注册<code>ref</code>数组</li>
</ul>
<p><strong>组件</strong></p>
<ul>
<li>只能使用普通函数创建功能组件</li>
<li><code>functional</code>属性在单文件组件（SFC）</li>
<li>异步组件现在需要<code>defineAsyncComponent</code>方法来创建</li>
</ul>
<p><strong>渲染函数</strong></p>
<ul>
<li>渲染函数<code>API</code>改变</li>
<li><code>$scopeSlots</code>property 已删除，所有插槽都经过<code>$slot</code>作为函数暴露</li>
<li>自定义指令API已更改为与组件生命周期一致</li>
<li>一些转换<code>class</code>被重命名了：<code>v-enter ➡️ v-enter-from</code>、<code>v-leave ➡️ v-leave-from</code></li>
<li>组件<code>watch</code>选项和实例方法<code>$watch</code>不再支持点分隔字符串路径，该用计算函数作为参数</li>
<li>在<code>Vue 2.x</code>中，应用根容器的<code>outerHTML</code>将替换为根组件模板（如果根组件没有模板/渲染选项，则最终编译为模板）。<code>Vue 3.x </code>现在使用应用程序容器的<code>innerHTML</code>。</li>
</ul>
<p><strong>其他小改变</strong></p>
<ul>
<li>生命周期钩子函数的重命名：<code>beforeDestory ➡️ beforeUnmount</code>、<code>destoryed ➡️ unmounted</code></li>
<li>自定义指令API已更改为与组件生命周期一致</li>
<li><code>data</code>应始终声明为函数</li>
<li>来自<code>mixin</code>的<code>data</code>选项现在可简单地合并</li>
<li><code>attribute</code>强制策略已更改</li>
<li><code>&lt;template&gt;</code> 没有特殊指令的标记 (<code>v-if/else-if/else</code>、<code>v-for</code> 或 <code>v-slot</code>) 现在被视为普通元素，并将生成原生的 <code>&lt;template&gt;</code> 元素，而不是渲染其内部内容。</li>
</ul>
<p><strong>移除API</strong></p>
<ul>
<li><code>keyCode</code> 支持作为 <code>v-on</code> 的修饰符</li>
<li><code>$on</code>，<code>$off</code> 和 <code>$once</code> 实例方法</li>
<li>过滤<code>filter</code></li>
<li>内联模板 <code>attribute</code></li>
<li><code>$destroy</code> 实例方法。用户不应再手动管理单个 <code>Vue</code> 组件的生命周期。</li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>手写promise.all和promise.race</title>
    <url>/2022/08/11/%E6%89%8B%E5%86%99promise-all%E5%92%8Cpromise-race/</url>
    <content><![CDATA[<h2 id="1-promise-all"><a href="#1-promise-all" class="headerlink" title="1.promise.all"></a>1.promise.all</h2><p>来MDN的介绍：</p>
<blockquote>
<p>Promise.all() 方法接收一个 promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型）的输入，并且只返回一个Promise实例， 那个输入的所有 promise 的 resolve 回调的结果是一个数组。这个Promise的 resolve 回调执行是在所有输入的 promise 的 resolve 回调都结束，或者输入的 iterable 里没有 promise 了的时候。它的 reject 回调执行是，只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且 reject 的是第一个抛出的错误信息。</p>
</blockquote>
<ol>
<li>Promise.all() 方法接收一个promise的iterable类型（注：Array，Map，Set都属于ES6的iterable类型）的输入。 ➡️  <span style="background:yellow;">说明所传参数都具有Iterable,也就是可遍历。</span></li>
<li>并且只返回一个Promise实例。➡️ <span style="background:yellow;"> 说明最终返回是一个Promise对象。</span></li>
<li>那个输入的所有promise的resolve回调的结果是一个数组。➡️ <span style="background:yellow;"> 说明最终返回的结果是个数组，且数组内数据要与传参数据对应。</span></li>
<li>这个Promise的resolve回调执行是在所有输入的promise的resolve回调都结束，或者输入的iterable里没有promise了的时候。➡️ <span style="background:yellow;"> 说明最终返回时，要包含所有的结果的返回。</span></li>
<li>它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。➡️ <span style="background:yellow;">  说明只要一个报错，立马调用reject返回错误信息。</span> </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promiseAll</span>(<span class="params">iterator</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promises = <span class="title class_">Array</span>.<span class="title function_">from</span>(iterator);</span><br><span class="line">  <span class="keyword">const</span> len = promises.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">//每次执行成功+1，当等于长度时，说明所有数据都返回，可以resolve()</span></span><br><span class="line">  <span class="keyword">let</span> data = [];<span class="comment">//用来存放返回的数据数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    promises[i].<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      data[i]=res;</span><br><span class="line">      <span class="keyword">if</span>(++index === len)&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-promise-race"><a href="#2-promise-race" class="headerlink" title="2.promise.race"></a>2.promise.race</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promiseRace</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改返回对象的状态为【成功】</span></span><br><span class="line">        <span class="title function_">resolve</span>(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改返回对象的状态为【失败】</span></span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Promise-prototype-finally"><a href="#3-Promise-prototype-finally" class="headerlink" title="3.Promise.prototype.finally"></a>3.Promise.prototype.finally</h2><p><code>finally()</code>方法用于指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作(无论<code>promise</code>被<code>reslove</code>或者<code>reject</code>，都会执行到<code>finally</code>里面去)<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220901115757.png"><br><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 <code>Promise</code>状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 <code>Promise</code> 的执行结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> error &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中的$nextTick</title>
    <url>/2022/08/11/Vue%E4%B8%AD%E7%9A%84$nextTick/</url>
    <content><![CDATA[<h3 id="1-nextTick-是什么？"><a href="#1-nextTick-是什么？" class="headerlink" title="1.nextTick 是什么？"></a>1.nextTick 是什么？</h3><p>nextTick本质上就是执行延迟回调的钩子函数，接收一个回调函数作为参数，在下次DOM更新循环结束之后，执行延迟回调。<br>在修改数据之后立即调用这个方法，获取更新后的DOM。</p>
<h3 id="2-nextTick-的作用是什么？"><a href="#2-nextTick-的作用是什么？" class="headerlink" title="2.nextTick 的作用是什么？"></a>2.nextTick 的作用是什么？</h3><p>说到<code>nextTick</code>就要谈到<code>Vue</code>的异步更新，<code>Vue</code>在更新DOM时是异步更新的。<br>【 见以下第3部分-Vue的异步更新队列 】</p>
<blockquote>
<p>例如当你设置<code>vm.someDate = &#39;new Vue&#39; </code>, 该组件不会立即重新渲染。当刷新队列时，组件在下一个事件’tick’中更新。<br>但如果你想立即基于vm.someDate更新后的DOM状态来做点什么，这可能就会有些棘手。此时我们就可以先用nextTick(callbacks)在真正DOM渲染之前在数据变化之后立即对其操作。</p>
</blockquote>
<p><b style="background:red;">但实际情况是nextTick是DOM更新之后延迟回调</b></p>
<p>nextTick 除了 <strong>①让我们可以在DOM更新之后延迟回调</strong> ，还有一个作用是 <strong>② Vue内部使用nextTick，把渲染DOM这个操作放入callbacks</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220811145832.png"></p>
<h4 id="nextTick的源码浅析"><a href="#nextTick的源码浅析" class="headerlink" title="nextTick的源码浅析"></a>nextTick的源码浅析</h4><p>Vue.nextTick用于延迟执行一段代码，它接受2个参数（回调函数和执行回调函数的上下文环境），如果没有提供回调函数，那么将返回promise对象。<br>源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defer a task to execute it asynchronously.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> nextTick = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> callbacks = [] <span class="comment">// 用来存储所有需要执行的回调函数</span></span><br><span class="line">  <span class="keyword">let</span> pending = <span class="literal">false</span> <span class="comment">// 用来标志是否正在执行回调函数</span></span><br><span class="line">  <span class="keyword">let</span> timerFunc <span class="comment">// 用来触发执行回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">nextTickHandler</span> () &#123; <span class="comment">// 这个函数用来执行callbacks里存储的所有回调函数</span></span><br><span class="line">    pending = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">    callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      copies[i]()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the nextTick behavior leverages the microtask queue, which can be accessed</span></span><br><span class="line">  <span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line">  <span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line">  <span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line">  <span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line">  <span class="comment">// Promise is available, we will use it:</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  接下来是将触发方式赋值给timerFunc:</span></span><br><span class="line"><span class="comment">  先判断是否原生支持promise，如果支持，则利用promise来触发执行回调函数；</span></span><br><span class="line"><span class="comment">  否则，如果支持MutationObserver，则实例化一个观察者对象，观察文本节点发生变化时，触发执行所有回调函数。</span></span><br><span class="line"><span class="comment">  如果都不支持，则利用setTimeout设置延时为0。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">logError</span> = err =&gt; &#123; <span class="variable language_">console</span>.<span class="title function_">error</span>(err) &#125;</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      p.<span class="title function_">then</span>(nextTickHandler).<span class="title function_">catch</span>(logError)</span><br><span class="line">      <span class="comment">// in problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">      <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">      <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">      <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">      <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">      <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">    <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">  )) &#123;</span><br><span class="line">    <span class="comment">// use MutationObserver where native Promise is not available,</span></span><br><span class="line">    <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(nextTickHandler)</span><br><span class="line">    <span class="keyword">var</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">    observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">      <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">      textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// fallback to setTimeout</span></span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(nextTickHandler, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 最后是queueNextTick函数。</span></span><br><span class="line"><span class="comment">// 因为nextTick是一个即时函数，所以queueNextTick函数是返回的函数，接受用户传入的参数，用来往callbacks里存入回调函数。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">queueNextTick</span> (cb?: <span class="title class_">Function</span>, ctx?: <span class="title class_">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> _resolve</span><br><span class="line">    callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">        <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">      pending = <span class="literal">true</span></span><br><span class="line">      <span class="title function_">timerFunc</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        _resolve = resolve</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220811235017.png"><br>nextTick的源码流程：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220811151252.png"></p>
<h3 id="3-Vue的异步更新队列"><a href="#3-Vue的异步更新队列" class="headerlink" title="3.Vue的异步更新队列"></a>3.Vue的异步更新队列</h3><p>vue在更新DOM时是异步执行的。<b style="background:yellow;"> 只要侦测到数据变化，vue将开启一个队列，并缓冲在同一个事件循环中所发生的所有数据变更。如果一个watcher被多次触发，只会被推入队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。<br>然后，在下一个的事件循环‘tick’，vue刷新队列并执行实际工作（已去重）。vue在内部对异步队列尝试使用原生的<code>Promise.then</code>、<code>MutationObserver</code>和<code>setImmediate</code>，如果执行环境不支持，则会采用<code>setTimeout(fn,0)</code>代替。</b></p>
<h3 id="4-nextTick的适用场景"><a href="#4-nextTick的适用场景" class="headerlink" title="4.nextTick的适用场景"></a>4.nextTick的适用场景</h3><p>①需要数据动态地为页面某些DOM元素添加事件，这就要求dom渲染完毕时去设置，但<code>created</code>与<code>mounted</code>函数执行时一般DOM并没有渲染完毕，因此需要使用<code>nextTick</code>函数<br>②使用第三方插件时，希望在vue生成的某些dom动态变化更新时应用该插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_initScroll</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③数据改变之后立即获取焦点操作</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【13】事件代理及其应用场景</title>
    <url>/2022/08/09/13-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h3 id="1-什么是“事件代理”？"><a href="#1-什么是“事件代理”？" class="headerlink" title="1.什么是“事件代理”？"></a>1.什么是“事件代理”？</h3><p>事件代理（Event Delegation）也称之为事件委托。是JS中常用的绑定事件的技巧。<br>事件代理是把原来需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务。通俗来讲就是把一个元素的响应的事件（<code>click</code>、<code>keydown</code>等）的函数委托到其父元素上。</p>
<p>事件代理的原理是 <b style="background:yellow;">DOM元素的事件冒泡</b></p>
<p>一个事件触发后，会在子元素和父元素之间传播。这种传播分为三个阶段：</p>
<ul>
<li>捕获阶段：从window对象传导到目标节点（从上层传到底层）称为“捕获阶段”，在这一阶段不会响应任何事件。</li>
<li>目标阶段：在目标节点上触发，称为“目标阶段”。</li>
<li>冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”。事件代理即是利用事件冒泡的机制把里层需要相应的事件绑定到外层。</li>
</ul>
<p><b style="background:yellow;">事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而事件委托就是在冒泡阶段完成</b></p>
<h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h3><p>如果有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item n<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果给每一个列表项一一都绑定一个函数，对于内存消耗是非常大的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素</span></span><br><span class="line"><span class="keyword">const</span> lists = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="comment">// 循环遍历绑定事件</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;lists.<span class="property">length</span>;i++)&#123;</span><br><span class="line">  lists[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e,target.<span class="property">innerHTML</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候可以采用事件委托，把点击事件绑定在父元素<code>ul</code>上，然后执行时间的时候再去匹配目标元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给父层元素绑定事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="comment">//兼容性处理</span></span><br><span class="line">  <span class="keyword">var</span> event = e || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">  <span class="keyword">var</span> target = event.<span class="property">target</span> || event.<span class="property">srcElement</span>;</span><br><span class="line">  <span class="comment">// 判断是否匹配目标元素</span></span><br><span class="line">  <span class="keyword">if</span>(target.<span class="property">nodeName</span>.<span class="property">toLocaleLowerCase</span> === <span class="string">&#x27;li&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;the content is:&#x27;</span>,target.<span class="property">innerHTML</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>还有一种场景是 上述列表项并不多，我们给每个列表项都绑定了事件。但是如果用户能够随时动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增元素绑定事件，给即将删去的元素解绑事件。<br>如果采用事件委托就没有这种麻烦。因为事件是绑定在父层元素的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的</p>
<p><strong>示例：</strong></p>
<p>下面html结构中，点击input可以动态添加元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用事件委拖</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> oBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> oUl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ul1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> num = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件委托，添加的子元素也有事件</span></span><br><span class="line">oUl.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e = e || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">  <span class="keyword">const</span> target = e.<span class="property">target</span> || e.<span class="property">srcElement</span>;</span><br><span class="line">  <span class="keyword">if</span>(target.<span class="property">nodeName</span>.<span class="property">toLocaleLowerCase</span> === <span class="string">&#x27;li&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;the content is:&#x27;</span>,target.<span class="property">innerHTML</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新节点</span></span><br><span class="line">oBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  num++;</span><br><span class="line">  <span class="keyword">const</span> oLi = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">  oLi.<span class="property">innerHTML</span> = <span class="string">`item <span class="subst">$&#123;num&#125;</span>`</span>;</span><br><span class="line">  oUl.<span class="title function_">appendChild</span>(oLi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，利用事件委托在动态绑定事件的情况下是可以减少很多重复工作的。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>适合事件委托的事件有：<code>click</code>、<code>mousedown</code>、<code>keydown</code>、<code>keyup</code>、<code>keypress</code><br>事件委托有两大优点：</p>
<ul>
<li>减少整个页面所需要的内存，提升整体性能</li>
<li>动态绑定，减少重复工作</li>
</ul>
<p>事件委托也存在局限性：</p>
<ul>
<li><code>focus</code>、<code>blur</code>这些事件没有事件冒泡机制，所以无法委托绑定事件</li>
<li><code>mousemove</code>、<code>mouseout</code>这样的事件，虽然有事件冒泡，但是只能通过位置去计算定位，对性能消耗高，也不适合事件委托</li>
<li>如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件</li>
</ul>
<p>事件委托中有两个对象<code>target</code>和<code>currentTarget</code>，两者的含义不同：</p>
<ul>
<li><code>target</code>：事件触发的真实元素（点击）</li>
<li><code>currentTarget</code>：事件绑定元素（绑定）</li>
<li>事件处理函数中的<code>this</code>指向为<code>currentTarget</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220811105526.png"></p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中computed和watch的区别</title>
    <url>/2022/08/09/Vue%E4%B8%ADcomputed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>computed和watch都能实现对数据的监听，但是二者还是存在区别：</p>
<ul>
<li>功能上：<code>computed</code>是计算属性，<code>watch</code>用来监听一个值的变化</li>
<li><code>computed</code>有缓存，<code>data</code>中的数据不发生变化，不会重新计算；而<code>watch</code>每次监听的值发生变化都会执行回调</li>
<li><code>computed</code>默认首次加载就开始监听，<code>watch</code>默认第一次加载不进行监听（设置属性<code>immediate:true</code>会开启默认第一次加载就开始监听）</li>
<li><code>computed</code>属性值是一个函数，那么默认会走<code>get</code>方法，必须要有<code>return</code>返回值，<code>watch</code>不必有<code>return</code>返回值</li>
<li><code>watch</code>支持异步</li>
<li><strong>选择computed还是watch？</strong> 官网说：<span style="background:yellow;">当需要数据变化时执行异步或者开销较大的操作时，watch方式是最有用的。所以watch支持异步</span></li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>watch和computed都是以Vue的依赖追踪机制为基础的，当某一个依赖型数据发生变化的时候，所有依赖这个数据的相关数据会自动发生变化，即自动调用相关的函数，来实现数据的变动。</p>
<blockquote>
<p>（依赖型数据：简单理解即放在 data 等对象下的实例数据）</p>
</blockquote>
<p><strong>当依赖的值变化时，在watch中，是可以做一些复杂的操作的，而computed中的依赖，仅仅是一个值依赖于另一个值，是值上的依赖。</strong></p>
<h3 id="computed是如何实现缓存的？"><a href="#computed是如何实现缓存的？" class="headerlink" title="computed是如何实现缓存的？"></a><code>computed</code>是如何实现缓存的？</h3><p>围绕一个例子，讲解<code>computed</code>初始化及更新时的流程，来看看计算属性是怎么实现缓存的以及依赖是怎么被收集的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>&#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vue2.6.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">count</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">change</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">2</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> + <span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-初始化computed"><a href="#1-初始化computed" class="headerlink" title="1.初始化computed"></a>1.初始化<code>computed</code></h4><p>vue初始化时先执行<code>init</code>方法，里面的<code>initState</code>会进行计算属性的初始化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (opts.<span class="property">computed</span>) &#123;<span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>initComputed</code>的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> watchers = vm.<span class="property">_computedWatchers</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>); </span><br><span class="line"><span class="comment">// 依次为每个 computed 属性定义一个计算watcher</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">  <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">  watchers[key] = <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">      vm, <span class="comment">// 实例</span></span><br><span class="line">      getter, <span class="comment">// 用户传入的求值函数 sum</span></span><br><span class="line">      noop, <span class="comment">// 回调函数 可以先忽视</span></span><br><span class="line">      &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125; <span class="comment">// 声明 lazy 属性 标记 computed watcher</span></span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 用户在调用 this.sum 的时候，会发生的事情</span></span><br><span class="line">  <span class="title function_">defineComputed</span>(vm, key, userDef)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的响应式原理</title>
    <url>/2022/08/08/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>响应式原理是Vue的核心特性之一。数据驱动视图，当我们修改数据的时候，视图随之而更新。</p>
<p>Vue2.x是借助<code>Object.defineProperty()</code>实现的，而Vue3.x是借助<code>proxy</code>实现的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.jpg"></p>
<p>Data通过<code>Observer</code>转换成<code>getter/setter</code>的形式来追踪变化。<br>当外界通过<code>watcher</code>读取数据时，会触发<code>getter</code>，从而将<code>watcher</code>添加到依赖中。<br>当数据发生变化时会触发<code>setter</code>，从而向<code>Dep</code>中的依赖（<code>watcher</code>）发送通知。<code>watcher</code>接收到通知之后，会向外界发送通知，变化通知到外界可能会触发视图更新，也可能触发用户的某个回调函数。</p>
<blockquote>
<p>3.x与2.x的核心思想是一致的，只不过是数据劫持使用<code>proxy</code>而不是<code>Object.defineProperty</code>，<code>proxy</code>相比<code>Object.defineProperty</code>在处理数组和新增删除属性响应式的处理上更加方便。</p>
</blockquote>
]]></content>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一谈Vue中的data</title>
    <url>/2022/08/04/%E8%B0%88%E4%B8%80%E8%B0%88Vue%E4%B8%AD%E7%9A%84data/</url>
    <content><![CDATA[<p><strong>问题：为什么data属性是一个函数而不是一个对象？</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220805200207.png"></p>
<h3 id="1-实例和组件定义data的区别"><a href="#1-实例和组件定义data的区别" class="headerlink" title="1. 实例和组件定义data的区别"></a>1. 实例和组件定义data的区别</h3><p>vue实例中定义data属性既可以是一个对象也可以是一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 对象格式</span></span><br><span class="line">  <span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">foo</span>:<span class="string">&#x27;foo&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 函数格式</span></span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attr">foo</span>:<span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><b style="background-color:yellow;font-weight:800;">组件中定义data属性，只能是一个函数。</b></p>
<p>如果为组件data直接定义为一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;component1&#x27;</span>,&#123;</span><br><span class="line">  <span class="attr">template</span>:<span class="string">`&lt;div&gt;组件&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">foo</span>:<span class="string">&#x27;foo&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>会得到警告信息：<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220804234701.png"></p>
<h3 id="2-组件data定义函数与对象的区别"><a href="#2-组件data定义函数与对象的区别" class="headerlink" title="2.组件data定义函数与对象的区别"></a>2.组件data定义函数与对象的区别</h3><p>上面提到组件中的<code>data</code>必须是一个函数，这是为什么？<br>我们在定义好一个组件之后，<code>vue</code>最终都会通过<code>vue.extend()</code>构成组件实例</p>
<p>我们来模仿一下组件构造函数，定义data属性，采用<strong>对象</strong>的形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">data</span> = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建两个组件实例</span></span><br><span class="line"><span class="keyword">const</span> componentA = <span class="keyword">new</span> <span class="title class_">Component</span>()</span><br><span class="line"><span class="keyword">const</span> componentB = <span class="keyword">new</span> <span class="title class_">Component</span>()</span><br></pre></td></tr></table></figure>
<p>当我们修改<code>componentA</code>组件<code>data</code>属性的值，<code>componentB</code>中的值也发生了改变</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>); <span class="comment">// 0</span></span><br><span class="line">componentA.<span class="property">data</span>.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>产生这样的原因是两者共用了同一个内存地址，<code>componentA</code>修改的内容，同样对<code>componentB</code>产生了影响。</p>
<p>如果我们采用函数的形式，则不会出现这种情况（<strong>函数返回的对象内存地址并不相同</strong>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = <span class="variable language_">this</span>.<span class="title function_">data</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">data</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时修改<code>componentA</code>组件<code>data</code>属性的值，<code>componentB</code>中的值不受影响</p>
<p>vue组件可能会有很多个实例，采用函数返回一个全新的data形式，使得每个实例对象的数据不会受到其他实例对象数据的污染</p>
<h3 id="3-原理分析"><a href="#3-原理分析" class="headerlink" title="3.原理分析"></a>3.原理分析</h3><p>首先从<code>vue</code>初始化<code>data</code>代码中，可以看出<code>data</code>的定义可以是函数也可以是对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span>(<span class="params">vm:Component</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span>;</span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  ? <span class="title function_">getData</span>(data,vm)</span><br><span class="line">  : data||&#123;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然源码在初始化<code>data</code>时既能是<code>object</code>又能是<code>function</code>，为什么在将<code>data</code>声明为对象时会报警告呢？<br>组件在创建的时候，会进行选项的合并。在源码中自定义组件会进入<code>mergeoptions</code>进行选项合并</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span>(<span class="params">options?:<span class="built_in">Object</span></span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// merge options</span></span><br><span class="line">  <span class="keyword">if</span>(options &amp;&amp; options.<span class="property">_isComponent</span>)&#123;</span><br><span class="line">    <span class="comment">// optimize internal component instantiation（优化内部组件实例化）</span></span><br><span class="line">    <span class="comment">// since dynamic options merging is pretty slow, and none of the </span></span><br><span class="line">    <span class="comment">// internal component options needs special treatment</span></span><br><span class="line">    <span class="comment">//（因为动态选项合并很慢，而且没有内部组件选项需要的特殊处理。）</span></span><br><span class="line">    <span class="title function_">initInternalComponent</span>(vm,options)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">      <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义<code>data</code>会进行数据校验，这时<code>vm</code>实例为<code>undefined</code>，进入<code>if</code>判断，若<code>data</code>类型不是<code>function</code>，则会出现警告提示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">strats.<span class="property">data</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  parentVal: any,</span></span><br><span class="line"><span class="params">  childVal: any,</span></span><br><span class="line"><span class="params">  vm?: Component</span></span><br><span class="line"><span class="params"></span>): ?<span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (childVal &amp;&amp; <span class="keyword">typeof</span> childVal !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;The &quot;data&quot; option should be a function &#x27;</span> +</span><br><span class="line">            <span class="string">&quot;that returns a per-instance value in component &quot;</span> +</span><br><span class="line">            <span class="string">&quot;definitions.&quot;</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> parentVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mergeDataOrFn</span>(parentVal, childVal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mergeDataOrFn</span>(parentVal, childVal, vm);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4.结论"></a>4.结论</h3><ul>
<li>根实例对象<code>data</code>可以是对象也可以是函数（根实例时单例），不会产生数据污染的情况</li>
<li>组件实例对象的<code>data</code>必须为函数，目的是为了防止多个组件实例对象之间共用一个<code>data</code>，产生数据污染。采用函数的形式，<code>initData</code>时会将其作为工厂函数都会返回全新的<code>data</code>对象格式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220805204613.png"></p>
]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一谈BFC</title>
    <url>/2022/07/29/%E8%B0%88%E4%B8%80%E8%B0%88BFC/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220729154722.png"></p>
<h2 id="1-何为BFC？"><a href="#1-何为BFC？" class="headerlink" title="1.何为BFC？"></a>1.何为BFC？</h2><p>BFC（Block Formating Context）块级格式化上下文，是Web页面的一块独立的渲染区域，具有BFC特性的元素可以看成是一个独立的容器，容器内部的元素在布局上不会影响到外面的元素。</p>
<h2 id="2-触发BFC的条件"><a href="#2-触发BFC的条件" class="headerlink" title="2.触发BFC的条件"></a>2.触发BFC的条件</h2><ul>
<li>根元素（<code>&lt;html&gt;</code>）</li>
<li><code>float</code>不为<code>none</code>的元素</li>
<li><code>position</code>为<code>fixed</code>或<code>absolute</code>的元素</li>
<li><code>overflow</code>不为<code>visible</code>的元素</li>
<li><code>display</code>为<code>inline-block</code>、<code>table-cell</code>、<code>flex</code>等的元素</li>
</ul>
<h2 id="3-同一个BFC内的布局规则"><a href="#3-同一个BFC内的布局规则" class="headerlink" title="3.同一个BFC内的布局规则"></a>3.同一个BFC内的布局规则</h2><ol>
<li>box会在垂直方向上一个接一个放置</li>
<li>垂直方向上的距离由<code>margin</code>决定，属于同一个BFC的两个相邻的box的<code>margin</code>会发生重叠，以最大的<code>margin</code>为合并值</li>
<li>BFC内部每个元素的<code>margin-left</code>与父节点的左边接触（对于从左往右格式化而言，否则反之）</li>
<li>BFC区域不会与float元素的区域重叠</li>
<li>计算BFC元素高度时，其浮动子元素也参与计算</li>
</ol>
<h2 id="4-BFC的应用"><a href="#4-BFC的应用" class="headerlink" title="4.BFC的应用"></a>4.BFC的应用</h2><ol>
<li>分属于不同的BFC时，可以放置<code>margin</code>重叠</li>
<li>清除内部浮动（给父元素开启BFC）</li>
<li>适应多栏布局</li>
</ol>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的生命周期</title>
    <url>/2022/07/28/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h3 id="1-生命周期是什么？"><a href="#1-生命周期是什么？" class="headerlink" title="1.生命周期是什么？"></a>1.生命周期是什么？</h3><p>Vue的生命周期是指Vue实例从创建到销毁的过程，即指从创建、初始化数据、编译模板、挂载DOM、数据变化渲染更新到DOM上、销毁等一系列过程。</p>
<h3 id="2-生命周期有哪些？"><a href="#2-生命周期有哪些？" class="headerlink" title="2.生命周期有哪些？"></a>2.生命周期有哪些？</h3><p>Vue的生命周期总共可以分为8个阶段：创建前后，载入前后，更新前后，销毁前后，以及一些特殊场景的生命周期。</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>组件实例创建之初</td>
</tr>
<tr>
<td>created</td>
<td>组件实例已经完全创建</td>
</tr>
<tr>
<td>beforeMounted</td>
<td>组件挂载之前</td>
</tr>
<tr>
<td>mounted</td>
<td>组件挂载到实例上去之后</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据发生变化，更新之前</td>
</tr>
<tr>
<td>updated</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td>beforeDestory</td>
<td>组件实例销毁之前</td>
</tr>
<tr>
<td>destoryed</td>
<td>组件实例销毁之后</td>
</tr>
<tr>
<td>activated</td>
<td>keep-alive缓存的组件激活时</td>
</tr>
<tr>
<td>deactivated</td>
<td>keep-alive缓存的组件停用时调用</td>
</tr>
</tbody></table>
<p>在Vue生命周期钩子函数中会自动绑定this上下文到实例中，因此可以生命周期钩子函数中访问数据，运行方法。</p>
<h3 id="3-生命周期的整体流程"><a href="#3-生命周期的整体流程" class="headerlink" title="3.生命周期的整体流程"></a>3.生命周期的整体流程</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg"> </p>
<p><strong>具体分析</strong></p>
<p><strong>beforeCeated → created</strong></p>
<ul>
<li>初始化Vue实例，进行数据观测</li>
</ul>
<p><strong>created</strong></p>
<ul>
<li>完成数据观测，属性与方法的运算，<code>watch</code>、<code>event</code>事件回调的配置</li>
<li>可调用<code>methods</code>中的方法，访问和修改<code>data</code>数据触发响应式渲染dom，可通过<code>computed</code>和<code>watch</code>完成数据计算</li>
<li>此时<code>vm.$el</code>并没有被创建</li>
</ul>
<p><strong>created → beforeMount</strong></p>
<ul>
<li>判断是否存在<code>el </code>选项，若不存在则停止编译，直到调用<code>vm.$mount(el)</code>才会继续编译</li>
<li>优先级：<code>render</code> &gt; <code>template</code> &gt; <code>outerHTML</code></li>
<li><code>vm.el</code>获取到的是挂载<code>DOM</code>的</li>
</ul>
<p><strong>mounted</strong></p>
<ul>
<li><code>vm.el</code>已经完成<code>DOM</code>的挂载和渲染，此刻打印<code>vm.$el</code>，发现之前的挂载点及内容被替换成新的<code>DOM</code></li>
</ul>
<p><strong>beforeUpdate</strong></p>
<ul>
<li>更新的数据必须是被渲染在模板上的（<code>el</code>、<code>render</code> 、 <code>template</code> 之一）</li>
<li>此时<code>view</code>层还未更新</li>
<li>若在<code>beforeUpdate</code>中再次修改数据，不会再次触发更新方法</li>
</ul>
<p><strong>updated</strong></p>
<ul>
<li>完成<code>view</code>层的更新</li>
<li>若在<code>updated</code>中再次修改数据，会再次触发更新方法（<code>beforeUpdate</code>、<code>updated</code>）</li>
</ul>
<p><strong>beforeDestory</strong></p>
<ul>
<li>实例被销毁前调用，此时实例属性与方法仍可访问</li>
</ul>
<p><strong>destroyed</strong></p>
<ul>
<li>完全销毁一个实例。可清理它与其他实例之间的连接，解绑它的全部指令及事件监听器</li>
<li>并不能清除<code>DOM</code>，仅仅销毁实例</li>
</ul>
<p><strong>使用场景</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220728235433.png"></p>
<h3 id="题外话：数据请求在created还是mounted？"><a href="#题外话：数据请求在created还是mounted？" class="headerlink" title="题外话：数据请求在created还是mounted？"></a>题外话：数据请求在created还是mounted？</h3><p>一般来说，在<code>created</code>和<code>mounted</code>中都可以发送数据请求。但是大部分时候会在<code>created</code>中发送请求。<br><code>created</code>是在组件实例一旦创建完成立即调用，此时页面<code>dom</code>节点并未生成。<br><code>mounted</code>是在页面<code>dom</code>节点渲染完毕之后立即执行，此时页面<code>dom</code>节点已经生成。</p>
<p>在触发时机上<code>created</code>比<code>mounted</code>更早，二者都能拿到实例对象的属性和方法。<br>放在<code>mounted</code>中请求数据有可能导致页面闪动（页面<code>dom</code>结构已经生成，页面<code>dom</code>会进行二次渲染），在<code>created</code>就不会出现此类情况。</p>
<p><strong>建议：放在<code>created</code>中去请求数据</strong></p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【12】async和await实现原理</title>
    <url>/2022/07/27/12-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-async%E5%92%8Cawait%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Promise是一种异步编程的解决方案，实际上是利用编程技巧将回调函数的横向加载，改成纵向加载，达到链式调用的效果，避免回调地狱的问题。最大的问题是代码冗余，原来的任务被Promise包装一下，不管什么操作，一眼看去都是一堆的then，原来的语意变得不清楚。</p>
<p>为了解决 <code>Promise</code> 的问题，async和await在ES7中被提出，是关于异步的终极解决方案。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;    </span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="keyword">await</span> <span class="title function_">readFileWithPromise</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>())</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">await</span> <span class="title function_">readFileWithPromise</span>(<span class="string">&#x27;/etc/profile&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>())</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async和await函数写起来和同步函数一样，条件是需要接收Promise或原始类型的值。异步编程的最终目标是转换成人类最容易理解的形式。</p>
<h3 id="async和await的原理"><a href="#async和await的原理" class="headerlink" title="async和await的原理"></a>async和await的原理</h3><p>分析二者原理之前，需要一些前置知识：</p>
<h4 id="1-generator"><a href="#1-generator" class="headerlink" title="1. generator"></a>1. generator</h4><p>generator函数是协程在ES6的实现。协程简单来说就是多个线程相互协作，完成异步任务。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220728114039.png"><br>整个generator函数就是一个封装的异步任务，异步操作需要暂停的地方，都用yield语句注明。generator函数的执行方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> y = <span class="keyword">yield</span> x*<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// start &#123;value:2,done:false&#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="number">3</span>) <span class="comment">// &#123;value:3,done:true&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>gen()</code>不会立即执行，而是一上来就暂停，返回一个<code>Iterator</code>对象</li>
<li>每次<code>g.next()</code>都会打破暂停状态去执行，直到遇到下一个<code>yield</code>或者<code>return</code></li>
<li>遇到<code>yield</code>时，会执行<code>yield</code>后面的表达式，并返回执行之后的值，然后再次进入暂停状态，此时<code>done:false</code>。</li>
<li><code>next</code>函数可以接受参数，作为上个阶段异步任务的返回结果，被函数体内的变量接收</li>
<li>遇到<code>return</code>时，会返回值，执行结束，即<code>done:true</code></li>
<li>每次<code>g.next()</code>的返回值永远都是<code>&#123;value:... , done:...&#125;</code>的形式</li>
</ul>
<h4 id="2-thunk函数"><a href="#2-thunk函数" class="headerlink" title="2. thunk函数"></a>2. thunk函数</h4><p>JS中的thunk函数（译为转换程序），简单来说就是把带有回调函数的多参数函数转换成只接收回调函数的单参数版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">thunkify</span> = fn=&gt;<span class="function">(<span class="params">...res</span>)=&gt;</span><span class="function"><span class="params">callback</span>=&gt;</span><span class="title function_">fn</span>(...res,callback);</span><br><span class="line"><span class="keyword">const</span> thunk = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="keyword">const</span> readFileThunk = <span class="title function_">thunk</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="title function_">readFileThunk</span>(<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>单纯的thunk函数并没有很大的用处，大牛们想到将其与generator结合：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">readFileThunkWithGen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> content1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(content1);</span><br><span class="line">    <span class="keyword">const</span> content2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/profile&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(content2);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;fail&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">readFileThunkWithGen</span>();</span><br><span class="line">g.<span class="title function_">next</span>().<span class="title function_">value</span>(<span class="function">(<span class="params">err,data</span>)=&gt;</span>P&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="keyword">return</span> g.<span class="keyword">throw</span>(err).<span class="property">value</span></span><br><span class="line">  &#125;</span><br><span class="line">  g.<span class="title function_">next</span>(data.<span class="title function_">toString</span>()).<span class="title function_">value</span>(<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="keyword">return</span> g.<span class="keyword">throw</span>(err).<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g.<span class="title function_">next</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>thunk函数的真正作用是统一多参数函数的调用方式，在next调用时把控制权交还给generator，使generator函数可以使用低柜方式自启动流程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">run</span> = generator =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">generator</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">next</span> = (<span class="params">err, ...rest</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> g.<span class="keyword">throw</span>(err).<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = g.<span class="title function_">next</span>(rest.<span class="property">length</span> &gt; <span class="number">1</span> ? rest : rest[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="title function_">value</span>(next)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">run</span>(readFileThunkWithGen)</span><br></pre></td></tr></table></figure>
<p>有了自启动的加持，generator函数内就可以写“同步”的代码了。</p>
<p>generator 可以暂停执行，很容易让它和异步操作产生联系，因为我们在处理异步操作时，在等待的时候可以暂停当前任务，把程序控制权交还给其他程序，当异步任务有返回时，在回调中再把控制权交还给之前的任务。generator 实际上并没有改变 JavaScript 单线程、使用回调处理异步任务的本质。</p>
<h4 id="3-co函数库"><a href="#3-co函数库" class="headerlink" title="3.co函数库"></a>3.co函数库</h4><p>每次执行generator函数时自己写启动器比较麻烦。co函数库是一个generator函数的自启动执行器，使用条件是generator函数的yield命令后面只能说thunk函数或者Promise对象，co函数执行完饭回一个Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>)</span><br><span class="line"><span class="title function_">co</span>(readFileWithGen).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)) <span class="comment">// &#x27;done&#x27;</span></span><br><span class="line"><span class="title function_">co</span>(readFileThunkWithGen).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)) <span class="comment">// &#x27;done&#x27;</span></span><br></pre></td></tr></table></figure>
<p>co函数库的源码实现，其实就是将上面两种情况进行综合：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 做了简化，与源码基本一致</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">co</span> = (<span class="params">generator, ...rest</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = generator.<span class="title function_">call</span>(ctx, ...rest)</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(gen)</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onFulfilled</span> = res =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> ret</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.<span class="title function_">next</span>(res)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>(ret)</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onRejected</span> = err =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> ret</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.<span class="keyword">throw</span>(err)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>(ret)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">next</span> = result =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="property">done</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(result.<span class="property">value</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">toPromise</span>(result.<span class="property">value</span>).<span class="title function_">then</span>(onFulfilled, onRejected)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onFulfilled</span>()</span><br><span class="line">  &#125;)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">toPromise</span> = value =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isPromise</span>(value)) <span class="keyword">return</span> value</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;function&#x27;</span> == <span class="keyword">typeof</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">value</span>(<span class="function">(<span class="params">err, ...rest</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">reject</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">resolve</span>(rest.<span class="property">length</span> &gt; <span class="number">1</span> ? rest : rest[<span class="number">0</span>])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async、await是co库的官方实现。也可以看作自带启动器的generator函数的语法糖。不同的是，async、await只支持Promise和原始类型的值，不支持thunk函数。</p>
<p><strong>不管回调函数、Promise、generator或者async/await哪种方式，都没有改变JS单线程、使用回调处理异步任务的本质。</strong></p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>前端路由模式：hash模式与history模式</title>
    <url>/2022/07/27/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%EF%BC%9Ahash%E6%A8%A1%E5%BC%8F%E4%B8%8Ehistory%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220830184521.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220830184721.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220830184805.png"><br>前端会通过使用不同的URL向用户展示不同的页面，使得当我们想要访问一个页面时只要知道其URL地址，再浏览器地址栏中输入便会看到这个页面。但是在平时也会存在输入确定的URL地址却无法访问到页面的情况（出现404页面）。这实际上与前端的路由模式息息相关。</p>
<h3 id="0-为什么使用路由？"><a href="#0-为什么使用路由？" class="headerlink" title="0.为什么使用路由？"></a>0.为什么使用路由？</h3><p>Ajax异步请求可以实现页面的无缝刷新，导致浏览器地址栏的URL不会发生任何变化，破坏了用户的浏览体验。同时本次浏览的页面内容使用URL访问无法重新复现。<br>使用路由就可以很好的解决这个问题。单页面应用利用JS动态切换网页内容，避免页面重载；路由则提供浏览器地址的变化。二者结合以后，页面内容发生变化时浏览器地址也发生变化。</p>
<blockquote>
<p>SPA（Single Page Application），即<b>单页面应用</b>。所谓单页 Web 应用，就是只有一张 Web 页面的应用。单页应用程序 (SPA) 是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序。 浏览器一开始会加载必需的 HTML 、 CSS 和 JavaScript ，所有的操作都在这张页面上完成，都由 JavaScript 来控制。</p>
</blockquote>
<p>前端路由有两种模式：hash模式和history模式</p>
<h3 id="1-hash模式"><a href="#1-hash模式" class="headerlink" title="1.hash模式"></a>1.hash模式</h3><p>hash模式就是一种把前端路由的路径用井号<code>#</code>拼接在真实URL后面的模式。当<code>#</code>后面的路径发生变化时，浏览器并不会重新发起请求，而是触发<code>hashchange</code>事件。</p>
<p><strong>示例</strong><br>新建一个<code>hash.html</code>文件，内容为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&#x27;#/a&#x27;</span>&gt;A页面&lt;/a&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;#/b&#x27;</span>&gt;</span>B页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    app.<span class="property">innerHTML</span> = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>,render);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">render</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，利用<code>a</code>标签设置了两个路由导航，把<code>app</code>当作视图渲染容器，当切换路由的时候触发视图容器的更新，这其实就是大多数前端框架哈希路由的实现原理。</p>
<blockquote>
<p>总结一下hash模式的优缺点：</p>
<ul>
<li><b>优点：</b>浏览器兼容性较好，连IE8都支持</li>
<li><b>缺点：</b>路径在<code>#</code>后面，比较丑；所有的跳转都在客户端进行操作，这种模式不利于<code>SEO</code>优化；</li>
</ul>
</blockquote>
<p><b style="background:yellow;">hash模式永远不会提交到服务器，只能在前端自生自灭。</b></p>
<h3 id="2-history模式"><a href="#2-history模式" class="headerlink" title="2. history模式"></a>2. history模式</h3><p>history API是H5提供的新特性，允许开发者直接更改前端路由，即更新浏览器URL地址而不重新打起请求。</p>
<p><strong>示例：</strong><br>新建<code>history.html</code>，内容为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript:toA();&quot;</span>&gt;A页面&lt;/a&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:toB();&quot;</span>&gt;</span>B页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    app.<span class="property">innerHTML</span> = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">toA</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    history.<span class="title function_">pushState</span>(&#123;&#125;,<span class="literal">null</span>,<span class="string">&#x27;/a&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">render</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">toB</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    history.<span class="title function_">pushState</span>(&#123;&#125;,<span class="literal">null</span>,<span class="string">&#x27;/b&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">render</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>,render);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>history API提供了丰富的函数供开发者调用，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.<span class="title function_">replaceState</span>(&#123;&#125;,<span class="literal">null</span>,<span class="string">&#x27;/b&#x27;</span>) <span class="comment">//替换路由</span></span><br><span class="line">history.<span class="title function_">pushState</span>(&#123;&#125;,<span class="literal">null</span>,<span class="string">&#x27;/a&#x27;</span>) <span class="comment">//路由压栈</span></span><br><span class="line">history.<span class="title function_">back</span>() <span class="comment">//返回</span></span><br><span class="line">history.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line">history.<span class="title function_">go</span>(-<span class="number">2</span>) <span class="comment">//后退2次</span></span><br></pre></td></tr></table></figure>
<p>上面代码监听了<code>popstate</code>事件，该事件能监听到：</p>
<ul>
<li>用户点击浏览器的前进、后退操作</li>
<li>手动调用history的<code>back</code>、<code>forward</code>和<code>go</code>方法</li>
</ul>
<p>监听不到：</p>
<ul>
<li>history的<code>pushState</code>和<code>replaceState</code>方法</li>
</ul>
<p>这也是为什么上面的<code>toA</code>和<code>toB</code>函数内部需要手动调用<code>render</code>方法的原因。</p>
<p>大家可能也注意到<code>light-server</code>的命令多了<code>--historyindex &#39;/history.html&#39;</code>参数，这是干什么的呢？<br>浏览器在刷新的时候，会按照路径发送真实的资源请求，如果这个路径是前端通过history API设置的URL，那么在服务器往往不存在这个资源，于是就返回404。上面参数的意思是如果后端资源不存在就返回<code>history.html</code>的内容。</p>
<p>因此，线上部署基于history API单页面应用的时候，一定要后端配合支持才行，否则会出现大量的404。</p>
<blockquote>
<p>总结一下 history模式的优缺点：</p>
<ul>
<li><b>优点：</b>路径比较正规，没有#</li>
<li><b>缺点：</b>兼容性不如hash，且需要服务端支持，否则一刷新就出现404</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【11】深拷贝和浅拷贝</title>
    <url>/2022/07/27/11-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>JavaScript中的数据类型分为两大类：原始数据类型和引用数据类型。</p>
<ul>
<li>原始数据类型的数据保存在栈内存中</li>
<li>引用数据类型的数据保存在堆内存中，其在栈内存中存储的是引用数据类型值在堆内存中的地址</li>
</ul>
<p>深拷贝和浅拷贝只是针对引用数据类型而言的。</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝。<br>如果属性是基本数据类型，拷贝的就是基本类型的值，如果属性是引用数据类型，拷贝的就是地址。<br><b style="background-color:yellow;font-weight:800;">浅拷贝是拷贝一层，深层次的引用类型则是共享内存地址。</b></p>
<p>一个简单的浅拷贝代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">      newObj[prop] = obj[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>JavaScript</code>中，存在浅拷贝的现象有：</p>
<ul>
<li><code>Object.assign()</code></li>
<li><code>Array.prototype.slice()</code></li>
<li><code>Array.prototype.concat()</code></li>
<li>使用拓展运算符实现复制</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.assign</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">  <span class="attr">grade</span>:<span class="string">&#x27;seven&#x27;</span>,</span><br><span class="line">  <span class="attr">doSomething</span>:&#123;</span><br><span class="line">    <span class="attr">type1</span>:<span class="string">&#x27;baseball&#x27;</span>,</span><br><span class="line">    <span class="attr">type2</span>:<span class="string">&#x27;swimming&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice()</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> newArr1 = arr1.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// concat()</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> newArr2 = arr2.<span class="title function_">concat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展运算符</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> newArr3 = [...arr3];</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝开辟一个新的栈，两个对象属性完全相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p>
<p>常见的深拷贝的方法有：</p>
<ul>
<li><code>_.cloneDeep()</code></li>
<li><code>jQuery.extend()</code></li>
<li><code>JSON.parse(JSON.stringfy())</code></li>
<li>手写循环递归</li>
</ul>
<p><strong>☀️_.cloneDeep()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>:&#123;<span class="attr">f</span>:&#123;<span class="attr">g</span>:<span class="number">1</span>&#125;&#125;,</span><br><span class="line">  <span class="attr">c</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>☀️jQuery.extend()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>:&#123;<span class="attr">f</span>:&#123;<span class="attr">g</span>:<span class="number">1</span>&#125;&#125;,</span><br><span class="line">  <span class="attr">c</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = $.<span class="title function_">extend</span>(<span class="literal">true</span>,&#123;&#125;,obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>☀️JSON.parse(JSON.stringfy())</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringfy</span>(obj1));</span><br><span class="line"><span class="comment">// JSON.stringfy():用于将 JavaScript 值转换为 JSON 字符串。</span></span><br><span class="line"><span class="comment">// JSON.parse():将json数据转换为 JavaScript 对象</span></span><br></pre></td></tr></table></figure>

<p>但是这种方式存在弊端，会忽略<code>undefined</code>、<code>symbol</code>和函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">name1</span>: <span class="literal">undefined</span>, <span class="comment">// 丢失</span></span><br><span class="line">    <span class="attr">name3</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;, <span class="comment">// 丢失</span></span><br><span class="line">    <span class="attr">name4</span>:  <span class="title class_">Symbol</span>(<span class="string">&#x27;A&#x27;</span>) <span class="comment">// 丢失</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;name: &quot;A&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用JSON.parse(JSON.stringfy())的弊端：<br>①数据中包含<code>function</code>，<code>undefined</code>， <code>Symbol</code>这几种类型（不可枚举属性），<code>JSON.stringfy</code>序列化之后，会丢失<br>②数据中包含<code>NaN</code>、<code>Infinity</code>、<code>-Infinity</code>，<code>JSON.stringfy</code>序列化之后的结果是<code>null</code><br>③数据中包含<code>Date</code>对象，<code>JSON.stringfy</code>序列化之后会变为字符串<br>④数据中包含<code>RegExp（正则表达式）</code>，序列化之后会变成空对象<br>⑤<code>map/set</code>集合，无法序列化</p>
</blockquote>
<p><strong>☀️循环递归</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dp</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isObject</span>(obj)) <span class="keyword">return</span> obj</span><br><span class="line">        <span class="comment">// 已经clone过的对象直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> map.<span class="title function_">get</span>(obj)</span><br><span class="line">        <span class="comment">// 解决循环引用</span></span><br><span class="line">        map.<span class="title function_">set</span>(obj, <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;)</span><br><span class="line">        <span class="comment">// 获取对象的构造函数</span></span><br><span class="line">        <span class="keyword">const</span> fn = obj.<span class="property">constructor</span></span><br><span class="line">        <span class="comment">// 如果是正则</span></span><br><span class="line">        <span class="keyword">if</span> (fn === <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是日期</span></span><br><span class="line">        <span class="keyword">if</span> (fn === <span class="title class_">Date</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj.<span class="title function_">getTime</span>())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是函数</span></span><br><span class="line">        <span class="keyword">if</span> (fn === <span class="title class_">Function</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj.<span class="title function_">bind</span>(&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">            <span class="keyword">const</span> newObj = []</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> obj) &#123;</span><br><span class="line">                newObj.<span class="title function_">push</span>(<span class="title function_">isObject</span>(v) ? <span class="title function_">dp</span>(v) : v)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将已拷贝后的对象存储起来</span></span><br><span class="line">            map.<span class="title function_">set</span>(obj, newObj)</span><br><span class="line">            <span class="keyword">return</span> newObj</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isObject</span>(obj)) &#123;</span><br><span class="line">            <span class="keyword">const</span> newObj = &#123;&#125;</span><br><span class="line">            <span class="comment">// 使用Reflect.ownKeys替换</span></span><br><span class="line">            <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> v = obj[k]</span><br><span class="line">                newObj[k] = <span class="title function_">isObject</span>(v) ? <span class="title function_">dp</span>(v) : v</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 将已拷贝后的对象存储起来</span></span><br><span class="line">            map.<span class="title function_">set</span>(obj, newObj)</span><br><span class="line">            <span class="keyword">return</span> newObj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dp</span>(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220727212435.png"><br>从上图中可以发现，深拷贝和浅拷贝都是创建出一个新的对象，但在复制对象属性的时候，行为不一样。<br>浅拷贝只复制属性指向某个对象的指针，而不是复制对象本身，新旧对象还是共享一块内存，修改对象属性会影响原对象。<br>但是深拷贝会另外创造一个一模一样的对象，新对象和旧对象不共享内存，修改对象不会影响原对象。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>前提是 拷贝类型为引用类型 的情况下：</p>
<ul>
<li>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址</li>
<li>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</li>
</ul>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue模板是如何编译的？</title>
    <url>/2022/07/26/Vue%E6%A8%A1%E6%9D%BF%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="认识模板编译"><a href="#认识模板编译" class="headerlink" title="认识模板编译"></a>认识模板编译</h3><p>在Vue文件中使用<code>&lt;template&gt;&lt;/template&gt; </code>表示模板，其内部包裹的代码并不是原生的HTML，因此浏览器是不认识模板的。所以我们要做的工作就是把<code>&lt;template&gt;&lt;/template&gt;</code>内部的代码编译成浏览器认识的原生HTML，这就是模板编译。</p>
<p>页面从<code>&lt;template&gt;&lt;/template&gt;</code>包裹的代码到视图最终展示的主要流程是</p>
<ol>
<li>提取出模板中的原生HTML和非原生HTML（比如绑定的属性、事件、指令等）</li>
<li>经过一些处理生成render函数</li>
<li>render函数再将模板内容生成对应的VNode</li>
<li>再经过patch过程（Diff）得到要渲染到视图的VNode</li>
<li>最后根据VNode创建真实DOM节点，也就是原生的HTML插入到视图中，完成渲染</li>
</ol>
<p>上述的1，2，3步骤就是模板编译的过程。<br>那代码究竟在步骤2中发生了什么？它是怎么编译，最终生成render函数的呢？</p>
<h3 id="模板编译详解-源码"><a href="#模板编译详解-源码" class="headerlink" title="模板编译详解 - 源码"></a>模板编译详解 - 源码</h3><h4 id="baseCompile"><a href="#baseCompile" class="headerlink" title="baseCompile()"></a>baseCompile()</h4><p>这个就是模板编译的入口函数，接收两个参数：1.<code>template</code>:就是要转换的模板字符串；2.<code>options</code>:就是转换时需要的参数</p>
<p>编译的流程主要有三步：</p>
<ol>
<li>模板解析：通过正则等方式提取出<code>&lt;template&gt;&lt;/template&gt;</code>里的标签元素、属性、变量等信息，并解析成抽象语法树AST</li>
<li>优化：遍历AST找出其中的静态节点和静态根节点，并进行标记</li>
<li>代码生成：根据AST生成渲染函数render</li>
</ol>
<p>上述三个步骤分别对应三个函数。</p>
<p>首先查看<code>baseCompile()</code>函数在哪里调用，即<strong>模板编译从那里开始</strong>。<br>源码地址：<code>src/complier/index.js - 11行</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = <span class="title function_">createCompilerCreator</span>(<span class="keyword">function</span> <span class="title function_">baseCompile</span> (</span><br><span class="line">  <span class="attr">template</span>: string, <span class="comment">// 就是要转换的模板字符串</span></span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span> <span class="comment">//就是转换时需要的参数</span></span><br><span class="line">): <span class="title class_">CompiledResult</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 进行模板解析，并将结果保存为 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">parse</span>(template.<span class="title function_">trim</span>(), options)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有禁用静态优化的话</span></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">optimize</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 2. 就遍历 AST，并找出静态节点并标记</span></span><br><span class="line">    <span class="title function_">optimize</span>(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 生成渲染函数</span></span><br><span class="line">  <span class="keyword">const</span> code = <span class="title function_">generate</span>(ast, options)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    <span class="attr">render</span>: code.<span class="property">render</span>, <span class="comment">// 返回渲染函数 render</span></span><br><span class="line">    <span class="attr">staticRenderFns</span>: code.<span class="property">staticRenderFns</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<p>上述的3个步骤在源码中均体现出来，接下来看一下具体的编译流程是啥样的。<br>以以下模板为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打印编译后的结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  ast<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    type<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    tag<span class="punctuation">:</span> &#x27;div&#x27;<span class="punctuation">,</span></span><br><span class="line">    attrsList<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;id&#x27;<span class="punctuation">,</span> value<span class="punctuation">:</span> &#x27;app&#x27; <span class="punctuation">&#125;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    attrsMap<span class="punctuation">:</span> <span class="punctuation">&#123;</span> id<span class="punctuation">:</span> &#x27;app&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    rawAttrsMap<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    parent<span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">    children<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        type<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        expression<span class="punctuation">:</span> &#x27;_s(name)&#x27;<span class="punctuation">,</span></span><br><span class="line">        tokens<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span> &#x27;@binding&#x27;<span class="punctuation">:</span> &#x27;name&#x27; <span class="punctuation">&#125;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        text<span class="punctuation">:</span> &#x27;<span class="punctuation">&#123;</span><span class="punctuation">&#123;</span>name<span class="punctuation">&#125;</span><span class="punctuation">&#125;</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">        static<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    plain<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    attrs<span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;id&#x27;<span class="punctuation">,</span> value<span class="punctuation">:</span> &#x27;<span class="string">&quot;app&quot;</span>&#x27;<span class="punctuation">,</span> dynamic<span class="punctuation">:</span> undefined <span class="punctuation">&#125;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    static<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    staticRoot<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  render<span class="punctuation">:</span> `with(this)<span class="punctuation">&#123;</span>return _c(&#x27;div&#x27;<span class="punctuation">,</span><span class="punctuation">&#123;</span>attrs<span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;app&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">[</span>_v(_s(name))<span class="punctuation">]</span>)<span class="punctuation">&#125;</span>`<span class="punctuation">,</span></span><br><span class="line">  staticRenderFns<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  errors<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  tips<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>生成的内容看起来有些吃力，实际上注意以下三个步骤都做了什么就行了：</p>
<ul>
<li>ast字段是第一步生成的</li>
<li>static字段，就是标记，是在第二步中根据ast里的type加上去的</li>
<li>render字段，就是第三步生成的</li>
</ul>
<hr>
<p>再来看源码。</p>
<h4 id="1-parse"><a href="#1-parse" class="headerlink" title="1.parse()"></a>1.parse()</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220726105550.png"></p>
<p>实现的功能是 通过正则等方法提取出来<code>&lt;template&gt;&lt;/template&gt;</code>模板字符串里所有的tag、props、children信息，生成一个对应结构的ast对象 。</p>
<p>parse()接收两个参数：</p>
<ul>
<li>template：就是要转换的模板字符串</li>
<li>options：就是转换时需要的参数。它包含有四个钩子函数，就是用来把parseHTML解析出来的字符串提取出来，并生成对应的AST</li>
</ul>
<p>核心步骤如下：<br>调用<code>parseHTML</code>函数对模板字符串进行解析：</p>
<ul>
<li>解析到开始标签、结束标签、文本、注释分别进行不同的处理</li>
<li>解析过程中遇到文本信息就调用文本解析器<code>parseText</code>函数进行文本解析</li>
<li>解析过程中遇到包含过滤器，就调用过滤器解析器<code>parseFilters</code>函数进行解析</li>
</ul>
<p>每一步解析的结果都合并到一个对象上（就是最后的AST）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parse()的部分源码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parse</span> (</span><br><span class="line">  <span class="attr">template</span>: string, <span class="comment">// 要转换的模板字符串</span></span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span> <span class="comment">// 转换时需要的参数</span></span><br><span class="line">): <span class="title class_">ASTElement</span> | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="title function_">parseHTML</span>(template, &#123;</span><br><span class="line">    warn,</span><br><span class="line">    <span class="attr">expectHTML</span>: options.<span class="property">expectHTML</span>,</span><br><span class="line">    <span class="attr">isUnaryTag</span>: options.<span class="property">isUnaryTag</span>,</span><br><span class="line">    <span class="attr">canBeLeftOpenTag</span>: options.<span class="property">canBeLeftOpenTag</span>,</span><br><span class="line">    <span class="attr">shouldDecodeNewlines</span>: options.<span class="property">shouldDecodeNewlines</span>,</span><br><span class="line">    <span class="attr">shouldDecodeNewlinesForHref</span>: options.<span class="property">shouldDecodeNewlinesForHref</span>,</span><br><span class="line">    <span class="attr">shouldKeepComment</span>: options.<span class="property">comments</span>,</span><br><span class="line">    <span class="attr">outputSourceRange</span>: options.<span class="property">outputSourceRange</span>,</span><br><span class="line">    <span class="comment">// 解析到开始标签时调用，如 &lt;div&gt;</span></span><br><span class="line">    start (tag, attrs, unary, start, end) &#123;</span><br><span class="line">        <span class="comment">// unary 是否是自闭合标签，如 &lt;img /&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 解析到结束标签时调用，如 &lt;/div&gt;</span></span><br><span class="line">    end (tag, start, end) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 解析到文本时调用</span></span><br><span class="line">    chars (<span class="attr">text</span>: string, <span class="attr">start</span>: number, <span class="attr">end</span>: number) &#123;</span><br><span class="line">      <span class="comment">// 这里会判断判断很多东西，来看它是不是带变量的动态文本</span></span><br><span class="line">      <span class="comment">// 然后创建动态文本或静态文本对应的 AST 节点</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 解析到注释时调用</span></span><br><span class="line">    comment (<span class="attr">text</span>: string, start, end) &#123;</span><br><span class="line">      <span class="comment">// 注释是这么找的</span></span><br><span class="line">      <span class="keyword">const</span> comment = <span class="regexp">/^&lt;!\--/</span></span><br><span class="line">      <span class="keyword">if</span> (comment.<span class="title function_">test</span>(html)) &#123;</span><br><span class="line">      <span class="comment">// 如果是注释，就继续找 &#x27;--&gt;&#x27;</span></span><br><span class="line">      <span class="keyword">const</span> commentEnd = html.<span class="title function_">indexOf</span>(<span class="string">&#x27;--&gt;&#x27;</span>)</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 返回的这个就是 AST</span></span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面解析文本时调用<code>chars()</code>会根据不同类型的节点加上不同type，来标记AST节点类型，这个属性在下一步标记的时候也会用的</p>
<table>
<thead>
<tr>
<th>type</th>
<th>AST 节点类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>元素节点</td>
</tr>
<tr>
<td>2</td>
<td>包含变量的动态文本节点</td>
</tr>
<tr>
<td>3</td>
<td>没有变量的纯文本节点</td>
</tr>
</tbody></table>
<h4 id="2-optimize"><a href="#2-optimize" class="headerlink" title="2.optimize()"></a>2.optimize()</h4><p>这个函数就是在AST里找出静态节点和静态根节点，并添加标记，为了后面patch过程中，直接跳过静态节点的比对，直接克隆一份过去，从而优化patch的性能。</p>
<p>optimize()的大致过程：</p>
<ul>
<li><p>标记静态节点（markStatic），就是判断type是上面哪种类型（type值的1，2，3）</p>
</li>
<li><ul>
<li>type的值为1：就是包含子元素的节点，设置static为false，并递归标记子节点，直到标记完所有的子节点</li>
</ul>
</li>
<li><ul>
<li>type的值为2：设置static为false</li>
</ul>
</li>
<li><ul>
<li>type的值为3: 就是不包含子节点和动态属性的纯文本节点，把它的static = true，patch的时候就会跳过这个，直接克隆一份</li>
</ul>
</li>
<li><p>标记静态根节点（markStaticRoots），这里的原理和标记静态节点基本相同，知识需要满足下面条件的节点才算是静态根节点</p>
</li>
<li><ul>
<li>节点本身必须是静态节点</li>
</ul>
</li>
<li><ul>
<li>必须有子节点</li>
</ul>
</li>
<li><ul>
<li>子节点不能只有一个文本节点</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">optimize</span> (<span class="attr">root</span>: ?<span class="title class_">ASTElement</span>, <span class="attr">options</span>: <span class="title class_">CompilerOptions</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span></span><br><span class="line">  isStaticKey = <span class="title function_">genStaticKeysCached</span>(options.<span class="property">staticKeys</span> || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  isPlatformReservedTag = options.<span class="property">isReservedTag</span> || no</span><br><span class="line">  <span class="comment">// 标记静态节点</span></span><br><span class="line">  <span class="title function_">markStatic</span>(root)</span><br><span class="line">  <span class="comment">// 标记静态根节点</span></span><br><span class="line">  <span class="title function_">markStaticRoots</span>(root, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-generate"><a href="#3-generate" class="headerlink" title="3.generate()"></a>3.generate()</h4><p>这个就是生成render的函数，就是说最终会返回下面这个东东</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如有这么个模板</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面模板编译后返回的 render 字段 就是这样的</span></span><br><span class="line"><span class="attr">render</span>: <span class="string">`with(this)&#123;return _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,[_v(_s(name))])&#125;`</span></span><br></pre></td></tr></table></figure>
<p>可以看出上面的render正是虚拟DOM的结构，就是把一个标签分为tag、props、children。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把内容格式化一下，容易理解一点</span></span><br><span class="line"><span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_c</span>(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">attrs</span>:&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;app&quot;</span>&#125; &#125;,</span><br><span class="line">    [  <span class="title function_">_v</span>(<span class="title function_">_s</span>(name))  ]</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>其中<code>with</code>是用来欺骗词法作用域的，它可以让我们更快的饮用一个对象上的多个属性<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220726130648.png"></p>
<p>函数内部的<code>_c</code>、<code>_v</code>、<code>_s</code>分别表示什么含义？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其实不止这几个，由于本文例子中没有用到就没都复制过来占位了</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">installRenderHelpers</span> (<span class="attr">target</span>: any) &#123;</span><br><span class="line">  target.<span class="property">_s</span> = toString <span class="comment">// 转字符串函数</span></span><br><span class="line">  target.<span class="property">_l</span> = renderList <span class="comment">// 生成列表函数</span></span><br><span class="line">  target.<span class="property">_v</span> = createTextVNode <span class="comment">// 创建文本节点函数</span></span><br><span class="line">  target.<span class="property">_e</span> = createEmptyVNode <span class="comment">// 创建空节点函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 补充</span></span><br><span class="line">_c = createElement <span class="comment">// 创建虚拟节点函数</span></span><br></pre></td></tr></table></figure>
<hr>
<p>继续看generator()的源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">generate</span> (</span><br><span class="line">  <span class="attr">ast</span>: <span class="title class_">ASTElement</span> | <span class="keyword">void</span>,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">CompilerOptions</span></span><br><span class="line">): <span class="title class_">CodegenResult</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="keyword">new</span> <span class="title class_">CodegenState</span>(options)</span><br><span class="line">  <span class="comment">// 就是先判断 AST 是不是为空，不为空就根据 AST 创建 vnode，否则就创建一个空div的 vnode</span></span><br><span class="line">  <span class="keyword">const</span> code = ast ? (ast.<span class="property">tag</span> === <span class="string">&#x27;script&#x27;</span> ? <span class="string">&#x27;null&#x27;</span> : <span class="title function_">genElement</span>(ast, state)) : <span class="string">&#x27;_c(&quot;div&quot;)&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class="line">    <span class="attr">staticRenderFns</span>: state.<span class="property">staticRenderFns</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个流程很简单，就是判断AST是不是为空，不为空就根据AST创建VNode，否则就创建一个空的div的VNode。<br>创建VNode主要是通过<code>genElement()</code>函数来实现的。</p>
<h4 id="4-genElement"><a href="#4-genElement" class="headerlink" title="4.genElement()"></a>4.genElement()</h4><p>这个函数的逻辑很清晰，通过<code>if/else</code>判断传进来的AST元素节点的属性，来执行不同的生成函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genElement</span> (<span class="attr">el</span>: <span class="title class_">ASTElement</span>, <span class="attr">state</span>: <span class="title class_">CodegenState</span>): string &#123;</span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">parent</span>) &#123;</span><br><span class="line">    el.<span class="property">pre</span> = el.<span class="property">pre</span> || el.<span class="property">parent</span>.<span class="property">pre</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">staticRoot</span> &amp;&amp; !el.<span class="property">staticProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genStatic</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">once</span> &amp;&amp; !el.<span class="property">onceProcessed</span>) &#123; <span class="comment">// v-once</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genOnce</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">for</span> &amp;&amp; !el.<span class="property">forProcessed</span>) &#123; <span class="comment">// v-for</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genFor</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">if</span> &amp;&amp; !el.<span class="property">ifProcessed</span>) &#123; <span class="comment">// v-if</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genIf</span>(el, state)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// template 节点 &amp;&amp; 没有插槽 &amp;&amp; 没有 pre 标签</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">&#x27;template&#x27;</span> &amp;&amp; !el.<span class="property">slotTarget</span> &amp;&amp; !state.<span class="property">pre</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genChildren</span>(el, state) || <span class="string">&#x27;void 0&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">&#x27;slot&#x27;</span>) &#123; <span class="comment">// v-slot</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genSlot</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// component or element</span></span><br><span class="line">    <span class="keyword">let</span> code</span><br><span class="line">    <span class="comment">// 如果有子组件</span></span><br><span class="line">    <span class="keyword">if</span> (el.<span class="property">component</span>) &#123;</span><br><span class="line">      code = <span class="title function_">genComponent</span>(el.<span class="property">component</span>, el, state)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> data</span><br><span class="line">      <span class="comment">// 获取元素属性 props</span></span><br><span class="line">      <span class="keyword">if</span> (!el.<span class="property">plain</span> || (el.<span class="property">pre</span> &amp;&amp; state.<span class="title function_">maybeComponent</span>(el))) &#123;</span><br><span class="line">        data = <span class="title function_">genData</span>(el, state)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取元素子节点</span></span><br><span class="line">      <span class="keyword">const</span> children = el.<span class="property">inlineTemplate</span> ? <span class="literal">null</span> : <span class="title function_">genChildren</span>(el, state, <span class="literal">true</span>)</span><br><span class="line">      code = <span class="string">`_c(&#x27;<span class="subst">$&#123;el.tag&#125;</span>&#x27;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">        data ? <span class="string">`,<span class="subst">$&#123;data&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span> // data</span></span></span><br><span class="line"><span class="subst"><span class="string">      &#125;</span><span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">        children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span> // children</span></span></span><br><span class="line"><span class="subst"><span class="string">      &#125;</span>)`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// module transforms</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; state.<span class="property">transforms</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      code = state.<span class="property">transforms</span>[i](el, code)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回上面作为 with 作用域执行的内容</span></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里还可以发现v-for的优先级高于v-if</p>
</blockquote>
<h3 id="render-函数"><a href="#render-函数" class="headerlink" title="render 函数"></a>render 函数</h3><p>在Vue项目的<code>main.js</code>文件中，存在以下代码：<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725164129.png"><br>调用render函数会得到传入的模板（<code>.vue</code>文件）对应的虚拟DOM，那么这个render函数是从哪里来的？它是如何将<code>.vue</code>文件转换成浏览器可识别的代码的呢？</p>
<p>render函数的来源有两种方式：</p>
<ul>
<li>第一种就是经过模板编译生成render函数</li>
<li>第二种是我们自己定义在组件里的render函数，这种会跳过模板编译的过程</li>
</ul>
<h4 id="自定义的render"><a href="#自定义的render" class="headerlink" title="自定义的render"></a>自定义的render</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220726131746.png"><br>上面三种情况最后编译出的内容完全一样。<br>那么，你一定会有一个疑问，既然模板能自己编译自动生成，为什么还要提出自定义render？<br>原因有二：</p>
<ol>
<li>自己把VNode写了，就会直接跳过模板编译，不用再经历模板编译过程中解析模板动态属性、事件、指令等，所以性能上会有所提升。这一点在下面的渲染优先级上有所体现。</li>
<li>还有一些情况，能让我们的代码写法更加灵活，更加方便简洁，不会冗余</li>
</ol>
<p><em>（在Element-UI的组件源码中就有大量的重写render函数）</em></p>
<h5 id="1-渲染优先级"><a href="#1-渲染优先级" class="headerlink" title="1.渲染优先级"></a>1.渲染优先级</h5><p>Vue的生命周期中关于模板编译的部分，如下<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220726142359.png"><br>从图中可以知道，如果有<code>template</code>，就不会管<code>el</code>，所以<strong>template比el的优先级更高</strong>。</p>
<p>那我们自己手写的render函数呢？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123; <span class="attr">name</span>:<span class="string">&#x27;沐华&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>:<span class="string">&#x27;&lt;div&gt;掘金&lt;/div&gt;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">render</span>(<span class="params">h</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, <span class="string">&#x27;好好学习，天天向上&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果在页面上渲染出来的只有<code>&lt;div&gt;好好学习，天天向上&lt;/div&gt;</code>。因此，<strong>render函数的优先级更高</strong>。<br>所以，综上所述：<span style="background-color:yellow; font-weight:800;">优先级：render函数 &gt; template &gt; outerHTML </span><br>因为不管是<code>el</code>挂载的<code>outerHTML</code>，还是<code>template</code>，最后都会被编译成<code>render</code>函数，而如果已经有了<code>render</code>函数，就跳过前面的编译。这一点在源码中也有体现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"> el, hydrating </span>) &#123;</span><br><span class="line">   el = el &amp;&amp; <span class="title function_">query</span>(el);</span><br><span class="line">   <span class="keyword">var</span> options = <span class="variable language_">this</span>.<span class="property">$options</span>;</span><br><span class="line">   <span class="comment">// 如果没有 render </span></span><br><span class="line">   <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> template = options.<span class="property">template</span>;</span><br><span class="line">     <span class="comment">// 再判断，如果有 template</span></span><br><span class="line">     <span class="keyword">if</span> (template) &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">           template = <span class="title function_">idToTemplate</span>(template);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">         template = template.<span class="property">innerHTML</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">       &#125;</span><br><span class="line">     <span class="comment">// 再判断，如果有 el</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">       template = <span class="title function_">getOuterHTML</span>(el);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2-更灵活的写法"><a href="#2-更灵活的写法" class="headerlink" title="2.更灵活的写法"></a>2.更灵活的写法</h5><p>以如下代码为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;level === 1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;level === 2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-else-if</span>=<span class="string">&quot;level === 3&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>:[<span class="string">&#x27;level&#x27;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以换一种方式，写出和上面编译效果一样的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;level&#x27;</span>],</span><br><span class="line">    <span class="title function_">render</span>(<span class="params">h</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;h&#x27;</span> + <span class="variable language_">this</span>.<span class="property">level</span>, <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="title function_">default</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>或者下面这样，多次调用的时候就很方便</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;level&#x27;</span>],</span><br><span class="line">    <span class="title function_">render</span>(<span class="params">h</span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> tag = <span class="string">&#x27;h&#x27;</span> + <span class="variable language_">this</span>.<span class="property">level</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">tag</span>&gt;</span>&#123;this.$slots.default()&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220726154204.png" alt="何为模板编译？"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220913150808.png" alt="模板编译详解"></p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>说一说Vue的diff算法</title>
    <url>/2022/07/25/VUE%E7%9A%84diff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725102930.png"></p>
<h2 id="1-Vue的diff算法是什么？"><a href="#1-Vue的diff算法是什么？" class="headerlink" title="1.Vue的diff算法是什么？"></a>1.Vue的diff算法是什么？</h2><p>diff算法是一种通过同层的树节点比较的高效算法。其有两个特点：</p>
<ul>
<li>比较只会在同层级进行，不会跨层级比较</li>
<li>在diff比较的过程中，循环从两边向中间比较</li>
</ul>
<p>diff算法在很多场景下都有应用，在vue中，作用于虚拟dom渲染成真实dom的新旧VNode节点比较</p>
<h2 id="2-Vue的diff算法的比较方式是什么？"><a href="#2-Vue的diff算法的比较方式是什么？" class="headerlink" title="2.Vue的diff算法的比较方式是什么？"></a>2.Vue的diff算法的比较方式是什么？</h2><p>diff算法的整体策略为：<span style="color:red;font-weight:800;">深度优先，同层比较。</span></p>
<ol>
<li>只会在同层级进行，不会跨层级比较<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725104449.png"></li>
<li>在比较过程中，循环会从两边向中间收拢<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725104537.png"></li>
</ol>
<hr>
<p>下面举个vue通过diff算法更新的例子：<br>新旧节点如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725104923.png"><br>第一次循环之后发现旧节点D（old - endIndex）和新节点D（new - startIndex）相同，直接复用旧节点D作为diff后的第一个真实节点，同时旧节点的endIndex往前移动到C，新节点的startIndex移动到C<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725105449.png"><br>第二次循环，发现此时旧节点的endIndex对应的节点C与新节点的startIndex对应的节点C相同，故此进行和第一次循环相同的工作<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725105802.png"><br>第三次循环发现新节点E未出现在旧节点中，只能直接创建真实节点E插入到C节点之后，然后将新节点的startIndex移动到下一个节点A上<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725110338.png"><br>第四次循环发现旧节点的startIndex对应的节点值A和新节点startIndex对应的节点值A相同，故将A节点移动到真实节点E之后。此时同时将旧节点的startIndex后移一位，新节点的startIndex后移一位<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725110821.png"><br>第五次循环发现旧节点的startIndex对应的节点B与新节点startIndex对应的节点B相同，所以将节点B移动到真实节点A之后，同时新旧节点的startIndex都后移一位<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725111112.png"><br>第六次循环发现旧节点的startIndex的值大于endIndex值，所以就需要创建新节点中所有startIndex到endIndex的节点，放在真实节点B之后<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725111412.png"></p>
<h2 id="3-Vue的diff算法的原理分析"><a href="#3-Vue的diff算法的原理分析" class="headerlink" title="3.Vue的diff算法的原理分析"></a>3.Vue的diff算法的原理分析</h2><p>在Vue中当数据发生变化时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实DOM打补丁，更新相应的视图</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode)) &#123; <span class="comment">// 没有新节点，直接执行destory钩子函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode)) <span class="title function_">invokeDestroyHook</span>(oldVnode)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) &#123;</span><br><span class="line">        isInitialPatch = <span class="literal">true</span></span><br><span class="line">        <span class="title function_">createElm</span>(vnode, insertedVnodeQueue) <span class="comment">// 没有旧节点，直接用新节点生成dom元素</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isRealElement = <span class="title function_">isDef</span>(oldVnode.<span class="property">nodeType</span>)</span><br><span class="line">        <span class="keyword">if</span> (!isRealElement &amp;&amp; <span class="title function_">sameVnode</span>(oldVnode, vnode)) &#123;</span><br><span class="line">            <span class="comment">// 判断旧节点和新节点自身一样，一致执行patchVnode</span></span><br><span class="line">            <span class="title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则直接销毁及旧节点，根据新节点生成dom元素</span></span><br><span class="line">            <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVnode.<span class="property">nodeType</span> === <span class="number">1</span> &amp;&amp; oldVnode.<span class="title function_">hasAttribute</span>(<span class="variable constant_">SSR_ATTR</span>)) &#123;</span><br><span class="line">                    oldVnode.<span class="title function_">removeAttribute</span>(<span class="variable constant_">SSR_ATTR</span>)</span><br><span class="line">                    hydrating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isTrue</span>(hydrating)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">hydrate</span>(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">                        <span class="title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVnode</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                oldVnode = <span class="title function_">emptyNodeAt</span>(oldVnode)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vnode.<span class="property">elm</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>patch函数前两个参数为oldVNode和VNode，分别代表新的节点和之前的旧节点，函数中主要做了四个判断：<br>1️⃣ 没有新节点，直接触发旧节点的destory钩子<br>2️⃣ 没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较，直接调用createElm全部新建<br>3️⃣ 旧节点和新节点一样：通过sameVnode判断节点是否一样，一样直接调用patchVnode去处理这两个节点<br>4️⃣ 旧节点和新节点自身不一样：当两个节点不一样时，直接创建新节点，删除旧节点</p>
<p>接下来，谈一谈patchVnode部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchVnode</span> (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    <span class="comment">// 如果新旧节点一致，什么都不做</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化</span></span><br><span class="line">    <span class="keyword">const</span> elm = vnode.<span class="property">elm</span> = oldVnode.<span class="property">elm</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步占位符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTrue</span>(oldVnode.<span class="property">isAsyncPlaceholder</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">asyncFactory</span>.<span class="property">resolved</span>)) &#123;</span><br><span class="line">        <span class="title function_">hydrate</span>(oldVnode.<span class="property">elm</span>, vnode, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode.<span class="property">isAsyncPlaceholder</span> = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新旧都是静态节点，并且具有相同的key</span></span><br><span class="line">    <span class="comment">// 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上</span></span><br><span class="line">    <span class="comment">// 也不用再有其他操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTrue</span>(vnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">      <span class="title function_">isTrue</span>(oldVnode.<span class="property">isStatic</span>) &amp;&amp;</span><br><span class="line">      vnode.<span class="property">key</span> === oldVnode.<span class="property">key</span> &amp;&amp;</span><br><span class="line">      (<span class="title function_">isTrue</span>(vnode.<span class="property">isCloned</span>) || <span class="title function_">isTrue</span>(vnode.<span class="property">isOnce</span>))</span><br><span class="line">    ) &#123;</span><br><span class="line">      vnode.<span class="property">componentInstance</span> = oldVnode.<span class="property">componentInstance</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.<span class="property">data</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">prepatch</span>)) &#123;</span><br><span class="line">      <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.<span class="property">children</span></span><br><span class="line">    <span class="keyword">const</span> ch = vnode.<span class="property">children</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data) &amp;&amp; <span class="title function_">isPatchable</span>(vnode)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.<span class="property">update</span>.<span class="property">length</span>; ++i) cbs.<span class="property">update</span>[i](oldVnode, vnode)</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">update</span>)) <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果vnode不是文本节点或者注释节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode.<span class="property">text</span>)) &#123;</span><br><span class="line">      <span class="comment">// 并且都有子节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh) &amp;&amp; <span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">        <span class="comment">// 并且子节点不完全一致，则调用updateChildren</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) <span class="title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果只有新的vnode有子节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="comment">// elm已经引用了老的dom节点，在老的dom节点上添加子节点</span></span><br><span class="line">        <span class="title function_">addVnodes</span>(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.<span class="property">length</span> - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldCh)) &#123;</span><br><span class="line">        <span class="title function_">removeVnodes</span>(elm, oldCh, <span class="number">0</span>, oldCh.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果老节点是文本节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">text</span>)) &#123;</span><br><span class="line">        nodeOps.<span class="title function_">setTextContent</span>(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果新vnode和老vnode是文本节点或注释节点</span></span><br><span class="line">      <span class="comment">// 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.<span class="property">text</span> !== vnode.<span class="property">text</span>) &#123;</span><br><span class="line">      nodeOps.<span class="title function_">setTextContent</span>(elm, vnode.<span class="property">text</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = data.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">postpatch</span>)) <span class="title function_">i</span>(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>patchVnode主要做以下4个判断：<br>1️⃣ 新节点是否为文本节点，如果是，直接更新dom的文本内容为新节点的文本内容<br>2️⃣ 新节点和旧节点如果都有子节点，则调用updateChildren函数处理比较更新子节点<br>3️⃣ 只有新节点有子节点，旧节点没有，不需要比较，所有子节点都是全新的，直接全部新建（创建出新的DOM，添加进老节点里作为子节点）<br>4️⃣ 只有旧节点有子节点而新节点没有子节点，要做的就是将所有的旧节点的子节点全部删除</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>当Vue中的数据发生变化时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者会调用patch函数给真实DOM打补丁</li>
<li>在patch函数中通过isSameVnode方法进行判断新旧节点是否相同，相同则调用patchVnode方法</li>
<li>patchVnode方法主要做了以下操作：</li>
<li><ul>
<li>找到对应的真实dom，称为el</li>
</ul>
</li>
<li><ul>
<li>如果新节点均为文本节点，且只有文本内容不同，直接更新旧节点的文本内容即可</li>
</ul>
</li>
<li><ul>
<li>如果旧节点有子节点而新节点没有子节点，将旧节点的所有子节点删除就OK了</li>
</ul>
</li>
<li><ul>
<li>如果新节点有子节点而旧节点没有子节点，则创建新节点的子节点添加到旧节点里作为子节点</li>
</ul>
</li>
<li><ul>
<li>新旧节点都有子节点，调用updateChildren函数比较子节点  </li>
</ul>
</li>
<li>updateChildren函数主要做以下操作：</li>
<li><ul>
<li>设置新旧VNode的头尾指针</li>
</ul>
</li>
<li><ul>
<li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch工作、调用createElm创建新节点等</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725125732.png"></p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Baidu的CSS手写题</title>
    <url>/2022/07/25/Baidu%E7%9A%84CSS%E6%89%8B%E5%86%99%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>输了就是输了，这说明什么呀，小朋友，还得练。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725090509.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220725091814.png"></p>
<p>题目难点在于：中间部分（aside和section的高度未指定，但仍需要占满整个空白区域）<br>解决办法：<code>position:fixed</code>确定中间部分在页面的位置，aside指定宽高，section指定<code>align-self:stretch;</code></p>
<iframe width="100%" height="700" src="//jsrun.net/pgPKp/embedded/all/dark" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Baidu&#x27;s CSS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span>aside<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;section&quot;</span>&gt;</span>section<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  *&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">header</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">footer</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  </span></span><br><span class="line"><span class="language-css">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">500px</span>) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">top</span>:<span class="number">110px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">bottom</span>: <span class="number">110px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.aside</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.section</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">align-self</span>: stretch;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">500px</span>) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">top</span>:<span class="number">110px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">bottom</span>: <span class="number">110px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.aside</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">      <span class="comment">/* align-self: flex-start; */</span></span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.section</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">align-self</span>: stretch;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>JS利用高阶函数实现函数缓存【备忘模式】</title>
    <url>/2022/07/24/JS%E5%88%A9%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现一个可以缓存结果的高阶函数，如果函数成功执行，缓存结果并返回<br>function cache (fn){<br>}</p>
<p>const fn = ()=&gt;{<br>  console.log(‘执行了’)<br>  return Math.random();<br>}</p>
<p>const cachedFn = cache(fn)<br>console.log(cachedFn()) // 0.2333<br>console.log(cachedFn()) // 0.2333</p>
<p><em>(字节前端面试题)</em></p>
<h3 id="知识点1-高阶函数"><a href="#知识点1-高阶函数" class="headerlink" title="知识点1:高阶函数"></a>知识点1:高阶函数</h3><p>高阶函数就是那种 <strong>输入参数里有一个或多个函数</strong> ，输出也是函数的函数。 </p>
<h3 id="知识点2-高阶函数实现缓存-备忘模式"><a href="#知识点2-高阶函数实现缓存-备忘模式" class="headerlink" title="知识点2:高阶函数实现缓存(备忘模式)"></a>知识点2:高阶函数实现缓存(备忘模式)</h3><p>好比有一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次运行<code>add(1)</code>都会输出2，若是继续输入1，仍然会计算<code>1+1</code>，若是该操作是一个开销很大的操作，每次都重新进行计算会耗费大量的性能。如果能够 <strong>对已经计算的结果进行缓存，当再次计算该数时直接取缓存的内容，只有当新的数字时才进行重新计算</strong> ，这样就会极大降低性能消耗。</p>
<p>实现思路：<br>在备忘录函数内部创建一个对象cache来存储执行结果，若下次再输入同样的参数，就直接从cache中取出。只有传入新的参数时才会重新计算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cache</span> (fn) &#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> _args = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(args);</span><br><span class="line">    <span class="keyword">return</span> cache[_args] || (cache[_args] = fn.<span class="title function_">apply</span>(fn, args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cachedFn = <span class="title function_">cache</span>(fn)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cachedFn</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cachedFn</span>())</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220724230528.png"></p>
<p>可以发现fn函数实际上只执行了一次，第二次是直接从cache 中取值。</p>
]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>ByteDance的CSS手写题</title>
    <url>/2022/07/24/ByteDance%E7%9A%84CSS%E6%89%8B%E5%86%99%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220724141358.png"></p>
<p>要求：HTML代码不能变动，只能写CSS代码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220724144459.png"></p>
<iframe width="100%" height="350" src="//jsrun.net/7ZPKp/embedded/all/dark" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<h3 id="flex布局知识点"><a href="#flex布局知识点" class="headerlink" title="flex布局知识点"></a>flex布局知识点</h3><h4 id="1-容器属性"><a href="#1-容器属性" class="headerlink" title="1.容器属性"></a>1.容器属性</h4><ul>
<li>flex-direction:指定容器中元素的排列方式（flex主轴的排列方向）</li>
</ul>
<p>-row 默认值，弹性元素在容器中水平排列（自左向右）<br>-row-reverse 弹性元素在容器中反向水平排列（自右向左）<br>-column 弹性元素纵向排列（自上向下）<br>-column-reverse 弹性元素反向纵向排列（自下向上）</p>
<br>

<ul>
<li>flex-wrap:设置元素在容器中换行</li>
</ul>
<p>-nowrap 默认值，元素不会自动换行<br>-wrap 元素沿着辅轴方向自动换行<br>-wrap-reverse 元素沿着辅轴反方向换行</p>
<br>

<ul>
<li><p>flex-flow = flex-direction + flex-wrap</p>
</li>
<li><p>justify-content:定义元素在主轴上的排序方式<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117135730.png" alt="justify-content取值"></p>
</li>
</ul>
<br>

<ul>
<li>align-items:定义元素在辅轴上的排序方式<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117135907.png" alt="align-items取值"></li>
</ul>
<p><em>（元素属性align-self可以用来覆盖当前弹性元素上的align-items，设置单个元素的排列方式）</em></p>
<h4 id="2-元素属性"><a href="#2-元素属性" class="headerlink" title="2.元素属性"></a>2.元素属性</h4><ul>
<li>order:定义子元素或者子容器的排列顺序。数值越小，排列越靠前，默认为0。使用代码：<code>.item &#123; order: xxx; &#125;</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117140405.png" alt="order"></li>
</ul>
<br>

<ul>
<li>flex-grow:定义子元素的或子容器的放大比例，默认值为0（原始尺寸）。使用代码:<code>.item &#123; flex-grow: xxx;&#125; </code></li>
</ul>
<br>

<ul>
<li>flex-shrink:定义子元素的或子容器的放大比例，默认值为1（即如果空间不足，该项目将缩小。）。使用代码:<code>.item &#123; flex-shrink: xxx;&#125; </code></li>
</ul>
<br>

<ul>
<li>flex-basis:定义了在分配多余空间之前，项目占据的主轴空间（main size）。它的默认值为auto，即项目的本来大小。使用代码:<code>.item:&#123; flex-basis:xxx;&#125;</code> 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</li>
</ul>
<br>

<ul>
<li>align-self:允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117140115.png" alt="align-self"></li>
</ul>
<h3 id="元素透明度设置"><a href="#元素透明度设置" class="headerlink" title="元素透明度设置"></a>元素透明度设置</h3><ul>
<li><p>opacity：元素整体透明度都会设置，包括文字，内容所有内容。</p>
</li>
<li><p>rgba：rgba(red, green, blue, alpha)，其中alpha为透明度设置。这个透明度只会影响颜色，不会影响其他元素。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>大数相加</title>
    <url>/2022/07/23/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p>JS语言支持的整数安全范围是（-2^53 , 2^53），所以进行数字相加计算时，只能在该范围内进行计算，一旦超出，就无法进行计算了。</p>
<p>但是在日常学习工作中又不可避免的会遇到大数相加的问题，因此就需要对其进行解决。</p>
<p>大数相加问题的解决思路：</p>
<ol>
<li>将数字存储为字符串</li>
<li>求和时对每一位进行求和：这一过程中需要判断是否产生进位，当加到最开始的数字时还要判断是否产生进位</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bigNumSum</span> (s, t) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>), b = t.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> len = <span class="title class_">Math</span>.<span class="title function_">max</span>(a.<span class="property">length</span>, b.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">let</span> res = []; <span class="comment">//最终结果</span></span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span>; <span class="comment">// 判断是否有进位</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> num1 = a.<span class="title function_">pop</span>(), num2 = b.<span class="title function_">pop</span>();</span><br><span class="line">    num1 = num1 ? <span class="built_in">parseInt</span>(num1) : <span class="number">0</span>;</span><br><span class="line">    num2 = num2 ? <span class="built_in">parseInt</span>(num2) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> tempSum; <span class="comment">//暂时记录两数相加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123; <span class="comment">//首先判断是否有进位</span></span><br><span class="line">      tempSum = num1 + num2 + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tempSum = num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tempSum &gt; <span class="number">9</span>) &#123; <span class="comment">// 判断两数相加是否产生进位</span></span><br><span class="line">      res.<span class="title function_">push</span>(tempSum % <span class="number">10</span>);</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(tempSum);</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == len - <span class="number">1</span> &amp;&amp; flag)<span class="comment">//最开始两数相加，且存在进位情况</span></span><br><span class="line">      res.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>手写LRU</title>
    <url>/2022/07/22/%E6%89%8B%E5%86%99LRU/</url>
    <content><![CDATA[<h2 id="LRU（Least-Recently-Used）最近最少使用"><a href="#LRU（Least-Recently-Used）最近最少使用" class="headerlink" title="LRU（Least Recently Used）最近最少使用"></a>LRU（Least Recently Used）最近最少使用</h2><p>LRU是一个非常经典的算法，一般可用如下场景描述：我们访问了很多个页面，使用内存去存储这些页面，随着时间的推移，页面越来越多，但是内存空间是有限的，所以需要删除一些页面，删除页面基于的策略是 <strong>删除最近最久没有使用过的</strong>页面。</p>
<p>手写LUR需要注意如下场景的问题：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220722170756.png"></p>
<ol>
<li>访问已经存在的页面：先删除该页面，在重新添加</li>
<li>访问新的页面：若未超内存长度，直接放入；若超出内存长度，删除第一个，放入新的</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key,value</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">    <span class="comment">//若存在内存中：删除原来的，重新放入</span></span><br><span class="line">    <span class="keyword">if</span>(data.<span class="title function_">has</span>(key))&#123;</span><br><span class="line">      data.<span class="title function_">delete</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    data.<span class="title function_">set</span>(key,value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若超出内存长度:删除第一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(data.<span class="property">size</span>&gt;<span class="variable language_">this</span>.<span class="property">length</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> delKey = data.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>;</span><br><span class="line">      data.<span class="title function_">delete</span>(delKey);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">    <span class="comment">// 未找到</span></span><br><span class="line">    <span class="keyword">if</span>(!data.<span class="title function_">has</span>(key)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 找到：取值，删除，重新写入</span></span><br><span class="line">    <span class="keyword">const</span> value = data.<span class="title function_">get</span>(key);</span><br><span class="line">    data.<span class="title function_">delete</span>(key);</span><br><span class="line">    data.<span class="title function_">set</span>(key,value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>各种无厘头手写</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【10】防抖和节流</title>
    <url>/2022/07/22/10-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>防抖和节流是前端面试中不可避免的一个知识点，主要会考察：1.两者的区别是什么? 2.分别用于什么场景？</p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>何为防抖？防止抖动（内心os:你就抖吧，等你不抖了，我们再交互）</p>
<p>相关场景：搜索框的输入、 手机号，邮箱的验证  用户不停的输入（这就是抖动的过程），当用户输入完成了（不抖了），才开始触发搜索 or 验证。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220722110454.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">callback,delay=<span class="number">2000</span></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(value);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>何为节流？节省流量/节省交互（内心os:一个一个来，禁止插队，按照每人分配的时间段，每人只能执行一次哦）</p>
<p>相关场景：drag（拖动）事件或者 scroll（滚动） 期间触发某个毁掉，要设置一个时间间隔。我只需要在过程中出发一次回调，但又不需要那么频繁。   高频点击表单提交，一定时间内只提交一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span> (fn, delay=<span class="number">2000</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> begin = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> cur = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">    <span class="keyword">if</span>((cur-begin)&gt;delay)&#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>);</span><br><span class="line">      begin=cur;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>有一种更佳的区别解释：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220722112514.png"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>防抖在连续的事件，只需触发一次回调的场景有：</p>
<ul>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li>
<li>手机号、邮箱验证输入检测</li>
<li>窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染</li>
</ul>
<p>节流在间隔一段时间执行一次回调的场景有：</p>
<ul>
<li>滚动加载，加载更多或滚到底部监听</li>
<li>搜索框，搜索联想功能</li>
</ul>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>从浏览器输入URL到页面渲染出来发生了什么？</title>
    <url>/2022/07/10/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%87%BA%E6%9D%A5%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p><strong>从浏览器输入URL到页面渲染出来发生了什么</strong><br>如果知道在浏览器输入URL后会建立TCP连接，并在此之上有HTTP的请求与响应，在浏览器接收到数据之后，了解HTML与CSS文件如何构成渲染树，以及JS引擎渲染解析和执行的基本流程。<br>这种程度只能算是初窥门径。在面对网站较差性能表现的时候，能够从网络连接、关键路径渲染以及JS执行过程的角度去分析和找寻存在的问题。<br>这个问题的细致回答，涉及信号与系统、计算机原理、操作系统、网络通信、浏览器内核、DNS解析、负载均衡、页面渲染等方面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220710154214.png"></p>
<h3 id="第一步：浏览器接收到URL，到网络请求线程的开启"><a href="#第一步：浏览器接收到URL，到网络请求线程的开启" class="headerlink" title="第一步：浏览器接收到URL，到网络请求线程的开启"></a>第一步：浏览器接收到URL，到网络请求线程的开启</h3><p>浏览器解析URL之后，如果是HTTP请求，浏览器会新建一个网络请求线程去下载所需要的资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220710220528.png"><br>线程与进程的关系：<br>（1）只要某个线程出错，就会导致进程的崩溃<br>（2）进程与进程之间相互隔离。这样能够保证当一个进程崩溃或者挂起时，并不会影响其他进程的正常运行<br>（3）进程所占用的资源会在其关闭后由操作系统回收。即使进程中的某个线程存在内存泄漏，当进程退出时，相关资源也会被回收<br>（4）线程之间可以共享所属进程的数据</p>
<p>浏览器在发展过程中，也由单线程浏览器发展成多线程浏览器。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220710223219.png"></p>
<h3 id="第二步：建立HTTP请求"><a href="#第二步：建立HTTP请求" class="headerlink" title="第二步：建立HTTP请求"></a>第二步：建立HTTP请求</h3><h4 id="2-1-DNS解析"><a href="#2-1-DNS解析" class="headerlink" title="2.1 DNS解析"></a>2.1 DNS解析</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220710223531.png"><br>首先查询浏览器自身的DNS缓存，当在浏览器缓存中没有找到IP地址时，就会搜索系统自身的DNS缓存，若还未查找到，就会尝试从系统的host文件中查找。【这个过程是递归查询】<br>接下来便会到本地域名服务器上查询。采取迭代查询的方式依次查询根域名服务器、COM顶级域名服务器、权限域名服务器。</p>
<p>DNS解析是一个很耗时的过程，若解析域名过多，势必会延缓首屏加载时间。</p>
<h4 id="2-2-TCP连接"><a href="#2-2-TCP连接" class="headerlink" title="2.2 TCP连接"></a>2.2 TCP连接</h4><p>当本地浏览器向目标主机发起HTTP请求，就需要通过传输层建立端到端的连接。传输层常见的协议有TCP和UDP。</p>
<p>对于TCP连接，不可避免的要谈起“三次握手”和“四次挥手”。</p>
<p><strong>“三次挥手”</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220710225459.png"><br>① 请求建立连接 ② 客户端SYN的确认应答及请求建立连接 ③ 服务器端SYN的确认应答</p>
<p><strong>“四次挥手”</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220710225840.png"><br>① 请求断开连接 ② 客户端FIN的确认应答 ③ 服务器FIN的确认应答 ④ 请求断开链接</p>
<h3 id="第三步：前后端交互"><a href="#第三步：前后端交互" class="headerlink" title="第三步：前后端交互"></a>第三步：前后端交互</h3><h4 id="3-1-反向代理服务器"><a href="#3-1-反向代理服务器" class="headerlink" title="3.1 反向代理服务器"></a>3.1 反向代理服务器</h4><p>反向代理服务器的通常作用如下：</p>
<ul>
<li>负载均衡</li>
<li>安全防火墙</li>
<li>加密及SSL加速</li>
<li>数据压缩</li>
<li>解决跨域</li>
<li>对静态资源加速</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220710231232.png"></p>
<h4 id="3-2-HTTP相关协议特性"><a href="#3-2-HTTP相关协议特性" class="headerlink" title="3.2 HTTP相关协议特性"></a>3.2 HTTP相关协议特性</h4><p><strong>长连接 &amp; 短连接</strong></p>
<p>长连接：就是在客户端与服务器端建立的TCP连接上可以连续发送多个数据包，但需要双方发送心跳检查包来维持这个连接。</p>
<p>短连接：当客户端需要向服务器发送请求时，会在网络层IP协议之上建立一个TCP连接，当请求发送并收到响应后，则断开连接。</p>
<p>长连接并非永久保持，它有一个持续的时间，可以在服务器中进行配置</p>
<p><strong>HTTP2.0的优点</strong></p>
<ul>
<li>多路复用：一个连接可以请求多个资源</li>
<li>二进制分帧：在应用层和传输层之间，新加入一个二进制分帧层，以实现低延迟和高吞吐量</li>
<li>服务器端推送：服务器可以实现一个请求向客户端发送多个响应，这样便可以实现服务器主动向客户端推送的功能</li>
<li>设置请求优先级：服务器会根据请求所设置的优先级，来决定需要多少资源处理该请求</li>
<li>HTTP头部压缩：减少报文传输体积</li>
</ul>
<h4 id="3-3-浏览器缓存"><a href="#3-3-浏览器缓存" class="headerlink" title="3.3 浏览器缓存"></a>3.3 浏览器缓存</h4><p><a href="https://qw-null.github.io/2022/03/12/HTTP%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98VS%E5%BC%BA%E7%BC%93%E5%AD%98/">协商缓存VS强缓存</a></p>
<h3 id="第四步：关键路径渲染"><a href="#第四步：关键路径渲染" class="headerlink" title="第四步：关键路径渲染"></a>第四步：关键路径渲染</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220905233255.png"></p>
<p><strong>【Q：CSSOM树和DOM树是同时解析的吗？】</strong><br>浏览器会下载<code>HTML</code>解析页面生成<code>DOM</code>树，遇到<code>CSS</code>标签就开始解析<code>CSS</code>，这个过程不会阻塞，但是如果遇到了<code>JS</code>脚本，此时假如<code>CSSOM</code>还没有构建完，需要等待<code>CSSOM</code>构建完，再去执行<code>JS</code>脚本，然后再执行<code>DOM</code>解析，此时会阻塞。</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS中的三列布局</title>
    <url>/2022/07/09/CSS%E4%B8%AD%E7%9A%84%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>三列布局的要求一般为：</p>
<ol>
<li>左右两边宽度固定，中间宽度自适应。</li>
<li>中间列的内容可以完整显示。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220712100505.png"></p>
<h2 id="1-定位方式"><a href="#1-定位方式" class="headerlink" title="1. 定位方式"></a>1. 定位方式</h2><iframe width="100%" height="300" src="//jsrun.net/SBzKp/embedded/all/dark" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="2-flex-布局"><a href="#2-flex-布局" class="headerlink" title="2. flex 布局"></a>2. flex 布局</h2><iframe width="100%" height="300" src="//jsrun.net/4BzKp/embedded/all/dark" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="3-圣杯布局"><a href="#3-圣杯布局" class="headerlink" title="3.圣杯布局"></a>3.圣杯布局</h2><p>圣杯布局的步骤：</p>
<ol>
<li>首先给<code>left</code>、<code>middle</code>、<code>right</code>设置上<code>float: left</code>, 脱离文档流；</li>
<li>给container(父元素)设置上<code>overflow: hidden</code> 可以形成BFC撑开文档</li>
<li><code>left</code>、<code>right</code>设置上各自的宽度，<code>middle</code>设置<code>width: 100%</code><br>🌟 接下来比较重要了：</li>
<li>给<code>left</code>、<code>middle</code>、<code>right</code>设置<code>position: relative</code></li>
<li><code>left</code>设置 <code>left: -leftWidth</code>,<code>margin-left:-100%</code>，<code>right</code>设置 <code>right: -rightWidth</code>,<code>margin-left:-rightWidth</code></li>
<li><code>container</code>设置<code>padding: 0, rightWidth, 0, leftWidth</code></li>
</ol>
<iframe width="100%" height="400" src="//jsrun.net/uBzKp/embedded/all/dark" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="4-双飞翼布局"><a href="#4-双飞翼布局" class="headerlink" title="4.双飞翼布局"></a>4.双飞翼布局</h2><p>双飞翼布局的步骤：</p>
<ol>
<li>首先给<code>left</code>、<code>main</code>、<code>right</code>设置上<code>float: left</code>, 脱离文档流；<code>main</code>中增加<code>main-contain</code></li>
<li>给<code>container</code>设置上<code>overflow: hidden</code> 可以形成BFC撑开文档</li>
<li><code>left</code>、<code>right</code>设置上各自的宽度，<code>main</code>设置<code>width: 100%</code><br>🌟 接下来与圣杯布局不一样的地方：</li>
<li><code>left</code>设置 <code>margin-left: -100%</code>, <code>right</code>设置 <code>margin-left: -rightWidth</code>,<code>container</code>不再设置<code>padding</code></li>
<li><code>main-content</code>设置<code>margin: 0 rightWidth 0 leftWidth</code></li>
</ol>
<iframe width="100%" height="400" src="//jsrun.net/YRzKp/embedded/all/dark" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="5-圣杯布局和双飞翼布局"><a href="#5-圣杯布局和双飞翼布局" class="headerlink" title="5.圣杯布局和双飞翼布局"></a>5.圣杯布局和双飞翼布局</h2><p><strong>✨实现的功能</strong><br>要求中间内容优先渲染，左右内容宽度固定，中间主要内容宽度自适应排布</p>
<p><strong>✨区别</strong><br><strong>1.表现形式上</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220709231825.png"><br>圣杯布局是中间栏为两边腾开位置<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220709231855.png"><br>双飞翼布局则是中间栏不变，将内容部分为两边腾开位置</p>
<p><strong>2.代码结构</strong><br>双飞翼布局中间层多了一层<code>div</code>标签</p>
]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【9】变量提升</title>
    <url>/2022/06/16/9-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>在JS中，不可避免的要声明变量和函数，那么在声明之后，JS引擎是如何找到这些变量的呢？</p>
<p>JS代码在执行过程中必然会进入到执行上下文中。当一个函数被调用时，一个新的上下文就会被创建。<br>通常一个执行上下文的生命周期分为如下阶段：</p>
<ul>
<li>创建阶段：在这个阶段中，执行上下文会创建变量对象，确定this指向，以及其他需要的状态。</li>
<li>代码执行阶段：创建阶段完成之后，就会执行代码，完成变量的赋值，以及执行其他代码。</li>
<li>销毁阶段：可执行代码执行完毕后，执行上下文出栈，对应的内存失去引用，等待垃圾回收器的回收。</li>
</ul>
<p>而对于变量提升的考察，会体现在创建阶段和代码执行阶段。而在变量提升中有两个重要的概念<b style="color:red;">变量对象（Variable Object，即VO）</b>、<b style="color:red;">活动对象（Active Object，即AO）</b>。</p>
<h2 id="变量对象（VO）"><a href="#变量对象（VO）" class="headerlink" title="变量对象（VO）"></a>变量对象（VO）</h2><p>变量对象的创建，依次经历以下几个过程：①建立arguments对象 ➡️ ②检查当前上下文的函数声明 ➡️ ③检查var变量声明，创建属性</p>
<p>①建立arguments对象<br>检查当前上下文中的参数，建立该对象下的属性与属性值。</p>
<p>②检查当前上下文的函数声明<br>也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用</p>
<p>③检查var变量声明，创建属性<br>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined，const/let声明的变量没有赋值不能提前使用<br><b style="color:red;">【如果var变量与函数名同名，则在这个阶段，以函数值为准，在下一个阶段，函数值会被变量值覆盖】</b></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220616215507.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220616223053.png"></p>
<p>从上面的例子中可以看出，function声明会比var声明优先级更高。</p>
<hr>
<p>结合例子进行进一步讨论：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>

<p>对于上述例子，直接从test()的执行上下文开始理解。全局作用域中运行test()时，test()的执行上下文开始创建。创建过程可以通过如下代码展示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建过程</span></span><br><span class="line">testEC = &#123;</span><br><span class="line">  <span class="comment">// 变量对象</span></span><br><span class="line">  <span class="attr">VO</span>:&#123;&#125;,</span><br><span class="line">  <span class="attr">scopeChain</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">VO</span> = &#123;</span><br><span class="line">  <span class="attr">arguments</span>:&#123;...&#125;,<span class="comment">//注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理</span></span><br><span class="line">  <span class="attr">foo</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">reference</span>&gt;</span>, //表示foo的地址引用</span></span><br><span class="line"><span class="language-xml">  a:undefined</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在未进入执行阶段之前，变量对象的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
<h2 id="活动对象（AO）"><a href="#活动对象（AO）" class="headerlink" title="活动对象（AO）"></a>活动对象（AO）</h2><p>其实变量对象（VO）和活动对象（AO）都是同一个对象，只是处于执行上下文的不同生命周期。只有处于函数调用栈栈顶的执行对象的上下文中的变量对象才会变成活动对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line"><span class="variable constant_">VO</span> -&gt;  <span class="variable constant_">AO</span>   <span class="comment">// Active Object</span></span><br><span class="line"><span class="variable constant_">AO</span> = &#123;</span><br><span class="line">    <span class="attr">arguments</span>: &#123;...&#125;,</span><br><span class="line">    <span class="attr">foo</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">reference</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">    a: 1,</span></span><br><span class="line"><span class="language-xml">    this: Window</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>所以上面例子的执行顺序就变成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>());</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>
<hr>
<p>🌰 例子：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220616234514.png"><br>执行结果：<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220616235400.png"></p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>JS模块化</title>
    <url>/2022/06/15/JS%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>在JS发展初期，主要是为了实现简单的页面逻辑交互。如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀。在最开始将所有的JS代码都封装在同一个JS文件中的做法不再合适，这样做带来了一定的问题：1.耦合度高，不方便后期维护；2. 功能点不明确；3.容易污染全局环境。于是提出了模块化的概念。</p>
</blockquote>
<h3 id="1-什么是模块？"><a href="#1-什么是模块？" class="headerlink" title="1.什么是模块？"></a>1.什么是模块？</h3><ul>
<li>将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并进行组合在一起</li>
<li>块的内部数据/实现是私有的，只是向外暴露一些接口（方法）与外部其他模块通信</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220615171844.png"><br>（<em>上述两种方式： 对象可以随时修改，一点不安全</em>）</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220615172030.png"></p>
<h3 id="2-模块化的好处？"><a href="#2-模块化的好处？" class="headerlink" title="2.模块化的好处？"></a>2.模块化的好处？</h3><ol>
<li>避免命名冲突（减少命名空间的污染）</li>
<li>更好的分离，按需加载</li>
<li>更高复用性</li>
<li>高可维护性</li>
</ol>
<h3 id="3-页面引入多个-lt-script-gt"><a href="#3-页面引入多个-lt-script-gt" class="headerlink" title="3.页面引入多个&lt;script&gt;"></a>3.页面引入多个&lt;script&gt;</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220622235645.png"><br>引入模块化随之带来的问题是 </p>
<ol>
<li><p>请求过多：首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p>
</li>
<li><p>依赖模糊：我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p>
</li>
<li><p>难以维护</p>
</li>
</ol>
<p>因为模块化过程中可能会出现上述的问题，因此，提出了模块化规范的概念。</p>
<h3 id="4-模块化规范"><a href="#4-模块化规范" class="headerlink" title="4.模块化规范"></a>4.模块化规范</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83.png"></p>
<h4 id="4-1-CommonJS"><a href="#4-1-CommonJS" class="headerlink" title="4.1 CommonJS"></a>4.1 CommonJS</h4><p>最开始出现的CommonJS仅仅针对服务器端，后来才逐步支持浏览器端。</p>
<blockquote>
<p>每个文件都可当作一个模块（JS文件）<br>在服务器端：模块的加载运行是同步的<br>在浏览器端：模块需要提前编译打包处理</p>
</blockquote>
<p><b>基本语法：</b><br>✨ 暴露模块：<code>module.exports = value(任意数据类型)</code> 、<code>exports.xxx = value</code></p>
<p>  Q: 暴露的模块到底是什么？➡️ A：暴露的是 <code>exports</code> 这个对象</p>
<p>✨ 引入模块：<code>require（XXX）// 1.第三方模块：XXX为模块名；2.自定义模块：XXX为模块文件路径</code></p>
<p><b>实现：</b><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220623101353.png"> </p>
<p>说明：浏览器是无法识别CommonJs的，所以需要引进Browserify打包成为浏览器可以识别的js文件</p>
<h4 id="4-2-AMD-Asynchronous-Module-Definition"><a href="#4-2-AMD-Asynchronous-Module-Definition" class="headerlink" title="4.2 AMD (Asynchronous Module Definition)"></a>4.2 AMD (Asynchronous Module Definition)</h4><p>专门用于浏览器端，模块加载是异步的。<br>AMD依赖于一个库 <code>require.js</code></p>
<p><b>基本语法：</b><br>✨ 暴露模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;module1&#x27;</span>,<span class="string">&#x27;module2&#x27;</span>],<span class="keyword">function</span>(<span class="params">m1,m2</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入使用模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>,<span class="string">&#x27;module2&#x27;</span>],<span class="keyword">function</span>(<span class="params">m1,m2</span>)&#123;</span><br><span class="line">  使用m1 / m2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AMD的规范是依赖于<code>require.js</code>这个库的</p>
<p>第三方库jQuery默认支持AMD，在AMD中引入使用时，名字应该使用<code>jquery</code></p>
<h4 id="4-3-CMD-了解即可，由阿里大佬提出"><a href="#4-3-CMD-了解即可，由阿里大佬提出" class="headerlink" title="4.3 CMD (了解即可，由阿里大佬提出)"></a>4.3 CMD (了解即可，由阿里大佬提出)</h4><p>专门用于浏览器端，模块的加载是异步的<br>模块使用时才会加载执行</p>
<p><b>基本语法：</b><br>✨ 定义暴露模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>,<span class="built_in">exports</span>,<span class="variable language_">module</span></span>)&#123;</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">xxx</span> = value</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>,<span class="built_in">exports</span>,<span class="variable language_">module</span></span>)&#123;</span><br><span class="line">  <span class="comment">// 引入依赖模块（同步）</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2&#x27;</span>)</span><br><span class="line">  <span class="comment">// 引入依赖模块（异步）</span></span><br><span class="line">  <span class="built_in">require</span>.<span class="title function_">async</span>(<span class="string">&#x27;./module3&#x27;</span>,<span class="keyword">function</span>(<span class="params">m3</span>)&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">xxx</span> = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>✨ 引入使用模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&#x27;./module4&#x27;</span>)</span><br><span class="line">  m1.<span class="title function_">show</span>()</span><br><span class="line">  m4.<span class="title function_">show</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实际上，CMD是将CommonJS和AMD进行了组合，在定义暴露模块时采用AMD的做法，而暴露模块时采用CommonJS的方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220623152406.png"></p>
<h4 id="4-4-ES6-Module（⭐-重要）"><a href="#4-4-ES6-Module（⭐-重要）" class="headerlink" title="4.4 ES6 Module（⭐ 重要）"></a>4.4 ES6 Module（⭐ 重要）</h4><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<p><b>✨ 规范：</b></p>
<ol>
<li>每个文件都是一个模块</li>
<li>要借助Babel和Browserify依次编译代码，才能在浏览器运行</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220623164111.png"><br>（<em>浅谈一嘴 ➡️ Babel的两个重要功能：1.将ES6转化为ES5； 2.将JSX转化为JS（React中）</em>）</p>
<p><b>✨ 语法：</b></p>
<ul>
<li>暴露模块：<code>export</code>:<code>export</code>命令用于规定模块的对外接口</li>
<li>引入模块：<code>import</code>:<code>import</code>命令用于输入其他模块提供的功能</li>
</ul>
<p><b>暴露模块：</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>分别暴露： <span class="keyword">export</span> 暴露内容</span><br><span class="line"><span class="number">2.</span>统一暴露： <span class="keyword">export</span> &#123;暴露内容<span class="number">1</span>，暴露内容<span class="number">2</span>&#125;</span><br><span class="line"><span class="number">3.</span>默认暴露： <span class="keyword">export</span> <span class="keyword">default</span> 暴露内容</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220624150216.png"><br>（说明：想暴露谁就暴露谁，必须在 <strong>正常代码</strong> 的前面加export）</p>
<p><b>引入模块：</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>方法<span class="number">1</span>:  <span class="keyword">import</span> &#123;xxx,yyy&#125; <span class="keyword">from</span> <span class="string">&#x27;./module1&#x27;</span></span><br><span class="line"><span class="number">2.</span>方法<span class="number">2</span>:  <span class="keyword">import</span> module3 <span class="keyword">from</span> <span class="string">&#x27;./module3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 导入默认</span></span><br><span class="line"><span class="keyword">import</span> defaultModule <span class="keyword">from</span> <span class="string">&#x27;./myModule&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 导入指定的一个</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Emp</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./myModule&#x27;</span></span><br><span class="line"><span class="comment">// 导入指定的多个</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Emp</span>, person&#125; <span class="keyword">from</span> <span class="string">&#x27;./myModule&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 导入所有</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> allFromModule <span class="keyword">from</span> <span class="string">&#x27;./myModule&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>➡️ ES6 模块与 CommonJS 模块的差异</strong><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220627001731.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220627002132.png"></p>
<p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><p>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</p>
</li>
<li><p>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</p>
</li>
<li><p>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重</p>
</li>
<li><p><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</strong></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue面经二三事</title>
    <url>/2022/06/15/Vue%E9%9D%A2%E7%BB%8F%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="1-v-if和v-for哪个优先级更高？"><a href="#1-v-if和v-for哪个优先级更高？" class="headerlink" title="1.v-if和v-for哪个优先级更高？"></a>1.v-if和v-for哪个优先级更高？</h2><p>回答：</p>
<ol>
<li><p>在<code>Vue2</code>中<code>v-for</code>的优先级高于<code>v-if</code>，在<code>Vue3</code>中刚好相反，<code>v-for</code>的优先级低于<code>v-if</code>。</p>
</li>
<li><p>文档中明确指出<b style='color:red'>永远不要把<code>v-for</code>和<code>v-if</code>同时用在同一个元素上</b>。二者同时使用时，从输出的渲染函数可以看出会先执行循环再判断条件，在循环的过程中多次对DOM元素进行添加或删除，这样会造成大量性能的消耗。</p>
</li>
<li><p>实际开发过程中对<code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>通常存在两种解决方法：<br>①将<code>v-if</code>的判断过程移到外部计算中，先对数据进行计算筛选出要展示的数据。<br>②此时把 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>、<code>ol</code>)即可。</p>
</li>
</ol>
<p>在<code>Vue2</code>和<code>Vue3</code>中对语句</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;item.isActive&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; item.name &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>的渲染函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue2</span></span><br><span class="line">ƒ <span class="title function_">anonymous</span>(<span class="params"></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">with</span>(<span class="params"><span class="variable language_">this</span></span>)&#123;<span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;app&quot;</span>&#125;&#125;,<span class="title function_">_l</span>((items),<span class="keyword">function</span>(<span class="params">item</span>)&#123;<span class="keyword">return</span> (item.<span class="property">isActive</span>)?<span class="title function_">_c</span>(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">key</span>:item.<span class="property">id</span>&#125;,[<span class="title function_">_v</span>(<span class="string">&quot;\n      &quot;</span>+<span class="title function_">_s</span>(item.<span class="property">name</span>)+<span class="string">&quot;\n    &quot;</span>)]):<span class="title function_">_e</span>()&#125;),<span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue3</span></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">anonymous</span>(<span class="params"></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> _Vue = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache</span>) &#123;</span><br><span class="line">  <span class="keyword">with</span> (_ctx) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">renderList</span>: _renderList, <span class="title class_">Fragment</span>: _Fragment, <span class="attr">openBlock</span>: _openBlock, <span class="attr">createElementBlock</span>: _createElementBlock, <span class="attr">toDisplayString</span>: _toDisplayString, <span class="attr">createCommentVNode</span>: _createCommentVNode &#125; = _Vue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shouldShowUsers</span><br><span class="line">      ? (<span class="title function_">_openBlock</span>(<span class="literal">true</span>), <span class="title function_">_createElementBlock</span>(_Fragment, &#123; <span class="attr">key</span>: <span class="number">0</span> &#125;, <span class="title function_">_renderList</span>(items, <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">key</span>: item.<span class="property">id</span> &#125;, <span class="title function_">_toDisplayString</span>(item.<span class="property">name</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>))</span><br><span class="line">        &#125;), <span class="number">128</span> <span class="comment">/* KEYED_FRAGMENT */</span>))</span><br><span class="line">      : <span class="title function_">_createCommentVNode</span>(<span class="string">&quot;v-if&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="2-v-for中key的作用是什么？"><a href="#2-v-for中key的作用是什么？" class="headerlink" title="2. v-for中key的作用是什么？"></a>2. v-for中key的作用是什么？</h2><p>回答：</p>
<ol>
<li><p>key的作用主要是为了更高效的更新虚拟DOM。</p>
</li>
<li><p>vue在patch过程中<b style='color:red'>判断两个节点是否是相同节点key是一个必要条件</b>。从源码中可以知道，vue判断两个节点是否相同时主要判断两者的key和元素类型等，因此如果不设置key，它的值就是undefined，则可能永远认为这是两个相同节点，只能去做更新操作，这造成了大量的dom更新操作，明显是不可取的。</p>
</li>
<li><p>实际使用中在渲染一组列表时key必须设置，并且必须是唯一标识，应该避免使用index作为key值，使用index作为key值可能会导致一些隐藏的bug；在vue中使用相同元素标签过渡切换时，也会使用key属性，其目的是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220615095710.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220615095750.png"></p>
<h2 id="3-双向数据绑定以及它的实现原理？"><a href="#3-双向数据绑定以及它的实现原理？" class="headerlink" title="3.双向数据绑定以及它的实现原理？"></a>3.双向数据绑定以及它的实现原理？</h2><p>回答：</p>
<ol>
<li>vue中双向数据绑定是通过指令<code>v-model</code>实现的，可以绑定一个动态数值到视图，同时视图中的变化也能改变这个数值。<code>v-model</code>是语法糖，默认情况下相当于<code>:value和@input</code>。</li>
<li>通常在表单项上使用<code>v-model</code>，原生的表单项可以直接使用<code>v-model</code>，自定义组件上如果要使用需要在组建内绑定value并且处理输入事件。</li>
<li>输出包含<code>v-model</code>模板的渲染函数，<b style='color:red'>发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应的变量更新操作</b>。</li>
<li>使用<code>v-model</code>可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好。</li>
</ol>
<p>后续追问：<br>1.v-model和sync修饰符有什么区别？<br>2.</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【8】JS中的 ‘==’ 隐式转换规则</title>
    <url>/2022/06/12/8-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-JS%E4%B8%AD%E7%9A%84%E2%80%98==%E2%80%99%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="✍-转换关系图"><a href="#✍-转换关系图" class="headerlink" title="✍ 转换关系图"></a>✍ 转换关系图</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220612145432.png"><br>1.对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字<br>2.对象和字符串进行比较时，对象转换为字符串，然后两者进行比较<br>3.对象和数字比较时，对象转化为字符串,然后转换为数字，再和数字进行比较<br>4.字符串和数字比较时，字符串转换为数字<br>5.字符串和布尔值进行比较时，二者全部转换成数值再比较<br>6.布尔值和数字进行比较时，布尔转换为数字</p>
<h2 id="✍-五条重要规则："><a href="#✍-五条重要规则：" class="headerlink" title="✍ 五条重要规则："></a>✍ 五条重要规则：</h2><ol>
<li><code>NaN</code>和其他任何类型比较永远返回<code>false</code>（包括它自己）</li>
</ol>
<p><code>NaN == NaN</code> ➡️ <code>false</code></p>
<ol start="2">
<li><p><code>Boolean</code>和其他任何类型比较，<code>Boolean</code>都会首先被转换为<code>Number</code></p>
</li>
<li><p><code>String</code>和<code>Number</code>进行比较，现将 <code>String</code>转换为<code>Number</code>类型</p>
</li>
<li><p><code>null == undefined</code>结果为<code>true</code>，除此之外，和其他任何类型比较结果都为<code>false</code></p>
</li>
<li><p>原始类型和引用类型做比较时，引用类型会依照<code>ToPrimitive</code>规则转换为原始类型（<code>ToPrimitive</code>规则是引用数据类型向原始类型转换的规则，它遵循先<code>valueOf</code>后<code>toString</code>的模式期望得到一个原始类型）</p>
</li>
</ol>
<h2 id="✍-数学运算中的类型转换"><a href="#✍-数学运算中的类型转换" class="headerlink" title="✍ 数学运算中的类型转换"></a>✍ 数学运算中的类型转换</h2><p>对各种非<code>NUmber</code>类型进行 （-*/）运算时，会现将非<code>Number</code>类型转换为<code>Number</code>类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>-<span class="literal">true</span> <span class="comment">// 0,先将true转化为数字1</span></span><br><span class="line"><span class="number">1</span>-<span class="literal">null</span> <span class="comment">//1,先将null转换为数字0</span></span><br><span class="line"><span class="number">1</span>*<span class="literal">undefined</span> <span class="comment">//NaN,先将undefined转化为数字NaN</span></span><br><span class="line"><span class="number">2</span>*[<span class="string">&#x27;5&#x27;</span>] <span class="comment">// [&#x27;5&#x27;]首先会转换为&#x27;5&#x27;，然后再转化为数字5</span></span><br></pre></td></tr></table></figure>
<p>✨ <b>加法的特殊性</b><br>①一侧为<code>String</code>,被识别为字符串拼接。 <code>123+&#39;123&#39;=&#39;123123&#39;</code><br>②一侧为<code>Number</code>，另一侧为原始类型，将原始类型转换为<code>Number</code>。<code>123+true = 124; 123+null=123</code><br>③一侧为<code>Number</code>，另一侧为引用数据类型，先将引用数据类型和<code>Number</code>转换为字符串，然后拼接。<code>123+&#123;&#125;=&#39;123[object object]&#39; </code></p>
<h2 id="✍-逻辑语句中的类型转换"><a href="#✍-逻辑语句中的类型转换" class="headerlink" title="✍ 逻辑语句中的类型转换"></a>✍ 逻辑语句中的类型转换</h2><p>单个变量：只有<code>null、undefined、&#39;&#39;、NaN、0、false</code>的结果为<code>false</code>，其余的结果为<code>true</code>(比如，<code>&#123;&#125;、[]</code>)</p>
<h2 id="✍-重点"><a href="#✍-重点" class="headerlink" title="✍ 重点"></a>✍ 重点</h2><p><code>&#123;&#125;</code>转换为字符串是<code>[object,object]</code></p>
<p><code>[object,object]</code>转换为数值是<code>NaN</code></p>
<p><code>null==undefined</code>结果为<code>true</code>，除此之外和其他任何值比较的结果都为<code>false</code></p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【7】图片懒加载</title>
    <url>/2022/05/24/7-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>图片懒加载，顾名思义，就是滑动页面到能看到图片的时候再加载图片。</p>
<p>对于图片懒加载而言，可以分为两部分进行考虑：①判断图片进入到可视窗口 ②控制图片进行加载</p>
<h1 id="0-为什么懒加载？"><a href="#0-为什么懒加载？" class="headerlink" title="0. 为什么懒加载？"></a>0. 为什么懒加载？</h1><p>对于首屏之外的内容，特别是图片和视频，一方面由于资源文件很大，若是全部加载完成，既费时又费力，还容易阻塞渲染引起卡顿；另一方面，就算加载完成用户也不一定浏览到全部内容，如果首屏没有吸引到用户，很可能整个页面都会被关闭。<br>所以，在首次打开网站时，应尽量只加载首屏内容，首屏之外的图片或视频可以等到用户滑动到的时候再加载。</p>
<h1 id="1-实现方式："><a href="#1-实现方式：" class="headerlink" title="1. 实现方式："></a>1. 实现方式：</h1><h2 id="方式一：位置计算-监听滚动事件-DataSet-API"><a href="#方式一：位置计算-监听滚动事件-DataSet-API" class="headerlink" title="方式一：位置计算 + 监听滚动事件 + DataSet API"></a>方式一：位置计算 + 监听滚动事件 + DataSet API</h2><p>👉 判断图片出现在窗口中需要用到<code>clientTop</code>，<code>offsetTop</code>，<code>clientHeight</code> 以及 <code>scrollTop</code> 各种关于图片的高度作比对<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220524151700.png"><br>（一堆东西也记不住，不如，放过自己？）</p>
<p>👉 监听 <code>window.scroll</code> 事件</p>
<p>👉 控制图片加载</p>
<p><code>&lt;img data-src=&quot;shanyue.jpg&quot;&gt;</code></p>
<p>首先设置一个临时 <code>Data</code> 属性 <code>data-src</code>，控制加载时使用 <code>src</code> 代替 <code>data-src</code>，可利用 <code>DataSet API</code> 实现</p>
<p><code>img.src = img.datset.src</code></p>
<h2 id="方式二：getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API"><a href="#方式二：getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API" class="headerlink" title="方式二：getBoundingClientRect API + Scroll with Throttle + DataSet API"></a>方式二：getBoundingClientRect API + Scroll with Throttle + DataSet API</h2><p>👉 <code> getBoundingClientRecy()</code>函数获取元素的相对位置。<br>getBoundingClientRecy().top 、 getBoundingClientRecy().bottom 、 getBoundingClientRecy().left 、 getBoundingClientRecy().right<br>位置如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220524160129.png"></p>
<p>如何判断图片出现在了当前视口？</p>
<p><code> img.getBoundingClientRect().top &lt; document.documentElement.clientHeight</code></p>
<p>👉 优化<code>window.scroll</code>事件<br>加个节流器，提高性能。工作中一般使用 lodash.throttle 就可以了。</p>
<p><code>_.throttle(func, [wait=0], [options=&#123;&#125;])</code></p>
<p>👉 控制图片加载 同方式一</p>
<h2 id="方式三：IntersectionObserver-API-DataSet-API"><a href="#方式三：IntersectionObserver-API-DataSet-API" class="headerlink" title="方式三：IntersectionObserver API + DataSet API"></a>方式三：IntersectionObserver API + DataSet API</h2><p>⚡ 方案二使用的方法是: <code>window.scroll</code> 监听 <code>Element.getBoundingClientRect()</code> 并使用 <code>_.throttle</code> 节流</p>
<p>👉 一系列组合动作太复杂了，于是浏览器出了一个三合一事件:   <code>Intersection Observer API</code>，一个能够监听元素是否到了当前视口的事件，一步到位！</p>
<p>关于<code>Intersection Observer API</code>的简述：<br>每当因页面滚动或者窗口尺寸发生变化，使得目标元素（target）与设备视窗或其他指定元素产生交集时，便会触发<code>Intersection Observer API</code>配置的回调函数，在该回调函数中进行延迟加载的逻辑处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">changes</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// changes: 目标元素集合</span></span><br><span class="line">  changes.<span class="title function_">forEach</span>(<span class="function">(<span class="params">change</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// intersectionRatio</span></span><br><span class="line">    <span class="keyword">if</span> (change.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> img = change.<span class="property">target</span></span><br><span class="line">      img.<span class="property">src</span> = img.<span class="property">dataset</span>.<span class="property">src</span></span><br><span class="line">      observer.<span class="title function_">unobserve</span>(img)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(img)</span><br></pre></td></tr></table></figure>

<h2 id="方式四：LazyLoading属性"><a href="#方式四：LazyLoading属性" class="headerlink" title="方式四：LazyLoading属性"></a>方式四：LazyLoading属性</h2><p>浏览器觉得懒加载这事可以交给自己做，你们开发者加个属性就好了。缺点就是兼容性存在问题。<br><code> &lt;img src=&quot;shanyue.jpg&quot; loading=&quot;lazy&quot;&gt;</code></p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【6】this指向问题</title>
    <url>/2022/05/06/6-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220506102501.png"></p>
<blockquote>
<p>重要的事情说三遍：<b style="color:red">this 永远指向最后调用它的那个对象</b>、<b style="color:red">this 永远指向最后调用它的那个对象</b>、<b style="color:red">this 永远指向最后调用它的那个对象</b>。</p>
</blockquote>
<h2 id="1-this的六道坎"><a href="#1-this的六道坎" class="headerlink" title="1. this的六道坎"></a>1. this的六道坎</h2><p><em>（偶然间读到一篇超级nice的博客，觉得比我之前写的棒多了，so，毫不犹豫的转载过来。<a href="https://blog.crimx.com/2016/05/12/understanding-this/">👉博客原文</a>）</em></p>
<blockquote>
<p>this is all about context.</p>
</blockquote>
<p>说白了<code>this</code>就是找大佬，找拥有当前上下文（<code>context</code>）的对象（<code>context object</code>）。<br>大佬可以分为六层，层数越高权力越大，<code>this</code>只会认最大的。</p>
<h4 id="第一层：世界的尽头"><a href="#第一层：世界的尽头" class="headerlink" title="第一层：世界的尽头"></a>第一层：世界的尽头</h4><p>权力最小的大佬是作为备胎的存在，在普通情况下就是全局，浏览器里就是<code>window</code>；在<code>use strict</code>的情况下就是<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showThis</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showStrictThis</span> () &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showThis</span>() <span class="comment">// window</span></span><br><span class="line"><span class="title function_">showStrictThis</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="第二层：点石成金"><a href="#第二层：点石成金" class="headerlink" title="第二层：点石成金"></a>第二层：点石成金</h4><p>第二层大佬说白了就是找这个函数前面的点<code>.</code>。</p>
<p>如果用到<code>this</code>的那个函数是属于某个 <code>context object</code> 的，那么这个 <code>context object</code> 绑定到<code>this</code>。</p>
<p>比如下面的例子，<code>boss</code>是<code>returnThis</code>的 <code>context object</code> ，或者说<code>returnThis</code>属于<code>boss</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> boss = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;boss&#x27;</span>,</span><br><span class="line">  returnThis () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boss.<span class="title function_">returnThis</span>() === boss <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>下面这个例子就要小心点咯，能想出答案么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> boss1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;boss1&#x27;</span>,</span><br><span class="line">  returnThis () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;boss2&#x27;</span>,</span><br><span class="line">  returnThis () &#123;</span><br><span class="line">    <span class="keyword">return</span> boss1.<span class="title function_">returnThis</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss3 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;boss3&#x27;</span>,</span><br><span class="line">  returnThis () &#123;</span><br><span class="line">    <span class="keyword">var</span> returnThis = boss1.<span class="property">returnThis</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">returnThis</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boss1.<span class="title function_">returnThis</span>() <span class="comment">// boss1</span></span><br><span class="line">boss2.<span class="title function_">returnThis</span>() <span class="comment">// ?</span></span><br><span class="line">boss3.<span class="title function_">returnThis</span>() <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>
<p>答案是<code>boss1</code>和<code>window</code>哦，猜对了吗。</p>
<p>只要看使用<code>this</code>的那个函数。</p>
<p>在<code>boss2.returnThis</code>里，使用<code>this</code>的函数是<code>boss1.returnThis</code>，所以<code>this</code>绑定到<code>boss1</code>；</p>
<p>在<code>boss3.returnThis</code>里，使用<code>this</code>的函数是<code>returnThis</code>，所以<code>this</code>绑定到备胎。</p>
<p>要想把<code>this</code>绑定到<code>boss2</code>怎么做呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> boss1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;boss1&#x27;</span>,</span><br><span class="line">  returnThis () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;boss2&#x27;</span>,</span><br><span class="line">  <span class="attr">returnThis</span>: boss1.<span class="property">returnThis</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boss2.<span class="title function_">returnThis</span>() <span class="comment">//boss2</span></span><br></pre></td></tr></table></figure>
<p>没错，只要让使用<code>this</code>的函数是属于<code>boss2</code>就行。</p>
<h4 id="第三层：指腹为婚"><a href="#第三层：指腹为婚" class="headerlink" title="第三层：指腹为婚"></a>第三层：指腹为婚</h4><p>第三层大佬是<code>Object.prototype.call</code>和<code>Object.prototype.apply</code>，它们可以通过参数指定<code>this</code>。（注意<code>this</code>是不可以直接赋值的哦，<code>this = 2</code>会报<code>ReferenceError</code>。）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnThis</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;boss1&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">returnThis</span>() <span class="comment">// window</span></span><br><span class="line">returnThis.<span class="title function_">call</span>(boss1) <span class="comment">// boss1</span></span><br><span class="line">returnThis.<span class="title function_">apply</span>(boss1) <span class="comment">// boss1</span></span><br></pre></td></tr></table></figure>
<h4 id="第四层：海誓山盟"><a href="#第四层：海誓山盟" class="headerlink" title="第四层：海誓山盟"></a>第四层：海誓山盟</h4><p>第四层大佬是<code>Object.prototype.bind</code>，他不但通过一个新函数来提供永久的绑定，<b style="color:red">还会覆盖第三层大佬的命令【即：<code>bind（）</code>提供永久绑定，会覆盖<code>call()</code>和<code>apply()</code>】</b>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnThis</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;boss1&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss1returnThis = returnThis.<span class="title function_">bind</span>(boss1)</span><br><span class="line"></span><br><span class="line"><span class="title function_">boss1returnThis</span>() <span class="comment">// boss1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;boss2&#x27;</span> &#125;</span><br><span class="line">boss1returnThis.<span class="title function_">call</span>(boss2) <span class="comment">// still boss1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第五层：内有乾坤"><a href="#第五层：内有乾坤" class="headerlink" title="第五层：内有乾坤"></a>第五层：内有乾坤</h4><p>一个比较容易忽略的会绑定<code>this</code>的地方就是<code>new</code>。当我们<code>new</code>一个函数时，就会自动把<code>this</code>绑定在新对象上，然后再调用这个函数。<b style="color:red">它会覆盖<code>bind()</code>的绑定</b>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showThis</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showThis</span>() <span class="comment">// window</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">showThis</span>() <span class="comment">// showThis</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;boss1&#x27;</span> &#125;</span><br><span class="line">showThis.<span class="title function_">call</span>(boss1) <span class="comment">// boss1</span></span><br><span class="line"><span class="keyword">new</span> showThis.<span class="title function_">call</span>(boss1) <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss1showThis = showThis.<span class="title function_">bind</span>(boss1)</span><br><span class="line"><span class="title function_">boss1showThis</span>() <span class="comment">// boss1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">boss1showThis</span>() <span class="comment">// showThis</span></span><br></pre></td></tr></table></figure>

<h4 id="第六层：军令如山"><a href="#第六层：军令如山" class="headerlink" title="第六层：军令如山"></a>第六层：军令如山</h4><p>最后一个法力无边的大佬就是 <code>ES2015</code> 的箭头函数。箭头函数里的<code>this</code>不再妖艳，被永远封印到当前词法作用域之中，称作 <code>Lexical this</code> ，在代码运行前就可以确定。没有其他大佬可以覆盖。</p>
<p>这样的好处就是方便让回调函数的<code>this</code>使用当前的作用域，不怕引起混淆。</p>
<p>所以对于箭头函数，只要看它在哪里创建的就行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span> (cb) &#123;</span><br><span class="line">  <span class="title function_">cb</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">callback</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125;) <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;boss1&#x27;</span>,</span><br><span class="line">  <span class="attr">callback</span>: callback,</span><br><span class="line">  callback2 () &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boss1.<span class="title function_">callback</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125;) <span class="comment">// still window</span></span><br><span class="line">boss1.<span class="title function_">callback2</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125;) <span class="comment">// boss1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面这种奇葩的使用方式就需要注意：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">returnThis</span> = (<span class="params"></span>) =&gt; <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">returnThis</span>() <span class="comment">// window</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">returnThis</span>() <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;boss1&#x27;</span>,</span><br><span class="line">  returnThis () &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">func</span> = (<span class="params"></span>) =&gt; <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">func</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnThis.<span class="title function_">call</span>(boss1) <span class="comment">// still window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss1returnThis = returnThis.<span class="title function_">bind</span>(boss1)</span><br><span class="line"><span class="title function_">boss1returnThis</span>() <span class="comment">// still window</span></span><br><span class="line"></span><br><span class="line">boss1.<span class="title function_">returnThis</span>() <span class="comment">// boss1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boss2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;boss2&#x27;</span>,</span><br><span class="line">  <span class="attr">returnThis</span>: boss1.<span class="property">returnThis</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boss2.<span class="title function_">returnThis</span>() <span class="comment">// boss2</span></span><br></pre></td></tr></table></figure>
<p>如果你不知道最后为什么会是 boss2，继续理解<b style="color:red;"> “对于箭头函数，只要看它在哪里创建”</b>这句话。</p>
<h2 id="2-改变this指向的方法"><a href="#2-改变this指向的方法" class="headerlink" title="2.改变this指向的方法"></a>2.改变<code>this</code>指向的方法</h2><ul>
<li>ES6 的箭头函数</li>
<li>函数内部使用 <code>_this = this</code></li>
<li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li>
<li><code>new</code> 实例化一个对象</li>
</ul>
<p>⭐ 箭头函数<br><b>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</b></p>
<blockquote>
<p>箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">&quot;Cherry&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">func1</span>()</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">func2</span>()     <span class="comment">// Cherry</span></span><br></pre></td></tr></table></figure>

<p>⭐ 函数内部使用 <code>_this = this</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line"></span><br><span class="line">    name : <span class="string">&quot;Cherry&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            _this.<span class="title function_">func1</span>()</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">func2</span>()       <span class="comment">// Cherry</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，在 <code>func2</code> 中，首先设置 <code>var _this = this;</code>，这里的 <code>this</code> 是调用 <code>func2</code> 的对象 <code>a</code>，为了防止在 <code>func2</code> 中的 <code>setTimeout</code> 被 <code>window</code> 调用而导致的在 <code>setTimeout</code> 中的 <code>this</code> 为 <code>window</code>。我们将 <code>this</code>(指向变量 a) 赋值给一个变量 <code>_this</code>，这样，在 <code>func2</code> 中我们使用 <code>_this</code> 就是指向对象 <code>a</code> 了。</p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Set、Map、WeakSet、WeakMap的二三事</title>
    <url>/2022/04/25/%E5%85%B3%E4%BA%8ESet%E3%80%81Map%E3%80%81WeakSet%E3%80%81WeakMap%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h2><p>特征：</p>
<ol>
<li>成员不能重复</li>
<li>只有键值，没有键名，有点类似于数组</li>
<li>可以遍历</li>
</ol>
<p><code>console.log(Set.prototype)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220425144545.png"></p>
<p>对于<code>Set</code>应该明确的几点：</p>
<p><b>⭐ 不重复</b><br>在js中判断元素相等的方法有两种：<code>===</code>和 <code>Object.is</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>  <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span> , <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span> , -<span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>我们不妨来看一下，<code>Set</code>遵循哪种原则呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="title class_">NaN</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="title class_">NaN</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">0</span>);</span><br><span class="line">set.<span class="title function_">add</span>(-<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220425145751.png"></p>
<p>可以看到，在<code>Set</code>中，认为<code>NaN</code>是相等的，认为<code>+0</code>和<code>-0</code>也是相等的，所以才会说<code>Set</code>中成员是<b style="color:red;">不重复的。</b></p>
<p><b>⭐ 数组 ⇌ Set</b></p>
<p>数组转换为<code>Set</code>：<code>new Set([1,2,3])</code></p>
<p><code>Set</code>转换为数组：<code>[...set]</code></p>
<h2 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2.WeakSet"></a>2.WeakSet</h2><p>特征：</p>
<ol>
<li>成员都是对象（<code>Object</code>或者继承自<code>Object</code>的类型），尝试其他值会抛出<code>TypeError</code></li>
<li>WeakSet是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存DOM节点，不容易造成内存泄漏</li>
<li>不能遍历</li>
</ol>
<p><code>console.log(WeakSet.prototype)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220425151232.png"></p>
<p>对于<code>WeakSet</code>需要明确几点：</p>
<p><b>⭐ 何为 强引用 &amp; 弱引用？</b></p>
<p>对于一个全局变量<code>var key = &#123;&#125;</code>，JS垃圾回收器不能自动将其回收，若想要释放内存，则需让 <code>key = null</code>。</p>
<p>※ 强引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = &#123; <span class="attr">name</span>: <span class="string">&quot;Kitty&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> pets = [cat];</span><br><span class="line"></span><br><span class="line">cat = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pets); <span class="comment">// [&#123; name: &quot;Kitty&quot; &#125;]</span></span><br></pre></td></tr></table></figure>
<p>通过将变量 <code>cat</code> 创建为对象，并把这个对象放入一个数组 <code>pets</code> 中，然后通过将它的值设置为 <code>null</code> 来删除其对原始对象的引用。</p>
<p>尽管我们再也无法访问 <code>cat</code> 变量，但由于在 <code>pets</code> 数组和这个对象之间存在<b>强引用关系</b>，因此这个对象其实仍保留在内存中，并且可以通过 <code>pets[0]</code> 访问到它。 换句话说，<b>强引用可以防止垃圾回收从内存中删除对象。</b></p>
<p>※ 弱引用</p>
<p>弱引用是对对象的引用，如果它还是对内存中对象的唯一引用，就能顺利地进行垃圾回收。相反，一般强引用都会防止垃圾回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pets = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> cat = &#123; <span class="attr">name</span>: <span class="string">&quot;Kitty&quot;</span> &#125;;</span><br><span class="line">pets.<span class="title function_">set</span>(cat, <span class="string">&quot;Kitty&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pets); <span class="comment">// WeakMap &#123;&#123;…&#125; =&gt; &#x27;Kitty&#x27;&#125;</span></span><br><span class="line">cat = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待垃圾回收后</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pets); <span class="comment">// WeakMap&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过利用 <code>WeakMap</code> 及其附带的弱引用，我们可以看到两种类型的引用之间的差异。虽然对原始 <code>cat</code> 对象的强引用仍然存在，但 <code>cat</code> 对象仍然存在于 <code>WeakMap</code> 中，我们可以毫无问题地访问它。</p>
<p>但是，当我们通过将 <code>cat</code>变量重新赋值 <code>null</code> 来覆盖对原始 <code>cat</code> 对象的引用时，由于内存中对原始对象的唯一引用是来自我们创建的 <code>WeakMap</code> 的弱引用，所以它不会阻止垃圾回收的发生。这意味着当 <code>JavaScript</code> 引擎再次运行垃圾回收过程时，<code>cat</code> 对象将从内存和我们分配给它的 <code>WeakMap</code> 中删除。</p>
<p><b>因此这里的关键区就别在于</b>，强引用可以防止对象进行垃圾回收，而弱引用则不会。</p>
<p>默认情况下，<b style="color:red;">JavaScript 对其所有引用使用强引用，使用弱引用的唯一方法是使用 WeakMap 或 WeakSet。</b></p>
<h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h2><p>特征：</p>
<ol>
<li>本质上是键值对</li>
<li>可以遍历</li>
</ol>
<p>Q：<code>Object</code>与<code>Map</code>的区别？</p>
<ul>
<li>键的类型：<code>Object</code>的key值必须是<code>String</code>、<code>Number</code>或者<code>Symbol</code>，<code>Map</code>的键可以是JavaScript支持的所有类型。</li>
<li>元素顺序：<code>Map</code> 元素的顺序遵循插入的顺序，而 <code>Object</code> 的则没有这一特性。</li>
<li>继承：<code>Map</code> 继承自 <code>Object</code> 对象。</li>
</ul>
<h2 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4.WeakMap"></a>4.WeakMap</h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【5】闭包</title>
    <url>/2022/04/24/5-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="1-什么是闭包？"><a href="#1-什么是闭包？" class="headerlink" title="1.什么是闭包？"></a>1.什么是闭包？</h2><p>在JavaScript中，函数内部可以读取全局变量，在函数外部却无法读取函数内的局部变量。</p>
<p>闭包指的是<b>有权访问另外一个函数作用域中的变量的函数</b>，也就是能够读取其他函数内部变量的函数。<br>⭐ <b style="color:red;">闭包的本质是函数，有权访问另外一个函数作用域中的变量的函数</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">999</span>; </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=<span class="title function_">f1</span>();</span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，函数<code>f2</code>定义在函数<code>f1</code>的作用域内，因此<code>f1</code>内部的局部变量对<code>f2</code>是可见的，但<code>f2</code>内部的局部变量对<code>f1</code>是不可见的。那么只要把<code>f2</code>作为<code>f1</code>的返回值，就可以在<code>f1</code>外部读取它的内部变量了。</p>
<p>⭐ 父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<h3 id="1-1-闭包的作用"><a href="#1-1-闭包的作用" class="headerlink" title="1.1 闭包的作用"></a>1.1 闭包的作用</h3><ul>
<li>使函数的内部变量(函数)在函数执行完后，仍然存活在内存中，延长了局部变量的生命周期</li>
<li>将变量(函数)定义在闭包中使用，避免污染全局变量</li>
<li>定义JS模块</li>
</ul>
<h3 id="1-2-闭包的缺点"><a href="#1-2-闭包的缺点" class="headerlink" title="1.2 闭包的缺点"></a>1.2 闭包的缺点</h3><p>函数执行完后，函数内的变量没有释放，占用内存时间会变长，容易造成内存泄露</p>
<h2 id="2-闭包存在的问题"><a href="#2-闭包存在的问题" class="headerlink" title="2.闭包存在的问题"></a>2.闭包存在的问题</h2><p>使用闭包的时候，①引用的变量可能发生变化 ②this指向的问题</p>
<h3 id="2-1-引用变量的变化"><a href="#2-1-引用变量的变化" class="headerlink" title="2.1 引用变量的变化"></a>2.1 引用变量的变化</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span> () &#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="function">() =&gt;</span> i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">outer</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x[i]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为每个闭包函数访问变量i是outer执行环境下的变量i，随着循环的结束，i已经变成10了，所以执行每个闭包函数，结果打印10， 10， …， 10。<br>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span> () &#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">outer</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// [0, 1, 2, 3, 4,5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p>此时访问的num，是上层函数执行环境的num，数组有10个函数对象，每个对象的执行环境下的number都不一样。</p>
<h3 id="2-2-this的指向"><a href="#2-2-this的指向" class="headerlink" title="2.2  this的指向"></a>2.2  this的指向</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;object&quot;</span>，</span><br><span class="line">  getName： <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">object.<span class="title function_">getName</span>()()    <span class="comment">// underfined</span></span><br></pre></td></tr></table></figure>
<p>因为里面的闭包函数是在window作用域下执行的，也就是说，this指向windows，打印undefined。</p>
<p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">    getName : <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">object.<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<p>使用that指向object,指定了匿名函数调用时的this指向对象。</p>
<p>闭包会使得 函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>同时闭包会在 父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>get、post和put的区别</title>
    <url>/2022/04/21/get%E3%80%81post%E5%92%8Cput%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="1-get请求和post请求的区别"><a href="#1-get请求和post请求的区别" class="headerlink" title="1.get请求和post请求的区别"></a>1.get请求和post请求的区别</h2><ol>
<li>get用来获取数据，post用来提交数据</li>
<li>参数长度限制：get参数有长度限制（受限于url长度，具体数值取决于浏览器和服务器的限制，最长2048字节），get请求的参数会附加在url之后，以”?”分割url和传输数据，多个参数通过”&amp;”连接；post参数无长度限制，会把参数放在http请求体中</li>
<li>安全：get是明文传输，post请求可以通过抓包工具看到，也相当于是明文的</li>
<li>缓存：get能够被缓存，会保存在浏览器历史记录中，还可能保存在web服务器的日志中；post不能被缓存</li>
<li>效率：get请求的速度比post请求速度快，get请求执行效率却比post方法好，原因：post在真正接收数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据。</li>
</ol>
<h2 id="2-post和put的区别"><a href="#2-post和put的区别" class="headerlink" title="2.post和put的区别"></a>2.post和put的区别</h2><ol>
<li>put操作需要明确知道操作的对象，如果对象不存在会创建对象，如果对象存在，则会全部替换目标对象；post请求并不知道要操作的对象，post创建对象时，由http服务器为新创建的对象生成一个唯一的uri，post修改对象时，一般只修改目标对象的部分内容。</li>
<li>put操作是幂等的，post操作是非幂等的。</li>
</ol>
<h4 id="何为幂等？"><a href="#何为幂等？" class="headerlink" title="何为幂等？"></a>何为幂等？</h4><p>幂等（idempotent）指操作不管执行多少次，结果都不会改变。<br>例如，你到银行中存钱，在存的过程中机器出现故障，执行多次存钱数据写入操作，但是最终你还是账户还是仅仅多出你存入的金额，存钱的操作就是幂等的。类似于<code>x=1</code>的操作，不管你执行多少次，结果都是<code>x=1</code>.</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack5学习笔记</title>
    <url>/2022/04/20/Webpack5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>视频地址：<a href="https://www.bilibili.com/video/BV14T4y1z7sw?p=3&share_source=copy_web">尚硅谷2022版Webpack5入门到原理（面试开发一条龙）</a></p>
<h1 id="上篇：基础"><a href="#上篇：基础" class="headerlink" title="上篇：基础"></a>上篇：基础</h1><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><h3 id="为什么需要打包工具？"><a href="#为什么需要打包工具？" class="headerlink" title="为什么需要打包工具？"></a>为什么需要打包工具？</h3><p>开发时，我们会使用框架（React、Vue），ES6模块化语法，Less/Sass 等css预处理器等语法进行开发。<br>这些代码在浏览器中时无法直接运行的，需要编译成浏览器能识别的JS、CSS等语法，才能运行。这就是打包工具需要完成的工作。<br>除此之外，打包工具还能<b> 压缩代码、做兼容性处理、提升代码性能 </b>等。</p>
<h3 id="常见的打包工具"><a href="#常见的打包工具" class="headerlink" title="常见的打包工具"></a>常见的打包工具</h3><p>Grunt、Webpack、Vite、Gulp、Rollup等</p>
<h1 id="1-Webpack-的基本使用"><a href="#1-Webpack-的基本使用" class="headerlink" title="1.Webpack 的基本使用"></a>1.Webpack 的基本使用</h1><p>Webpack 是<strong>一个静态资源打包工具</strong>。<br>它会以一个或者多个文件作为打包入口，将整个项目所有文件编译组合成一个或者多个文件输出出去。<br>输出的文件就是编译好的文件，可以在浏览器直接运行。我们将Webpack输出的文件叫做<code>bundle</code>。</p>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>Webpack本身功能是有限的：</p>
<ul>
<li>开发模式：仅能编译JS中的<code>ES Module</code>语法。</li>
<li>生产模式：仅能编译JS中的<code>ES Module</code>语法和压缩JS代码。</li>
</ul>
<p>因此<span style="color:red;">本身只能处理JS代码，对于其他代码的处理需要通过其他配置来实现</span>。</p>
<h3 id="开始使用（初步体验）"><a href="#开始使用（初步体验）" class="headerlink" title="开始使用（初步体验）"></a>开始使用（初步体验）</h3><ol>
<li>资源目录<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220702211636.png"></li>
<li>创建文件<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220702211721.png"></li>
<li>下载依赖</li>
</ol>
<ul>
<li><p>初始化 <code>npm init -y</code><br>此时会生成一个<code>package.json</code>文件<br>需要注意的是 <code>package.json</code> 中 <code>name</code> 字段不能叫做 <code>webpack</code>, 否则下一步会报错</p>
</li>
<li><p>下载依赖 <code>npm i webpack webpack-cli -D</code></p>
</li>
</ul>
<ol start="4">
<li>启用Webpack</li>
</ol>
<ul>
<li>开发模式：<code>npx webpack ./src/main.js --mode=development</code></li>
<li>生产模式：<code>npx webpack ./src/main.js --mode=production</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220702212252.png"></li>
</ul>
<ol start="5">
<li>观察输出文件<br>默认<code>Webpack</code>会将文件打包输出到<code>dist</code>目录下。只需查看<code>dist</code>目录下的文件情况就好。</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>Webpack 本身功能比较少，只能处理 js 资源，一旦遇到 css 等其他资源就会报错。</strong></p>
<h1 id="2-Webpack-的基本配置"><a href="#2-Webpack-的基本配置" class="headerlink" title="2.Webpack 的基本配置"></a>2.Webpack 的基本配置</h1><h3 id="5-大核心概念"><a href="#5-大核心概念" class="headerlink" title="5 大核心概念"></a>5 大核心概念</h3><ol>
<li>entry（入口）<br>指示Webpack从那个文件开始打包</li>
<li>output（输出）<br>指示Webpack打包完的文件输出到哪里去，如何命名等</li>
<li>loader（加载器）<br>Webpack本身只能处理js、json等资源，其他资源需要借助loader，Webpack才能解析</li>
<li>plugins（插件）<br>拓展Webpack的功能</li>
<li>mode（模式）<br>主要有两种：①开发模式：<code>development</code> ②生产模式：<code>production</code><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- 该文件在项目根目录下：webpack.config.js -- */</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>); <span class="comment">//nodejs核心模块，专门用来处理路径问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✨ Webpack 是基于 Node.js 运行的，所以采用 Common.js 模块化规范</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>, <span class="comment">// 相对路径</span></span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 文件的输出路径</span></span><br><span class="line">    <span class="comment">// __dirname nodejs的变量，代表当前文件的文件夹目录</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>), <span class="comment">// 绝对路径</span></span><br><span class="line">    <span class="comment">// 文件的输出名称</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载器</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// loader配置</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插件</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// plugin配置</span></span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>Webpack 是基于 Node.js 运行的，所以采用 Common.js 模块化规范</strong><br>运行指令：<code>npx webpack</code></p>
<h1 id="3-开发模式介绍"><a href="#3-开发模式介绍" class="headerlink" title="3.开发模式介绍"></a>3.开发模式介绍</h1><p>顾名思义，就是开发代码时使用的模式。<br>主要完成两件事：</p>
<ol>
<li>编译代码，是浏览器能够运行<br>开发时有样式资源、字体图标、图片资源、html资源等，webpack默认都不能处理这些资源，所以要加载配置来编译这些资源。</li>
<li>代码质量检查，树立代码规范<br>提前检查代码的一些隐患，让代码运行时更加健壮。<br>提前检查代码规范和格式，统一团队内编码风格。</li>
</ol>
<h1 id="4-处理样式资源"><a href="#4-处理样式资源" class="headerlink" title="4.处理样式资源"></a>4.处理样式资源</h1><p>需要借助Loader来帮助Webpack解析样式资源。</p>
<h3 id="处理CSS资源"><a href="#处理CSS资源" class="headerlink" title="处理CSS资源"></a>处理CSS资源</h3><ol>
<li>下载包 <code>npm i css-loader style-loader -D</code></li>
<li>功能介绍</li>
</ol>
<ul>
<li>css-loader：负责将 Css 文件编译成 Webpack 能识别的模块</li>
<li>style-loader：会动态创建一个 Style 标签，里面放置 Webpack 中 Css 模块内容<br>此时样式就会以 Style 标签的形式在页面上生效</li>
</ul>
<ol start="3">
<li><p>配置<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703001507.png"></p>
</li>
<li><p>添加CSS资源<br>创建CSS文件，编写样式 ➡️ 在webpack入口文件引入（<code>entry:&quot;./src/main.js&quot;</code>）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703001758.png"></p>
</li>
<li><p>运行指令<code>npx webpack</code><br>此时可以在网页源代码中看到样式文件的内容<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703001924.png"></p>
</li>
</ol>
<h3 id="处理Less资源"><a href="#处理Less资源" class="headerlink" title="处理Less资源"></a>处理Less资源</h3><ol>
<li>下载包 <code>npm i less-loader -D</code></li>
<li>功能介绍</li>
</ol>
<ul>
<li>less-loader：负责将 Less 文件编译成 Css 文件</li>
</ul>
<ol start="3">
<li>配置<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703124049.png"></li>
</ol>
<p>其余步骤同上</p>
<h3 id="处理-Sass-和-Scss-资源"><a href="#处理-Sass-和-Scss-资源" class="headerlink" title="处理 Sass 和 Scss 资源"></a>处理 Sass 和 Scss 资源</h3><ol>
<li>下载包 <code>npm i sass-loader sass -D</code></li>
<li>功能介绍</li>
</ol>
<ul>
<li>sass-loader：负责将 sass 文件编译成 css 文件</li>
<li>sass：sass-loader 依赖 sass 进行编译</li>
</ul>
<ol start="3">
<li>配置<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703141038.png"></li>
</ol>
<h1 id="5-处理图片资源"><a href="#5-处理图片资源" class="headerlink" title="5.处理图片资源"></a>5.处理图片资源</h1><p>在过去Webpack4中，处理图片资源通过<code>file-loader</code>和<code>url-loader</code>进行处理。<br>现在，Webpack5中已经将两个Loader功能内置到Webpack里，只需简单的配置就可以处理图片资源。</p>
<ol>
<li>配置<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703151535.png"></li>
<li>使用图片资源（在css中引入图片）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703151629.png"></li>
<li>对图片资源进行优化<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703151811.png"><br>优点：减少请求次数 ； 缺点：图片体积变大</li>
</ol>
<h1 id="6-修改输出文件的目录"><a href="#6-修改输出文件的目录" class="headerlink" title="6.修改输出文件的目录"></a>6.修改输出文件的目录</h1><ol>
<li>配置<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703152856.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703152941.png"></li>
</ol>
<h1 id="7-自动清空上次打包的资源"><a href="#7-自动清空上次打包的资源" class="headerlink" title="7.自动清空上次打包的资源"></a>7.自动清空上次打包的资源</h1><ol>
<li>配置<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703162904.png"></li>
</ol>
<h1 id="8-处理字体图标资源"><a href="#8-处理字体图标资源" class="headerlink" title="8.处理字体图标资源"></a>8.处理字体图标资源</h1><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703172540.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703172734.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703172803.png"><br>3. 配置<br>🌟 在module -&gt; rules 进行配置<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703173049.png"></p>
<p>type: “asset/resource” 和 type: “asset”的区别：</p>
<ol>
<li><code>type: &quot;asset/resource&quot;</code> 相当于<code>file-loader</code>, 将文件转化成 <code>Webpack</code> 能识别的资源，其他不做处理</li>
<li><code>type: &quot;asset&quot;</code> 相当于<code>url-loader</code>, 将文件转化成 <code>Webpack</code> 能识别的资源，同时小于某个大小的资源会处理成 <code>data URI</code> 形式</li>
</ol>
<h1 id="9-处理其他资源"><a href="#9-处理其他资源" class="headerlink" title="9.处理其他资源"></a>9.处理其他资源</h1><ol>
<li>配置<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703191702.png"></li>
</ol>
<h1 id="10-处理JS资源"><a href="#10-处理JS资源" class="headerlink" title="10.处理JS资源"></a>10.处理JS资源</h1><p>可能有人就会问，js资源Webpack不是已经处理了吗，为什么我们还要继续处理？<br>原因是Webpack对js的处理是有限的，只能编译js中ES模块化语法，不能编译其他语法，导致js不能在IE等浏览器运行，因此会去做一些兼容性的处理。其次，团队内部对代码格式是有严格要求的，需要使用专业的工具来进行检查。</p>
<ul>
<li>针对js兼容性处理，使用<code>Babel</code>来完成</li>
<li>针对代码格式，使用<code>Eslint</code>来完成</li>
</ul>
<p>先完成Eslint，检测代码格式无误后，再由Babel来做代码兼容。</p>
<h3 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h3><p>可组装的JavaScript和JSX检查工具。（用来检测js和jsx语法的工具，可以配置各项功能）</p>
<ol>
<li>配置文件<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703194958.png"></li>
<li>具体配置<br>以<code>.eslintrc.js</code>配置文件为例：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703195105.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703195139.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703195305.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703195416.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703195451.png"><br>比较有名的规则继承：<br><a href="https://eslint.bootcss.com/docs/rules/">Eslint 官方的规则：eslint:recommended</a><br><a href="https://github.com/vuejs/vue-cli/tree/dev/packages/@vue/cli-plugin-eslint">Vue Cli 官方的规则：plugin:vue/essential</a><br><a href="https://github.com/facebook/create-react-app/tree/main/packages/eslint-config-react-app">React Cli 官方的规则：react-app</a></li>
<li>在Webpack中使用（使用的是plugins）</li>
</ol>
<ul>
<li>下载包  <code>npm i eslint-webpack-plugin eslint -D</code></li>
<li>定义Eslint配置文件<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703200759.png"></li>
<li>配置<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703201041.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703201117.png"></li>
</ul>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><ol>
<li>下载包 <code>npm i babel-loader @babel/core @babel/preset-env -D </code></li>
<li>定义Babel配置文件</li>
</ol>
<ul>
<li>babel.config.js<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703215954.png"></li>
</ul>
<ol start="3">
<li>配置</li>
</ol>
<ul>
<li>webpack.config.js（在module - rules）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703220101.png"></li>
</ul>
<h1 id="11-处理HTML资源"><a href="#11-处理HTML资源" class="headerlink" title="11.处理HTML资源"></a>11.处理HTML资源</h1><ol>
<li>下载包 <code> npm i html-webpack-plugin -D</code></li>
<li>配置（使用的是plugins）</li>
</ol>
<ul>
<li>webpack.config.js<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703221528.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703221611.png"></li>
</ul>
<ol start="3">
<li>修改index.html<br>去掉引入的 js 文件，因为 HtmlWebpackPlugin 会自动引入<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703221757.png"></li>
</ol>
<h1 id="12-开发服务器-amp-自动化"><a href="#12-开发服务器-amp-自动化" class="headerlink" title="12.开发服务器 &amp; 自动化"></a>12.开发服务器 &amp; 自动化</h1><ol>
<li>下载包 <code>npm i webpack-dev-server -D</code></li>
<li>配置</li>
</ol>
<ul>
<li>webpack.config.js（单独开一项 devServer ）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703222431.png"></li>
</ul>
<ol start="3">
<li>运行指令 <code>npx webpack serve</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703222642.png"><br>日常开发中使用的就是这种形式</li>
</ol>
<h1 id="13-生产模式介绍"><a href="#13-生产模式介绍" class="headerlink" title="13.生产模式介绍"></a>13.生产模式介绍</h1><p>生产模式是开发完成代码后，我们需要得到代码将来部署上线。<br>这个模式下我们主要对代码进行优化，让其运行性能更好。</p>
<p>优化主要从两个角度出发:</p>
<ul>
<li>优化代码运行性能</li>
<li>优化代码打包速度</li>
</ul>
<h3 id="生产模式准备"><a href="#生产模式准备" class="headerlink" title="生产模式准备"></a>生产模式准备</h3><ol>
<li>文件目录<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703223601.png"></li>
<li>修改 webpack.dev.js<br>因为文件目录变了，所以所有绝对路径需要回退一层目录才能找到对应的文件<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703223718.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703223853.png"></li>
<li>修改 webpack.prod.js<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703223821.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703223930.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703224542.png"></li>
<li>配置运行指令<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703224542.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220703224634.png"><br>以后启动指令：</li>
</ol>
<ul>
<li>开发模式：<code>npm start</code> 或 <code>npm run dev</code></li>
<li>生产模式：<code>npm run build</code></li>
</ul>
<h1 id="中篇：Webpack高级配置"><a href="#中篇：Webpack高级配置" class="headerlink" title="中篇：Webpack高级配置"></a>中篇：Webpack高级配置</h1><p>所谓的高级配置其实就是进行Webpack优化，让代码在编译/运行时性能更好<br>将会从以下角度进行优化：</p>
<ul>
<li>提升开发体验</li>
<li>提升打包构建速度</li>
<li>减少代码体积</li>
<li>优化代码运行性能</li>
</ul>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【4】手写new</title>
    <url>/2022/04/19/4-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E6%89%8B%E5%86%99new/</url>
    <content><![CDATA[<h2 id="1-new-操作符"><a href="#1-new-操作符" class="headerlink" title="1. new 操作符"></a>1. <code>new</code> 操作符</h2><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
<p>使用<code>new</code>调用类的构造函数会执行如下操作：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220905114711.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">⭐ <span class="number">1.</span>构造函数无返回值</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"></span><br><span class="line">打印值为&#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">⭐ <span class="number">2.</span>构造函数返回值为对象</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">age</span>:<span class="number">18</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"></span><br><span class="line">打印值为&#123; <span class="attr">age</span>:<span class="number">18</span> &#125;</span><br><span class="line"></span><br><span class="line">⭐ <span class="number">3.</span>构造函数返回值为非对象</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"></span><br><span class="line">打印值为&#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p> 所以说<code>new</code>操作符必须要返回一个对象，如果构造函数中没有<code>return</code>那就返回<code>this</code>，如果有<code>return</code>并且<code>return</code>的是一个对象，那么就会返回这个对象，否则都返回<code>this</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220419204952.png"></p>
<blockquote>
<p>来自MDN的解释：<br>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情：<br>1.一个继承自 <code>Foo.prototype</code> 的新对象被创建。<br>2.使用指定的参数调用构造函数 <code>Foo</code>，并将 <code>this</code> 绑定到新创建的对象。<code>new Foo</code> 等同于 <code>new Foo()</code>，也就是没有指定参数列表，<code>Foo</code> 不带任何参数调用的情况。<br>3.由构造函数返回的对象就是 <code>new</code> 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</p>
</blockquote>
<p><b>※ 构造函数为箭头函数</b></p>
<p>普通函数创建时，引擎会按照特定的规则为这个函数创建一个<code>prototype</code>属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 <code>constructor</code> 的属性，指回与之关联的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    constructor: ƒ Foo()</span></span><br><span class="line"><span class="comment">    __proto__: Object</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<p>创建箭头函数时，引擎不会为其创建<code>prototype</code>属性，箭头函数没有<code>constructor</code>供<code>new</code>调用，因此使用new调用箭头函数会报错！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Person</span> = (<span class="params"></span>)=&gt;&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>()<span class="comment">//TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>也就是说构造函数必须是声明式的，即<code>function xxx()</code>，不可以是表达式的。</p>
<h2 id="2-手写new"><a href="#2-手写new" class="headerlink" title="2.手写new"></a>2.手写<code>new</code></h2><p>依据原理：</p>
<ol>
<li>创建一个对象<code>obj</code></li>
<li>该对象的<code>__proto__</code>指向构造函数Fn的原型<code>prototype</code></li>
<li>执行构造函数<code>Fn</code>的代码，往新创建的对象<code>obj</code>上添加成员属性和方法</li>
<li>返回这个新的对象<code>obj</code></li>
</ol>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">_new</span> (constructor, ...args) &#123;</span><br><span class="line">  <span class="comment">// 构造函数合法类型判断</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> constructor !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;constructor must be a function&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个空对象，并继承构造函数的 prototype 属性</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定this</span></span><br><span class="line">  <span class="keyword">let</span> result = constructor.<span class="title function_">apply</span>(obj, args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有返回值且返回值是对象类型，那么就将它作为返回值，否则就返回之前新建的对象</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result !== <span class="literal">null</span>) || <span class="keyword">typeof</span> result === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><p>作用：创建一个新对象，使用现有的对象来提供新创建的对象的 <code>__proto__</code></p>
<p>因此，可以得出结论</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(func.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line">⭐ 相当于如下语句：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Con</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span> = func.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = func;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Con</span>();</span><br></pre></td></tr></table></figure>

<h3 id="通过new的方式创建对象与通过字面量创建的区别"><a href="#通过new的方式创建对象与通过字面量创建的区别" class="headerlink" title="通过new的方式创建对象与通过字面量创建的区别"></a>通过<code>new</code>的方式创建对象与通过字面量创建的区别</h3><ul>
<li><code>new Object()</code> 方式创建对象本质上是方法调用，涉及到在原型链中查找该方法，当找到该方法后，又会生产方法调用必须的堆栈信息，方法调用结束后，还要释放该堆栈，性能不如字面量的方式</li>
<li>通过对象字面量定义对象时，不会调用<code>Object</code>的构造函数</li>
</ul>
<p>Tips : 使用字面量的方式创建对象 性能上 更好，可读性 更高</p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【3】作用域 &amp; 执行上下文</title>
    <url>/2022/04/18/3-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220419202053.png"></p>
<hr>

<h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h2><p><a href="https://qw-null.github.io/2022/02/25/Javascript%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/#2-3-1-%E4%BD%9C%E7%94%A8%E5%9F%9F">其他参考内容</a></p>
<p>作用域是指程序一个代码坐在的区域，它规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220314203108.png"></p>
<p>JavaScript 采用<span style="background-color:#f1c40f">词法作用域(lexical scoping)</span>，也就是静态作用域。</p>
<h4 id="1-1-静态作用域与动态作用域"><a href="#1-1-静态作用域与动态作用域" class="headerlink" title="1.1 静态作用域与动态作用域"></a>1.1 静态作用域与动态作用域</h4><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p>
<p>动态作用域，函数的作用域是在函数调用的时候才决定的。（在JS中没有的）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>();</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果是1。执行流程是执行<code>bar()</code>时会调用内部的<code>foo()</code>，执行 <code>foo()</code>时，先从 <code>foo</code> 函数内部查找是否有局部变量 <code>value</code>，如果没有，<b style="background-color:#F39C12">就根据书写的位置，查找上面一层的代码</b>，也就是 value 等于 1，所以结果会打印 1。</p>
<blockquote>
<p>假设JavaScript采用动态作用域，让我们分析下执行过程：<br>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p>
</blockquote>
<h2 id="2-执行上下文栈"><a href="#2-执行上下文栈" class="headerlink" title="2.执行上下文栈"></a>2.执行上下文栈</h2><p><a href="https://qw-null.github.io/2022/02/25/Javascript%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/#2-2%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88">其他参考内容</a></p>
<p>通常说的JS可执行代码有三类：全局代码、函数代码、eval代码。</p>
<p>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。</p>
<p>接下来问题来了，我们写的函数多了，如何管理创建的那么多执行上下文呢？</p>
<p>所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。</p>
<hr>

<p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p>
<p><code>ECStack = [];</code></p>
<p>试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 <code>globalContext</code> 表示它，并且只有当整个应用程序结束的时候，<code>ECStack</code> 才会被清空，所以程序结束之前， <code>ECStack</code> 最底部永远有个 <code>globalContext</code>：</p>
<p><code>ECStack = [ globalContext ];</code></p>
<p>现在 JavaScript 遇到下面的这段代码了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fun3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fun3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fun2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun1</span>();</span><br></pre></td></tr></table></figure>

<p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1()</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;fun1&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1中竟然调用了fun2，还要创建fun2的执行上下文</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;fun2&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦，fun2还调用了fun3！</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;fun3&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun3执行完毕</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun2执行完毕</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1执行完毕</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span></span><br></pre></td></tr></table></figure>

<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>⭐ 代码段一</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkscope</span>();</span><br></pre></td></tr></table></figure>

<p>⭐ 代码段二</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkscope</span>()();</span><br></pre></td></tr></table></figure>

<p>两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？<br>答案就是执行上下文栈的变化不一样。</p>
<p>模拟代码段一：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;checkscope&gt; functionContext);</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;f&gt; functionContext);</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br></pre></td></tr></table></figure>

<p>模拟代码段二：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;checkscope&gt; functionContext);</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(&lt;f&gt; functionContext);</span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式【Observer】</title>
    <url>/2022/04/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E3%80%90Observer%E3%80%91/</url>
    <content><![CDATA[<h1 id="1-观察者模式是什么？"><a href="#1-观察者模式是什么？" class="headerlink" title="1. 观察者模式是什么？"></a>1. 观察者模式是什么？</h1><p>观察者模式，通常又被称为<b>发布订阅者模式</b>或<b>消息机制</b>。<br>它定义了对象间的一种一对多的依赖关系，只要当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新，解决了主体对象与观察者之间功能的耦合，即一个对象改变给其他对象通知的问题。</p>
<h1 id="2-观察者模式中二者分工"><a href="#2-观察者模式中二者分工" class="headerlink" title="2.观察者模式中二者分工"></a>2.观察者模式中二者分工</h1><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220414103356.png"></p>
<h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer_id = <span class="number">0</span>, observed_id = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">观察者类 -- 订阅者</span></span><br><span class="line"><span class="comment">实现功能：构造函数、更新自身的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = observer_id++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update (ob) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;观察者&#x27;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="string">&#x27;检测到被观察者&#x27;</span>, ob.<span class="property">id</span>, <span class="string">&#x27;的变化&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">被观察者类 -- 发布者</span></span><br><span class="line"><span class="comment">实现功能：构造函数、添加观察者方法、删除观察者方法、通知每一个观察者的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observed</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = observed_id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加观察者</span></span><br><span class="line">  addObserver (ob) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">push</span>(ob);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除观察者</span></span><br><span class="line">  removeObserver (ob) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span> = <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">o</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> o.<span class="property">id</span> != ob.<span class="property">id</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有观察者</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">update</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obs_d = <span class="keyword">new</span> <span class="title class_">Observed</span>();</span><br><span class="line"><span class="keyword">let</span> obs_1 = <span class="keyword">new</span> <span class="title class_">Observer</span>(), obs_2 = <span class="keyword">new</span> <span class="title class_">Observer</span>();</span><br><span class="line"></span><br><span class="line">obs_d.<span class="title function_">addObserver</span>(obs_1);</span><br><span class="line">obs_d.<span class="title function_">addObserver</span>(obs_2);</span><br><span class="line"></span><br><span class="line">obs_d.<span class="title function_">notify</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----------------&#x27;</span>)</span><br><span class="line">obs_d.<span class="title function_">removeObserver</span>(obs_1);</span><br><span class="line">obs_d.<span class="title function_">notify</span>();</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220414103913.png"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue双向数据绑定</title>
    <url>/2022/04/11/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>视频链接：<a href="https://www.bilibili.com/video/BV1Dr4y1c7xS?share_source=copy_web">【黑马程序员】vue双向数据绑定原理</a></p>
<h2 id="0-前置知识点-数组的reduce-方法"><a href="#0-前置知识点-数组的reduce-方法" class="headerlink" title="0.前置知识点 - 数组的reduce()方法"></a>0.前置知识点 - 数组的<code>reduce()</code>方法</h2><blockquote>
<p>应用场景：下次操作的初始值，依赖于上次操作的返回值</p>
</blockquote>
<ol>
<li>数值的累加操作<br>数组的<code>reduce</code>方法会循环当前数组，侧重于进行“滚雪球”的操作<br><code>Array.reduce(函数, 初始值)</code><br><code>Array.reduce((上次计算的结果，当前循环的Item项) =&gt; &#123; &#125;, 初始值)</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total += item;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 0是箭头函数的第一个参数的初始值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">//40</span></span><br></pre></td></tr></table></figure></li>
<li>链式获取对象的属性的值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">      <span class="attr">location</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> attrs = [<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;address&#x27;</span>, <span class="string">&#x27;location&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> res = attrs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">newObj, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> newObj[key]</span><br><span class="line">&#125;, obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 北京</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">      <span class="attr">location</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> attrStr = <span class="string">&#x27;info.address.location&#x27;</span></span><br><span class="line"><span class="keyword">const</span> res = attrStr.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">newObj, key</span>) =&gt;</span> newObj[key], obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 北京</span></span><br></pre></td></tr></table></figure>
<h2 id="1-发布订阅模式"><a href="#1-发布订阅模式" class="headerlink" title="1. 发布订阅模式"></a>1. 发布订阅模式</h2><ul>
<li><code>Dep</code>类：负责进行<b>依赖收集</b><br>首先，有个数组，专门存放所有的订阅信息；其次，还要提供一个向数组中追加订阅信息的方法；然后，还要提供一个循环，循环触发数组中的每一个订阅信息</li>
<li><code>Watcher</code>类：负责<b>订阅一些事件</b></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收集依赖/收集订阅</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// subs数组用来存放所有订阅者信息</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向subs数组中添加订阅者的信息</span></span><br><span class="line">  addSub (watcher) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(watcher)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布订阅的方法</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">watcher</span>) =&gt;</span> watcher.<span class="title function_">update</span>())</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅者的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发回调的方法</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cb</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> w1 = <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是第一个订阅者&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> w2 = <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是第二个订阅者&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">dep.<span class="title function_">addSub</span>(w1)</span><br><span class="line">dep.<span class="title function_">addSub</span>(w2)</span><br><span class="line"></span><br><span class="line">dep.<span class="title function_">notify</span>()</span><br></pre></td></tr></table></figure>
<h4 id="Vue中发布订阅模式如何运作？"><a href="#Vue中发布订阅模式如何运作？" class="headerlink" title="Vue中发布订阅模式如何运作？"></a>Vue中发布订阅模式如何运作？</h4><ul>
<li>只要我们为Vue中data数据重新赋值，这个复制动作会被Vue监听到</li>
<li>然后Vue要把数据的变化，通知到每一个订阅者</li>
<li>接下来，订阅者（DOM元素）要根据最新的数据，更新自己的内容 </li>
</ul>
<h2 id="2-使用Object-defineProperty-进行数据劫持"><a href="#2-使用Object-defineProperty-进行数据劫持" class="headerlink" title="2. 使用Object.defineProperty()进行数据劫持"></a>2. 使用<code>Object.defineProperty()</code>进行数据劫持</h2><p>Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
<blockquote>
<p>备注：应当直接在 Object 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。</p>
</blockquote>
<p>语法：<code>Object.defineProperty(obj, prop, descriptor)</code><br>参数：</p>
<ul>
<li><code>obj</code>：要定义属性的对象</li>
<li><code>prop</code>：要定义或修改的属性的名称或 <code>Symbol</code> </li>
<li><code>descriptor</code>：要定义或修改的属性描述符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,<span class="comment">// 当前属性允许被循环</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 当前属性允许被配置</span></span><br><span class="line">  get () &#123; <span class="comment">// getter</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取了obj.name&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set (newVal) &#123; <span class="comment">// setter</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;赋值了&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">// 获取了obj.name   Tom</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Sam&#x27;</span>; <span class="comment">//赋值了</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【2】继承</title>
    <url>/2022/04/07/2-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220407230555.png"></p>
<hr>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220418102829.jpg"></p>
<h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h2><p>过程：①定义父类构造函数 ➡ ②给父类的原型添加方法 ➡ ③定义子类型的构造函数 ➡<span style="color:red">④将创建的父类型对象赋值给子类型的原型</span> ➡ <span style="color:red">⑤将子类型的构造属性设置为子类型</span> ➡ ⑥给子类型的原型添加方法 ➡ ⑦创建子类型的对象，可以调用父类型的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">People</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pName</span> = <span class="string">&#x27;人类&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getPName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">pName</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sName</span> = <span class="string">&#x27;学生&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">People</span>()</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sName</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">People</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220407151237.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220407151337.png"></p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol>
<li>引用类型的属性被所有实例共享<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">names</span> = [<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;daisy&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span> () &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line">child1.<span class="property">names</span>.<span class="title function_">push</span>(<span class="string">&#x27;yayu&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">names</span>); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">names</span>); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li>在创建子类型实例时，不能向父类型传参</li>
</ol>
<h2 id="2-借用构造函数继承（假继承）"><a href="#2-借用构造函数继承（假继承）" class="headerlink" title="2.借用构造函数继承（假继承）"></a>2.借用构造函数继承（假继承）</h2><p>过程：①定义父类型构造函数 ➡ ②定义子类型的构造函数 ➡ ③在子类型构造函数中调用父类型构造</p>
<p><b style="color:red">关键点：在子类型构造函数中通过call调用父类型的构造函数</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">People</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span> (name, age, price) &#123;</span><br><span class="line">  <span class="title class_">People</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age); <span class="comment">//相当于 this.Person(name,age)</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>, <span class="number">13000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// Student &#123; name: &#x27;Tom&#x27;, age: 12, price: 13000 &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>避免了引用类型的属性被所有实例共享<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">names</span> = [<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;daisy&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span> () &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line">child1.<span class="property">names</span>.<span class="title function_">push</span>(<span class="string">&#x27;yayu&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">names</span>); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">names</span>); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li>在创建子类型实例时，可以向父类型传参</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>方法在构造函数中定义，每次创建实例都会创建一遍</p>
<h2 id="3-组合继承（原型链继承-借用构造函数继承）"><a href="#3-组合继承（原型链继承-借用构造函数继承）" class="headerlink" title="3.组合继承（原型链继承 + 借用构造函数继承）"></a>3.组合继承（原型链继承 + 借用构造函数继承）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">People</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span> (name, age, price) &#123;</span><br><span class="line">  <span class="title class_">People</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setPrice</span> = <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>, <span class="number">3500</span>);</span><br><span class="line">s.<span class="title function_">setName</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">s.<span class="title function_">setPrice</span>(<span class="number">1500</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// People &#123; name: &#x27;Jack&#x27;, age: 12, price: 1500 &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>融合继承原型链继承和构造函数继承的优点，是JavaScript中最常用的继承模式。</p>
<h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><p>原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新的对象。你需要把这个对象先传给<code>object()</code>，然后再对返回的对象进行适当的修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>)&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>※ 本质上，<code>object()</code>是对传入的对象执行了一次浅复制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span> (o) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span> () &#123; &#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="attr">frineds</span>: [<span class="string">&#x27;Daming&#x27;</span>, <span class="string">&#x27;Lingling&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">object</span>(person);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">object</span>(person);</span><br><span class="line"></span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&#x27;Sam&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">name</span>); <span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line">p1.<span class="property">frineds</span>.<span class="title function_">push</span>(<span class="string">&#x27;Amy&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">frineds</span>); <span class="comment">// [ &#x27;Daming&#x27;, &#x27;Lingling&#x27;, &#x27;Amy&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>※ 修改<code>p1.name</code>的值，<code>p2.name</code>的值并未发生改变，并不是因为<code>p1</code>和<code>p2</code>有独立的<code>name</code>值，而是因为<code>p1.name= &#39;Sam&#39; </code>是给<code>p1</code>添加了<code>name</code>的属性，并赋值为<code>Sam</code>，并非修改了原型上<code>name</code>的值。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>包含引用类型的属性值会被所有实例共享（与原型链继承相同）。</p>
<h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来做增强对象，最后返回对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title function_">object</span>(original);</span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>与借用构造函数继承模式相同，每次创建对象都会创建一遍方法。</p>
<h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6.寄生组合式继承"></a>6.寄生组合式继承</h2><p>组合继承的方式也存在效率的问题，最主要的效率问题就是父类构造函数始终会被调用两次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span> (name, age) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 第二次调用Parent()</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// 第一次调用Parent()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1)</span><br></pre></td></tr></table></figure>
<p>该如何精益求精，避免重复调用呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span> (name, age) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1);</span><br></pre></td></tr></table></figure>
<p>封装一下这个继承方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">prototype</span>(<span class="params">child, parent</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="title function_">object</span>(parent.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    prototype.<span class="property">constructor</span> = child;</span><br><span class="line">    child.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line"><span class="title function_">prototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式的高效率体现它只调用了一次 <code>Parent</code> 构造函数，并且因此避免了在 <code>Parent.prototype</code> 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 <code>instanceof</code> 和 <code>isPrototypeOf</code>。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。  ——《JavaScript高级程序设计》</p>
</blockquote>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【1】原型与原型链</title>
    <url>/2022/04/06/1.%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220406132939.png"></p>
<hr>

<h2 id="1-一张图"><a href="#1-一张图" class="headerlink" title="1. 一张图"></a>1. 一张图</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg"></p>
<ul>
<li>函数也是对象，对象的<code>__proto__</code>指向构造函数</li>
</ul>
<h2 id="2-什么是原型？"><a href="#2-什么是原型？" class="headerlink" title="2. 什么是原型？"></a>2. 什么是原型？</h2><p>每个JS对象（<code>null</code>除外）在创建的时候，就会与之关联的另一个对象，这个对象就是原型。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220406130950.png"></p>
<h2 id="3-什么是原型链？"><a href="#3-什么是原型链？" class="headerlink" title="3. 什么是原型链？"></a>3. 什么是原型链？</h2><p>由相互关联的原型组成的链状结构就是原型链。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220406131939.png"></p>
<h2 id="4-prototype"><a href="#4-prototype" class="headerlink" title="4. prototype"></a>4. <code>prototype</code></h2><p>每个函数都有一个<code>prototype</code>属性，指向调用该构造函数而创建的实例的原型。</p>
<ul>
<li><code>prototype</code>是函数才会有的属性</li>
</ul>
<h2 id="5-proto"><a href="#5-proto" class="headerlink" title="5. __proto__"></a>5. <code>__proto__</code></h2><p>每个JS对象（处了<code>null</code>）都具有一个属性<code>__proto__</code>，这个属性会指向该对象的原型。</p>
<h2 id="6-constructor"><a href="#6-constructor" class="headerlink" title="6. constructor"></a>6. constructor</h2><p>每个原型都有一个<code>constructor</code>属性指向关联的构造函数。</p>
<h2 id="7-实例与原型"><a href="#7-实例与原型" class="headerlink" title="7. 实例与原型"></a>7. 实例与原型</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220406132548.png"></p>
<h2 id="8-原型的原型"><a href="#8-原型的原型" class="headerlink" title="8. 原型的原型"></a>8. 原型的原型</h2><p>原型也是对象，既然是对象就可以通过最原始的方式创建<code>var obj = new Object()</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220406132827.png"></p>
<h2 id="9-真的是继承吗？"><a href="#9-真的是继承吗？" class="headerlink" title="9.真的是继承吗？"></a>9.真的是继承吗？</h2><blockquote>
<p>继承意味着复制，然而Javascript默认并不会复制对象的属性，相反，Javascript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。    ————《你不知道的Javascript》</p>
</blockquote>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>表格删除选中数据的二三事</title>
    <url>/2022/03/31/%E8%A1%A8%E6%A0%BC%E5%88%A0%E9%99%A4%E9%80%89%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="0-需求场景"><a href="#0-需求场景" class="headerlink" title="0.需求场景"></a>0.需求场景</h2><p>最近项目中遇到一个问题，删除表格中选中的数据【注意：选中过程中不能删除，只能在最终点击删除按钮时，执行删除操作】。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220331103520.png"></p>
<h2 id="1-需求转化"><a href="#1-需求转化" class="headerlink" title="1.需求转化"></a>1.需求转化</h2><p>实际上这个问题相当于一道算法题目。<br>给定一个数组<code>A = [9,8,7,6,5,4,2,3,1]</code>和表示数组下标的数组<code>B = [2,4,3]</code>，请删除<code>A</code>中下标在<code>B</code>中的元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>这道问题的难点在于删除数组元素时，需要保证每次删除数组元素时，数组元素的位置不能变。</p>
<p>解决问题的思路：</p>
<ol>
<li>使用<code>Array.filter()</code></li>
</ol>
<p>先将数组进行重新封装，封装成如下格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;value&quot;</span> <span class="punctuation">:</span> xxx<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;index&quot;</span> <span class="punctuation">:</span> xxx </span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>然后使用<code>Array.filter()</code>进行删除元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">productId</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">productName</span>: <span class="string">&#x27;电视机&#x27;</span>,</span><br><span class="line">        <span class="attr">num</span>: <span class="number">20</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="attr">productId</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">productName</span>: <span class="string">&#x27;洗衣机&#x27;</span>,</span><br><span class="line">        <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="attr">productId</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">productName</span>: <span class="string">&#x27;冰箱&#x27;</span>,</span><br><span class="line">        <span class="attr">num</span>: <span class="number">50</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="attr">productId</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">productName</span>: <span class="string">&#x27;空调&#x27;</span>,</span><br><span class="line">        <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">    arr = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item.<span class="property">num</span> != <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220331132547.png"></p>
<ol start="2">
<li>使用<code>map.has()</code><br>将数组<code>B</code>转化为<code>map</code>，循环数组<code>A</code>，判断数组<code>A</code>的下标值是否包含在数组<code>B</code>转化的<code>map</code>中。</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中with的用法</title>
    <url>/2022/03/23/JavaScript%E4%B8%ADwith%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>⚠ 警告：由于with语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用with语句。</p>
</blockquote>
<p>但是这个东东，不是用来做项目的，而是用来做面试题的。</p>
<h2 id="1-with简介"><a href="#1-with简介" class="headerlink" title="1. with简介"></a>1. with简介</h2><p>with语句的用途是将代码作用域设置为特定的对象，语法是：<code>with(expression) statement</code><br>使用with语句的主要场景是针对一个对象反复操作，此时将代码的作用域设置为该对象能提供便利。<br>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="string">&#x27;13&#x27;</span>,</span><br><span class="line">  <span class="attr">school</span>:<span class="string">&#x27;ucas&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果修改<code>person</code>的每一项属性值，一般做法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">person.<span class="property">age</span> = <span class="number">15</span>;</span><br><span class="line">person.<span class="property">school</span> = <span class="string">&#x27;SDAU&#x27;</span>;</span><br><span class="line"><span class="comment">// 上述代码中重复写了3次person</span></span><br></pre></td></tr></table></figure>
<p>使用<code>with</code>的写法，会更加简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">with</span>(<span class="params">person</span>)&#123;</span><br><span class="line">  name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">  age = <span class="number">15</span>;</span><br><span class="line">  school = <span class="string">&#x27;SDAU&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-with弊端"><a href="#2-with弊端" class="headerlink" title="2.with弊端"></a>2.with弊端</h2><ul>
<li>数据泄露</li>
<li>性能下降</li>
</ul>
<h3 id="2-1-数据泄露"><a href="#2-1-数据泄露" class="headerlink" title="2.1 数据泄露"></a>2.1 数据泄露</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(a); //ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(obj2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">// 2，a被泄漏到全局作用域上</span></span><br></pre></td></tr></table></figure>
<p>上述代码中创建了<code>obj1</code> 、<code>obj2</code>两个对象，其中<code>obj1</code>中有属性<code>a</code>，<code>obj2</code>没有属性<code>a</code>。<code>fn(obj) </code>函数接受一个 <code>obj</code> 的形参，该参数是一个对象引用，并对该对象执行了 <code>with(obj) &#123;...&#125;</code>。将<code>obj1</code>传递进去，<code>a = 2</code>赋值操作找到<code>obj.a</code>并将2赋值给它。当<code>obj2</code>传递进去时，但是并没有属性<code>a</code>，因此不会创建这个属性，所以<code>obj2.a</code>的值为<code>undefined</code>。<br>⭐ 为什么对<code>obj2</code>的操作会导致数据泄露？<br>当传递<code>obj2</code>给<code>with</code>时，<code>with</code>所声明的作用域是<code>obj2</code>，从这个作用域开始对<code>a</code>进行LHS查询：<code>obj2</code>的作用域➡<code>fn()</code>的作用域➡全局作用域，以上中都没有找到<code>a</code>，在<b>非严格模式下</b>，会在全局作用域中创建一个全局变量<code>a</code>。在<b>严格模式下</b>，会抛出<code>ReferenceError</code> 异常。</p>
<h3 id="2-2-性能下降"><a href="#2-2-性能下降" class="headerlink" title="2.2 性能下降"></a>2.2 性能下降</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;func&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> v = obj.<span class="property">a</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;func&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">funcWith</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;funcWith&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> v = a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;funcWith&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">funcWith</span>();</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220323113947.png"></p>
<p>原因是什么？<br>JavaScript 引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。</p>
<p>但如果引擎在代码中发现了 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。</p>
<p>最悲观的情况是如果出现了 with ，所有的优化都可能是无意义的。因此引擎会采取最简单的做法就是完全不做任何优化。如果代码大量使用 with 或者 eval()，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢的事实。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>内存溢出与内存泄漏</title>
    <url>/2022/03/20/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h1 id="1-内存溢出"><a href="#1-内存溢出" class="headerlink" title="1.内存溢出"></a>1.内存溢出</h1><ul>
<li>一种程序运行出现的错误</li>
<li>当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出错误</li>
</ul>
<p>例如，下面这一段程序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  obj[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当运行时，浏览器会报错：内存不足<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220320101217.png"></p>
<p><b>说明：内存是有限的资源，不能无限制地进行分配！</b></p>
<h1 id="2-内存泄漏"><a href="#2-内存泄漏" class="headerlink" title="2.内存泄漏"></a>2.内存泄漏</h1><ul>
<li>占用内存没有被及时释放</li>
<li>内存泄漏积累多了就容易导致内存溢出</li>
<li>常见的内存泄漏：<br>※ 意外的全局变量<br>※ 没有及时清理的计时器或者回调函数<br>※ 闭包</li>
</ul>
<p><b>⭐ 意外的全局变量</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123;</span><br><span class="line">  a = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>
<p>上述代码中，变量<code>a</code>实际上是全局变量，以这种方式定义时，变量不会随着<code>fn</code>函数的执行完成而释放。</p>
<p><b>⭐ 没有及时清理的计时器或者回调函数</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动循环定时器后不清理</span></span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----------------&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>由于没关闭定时器而导致内存溢出，除非浏览器关闭、刷新，不然的话会一直执行下去。因此需要及时清理定时器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clearInterval</span>(intervalId);</span><br></pre></td></tr></table></figure>

<p><b>⭐ 闭包</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(++a)</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">return</span> fn2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title function_">fn1</span>()</span><br><span class="line">  <span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>
<p>执行完函数之后<code>a</code>没有被释放掉，是因为<code>fn</code>保存了<code>fn1</code>函数。<br>因此需要将<code>fn</code>置为空，让垃圾回收器回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>变量提升和函数提升的优先级问题</title>
    <url>/2022/03/09/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>⭐ 首先在最开始介绍一下，JS中存在提升的原因？<br>JS引擎在读取代码时，进行两步操作：</p>
<ul>
<li>第一步：对整个JS代码进行读取解析</li>
<li>第二步：代码执行</li>
</ul>
<p>提升只会发生在第一步中，所以在代码执行之前，浏览器的解析器遇到变量名和函数声明时，会将其提升至当前作用域的最前面。</p>
<p><b style="background:yellow;">注意：</b></p>
<ol>
<li>上述提及的变量提升，只针对<code>var</code>声明的变量，使用<code>let</code>或<code>const</code>声明的变量不存在提升。</li>
<li>JS引擎严格规定句首用 <code>function</code> 的才能算作函数声明，其余的杂牌声明只能算作函数表达式.</li>
</ol>
<h2 id="变量提升-amp-函数提升"><a href="#变量提升-amp-函数提升" class="headerlink" title="变量提升 &amp; 函数提升"></a>变量提升 &amp; 函数提升</h2><ul>
<li>变量提升<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//&#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure>
上述代码相当于：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 只定义不声明就默认是undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//undefined</span></span><br><span class="line">a=<span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//hi</span></span><br></pre></td></tr></table></figure></li>
<li>函数提升<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);    <span class="comment">//f a()&#123;console.log(&#x27;hi&#x27;);&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);    <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述代码相当于：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b;<span class="comment">//undefined;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);    <span class="comment">//f a()&#123;console.log(&#x27;hi&#x27;);&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);    <span class="comment">//undefined</span></span><br><span class="line">b = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二者的优先级"><a href="#二者的优先级" class="headerlink" title="二者的优先级"></a>二者的优先级</h2><ul>
<li>函数提升会优先于变量提升，而且不会被同名的变量覆盖。</li>
<li>但是，如果这个同名变量被赋值了，那函数变量就会被覆盖。</li>
<li>当二者同时存在时，会先指向函数声明。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);    <span class="comment">//f a() &#123;...&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>());    <span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);    <span class="comment">//1</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>());    <span class="comment">//报错，现在的函数a已经被赋值过后的变量a给覆盖了，无法再调用a()</span></span><br></pre></td></tr></table></figure>
上述代码相当于：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);    <span class="comment">//f a() &#123;...&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>());    <span class="comment">//2</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);    <span class="comment">//1</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>());    <span class="comment">//报错，现在的函数a已经被赋值过后的变量a给覆盖了，无法再调用a()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>牛客网上的一道题目：<br>以下代码执行之后，控制台的输出是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure>
<p>答案是:Number。<br>原因是函数提升优先级高于变量提升，先执行函数提升，再执行变量提升。执行完函数提升之后，又执行了变量提升并进行赋值操作。此时函数变量被覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123; &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure>
<p>答案是：function。<br>此时先执行了函数提升，又执行了变量提升，但是变量没有进行赋值，因此指向函数。【当二者同时存在时，会先指向函数声明】</p>
<h2 id="为什么会有提升？"><a href="#为什么会有提升？" class="headerlink" title="为什么会有提升？"></a>为什么会有提升？</h2><p>Dmitry Soshnikov早些年在twitter上提出关于变量提升的问题，同时Brendan Eich给出了一些解答：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310195643.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310195820.png"><br>答案的大致意思是由于第一代JS虚拟机中的抽象纰漏导致的，编译器将变量放入栈槽内并编入索引。然后在（当前作用域）入口处将变量名绑定到栈槽内的变量上。（注：这里提到的抽象是计算机术语，是对内部发生的更加复杂的事情的一种简化。）<br>随后，Dmitry Soshnikov又提到了函数提升，他提到了函数的相互递归。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310200629.png"><br>Brendan Eich又对其进行了解答。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310200809.png"><br>大致意思是函数提升就是为了解决函数相互递归问题，大体上可以解决像ML语言这样自下而上的顺序问题。</p>
<hr>
对于函数递归的一些阐述：

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证偶数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isEven</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isOdd</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEven</span>(<span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证奇数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isOdd</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isEven</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于中间语句<code>console.log(isEven(2));</code>而言，它在执行的时候，<code>isOdd</code>函数还没有被声明，如果没有函数提升，那就必然会报错，这段程序就会陷入一种死循环的状态。</p>
<p>因此，在JS设计之初，就人为加入了函数提升。在代码执行时，将函数提升至当前作用域的顶部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证偶数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isEven</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isOdd</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证奇数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isOdd</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isEven</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEven</span>(<span class="number">2</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<hr>
最后，Brendan Eich还对变量提升和函数提升做了总结：

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310201531.png"><br>大概是说，变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。</p>
<h2 id="后续的补充"><a href="#后续的补充" class="headerlink" title="后续的补充"></a>后续的补充</h2><p>在stackoverflow中用户提出一道相关问题<a href="https://stackoverflow.com/questions/7506844/javascript-function-scoping-and-hoisting">Javascript function scoping and hoisting</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310201904.png"><br>大意就是他阅读了Ben Cherry写的一篇关于JS范围和提升的文章，对其中给出的一个案例存在疑惑，为什么代码执行结果是浏览器输出1？</p>
<p>然后下面有人对其问题进行了解答。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310202424.png"><br>函数提升意味着函数被移动到作用域的开头。（红框中的代码的执行过程实际上是绿框中代码的顺序）</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310202714.png"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>N进制数【Leetcode】</title>
    <url>/2022/03/07/N%E8%BF%9B%E5%88%B6%E6%95%B0%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>给定一个数字，求该数字的N进制表示方法（N&lt;10）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getN_aryNum = <span class="keyword">function</span>(<span class="params">n,num</span>)&#123;<span class="comment">//n表示进制，num表示原数</span></span><br><span class="line">  <span class="keyword">if</span>(num === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span>;<span class="comment">//原数是正数还是负数的标志</span></span><br><span class="line">  <span class="keyword">if</span>(num&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    num = -num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    res.<span class="title function_">push</span>(num%n);</span><br><span class="line">    num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num/n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag) res.<span class="title function_">push</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/base-7/">原题链接：504. 七进制数</a><br>给定一个整数 <code>num</code>，将其转化为 <b>7 进制</b>，并以字符串形式输出。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307145705.png"></p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> getN_aryNum = <span class="keyword">function</span>(<span class="params">n,num</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(num === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span>;<span class="comment">//原数是正数还是负数的标志</span></span><br><span class="line">  <span class="keyword">if</span>(num&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    num = -num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    res.<span class="title function_">push</span>(num%n);</span><br><span class="line">    num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num/n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag) res.<span class="title function_">push</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> convertToBase7 = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getN_aryNum</span>(<span class="number">7</span>,num)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript数组的reduce方法</title>
    <url>/2022/03/03/Javascript%E6%95%B0%E7%BB%84%E7%9A%84reduce%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Javascript数组的<code>reduce</code>方法对数组中的每个元素执行一个由您提供的<code>reducer</code>函数(升序执行)，将其结果汇总为单个返回值。</p>
<p>基本语法：<code>arr.reduce(callback,[initialValue])</code></p>
<p>参数说明：<br>callback 执行数组中每个值的函数，包含四个参数：</p>
<ul>
<li><code>previousValue</code>：第一项的值或者上一次叠加的结果值，或者是提供的初始值<code>initialValue</code></li>
<li><code>currentValue</code>：数组中当前被处理的元素</li>
<li><code>index</code>：当前元素在数组中的索引</li>
<li><code>array</code>：数组本身</li>
</ul>
<p>initialValue（可选）：作为第一次调用<code>callback</code>的第一个参数，可以控制返回值的格式</p>
<blockquote>
<p>reduce() 方法可以使用一下这个表达式总结一下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>


<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>次执行：pre=<span class="subst">$&#123;pre&#125;</span>,cur=<span class="subst">$&#123;cur&#125;</span>,index=<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220303165351.png"></p>
<p>代码分析：</p>
<ul>
<li>数组中的元素依次执行了回调函数。</li>
<li>因为给 initialValue 赋了初始值 10，所以第一次执行时， pre 的值默认从 10 开始。</li>
<li>每次执行时，pre 的值都是 cur 元素前的所有元素之和。</li>
<li>最后返回数组所有元素累加的和。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>次执行：pre=<span class="subst">$&#123;pre&#125;</span>,cur=<span class="subst">$&#123;cur&#125;</span>,index=<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220303165658.png"></p>
<p>可以看到代码只执行了3次，并且是从数组的第二个元素开始执行的，数组的第一位元素默认作为<code>pre</code>的值。</p>
<h2 id="实际用法"><a href="#实际用法" class="headerlink" title="实际用法"></a>实际用法</h2><h4 id="1-计算数组中每个元素出现的次数"><a href="#1-计算数组中每个元素出现的次数" class="headerlink" title="1.计算数组中每个元素出现的次数"></a>1.计算数组中每个元素出现的次数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pre, cur);</span><br><span class="line">  <span class="keyword">if</span> (cur <span class="keyword">in</span> pre) &#123;</span><br><span class="line">    pre[cur]++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pre[cur] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220303170846.png"></p>
<h4 id="2-数组去重"><a href="#2-数组去重" class="headerlink" title="2.数组去重"></a>2.数组去重</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pre, cur);</span><br><span class="line">  <span class="keyword">if</span> (!pre.<span class="title function_">includes</span>(cur)) &#123;</span><br><span class="line">    pre.<span class="title function_">push</span>(cur);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220303171115.png"></p>
<h4 id="3-对象属性求和"><a href="#3-对象属性求和" class="headerlink" title="3.对象属性求和"></a>3.对象属性求和</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">17</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Lily&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">19</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    a = a + b.<span class="property">age</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 54</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Z字形变换【Leetcode】</title>
    <url>/2022/03/01/Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<p>传送门：<a href="https://leetcode-cn.com/problems/zigzag-conversion/">6. Z 字形变换</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301143027.png"></p>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：<code>string convert(string s, int numRows);</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301143141.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>我愿称之为 ‘ 最强flag ’ </p>
</blockquote>
<p>要对字符串<code>s</code>进行Z字形存储，所按照顺序如下所示：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301145304.png"></p>
<p>通过图示可以发现：遍历字符串<code>s</code>时，每个字符在Z字形中对应的行索引先从小到大，再从大到小……如此往复，直到遍历结束。</p>
<p>so,问题的难点就在于，如何控制遍历过程的 <b>行索引</b> 呢？<br>其实通过一个<code>flag</code>变量就可以完美解决这个问题。</p>
<p><b>算法流程：</b></p>
<p>初始化变量：<code>res数组--存放对应索引的字符串</code>、<code>flag--改变行索引，初始值为-1</code>、<code>i--对应的行索引</code></p>
<ol>
<li><code>res[i] += c</code>：把每个字符<code>c</code>填入对应行</li>
<li><code>i += flag</code>：更新当前字符<code>c</code>对应的行索引</li>
<li><code>flag = -flag</code>：到达Z字形的转折点时，改变方向</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> convert = <span class="keyword">function</span>(<span class="params">s, numRows</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(numRows).<span class="title function_">fill</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;<span class="comment">//最终结果</span></span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,flag=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> s)&#123;</span><br><span class="line">        res[i] += c;</span><br><span class="line">        <span class="keyword">if</span>(i===<span class="number">0</span>||i===numRows-<span class="number">1</span>) flag = -flag;</span><br><span class="line">        i += flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(res)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> res)&#123;</span><br><span class="line">        <span class="comment">// console.log(i)</span></span><br><span class="line">        result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词【Leetcode】</title>
    <url>/2022/02/28/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <code>s</code> 和 <code>t </code>，编写一个函数来判断 <code>t </code>是否是 <code>s</code> 的字母异位词。</p>
<p>注意：若<code>s</code>和 <code>t </code>中每个字符出现的次数都相同，则称 <code>s </code>和 <code>t </code>互为字母异位词。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228202029.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>解体的关键在于：统计出包含元素的种类以及包含元素的个数。<br>因此，可以维护一个长度为26的数组【原因：<code>s</code>和<code>t</code>仅包含小写字母】，数组的每一项分别表示<code>a-z</code>中的一项，数组每一项的值代表出现的次数。</p>
<p>要点：</p>
<ul>
<li><p>如何将字符串的单个字符转换为数字？<br>借助JavaScript的 <code>charCodeAt()</code> 方法。<br>charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。<br>语法：<code>stringObject.charCodeAt(index)</code><br><b>注释：</b>字符串中第一个字符的下标是 0。如果 index 是负数，或大于等于字符串的长度，则 charCodeAt() 返回 NaN。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">charCodeAt</span>()); <span class="comment">// 97  [ a的ASCII码 ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">charCodeAt</span>(<span class="number">1</span>)); <span class="comment">// 98 [ b的ASCII码 ]</span></span><br></pre></td></tr></table></figure></li>
<li><p>补充点：如何将数字（ASCII码）转换为字符？<br>使用JS的<code>fromCharCode</code>方法<br>语法：<code>String.fromCharCode(num1[, ...[, numN]])</code><br>参数<code>num1, ..., numN</code>：一系列 UTF-16 代码单元的数字。范围介于 0 到 65535（0xFFFF）之间。大于 0xFFFF 的数字将被截断。不进行有效性检查。<br>返回值：一个长度为 N 的字符串，由 N 个指定的 UTF-16 代码单元组成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">97</span>;</span><br><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(num);  <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">100</span>;</span><br><span class="line"><span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(num1);  <span class="comment">// &#x27;d&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>!==t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> a = <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>(); <span class="comment">//获取a的ASCII码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s)&#123;</span><br><span class="line">        arr[i.<span class="title function_">charCodeAt</span>()-a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j <span class="keyword">of</span> t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!arr[j.<span class="title function_">charCodeAt</span>()-a]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        arr[j.<span class="title function_">charCodeAt</span>()-a]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><p>给你一个字符串数组，请你将 <b>字母异位词</b> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><b>字母异位词</b> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301095554.png"></p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>统计字符串数组每一项的字母出现的次数，并且以此作为键，具有相同键值的元素作为该键的值，就是字母异位词。<br>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301100250.png"></p>
<h4 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="keyword">function</span>(<span class="params">strs</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> strs)&#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> item)&#123;</span><br><span class="line">            count[i.<span class="title function_">charCodeAt</span>()-<span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map[count])&#123;</span><br><span class="line">            map[count].<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map[count] = [item];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(map);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>Object.values()方法</p>
<p>返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>
<p>语法：<code>Object.values(obj)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301101119.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)); <span class="comment">// [&#x27;bar&#x27;, 42]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于数组的对象，具有随机键排序</span></span><br><span class="line"><span class="comment">// 当我们使用数字键时，按照数字键的顺序返回数值。</span></span><br><span class="line"><span class="keyword">var</span> an_obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(an_obj)); <span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFoo 是不可枚举的属性</span></span><br><span class="line"><span class="keyword">var</span> my_obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123; <span class="attr">getFoo</span>: &#123; <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span>; &#125; &#125; &#125;);</span><br><span class="line">my_obj.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(my_obj)); <span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非对象参数将被强制转换为对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>统计元素出现的次数【Leetcode刷题心得】</title>
    <url>/2022/02/28/%E7%BB%9F%E8%AE%A1%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97%E3%80%91/</url>
    <content><![CDATA[<h2 id="0-情景模拟"><a href="#0-情景模拟" class="headerlink" title="0.情景模拟"></a>0.情景模拟</h2><p>在日常刷题过程中，通常会对字符串或者数组中的元素进行处理，在处理过程中，往往需要统计其中元素出现的次数，因此，本文主要记录日常自己使用的相关方法。</p>
<h2 id="1-对字符串的处理"><a href="#1-对字符串的处理" class="headerlink" title="1.对字符串的处理"></a>1.对字符串的处理</h2><p>以字符串 <code>s = &#39;abcabcaadcce&#39;</code>为例。</p>
<h4 id="1-1-统计字符串s中元素出现的次数"><a href="#1-1-统计字符串s中元素出现的次数" class="headerlink" title="1.1 统计字符串s中元素出现的次数"></a>1.1 统计字符串<code>s</code>中元素出现的次数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcabcaadcce&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.统计字符出现的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">let</span> key = s[i];</span><br><span class="line">  <span class="keyword">if</span> (obj[key]) &#123;</span><br><span class="line">    obj[key]++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj[key] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;统计结果：&#x27;</span>, obj);</span><br></pre></td></tr></table></figure>
<p>统计结果： { a: 4, b: 2, c: 4, d: 1, e: 1 }</p>
<h4 id="1-3-遍历统计对象-键-gt-值"><a href="#1-3-遍历统计对象-键-gt-值" class="headerlink" title="1.3 遍历统计对象(键-&gt;值)"></a>1.3 遍历统计对象(键-&gt;值)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;键：&#x27;</span>, i, <span class="string">&#x27; -&gt; 值：&#x27;</span>, obj[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>键： a  -&gt; 值： 4<br>键： b  -&gt; 值： 2<br>键： c  -&gt; 值： 4<br>键： d  -&gt; 值： 1<br>键： e  -&gt; 值： 1</p>
<h4 id="1-3-基于元素出现的次数进行排序"><a href="#1-3-基于元素出现的次数进行排序" class="headerlink" title="1.3 基于元素出现的次数进行排序"></a>1.3 基于元素出现的次数进行排序</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取属性值并按从小到大排序</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Object</span>.<span class="title function_">values</span>(obj).<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> new_obj = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">result.<span class="title function_">forEach</span>(<span class="function">(<span class="params">items, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 将原对象中的键值对按照属性值的排序顺序写入新对象</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[item] === items) &#123;</span><br><span class="line">      new_obj.<span class="title function_">set</span>(item, items);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(new_obj);</span><br></pre></td></tr></table></figure>

<p>排序后的结果：Map(5) { ‘d’ =&gt; 1, ‘e’ =&gt; 1, ‘b’ =&gt; 2, ‘a’ =&gt; 4, ‘c’ =&gt; 4 }</p>
<p>遍历map值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> new_obj.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-4-删除满足条件的元素"><a href="#1-4-删除满足条件的元素" class="headerlink" title="1.4 删除满足条件的元素"></a>1.4 删除满足条件的元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">delete</span> obj[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除后的结果&#x27;</span>, obj)</span><br></pre></td></tr></table></figure>

<p>删除后的结果 { b: 2, c: 4, d: 1, e: 1 }</p>
<h2 id="2-对数组的处理"><a href="#2-对数组的处理" class="headerlink" title="2.对数组的处理"></a>2.对数组的处理</h2><p>以数组 <code>arr = [1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 8, 8, 9]</code> 为例。</p>
<h4 id="2-1-统计数组中元素出现的次数"><a href="#2-1-统计数组中元素出现的次数" class="headerlink" title="2.1 统计数组中元素出现的次数"></a>2.1 统计数组中元素出现的次数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">let</span> key = arr[i];</span><br><span class="line">  <span class="keyword">if</span> (obj[key]) &#123;</span><br><span class="line">    obj[key]++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj[key] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;统计结果：&#x27;</span>, obj);</span><br></pre></td></tr></table></figure>
<p>统计结果： { ‘1’: 2, ‘2’: 3, ‘3’: 4, ‘4’: 1, ‘8’: 2, ‘9’: 1 }</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>刷题技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript高级教程</title>
    <url>/2022/02/25/Javascript%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV14s411E7qf?share_source=copy_web">尚硅谷JavaScript高级教程(javascript实战进阶)</a></p>
<h2 id="1-基础总结深入"><a href="#1-基础总结深入" class="headerlink" title="1.基础总结深入"></a>1.基础总结深入</h2><h3 id="1-1数据类型"><a href="#1-1数据类型" class="headerlink" title="1.1数据类型"></a>1.1数据类型</h3><p>两大类：1.基本（值）类型  2.对象（引用）类型</p>
<ol>
<li><p>基本（值）类型<br>String：任意字符串<br>Number：任意数字<br>Symbol：代表创建后独一无二且不可变的数据类型【它的出现我认为是为了解决可能出现的全局变量冲突的问题】<br>Boolean：true / false<br>Undefined：undefined<br>Null：null</p>
</li>
<li><p>对象（引用）类型<br>Object：任意对象<br>Function：一种特别的对象（特别在可以执行）<br>Array：一种特别的对象（特别在属性为数值下标，内部数据是有序的）</p>
</li>
<li><p>判断数据类型</p>
</li>
</ol>
<ul>
<li>typeof  ： 可以判断：undefined / 数值 / 字符串 / 布尔值</li>
<li>typeof  ： 不可以判断：<b style="background:yellow;">null与object、object与array</b></li>
<li>instanceof ：判断对象的具体类型</li>
<li>===  ： 可以判断：undefined / null （因为这两者只有一个数值）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.基本数据类型</span></span><br><span class="line"><span class="comment">// typeof 返回数据类型的字符串表达</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Undefined</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, <span class="keyword">typeof</span> a, <span class="keyword">typeof</span> a === <span class="string">&#x27;undefined&#x27;</span>, a === <span class="literal">undefined</span>); <span class="comment">// undefined  &#x27;undefined&#x27;  true  true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String</span></span><br><span class="line">a = <span class="string">&#x27;angle&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean</span></span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a === <span class="string">&#x27;boolean&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Null</span></span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === <span class="literal">null</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.对象数据类型</span></span><br><span class="line"><span class="keyword">var</span> b1 = &#123;</span><br><span class="line">  <span class="attr">b2</span>: [<span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="variable language_">console</span>.<span class="property">log</span>],</span><br><span class="line">  <span class="attr">b3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b3&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b1.<span class="property">b2</span> <span class="keyword">instanceof</span> <span class="title class_">Array</span>, b1.<span class="property">b2</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>);<span class="comment">// true true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b1.<span class="property">b3</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>, b1.<span class="property">b3</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>);<span class="comment">// true true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> b1.<span class="property">b3</span> === <span class="string">&#x27;function&#x27;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>为什么<code>b1.b3 instanceof Object</code> 是 <code>true</code>，这是因为函数是一种特殊的对象。</p>
<p>对于上述定义中的<code>b2</code>的第三个元素<code>console.log</code>进行类型判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> b1.<span class="property">b2</span>[<span class="number">2</span>] === <span class="string">&#x27;function&#x27;</span>);<span class="comment">//true</span></span><br><span class="line">b1.<span class="property">b2</span>[<span class="number">2</span>](<span class="number">4</span>);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="1-undefined与null的区别是什么？"><a href="#1-undefined与null的区别是什么？" class="headerlink" title="1.undefined与null的区别是什么？"></a>1.undefined与null的区别是什么？</h4><ul>
<li>undefined 代表定义未赋值</li>
<li>null表示定义了变量并且赋值为null</li>
</ul>
<h4 id="2-什么时候给变量赋值为null"><a href="#2-什么时候给变量赋值为null" class="headerlink" title="2.什么时候给变量赋值为null?"></a>2.什么时候给变量赋值为null?</h4><ul>
<li>初始赋值为null，表明将要赋值为对象。</li>
<li>结束前，让对象成为垃圾对象（被垃圾回收器回收）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 起始</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">null</span>; <span class="comment">// 初始赋值为null，表明将要赋值为对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定对象就要赋值</span></span><br><span class="line">b = [<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后</span></span><br><span class="line">b = <span class="literal">null</span>; <span class="comment">// 释放对象：让b指向的对象成为垃圾对象（被垃圾回收器回收）</span></span><br></pre></td></tr></table></figure>
<h4 id="3-严格区别变量类型与数据类型？"><a href="#3-严格区别变量类型与数据类型？" class="headerlink" title="3.严格区别变量类型与数据类型？"></a>3.严格区别变量类型与数据类型？</h4><p>数据的类型：*基本类型  *对象类型<br>变量类型（变量内存值的类型）：<br>*基本类型：保存基本类型的数据<br>*引用类型：保存地址值</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228110010.png"></p>
<p>对于上图中的变量<code>a</code>和<code>b</code>，因为其存储的是基本类型，所以数据直接保存在栈内存中，而对于变量<code>c</code>而言，其代表对象，因此在栈内存中只存储该对象在堆内存中的地址。</p>
<h3 id="1-2-数据，变量与内存"><a href="#1-2-数据，变量与内存" class="headerlink" title="1.2 数据，变量与内存"></a>1.2 数据，变量与内存</h3><h4 id="1-2-1-什么是数据？"><a href="#1-2-1-什么是数据？" class="headerlink" title="1.2.1 什么是数据？"></a>1.2.1 什么是数据？</h4><p>● 存储在内存中的代表特定信息的东西，本质上是0101……<br>● 数据的特点：可传递、可运算<br>● 一切皆数据<br>● 内存中所有操作的目标：数据【*算术运算 、 *逻辑运算、 <em>赋值运算 、</em>运行函数】</p>
<h4 id="1-2-2-什么是内存？"><a href="#1-2-2-什么是内存？" class="headerlink" title="1.2.2 什么是内存？"></a>1.2.2 什么是内存？</h4><p>● 内存条通电之后产生的可存储数据的空间（临时的）；<br>● 内存的产生和死亡：内存条（电路板） → 通电  → 产生内存空间  → 存储数据  → 处理数据  →  断电  →  内存空间和数据都消失；<br>● 一块小内存可以保存的2种数据：内部存储的数据 + 地址值<br>● 内存的分类：<br>  栈：全局变量和局部变量（空间较小）<br>  堆：对象（空间较大）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>
<p>上述代码在打印时，首先读取的是<code>obj</code>，此时读取的是<code>obj</code>的内容值，只不过内容值当中存储的是<code>obj</code>的地址值。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228114525.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228114817.png"></p>
<h4 id="1-2-3-什么是变量？"><a href="#1-2-3-什么是变量？" class="headerlink" title="1.2.3 什么是变量？"></a>1.2.3 什么是变量？</h4><p>可变化的量，由变量名和变量值组成；<br>每个变量都对应一小块内存，变量名用来查找对应的内存，变量值就是内存中保存的数据</p>
<h4 id="1-2-4-内存、数据、变量三者之间的关系？"><a href="#1-2-4-内存、数据、变量三者之间的关系？" class="headerlink" title="1.2.4 内存、数据、变量三者之间的关系？"></a>1.2.4 内存、数据、变量三者之间的关系？</h4><p>● 内存：用来存储数据的的空间<br>● 变量：是内存的标识</p>
<h4 id="1-2-5-相关问题："><a href="#1-2-5-相关问题：" class="headerlink" title="1.2.5 相关问题："></a>1.2.5 相关问题：</h4><h5 id="⭐-var-a-xxx，a内存中到底保存的是什么？"><a href="#⭐-var-a-xxx，a内存中到底保存的是什么？" class="headerlink" title="⭐ var a = xxx，a内存中到底保存的是什么？"></a>⭐ var a = xxx，a内存中到底保存的是什么？</h5><ul>
<li>xxx是基本数据，保存的是这个数据</li>
<li>xxx是对象，保存的是对象的地址值</li>
<li>xxx是一个变量，保存的是xxx的内容值（可能是基本数据，也可能是地址值）</li>
</ul>
<h5 id="⭐-关于引用变量赋值问题？"><a href="#⭐-关于引用变量赋值问题？" class="headerlink" title="⭐ 关于引用变量赋值问题？"></a>⭐ 关于引用变量赋值问题？</h5><p>● n个引用变量指向同一个对象，通过一个变量修改对象内部的数据，其他所有变量看到的是修改之后的数据。</p>
<p>● 2个引用对象指向同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br></pre></td></tr></table></figure>
<p>上述代码中，实现了将<code>obj1</code>的内容保存的<code>obj2</code>【<code>obj1</code>中保存的是地址值】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>) <span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>); <span class="comment">// Bob</span></span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">age</span>:<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = &#123;<span class="attr">name</span>:<span class="string">&#x27;Bob&#x27;</span>,<span class="attr">age</span>:<span class="number">13</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">age</span>,a.<span class="property">name</span>,a.<span class="property">age</span>); <span class="comment">// 12 Bob 13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  obj = &#123;<span class="attr">age</span>:<span class="number">15</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn2</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">age</span>); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>上述第二部分代码图示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220302084101.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228154520.png"></p>
<p>代码执行完毕之后，<code>age:15</code>会在哪里？<br>变量<code>obj</code>是函数的局部变量，在函数执行完毕之后，局部变量会被释放，一旦局部变量<code>obj</code>被释放，那么其指向的<code>age:15</code>就会被当作垃圾对象回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&#x27;Lily&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn3</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>); <span class="comment">// Lily</span></span><br></pre></td></tr></table></figure>
<p>实际上只要是没有切断变量与堆内存中存储内容之间的执行，修改其中一个，其他都会跟着变。</p>
<h5 id="⭐-在JS调用函数时传递变量参数，是值传递还是引用传递？"><a href="#⭐-在JS调用函数时传递变量参数，是值传递还是引用传递？" class="headerlink" title="⭐ 在JS调用函数时传递变量参数，是值传递还是引用传递？"></a>⭐ 在JS调用函数时传递变量参数，是值传递还是引用传递？</h5><p>答案：</p>
<ul>
<li>理解1：都是值传递，值分为两种：基本值和地址值。</li>
<li>理解2：可能是值传递，也可能是引用传递（地址值）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (a) &#123;</span><br><span class="line">  a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220302091425.png"></p>
<h5 id="⭐-JS引擎如何管理内存？"><a href="#⭐-JS引擎如何管理内存？" class="headerlink" title="⭐ JS引擎如何管理内存？"></a>⭐ JS引擎如何管理内存？</h5><p>1.内存生命周期</p>
<ul>
<li>分配小内存空间，得到它的使用权</li>
<li>存储数据，可以反复进行操作</li>
<li>释放小内存空间</li>
</ul>
<p>2.释放内存</p>
<ul>
<li>局部变量：函数执行完自动释放</li>
<li>对象：成为垃圾对象，由垃圾回收器回收</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码中共使用几个内存空间？<br>3个内存空间。一个是栈内存a，存储数据3；一个是栈内存obj，存储数据{}（堆内存）的地址；另一个是堆内存中存储的{}。</p>
<hr>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码中共使用几个内存空间？<br>2个内存空间。一个是栈内存a，存储数据3；一个是栈内存obj，存储值为null。堆内存中存储的{}被回收。</p>
<hr>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>
<p>上述代码中的b在函数<code>fn()</code>执行完毕之后会自动释放，而b指向的对象是在后面的某个时刻由垃圾回收器回收。</p>
<h3 id="1-3-对象"><a href="#1-3-对象" class="headerlink" title="1.3 对象"></a>1.3 对象</h3><h4 id="1-3-1-什么是对象？"><a href="#1-3-1-什么是对象？" class="headerlink" title="1.3.1 什么是对象？"></a>1.3.1 什么是对象？</h4><p>多个数据的封装体 或者 是用来保存多个数据的容器；<br>一个对象代表现实中的一个事物</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-为什么用对象？"><a href="#1-3-2-为什么用对象？" class="headerlink" title="1.3.2 为什么用对象？"></a>1.3.2 为什么用对象？</h4><p>统一管理多个数据</p>
<h4 id="1-3-3-对象的组成"><a href="#1-3-3-对象的组成" class="headerlink" title="1.3.3 对象的组成"></a>1.3.3 对象的组成</h4><p>属性 + 方法<br>♥ 属性：属性名（字符串）和属性值（任意类型）组成<br>♥ 方法：是一种特别的属性（属性值是函数）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">13</span>,</span><br><span class="line">  <span class="attr">setName</span>: <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">setAge</span>: <span class="keyword">function</span> (<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>, person.<span class="property">setName</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220302110213.png"></p>
<h4 id="1-3-4-如何访问对象内部数据？"><a href="#1-3-4-如何访问对象内部数据？" class="headerlink" title="1.3.4 如何访问对象内部数据？"></a>1.3.4 如何访问对象内部数据？</h4><p>※ 第一种方式：<code>.属性名</code>，编码简单，有时不能用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.<span class="title function_">setName</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line">p.<span class="property">name</span>;</span><br></pre></td></tr></table></figure>
<p>※ 第二种方式：<code>[&#39;属性名&#39;]</code>，编码麻烦，能通用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person[<span class="string">&#x27;setAge&#x27;</span>](<span class="number">23</span>);</span><br><span class="line">p[<span class="string">&#x27;age&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h5 id="⭐-什么情况下必须使用-39-属性名-39-的方式？"><a href="#⭐-什么情况下必须使用-39-属性名-39-的方式？" class="headerlink" title="⭐ 什么情况下必须使用[&#39;属性名&#39;]的方式？"></a>⭐ 什么情况下必须使用<code>[&#39;属性名&#39;]</code>的方式？</h5><p>1.属性名包含特殊字符：- 、空格<br>2.属性名不确定（属性名是个变量）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;&#125;</span><br><span class="line"><span class="number">1.</span>给p对象添加一个属性：content-type : text/json</span><br><span class="line">p.<span class="property">content</span>-type = <span class="string">&#x27;text/json&#x27;</span>  <span class="comment">// 不能用</span></span><br><span class="line">p[<span class="string">&#x27;content-type&#x27;</span>] = <span class="string">&#x27;text/json&#x27;</span> <span class="comment">//可以使用</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>属性名不确定（属性名是个变量）</span><br><span class="line"><span class="keyword">var</span> propName = <span class="string">&#x27;myAge&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">18</span>;</span><br><span class="line">p.<span class="property">propName</span> = value; <span class="comment">//不能用</span></span><br><span class="line">p[propName] = value; <span class="comment">//可以使用</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-函数"><a href="#1-4-函数" class="headerlink" title="1.4 函数"></a>1.4 函数</h3><h4 id="1-4-1-什么是函数？"><a href="#1-4-1-什么是函数？" class="headerlink" title="1.4.1 什么是函数？"></a>1.4.1 什么是函数？</h4><p>实现特定功能的n条语句的封装体<br>只有函数是可以执行的，其他类型的数据不能执行</p>
<h4 id="1-4-2-为什么要用函数？"><a href="#1-4-2-为什么要用函数？" class="headerlink" title="1.4.2 为什么要用函数？"></a>1.4.2 为什么要用函数？</h4><p>提高代码复用、便于阅读交流</p>
<h4 id="1-4-3-如何定义函数？"><a href="#1-4-3-如何定义函数？" class="headerlink" title="1.4.3 如何定义函数？"></a>1.4.3 如何定义函数？</h4><p>函数声明<br>表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>函数声明</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn1()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>表达式</span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2()&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-4-如何调用（执行）函数？"><a href="#1-4-4-如何调用（执行）函数？" class="headerlink" title="1.4.4 如何调用（执行）函数？"></a>1.4.4 如何调用（执行）函数？</h4><p>直接调用：<code>test()</code><br>通过对象调用：<code>obj.test()</code><br>new调用：<code>new test()</code><br>临时让test成为obj的方法进行调用：<code>test.call(obj) </code>、<code> test.apply(obj)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">xx</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* obj.<span class="title function_">test</span>(); <span class="comment">// 不能直接调用，因为obj中根本没有这个函数</span></span><br><span class="line"></span><br><span class="line">test.<span class="title function_">call</span>(obj) <span class="comment">//可以让一个函数成为指定任意对象的方法进行调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">xx</span>) <span class="comment">// Hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-4-4-回调函数"><a href="#1-4-4-回调函数" class="headerlink" title="1.4.4 回调函数"></a>1.4.4 回调函数</h4><h5 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a>什么是回调函数？</h5><p>3个特点：<br>1）自己定义的<br>2）没有调用<br>3）最终执行了（在某个时刻 或者 某个条件下）</p>
<h5 id="常见的回调函数"><a href="#常见的回调函数" class="headerlink" title="常见的回调函数"></a>常见的回调函数</h5><ul>
<li>dom事件的回调函数 ➡ this指的是发生事件的dom元素</li>
<li>定时器回调函数 ➡ this指的是window</li>
<li>ajax请求回调函数</li>
<li>生命周期回调函数</li>
</ul>
<h4 id="1-4-5-IIFE"><a href="#1-4-5-IIFE" class="headerlink" title="1.4.5 IIFE"></a>1.4.5 IIFE</h4><p>Immediately-Invoked Function Expression，立即调用函数表达式<br>匿名函数自调用 = IIFE<br>IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名函数自调用</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p><b> ♥ 作用：</b></p>
<ul>
<li>隐藏实现</li>
<li>不会污染外部（全局）命名空间</li>
<li>用它来编写js模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">test</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(++a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">$</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">//向外暴露一个全局函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">test</span>: test</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">$().<span class="title function_">test</span>() <span class="comment">// 1.$是一个函数 2.$执行后返回的是一个对象</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-6-函数中的this"><a href="#1-4-6-函数中的this" class="headerlink" title="1.4.6 函数中的this"></a>1.4.6 函数中的this</h4><h5 id="this-是什么？"><a href="#this-是什么？" class="headerlink" title="this 是什么？"></a>this 是什么？</h5><ul>
<li>任何函数本质上都是通过某个对象来调用的</li>
<li>所有函数内部都有一个变量this</li>
<li>它的值是调用函数的当前对象</li>
</ul>
<h5 id="如何确定this的值？"><a href="#如何确定this的值？" class="headerlink" title="如何确定this的值？"></a>如何确定this的值？</h5><ul>
<li><code>test()</code> ：window</li>
<li><code>p.test()</code> ：p</li>
<li><code>new test()</code> ：新创建的对象</li>
<li><code>p.call(obj)</code>：obj</li>
</ul>
<blockquote>
<ol>
<li>函数调用时，指向window </li>
<li>以方法调用时，指向调用该方法的对象 </li>
<li>使用new创建一个对象时，指向新创建的对象 </li>
<li>call,apply ,bind可以改变this指向，this指向指定的那个对象</li>
<li>在全局作用域中this代表window</li>
</ol>
</blockquote>
<h2 id="2-函数高级"><a href="#2-函数高级" class="headerlink" title="2.函数高级"></a>2.函数高级</h2><h3 id="2-1原型与原型链"><a href="#2-1原型与原型链" class="headerlink" title="2.1原型与原型链"></a>2.1原型与原型链</h3><h4 id="2-1-1-原型（prototype）"><a href="#2-1-1-原型（prototype）" class="headerlink" title="2.1.1 原型（prototype）"></a>2.1.1 原型（prototype）</h4><p><b>1.函数的<code>prototype</code>属性</b></p>
<ul>
<li>每个函数都有一个<code>prototype</code>属性，它默认指向一个<code>Object</code>空对象（即称为：原型对象）<blockquote>
<p>何为Object空对象？ 没有我们自己定义的属性</p>
</blockquote>
</li>
<li>原型对象中有一个属性<code>constructor </code>，它指向函数对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Date</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fun.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === fun); <span class="comment">//true（fun为自定义函数）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220303112643.png"><br>⭐ 构造函数和它的原型对象是一个相互引用的关系。<br>解释相互引用：当前存在两个对象<code>A</code>和<code>B</code>，<code>A</code>当中有一个属性可以找到<code>B</code>，<code>B</code>当中有一个属性可以找到<code>A</code>。</p>
<p><b>2.给原型对象添加属性（这里的属性一般都是方法）</b><br>给原型对象添加属性（一般是方法）➡ 实例对象可以访问</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给原型对象添加属性（一般是方法）➡ 实例对象可以访问</span></span><br><span class="line"><span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test方法&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line">fun.<span class="title function_">test</span>();<span class="comment">// test方法</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-显式原型与隐式原型"><a href="#2-1-2-显式原型与隐式原型" class="headerlink" title="2.1.2 显式原型与隐式原型"></a>2.1.2 显式原型与隐式原型</h4><ol>
<li>每个函数<code>function</code>都有一个<code>prototype</code>，即显式原型（属性）</li>
<li>每个实例对象都有一个<code>__proto__</code>，可称为隐式原型（属性）</li>
<li>对象的隐式原型的值为其对应构造函数的显式原型的值</li>
<li>总结：</li>
</ol>
<ul>
<li>函数的<code>prototype</code>属性：在定义函数时自动添加的，默认为一个空Object对象</li>
<li>对象的<code>__proto__</code>属性：在创建对象时自动添加的，默认值为构造函数的<code>prototype</code>属性值</li>
<li>程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span> () &#123; <span class="comment">// 内部语句：this.prototype = &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 每个函数function都有一个prototype，即显式原型（属性），默认指向一个空Object对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.每个实例对象都有一个__proto__，可称为隐式原型（属性）</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>(); <span class="comment">// 内部语句：this.__proto__ = Fn.prototype;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">__proto__</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.对象的隐式原型的值为其对应构造函数的显式原型的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> === fn.<span class="property">__proto__</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给原型添加方法</span></span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过实例对象调用原型的方法</span></span><br><span class="line">fn.<span class="title function_">test</span>()</span><br></pre></td></tr></table></figure>
<p>上述代码内存结构图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220304121321.png"></p>
<h4 id="2-1-3-原型链"><a href="#2-1-3-原型链" class="headerlink" title="2.1.3 原型链"></a>2.1.3 原型链</h4><p>访问一个对象的属性时：</p>
<ul>
<li>先在自身属性中查找，如果找到则返回</li>
<li>如果未找到，再沿着<code>__proto__</code>这条链向上查找，找到返回</li>
<li>如果最终没有找到，返回<code>undefined</code></li>
</ul>
<p>原型链的别名是隐式原型链。<br>原型链的作用：查找对象的属性（方法），只是用来查找，如果是一些赋值操作等，则不会查找原型链。</p>
<p><b style="background:#f8df70">原型链的本质是隐式原型链。</b><br>原型链的尽头是<code>Object的原型对象</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">test1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test1()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test2</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test2()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">test1</span>(); <span class="comment">// test1()</span></span><br><span class="line">fn.<span class="title function_">test2</span>(); <span class="comment">// test2()</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="title function_">toString</span>()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">test3</span>); <span class="comment">// undefined</span></span><br><span class="line">fn.<span class="title function_">test3</span>(); <span class="comment">//  &quot;TypeError: fn.test3 is not a function</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220305205820.png"><br>原型链的尽头是<code>Object的原型对象</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220305214943.png"><br>创建两个实例对象，实例对象有隐式原型属性<code>__proto__</code>，这个隐式原型属性指向的是Object的原型对象，（隐式原型属性<code>__proto__</code>的值是将<code>prototype</code>的值赋给它得到的）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220306140152.png"></p>
<ul>
<li><p>所有函数的<code>__proto__</code>都是一样的，都是通过<code>new Function()</code>产生的</p>
</li>
<li><p>任何函数都是通过<code>new Function()</code>产生的.因此，所有函数对象的隐式原型都指向<code>Function.prototype</code></p>
</li>
<li><p>实例对象的隐式原型属性等于构造函数的显示原型属性</p>
</li>
</ul>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li><p>函数的显式原型指向的对象：默认是空Object实例对象【但是Object不满足】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">test1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test1()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307084657.png"><br>( 😀 因此，上图中存在绿色部分)</p>
</li>
<li><p>所有函数都是Function的实例，包括Function它自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>Object 的原型对象是原型链的尽头</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="原型链的属性问题"><a href="#原型链的属性问题" class="headerlink" title="原型链的属性问题"></a>原型链的属性问题</h4><ul>
<li>读取对象属性值时：会自动到原型链中查找</li>
<li>设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加属性并设置其值</li>
<li>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</li>
</ul>
<p>※ <i style = "background:#a7ed3d">原型链是用来查找属性的，当为一个对象添加属性时，不会看原型链</i></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span> () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&#x27;AAA&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn1.<span class="property">a</span>); <span class="comment">// AAA</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line">fn2.<span class="property">a</span> = <span class="string">&#x27;BBB&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn1.<span class="property">a</span>, fn2.<span class="property">a</span>); <span class="comment">// AAA BBB</span></span><br></pre></td></tr></table></figure>
<p>此时<code>fn1</code>的内容为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307101504.png"><br>⭐ 查找<code>fn1</code>的<code>a</code>属性值时，发现<code>fn1</code>本身没有属性<code>a</code>，所以会自动到原型链中查找属性<code>a</code>。</p>
<p>此时<code>fn2</code>的内容为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307101627.png"><br>⭐ 查找<code>fn2</code>的<code>a</code>属性值时，发现<code>fn2</code>本身有属性<code>a</code>，所以直接输出该属性值，不再去查找原型链，但是原型链中实际上仍存在属性<code>a</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);</span><br><span class="line">p1.<span class="title function_">setName</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);</span><br></pre></td></tr></table></figure>
<p>⭐ 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Lily&#x27;</span>, <span class="number">13</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">__proto__</span> === p2.<span class="property">__proto__</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>⭐ 实例对象的隐式原型等于构造函数的显式原型</p>
<h4 id="2-1-4-instanceof"><a href="#2-1-4-instanceof" class="headerlink" title="2.1.4 instanceof"></a>2.1.4 instanceof</h4><p>instanceof 作用：<code>a instanceof b</code> → 判断<code>a</code>是否是<code>b</code>的实例【其中，a是实例对象，b是构造函数】</p>
<ul>
<li>instanceof 是如何判断的？<br>表达式：<code>A instanceof B</code><br>如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span> () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1 <span class="keyword">instanceof</span> <span class="title class_">Foo</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307113311.png"></p>
<hr>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span> () &#123; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Foo</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E6%97%A0%E6%A0%87%E9%A2%98.png"></p>
<h4 id="2-1-5-面试题"><a href="#2-1-5-面试题" class="headerlink" title="2.1.5 面试题"></a>2.1.5 面试题</h4><p><b>题目1</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span> () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">n</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123; <span class="comment">//这步操作直接改变了原型对象</span></span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">A</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">n</span>, b.<span class="property">m</span>, c.<span class="property">n</span>, c.<span class="property">m</span>);<span class="comment">// 1 undefined  2 3</span></span><br></pre></td></tr></table></figure>

<p>上述代码在内存中的示意图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220308130123.png"><br>（<em>最开始是是红色指示线，后来变为蓝色指示线</em>）</p>
<p>两种表达方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">表达方式<span class="number">1</span>：</span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">n</span> = <span class="number">1</span>;</span><br><span class="line">表达方式<span class="number">2</span>：</span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = &#123; </span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中表达方式1会影响原有的实例对象，因为表达方式1是在原有的实例对象上添加到。<br>表达方式2不会影响原有的实例对象，因为表达方式2直接改变了实例对象原型。</p>
<p>对于代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的理解：现在堆内存中创建对象<code>&#123;n:2,m:3&#125;</code>，然后改变<code>A.prototype</code>的指向。（<em>蓝色指示线部分</em>）</p>
<p><b>题目2</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">fn.<span class="title function_">a</span>(); <span class="comment">// a()</span></span><br><span class="line">fn.<span class="title function_">b</span>(); <span class="comment">// TypeError: fn.b is not a function</span></span><br><span class="line">F.<span class="title function_">a</span>(); <span class="comment">// a()</span></span><br><span class="line">F.<span class="title function_">b</span>(); <span class="comment">// b()</span></span><br></pre></td></tr></table></figure>

<h4 id="原型链一张图"><a href="#原型链一张图" class="headerlink" title="原型链一张图"></a>原型链一张图</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg"></p>
<p><b>实记口诀：</b></p>
<ol>
<li>函数都是<code>Function</code>构造出来的</li>
<li>一切函数都是对象，只要是函数对象，就会有原型<code>prototype</code>和隐式原型<code>__proto__</code>两个属性</li>
<li>普通对象身上只有<code>__proto__</code>，没有<code>prototype</code></li>
<li>实例化对象的<code>__proto__</code>都指向构造函数的<code>prototype</code></li>
<li>所有函数的<code>prototype</code>都指向自身的<code>prototype</code></li>
<li>所有的<code>prototype</code>的<code>__proto__</code>都指向<code>Object.prototype</code>（Object除外）</li>
<li>所有函数对象的<code>__proto__</code>都指向<code>Function.prototype</code>（包括Function自身）</li>
<li>所有对象身上都有<code>constructor</code>指向函数自身</li>
</ol>
<h3 id="2-2执行上下文与执行上下文栈"><a href="#2-2执行上下文与执行上下文栈" class="headerlink" title="2.2执行上下文与执行上下文栈"></a>2.2执行上下文与执行上下文栈</h3><h4 id="2-2-1-变量提升与函数提升"><a href="#2-2-1-变量提升与函数提升" class="headerlink" title="2.2.1 变量提升与函数提升"></a>2.2.1 变量提升与函数提升</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题：程序最终输出什么？</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上述代码的实际执行过程是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//undefined   </span></span><br><span class="line"><span class="title function_">fn2</span>(); <span class="comment">// fn2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在执行<code>console.log</code>时，变量<code>b</code>和函数<code>fn2</code>均未提前声明，但是仍然可以执行。原因是变量<code>b</code>进行了变量提升，函数<code>fn2</code>进行了函数提升。</p>
<ol>
<li>变量（声明）提升<br>通过<code>var</code>定义（声明）的变量，在定义语句之前就可以访问到，值为<code>undefined</code></li>
<li>函数（声明）提升<br>通过<code>function</code>声明的函数，在之前就可以直接调用，值为函数定义。<br>函数提升必须使用声明的方式。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309091249.png"></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn3); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn3&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码遵循的是变量提升。</p>
<h4 id="2-2-2-执行上下文"><a href="#2-2-2-执行上下文" class="headerlink" title="2.2.2 执行上下文"></a>2.2.2 执行上下文</h4><p><b>1.代码分类</b><br>全局代码 和 函数（局部）代码</p>
<p><b>2.全局执行上下文</b><br>在执行全局代码前将<code>window</code>确定为全局执行上下文。</p>
<p>对全局数据进行预处理:</p>
<ul>
<li><code>var</code>定义的全局变量 → <code>undefined</code>，添加为<code>window</code>的属性</li>
<li><code>function</code>声明的全局函数 → 赋值（<code>fun</code>）,添加为<code>window</code>的方法</li>
<li><code>this</code> → 赋值（<code>var</code>）</li>
</ul>
<p>–上述过程是在全局代码执行之前就会进行的操作</p>
<ul>
<li>执行全局代码</li>
</ul>
<p><b>3.函数执行上下文</b><br>在调用函数时，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈中）</p>
<p>对局部数据进行预处理：</p>
<ul>
<li>形参变量 → 赋值（实参） → 添加为执行上下文的属性</li>
<li><code>arguments</code> → 赋值（实参列表），添加为执行上下文的属性</li>
<li><code>var</code>定义的局部变量 → undefined，添加为执行上下文的属性</li>
<li><code>function</code>声明的函数 → 赋值（fun），添加为执行上下文的方法</li>
<li><code>this</code> → 赋值（调用函数的对象）</li>
</ul>
<p>开始执行函数体代码</p>
<h4 id="2-2-3-执行上下文栈"><a href="#2-2-3-执行上下文栈" class="headerlink" title="2.2.3 执行上下文栈"></a>2.2.3 执行上下文栈</h4><ol>
<li>在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象</li>
<li>在全局执行上下文（window）确定后，将其添加到栈中（压栈）</li>
<li>在函数执行上下文创建后，将其添加到栈中（压栈）</li>
<li>在当前函数执行完成后，将栈顶的对象移除（出栈）</li>
<li>当所有的代码执行完后，栈中只剩下window</li>
</ol>
<p><span style="background-color:#f9c116"> 处于活动状态的执行上下文环境只有一个。</span><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309154025.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.进入全局执行上下文</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="title function_">fn</span>(x + b);<span class="comment">// 3. 进入foo执行上下文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params">y</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">5</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + c + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(<span class="number">10</span>);<span class="comment">// 2.进入bar函数执行上下文</span></span><br></pre></td></tr></table></figure>
<p>上述代码结果为30。</p>
<p>执行上下文栈结构图如下所示：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309153021.png"></p>
<p>栈的底部始终是<code>window</code>，因为第一个产生的是<code>window</code>，要放入栈中进行管理。<br>执行上下文个数遵循 <code>n + 1</code>的原则，其中<code>n</code>指的是调用函数的次数，<code>1</code>指的是<code>window</code>。</p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p><b>⭐ 1.依次输出什么？整个过程中产生了几个执行上下文？</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;global begin:&#x27;</span> + i);</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo begin:&#x27;</span> + i);</span><br><span class="line">  <span class="title function_">foo</span>(i + <span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo end:&#x27;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;global end:&#x27;</span> + i);</span><br></pre></td></tr></table></figure>
<p>依次输出的结果：</p>
<blockquote>
<p>global begin:undefidned<br>foo begin:1<br>foo begin:2<br>foo begin:3<br>foo end:3<br>foo end:2<br>foo end:1<br>global end:1</p>
</blockquote>
<p>整个过程中产生了5个执行上下文。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309163434.png"></p>
<p><b>⭐ 2.函数提升与变量提升顺序</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a); <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上述代码先执行函数提升，再执行变量提升，但是变量未进行赋值操作，所以是function。<br>具体参考：<a href="https://qw-null.github.io/2022/03/09/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/">变量提升和函数提升的优先级问题</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(b <span class="keyword">in</span> <span class="variable language_">window</span>)) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span> (c) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">c</span>(<span class="number">2</span>); <span class="comment">// TypeError: c is not a function</span></span><br></pre></td></tr></table></figure>
<p>上述代码相当于：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220311102431.png"></p>
<h3 id="2-3作用域与作用域链"><a href="#2-3作用域与作用域链" class="headerlink" title="2.3作用域与作用域链"></a>2.3作用域与作用域链</h3><h4 id="2-3-1-作用域"><a href="#2-3-1-作用域" class="headerlink" title="2.3.1 作用域"></a>2.3.1 作用域</h4><ol>
<li>理解<br>作用域就像是一块“地盘”，一个代码所在的区域。它是静态的（相对于 执行上下文对象 而言，因为执行上下文对象只有代码执行时才会产生），在编写代码时就确定了。</li>
<li>分类<br>全局作用域、函数作用域、块级作用域（ES6出现）</li>
<li>作用<br>隔离变量，不同作用域下同名变量不会有冲突</li>
<li>作用域个数<br>作用域个数遵循<code>n + 1</code>的原则（与执行上下文相同），其中<code>n</code>指的是定义的函数的个数，<code>1</code>指的是全局作用域。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220314203108.png"><br>结果为：<br>fn() 100 20 300 10<br>bar() 1000 20 300 400 100<br>bar() 1000 20 300 400 200</p>
<h4 id="2-3-2-作用域与执行上下文"><a href="#2-3-2-作用域与执行上下文" class="headerlink" title="2.3.2 作用域与执行上下文"></a>2.3.2 作用域与执行上下文</h4><ol>
<li>区别：<br>⭐全局作用域之外，每个函数都会创建自己的作用域。作用域在函数定义时就已经确定了，而不是在函数调用时。全局执行上下文环境是在全局作用域确定之后，JS代码马上执行之前创建；函数执行上下文环境是在调用函数时，函数代码执行之前创建。<br>⭐作用域是静态的，只要函数定义好了就一直存在，且不会再变化。执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放。</li>
<li>联系<br>执行上下文（对象）是从属于所作用域。全局上下文环境 → 全局作用域；函数上下文环境 → 对应的函数作用域。</li>
</ol>
<h4 id="2-3-3-作用域链"><a href="#2-3-3-作用域链" class="headerlink" title="2.3.3 作用域链"></a>2.3.3 作用域链</h4><ol>
<li>理解<br>多个上下级关系的作用域形成的链，它的方向是从下向上（从内到外）；查找变量时就是沿着作用域链来查找的</li>
<li>查找一个变量的查找规则<br>① 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入②；<br>② 在上一级作用域的执行上下文中查找对应的属性，如果有直接返回，否则进入③；<br>③ 在执行②的相同操作，直到全局作用域，如果还找不到就排除找不到的异常。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span> () &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span> () &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn2</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220314230130.png"></p>
<h4 id="2-3-4-面试题"><a href="#2-3-4-面试题" class="headerlink" title="2.3.4 面试题"></a>2.3.4 面试题</h4><p>⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span> (f) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">show</span>(fn); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315140359.png"><br>执行函数<code>fn()</code>时，会先在<code>fn</code>的作用域中查找<code>x</code>，没有找到后会跳到其外部的作用域中继续寻找，<code>fn</code>的作用域和<code>show</code>的作用域是同级的不会相互查找。<br>⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">fn2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(fn2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">fn2</span>();</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315142215.png"><br>报错的原因是<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315142435.png"><br>在函数作用域中查找不到<code>fn2</code>，会到全局作用域中继续查找，在全局作用域中不存在<code>fn2</code>。<br>※ 如果想要调用<code>fn2</code>，应该修改代码为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">fn2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">fn2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">fn2</span>(); <span class="comment">// 结果为打印fn2</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4闭包"><a href="#2-4闭包" class="headerlink" title="2.4闭包"></a>2.4闭包</h3><ol>
<li><p>如何产生闭包？<br>当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包。</p>
</li>
<li><p>闭包是什么？<br>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<blockquote>
<p>使用chrome调试查看：<br>※ 理解一：闭包是嵌套的内部函数（该函数中引用了外部函数的变量）<br>※ 理解二：包含被引用变量（函数）的对象<br><b>注意：</b>闭包存在于嵌套的内部函数中</p>
</blockquote>
</li>
<li><p>产生闭包的条件？</p>
</li>
</ol>
<ul>
<li>函数嵌套</li>
<li>内部函数引用了外部函数的数据（变量 \ 函数）</li>
<li>执行了外部函数</li>
</ul>
<h4 id="2-4-1-常见的闭包"><a href="#2-4-1-常见的闭包" class="headerlink" title="2.4.1 常见的闭包"></a>2.4.1 常见的闭包</h4><ol>
<li>将函数作为另一个函数的返回值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span> () &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span> () &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fn1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f);</span><br></pre></td></tr></table></figure>
结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315154451.png"><br>上述过程中<b>创建了1个闭包</b>。通过代码<code>fn1()</code>产生。<br>再执行下列代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f</span>(); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li>
<li>将函数作为实参传递给另一个函数调用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showDelay</span> (msg, time) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">  &#125;, time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showDelay</span>(<span class="string">&#x27;延迟输出&#x27;</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
上述代码在执行过程中产生了闭包。因为<br>嵌套的内部函数引用了外部函数的变量<code>msg</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315160727.png"><br>若将代码修改如下，就不会产生闭包<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showDelay</span> (msg, time) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;无闭包产生&#x27;</span>)；</span><br><span class="line">  &#125;, time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showDelay</span>(<span class="string">&#x27;延迟输出&#x27;</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-4-2-闭包的作用"><a href="#2-4-2-闭包的作用" class="headerlink" title="2.4.2 闭包的作用"></a>2.4.2 闭包的作用</h4><ol>
<li><p>使得函数内部的变量在函数执行完后，仍存活在内存中（延长了局部变量的生命周期）</p>
</li>
<li><p>让函数外部可以操作（读写）到函数内部的数据（变量/函数）</p>
</li>
</ol>
<p>问题：<br><b>※ 1. 函数执行完后，函数内部声明的局部变量是否还在？</b><br>一般是不存在，存在于闭包中的变量才可能存在</p>
<p><b>※ 2. 在函数外部能直接访问函数内部的局部变量吗？</b><br>不能，但是通过闭包可以让外部操作它</p>
<h4 id="2-4-3-闭包的生命周期"><a href="#2-4-3-闭包的生命周期" class="headerlink" title="2.4.3 闭包的生命周期"></a>2.4.3 闭包的生命周期</h4><ol>
<li>产生：在嵌套内部函数定义执行完时就产生了（不是在调用时）</li>
<li>死亡：在嵌套的内部函数成为垃圾对象时 </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span> () &#123;</span><br><span class="line">  <span class="comment">// 此时闭包就已经产生了（函数提升，内部函数对象已经创建了）</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span> () &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fn1</span>();</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// 4</span></span><br><span class="line">f = <span class="literal">null</span>;<span class="comment">// 闭包死亡（包含必报的函数对象成为垃圾对象）</span></span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-闭包的应用：定义JS模块"><a href="#2-4-3-闭包的应用：定义JS模块" class="headerlink" title="2.4.3 闭包的应用：定义JS模块"></a>2.4.3 闭包的应用：定义JS模块</h4><p>JS模块是具有特定功能的JS文件，将所有的数据和功能都封装在一个函数内部（私有的），只向外暴露一个包含n个方法的对象或者函数，模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能。</p>
<p><b>※ 方式一</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myModule</span> () &#123;</span><br><span class="line">  <span class="comment">// 私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&quot;My module&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 操作数据的对象</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doSomething</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;doSomething()&#x27;</span>, msg.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doOtherthing</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;doOtherthing()&#x27;</span>, msg.<span class="title function_">toLowerCase</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露对象（给外部使用的方法）</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>※ 方式二</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&quot;My module&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 操作数据的对象</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doSomething</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;doSomething()&#x27;</span>, msg.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doOtherthing</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;doOtherthing()&#x27;</span>, msg.<span class="title function_">toLowerCase</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露对象（给外部使用的方法）</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">myModule</span> = &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h4 id="2-4-4-闭包的缺点及解决"><a href="#2-4-4-闭包的缺点及解决" class="headerlink" title="2.4.4 闭包的缺点及解决"></a>2.4.4 闭包的缺点及解决</h4><ol>
<li>缺点：<br>■ 函数执行完后，函数内的局部变量没有释放，占用内存时间会变长<br>■ 容易造成内存泄漏 【内存泄漏：内存占用却不使用】</li>
<li>解决：<br>■ 能不用闭包就不用<br>■ 及时释放</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span> () &#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>[<span class="number">100000</span>];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fn1</span>();</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line">f = <span class="literal">null</span>;<span class="comment">// 让内部函数成为垃圾对象 --&gt; 回收闭包</span></span><br></pre></td></tr></table></figure>
<p>补充知识点：<a href="https://qw-null.github.io/2022/03/20/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">内存溢出与内存泄漏</a></p>
<h4 id="2-4-5-面试题"><a href="#2-4-5-面试题" class="headerlink" title="2.4.5 面试题"></a>2.4.5 面试题</h4><p><b>⭐ 题目 1</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;This Window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  <span class="attr">getNameFunc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="title function_">getNameFunc</span>()());</span><br></pre></td></tr></table></figure>
<p>输出的结果为<code>This Window</code>，原因是函数调用时，<code>this</code>指向<code>window</code>，因此<code>this.name</code>指的是全局变量<code>name</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;This Window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  <span class="attr">getNameFunc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> that.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="title function_">getNameFunc</span>()());</span><br></pre></td></tr></table></figure>
<p>输出的结果为<code>My Object</code>，原因是<code>this</code>是在对象<code>object</code>的方法<code>getNameFunc</code>中进行调用的，以方法调用时，<code>this</code>指向调用该方法的对象，因此<code>that.name</code>相当于<code>object.name</code>。</p>
<p><b>⭐ 题目 2</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span> (n, o) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">fun</span>: <span class="keyword">function</span> (<span class="params">m</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fun</span>(m, n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">fun</span>(<span class="number">0</span>); <span class="comment">// undefidned</span></span><br><span class="line">a.<span class="title function_">fun</span>(<span class="number">1</span>); a.<span class="title function_">fun</span>(<span class="number">2</span>); a.<span class="title function_">fun</span>(<span class="number">3</span>);<span class="comment">// ? ? ?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">fun</span>(<span class="number">0</span>).<span class="title function_">fun</span>(<span class="number">1</span>).<span class="title function_">fun</span>(<span class="number">2</span>).<span class="title function_">fun</span>(<span class="number">3</span>);<span class="comment">// undefined ? ? ?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="title function_">fun</span>(<span class="number">0</span>).<span class="title function_">fun</span>(<span class="number">1</span>);<span class="comment">// undefined ?</span></span><br><span class="line">c.<span class="title function_">fun</span>(<span class="number">2</span>); c.<span class="title function_">fun</span>(<span class="number">3</span>);<span class="comment">// ? ?</span></span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefidned 0 0 0</span><br><span class="line">undefidned 0 1 2</span><br><span class="line">undefidned 0 1 1</span><br></pre></td></tr></table></figure>




<h2 id="3-面向对象高级"><a href="#3-面向对象高级" class="headerlink" title="3.面向对象高级"></a>3.面向对象高级</h2><h3 id="3-1-对象创建模式"><a href="#3-1-对象创建模式" class="headerlink" title="3.1 对象创建模式"></a>3.1 对象创建模式</h3><p>⭐ 方式一：Object构造函数模式</p>
<ul>
<li>套路：先创建空<code>Object</code>对象，再动态添加属性/方法</li>
<li>使用场景：起始时不确定对象内部数据</li>
<li>问题：语句太多</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个人：name:&quot;Tom&quot;,age:12</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">p.<span class="property">age</span> = <span class="number">12</span>;</span><br><span class="line">p.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">p.<span class="title function_">setName</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br></pre></td></tr></table></figure>
<p>结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220321112724.png"></p>
<p>⭐ 方式二：对象字面量模式</p>
<ul>
<li>套路：使用{}创建对象，同时指定属性/方法</li>
<li>使用场景：起始时对象内部数据是确定的</li>
<li>问题：如果创建多个对象，有重复代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个人：name:&quot;Tom&quot;,age:12</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">setName</span>: <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">p.<span class="title function_">setName</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>, p.<span class="property">age</span>); <span class="comment">// Jack 12</span></span><br></pre></td></tr></table></figure>

<p>⭐ 方式三：工厂模式</p>
<ul>
<li>套路：通过工厂函数动态创建对象并返回</li>
<li>适用场景：需要创建多个对象</li>
<li>问题：对象没有一个具体的类型，都是object类型</li>
</ul>
<p>※ 何为工厂函数？  —— 返回一个对象的函数成为工厂函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span> (name, age) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">age</span>: age,</span><br><span class="line">    <span class="attr">setName</span>: <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建2个人</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">createPerson</span>(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">createPerson</span>(<span class="string">&#x27;Jack&#x27;</span>,<span class="number">14</span>);</span><br></pre></td></tr></table></figure>

<p>⭐ 方式四：自定义构造函数模式</p>
<ul>
<li>套路：自定义构造函数，通过new创建对象</li>
<li>适用场景：需要创建多个类型确定的对象</li>
<li>问题：每个对象都有相同的数据，浪费内存</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">p1.<span class="title function_">setName</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但是此种方式创建的对象，每个对象中都包含<code>setName</code>方法，占用内存。</p>
<p>⭐ 方式五：构造函数+原型的组合模式</p>
<ul>
<li>套路：自定义构造函数，属性在函数中初始化，方法添加到原型上</li>
<li>适用场景：需要创建多个类型确定的对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="comment">// 在构造函数中，只初始化一般属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">13</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1, p2)</span><br></pre></td></tr></table></figure>
结果为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220321135956.png"></li>
</ul>
<h3 id="3-2-原型链继承"><a href="#3-2-原型链继承" class="headerlink" title="3.2 原型链继承"></a>3.2 原型链继承</h3><h4 id="3-2-1-方式一：-原型链继承"><a href="#3-2-1-方式一：-原型链继承" class="headerlink" title="3.2.1 方式一： 原型链继承"></a>3.2.1 方式一： 原型链继承</h4><p>过程如下：</p>
<ol>
<li>定义父类型构造函数</li>
<li>给父类型的原型添加方法</li>
<li>定义子类型的构造函数</li>
<li>创建父类型的对象赋值给子类型的原型</li>
<li>将子类型原型的构造属性设置为子类型</li>
<li>给子类型原型添加方法</li>
<li>创建子类型的对象：可以调用父类型的方法</li>
</ol>
<p><b>⭐ 关键点：子类型的原型为父类型的一个实例对象</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定义父类型构造函数</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Supper</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">supProp</span> = <span class="string">&#x27;Supper Property&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> 给父类型的原型添加方法</span><br><span class="line"><span class="title class_">Supper</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showSupperProp</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">supProp</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 定义子类型的构造函数</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">subProp</span> = <span class="string">&#x27;Sub Property&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型的原型为父类型的一个实例对象</span></span><br><span class="line"><span class="number">4.</span> 创建父类型的对象赋值给子类型的原型</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Supper</span>();</span><br><span class="line"><span class="number">5.</span> 将子类型原型的构造属性设置为子类型</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Sub</span></span><br><span class="line"><span class="number">6.</span> 给子类型原型添加方法</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showSubProp</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">subProp</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 创建子类型的对象：可以调用父类型的方法</span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">sub.<span class="title function_">showSupperProp</span>();</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220321171328.png"></p>
<h4 id="3-2-2-方式二：-借用构造函数继承（假的）"><a href="#3-2-2-方式二：-借用构造函数继承（假的）" class="headerlink" title="3.2.2 方式二： 借用构造函数继承（假的）"></a>3.2.2 方式二： 借用构造函数继承（假的）</h4><p>过程如下：</p>
<ol>
<li>定义父类型构造函数</li>
<li>定义子类型构造函数</li>
<li>在子类型构造函数中调用父类型构造</li>
</ol>
<p><b>⭐ 关键点：在子类型构造函数中通过<code>call()</code>调用父类型构造函数</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定义父类型构造函数</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 定义子类型构造函数</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span> (name, age, price) &#123;</span><br><span class="line">  <span class="number">3.</span> 在子类型构造函数中调用父类型构造</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age); <span class="comment">//相当于 this.Person(name,age)</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>, <span class="number">13000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure>
<p>结果为：<code>Student &#123; name: &#39;Tom&#39;, age: 12, price: 13000 &#125;</code></p>
<h4 id="3-2-3-方式三：-组合继承（原型链-借用构造函数）"><a href="#3-2-3-方式三：-组合继承（原型链-借用构造函数）" class="headerlink" title="3.2.3 方式三： 组合继承（原型链 + 借用构造函数）"></a>3.2.3 方式三： 组合继承（原型链 + 借用构造函数）</h4><p>过程如下： </p>
<ol>
<li>利用原型链实现对父类型对象的方法继承</li>
<li>利用<code>call()</code>借用父类型构造函数初始化相同属性</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name, age) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span> (name, age, price) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age); <span class="comment">// 为了得到属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 为了能看到父类型的方法</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span>; <span class="comment">// 修正constructor属性</span></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setPrice</span> = <span class="keyword">function</span> (<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>, <span class="number">13000</span>);</span><br><span class="line">s.<span class="title function_">setName</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">s.<span class="title function_">setPrice</span>(<span class="number">15000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br></pre></td></tr></table></figure>
<p>结果为<code>Student &#123; name: &#39;Jack&#39;, age: 12, price: 15000 &#125;</code></p>
<h4 id="3-2-4-补充：new一个对象背后做了什么？"><a href="#3-2-4-补充：new一个对象背后做了什么？" class="headerlink" title="3.2.4 补充：new一个对象背后做了什么？"></a>3.2.4 补充：new一个对象背后做了什么？</h4><ul>
<li>创建一个空对象</li>
<li>给对象设置<code>__proto__</code>，值为构造函数对象的<code>prototype</code>属性值</li>
<li>执行构造函数体（给对象添加属性 / 方法）</li>
</ul>
<h2 id="4-线程机制与事件机制"><a href="#4-线程机制与事件机制" class="headerlink" title="4.线程机制与事件机制"></a>4.线程机制与事件机制</h2><h3 id="4-1-进程与线程"><a href="#4-1-进程与线程" class="headerlink" title="4.1 进程与线程"></a>4.1 进程与线程</h3><p><b>进程（process）：</b>程序的一次执行，它占有一片独有的内存空间。可以通过window任务管理器查看进程。<br><b>线程（thread）：</b>线程是进程内一个独立执行的单元，是程序执行的一个完整流程，是CPU的最小的调度单元。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220322145958.png"><br>如果一个程序有2个进程，每个进程包含1个线程，则该程序是单线程程序。</p>
<p>⭐ 相关知识：</p>
<ol>
<li>应用程序必须运行在某个进程的某个线程上</li>
<li>一个进程至少有一个运行的线程：主线程（线程启动后自动创建）</li>
<li>一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的</li>
<li>一个进程内的数据可以供其中的多个线程直接共享</li>
<li>多个进程之间的数据是不能直接共享的</li>
<li>线程池（thread pool）：保存多个线程对象的容器，实现线程对象的反复利用</li>
</ol>
<p>⭐ 相关问题：</p>
<ol>
<li>何为多进程与多线程？<br>多进程运行：一个应用程序可以启动多个实例运行<br>多线程：在一个进程内，同时有多个线程运行</li>
<li>比较单线程与多线程？<br>多线程：【优点】能有效提升CPU的利用率 【缺点】创建多线程开销，线程间切换开销，死锁与状态同步问题<br>单线程：【优点】顺序变成简单易懂 【缺点】效率低</li>
<li>JS是单线程还是多线程？<br>JS是单线程运行的。但使用H5中的Web Workers可以多线程运行。</li>
<li>浏览器运行是单线程还是多线程？<br>浏览器运行是多线程。</li>
<li>浏览器运行是单进程还是多进程？<br>有单进程也有多进程。其中，单进程：firefox、老版IE，多进程：chrome、Edge。<h3 id="4-2-浏览器内核"><a href="#4-2-浏览器内核" class="headerlink" title="4.2 浏览器内核"></a>4.2 浏览器内核</h3></li>
</ol>
<table>
<thead>
<tr>
<th>浏览器名称</th>
<th>内核</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome、Safari</td>
<td>webkit</td>
</tr>
<tr>
<td>firefox</td>
<td>Gecko</td>
</tr>
<tr>
<td>IE</td>
<td>Trident</td>
</tr>
<tr>
<td>360，搜狗等国内浏览器</td>
<td>Trident + webkit</td>
</tr>
</tbody></table>
<p>浏览器内核由很多模块组成，其中包括：</p>
<ul>
<li>js引擎模块：负责js程序的编译与运行</li>
<li>html，css文档解析模块：负责页面文本解析</li>
<li>DOM/CSS模块：负责dom/css在内存中的相关处理</li>
<li>布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）</li>
</ul>
<p><b>【上述部分运行在主线程】</b></p>
<ul>
<li>……</li>
<li>定时器模块：负责定时器的管理</li>
<li>DOM事件响应模块：负责事件管理</li>
<li>网络请求模块：负责ajax请求</li>
</ul>
<p><b>【上述部分运行在分线程】</b></p>
<h3 id="4-3-定时器引发的思考"><a href="#4-3-定时器引发的思考" class="headerlink" title="4.3 定时器引发的思考"></a>4.3 定时器引发的思考</h3><p>相关问题：</p>
<ol>
<li>定时器真的是定时执行的吗？<br>定时器并不能保证真正定时执行，一般会延迟一丁点（可以接受），也可能延迟很长时间（不能接收）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;启动定时器前……&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器执行了&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>() - start);</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
多次执行结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324103330.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324103357.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324103437.png"></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;启动定时器前……&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器执行了&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>() - start);</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多次执行结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324110425.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324110514.png"></p>
<ol start="2">
<li><p>定时器回调函数是在哪个线程执行的？<br>在主线程执行（JS是单线程的）</p>
</li>
<li><p>定时器是如何实现的？<br>事件循环模型（详情见后续内容）</p>
</li>
</ol>
<h3 id="4-4-JS是单线程执行的"><a href="#4-4-JS是单线程执行的" class="headerlink" title="4.4 JS是单线程执行的"></a>4.4 JS是单线程执行的</h3><ol>
<li>如何证明JS执行是单线程的？<br>setTimeout()的回调函数是在主线程执行的<br>定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout --&gt; 2000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout --&gt; 1000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn函数执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>
执行结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324113636.png"></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout --&gt; 2000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout --&gt; 1000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn函数执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;alert之前&#x27;</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;---------&#x27;</span>); <span class="comment">// 暂停当前主线程的执行，同时暂停计时，点击确定之后，恢复程序的执行和计时</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;alert之后&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324114233.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324114309.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324114353.png"></p>
<ol start="2">
<li><p>为什么JS要用单线程模式，而不用多线程模式？<br>Javascript的单线程与它的用途有关，作为浏览器脚本语言，Javascript的主要用途是与用户互动以及操作DOM，这决定了它只能是单线程的，负责会带来很复杂的同步问题。</p>
</li>
<li><p>代码分类</p>
</li>
</ol>
<ul>
<li>初始化代码</li>
<li>回调代码</li>
</ul>
<ol start="4">
<li>JS引擎执行代码的基本流程<br>先执行初始化代码【包含一些特别的代码：设置定时器、绑定监听、发送ajax请求】，后面的某一个时刻才会执行回调代码</li>
</ol>
<blockquote>
<p>其中，设置定时器指的是setTimeout(),不包括内部的回调函数，其内部的回调函数需要在初始化代码执行完毕之后再执行</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout --&gt; 2000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout --&gt; 1000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout --&gt; 0&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn函数执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;alert之前&#x27;</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;---------&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;alert之后&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>最终结果执行顺序：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324143955.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324144022.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324144050.png"></p>
<h3 id="4-5-事件循环（轮询）模型"><a href="#4-5-事件循环（轮询）模型" class="headerlink" title="4.5 事件循环（轮询）模型"></a>4.5 事件循环（轮询）模型</h3><h4 id="4-5-1-模型原型图"><a href="#4-5-1-模型原型图" class="headerlink" title="4.5.1 模型原型图"></a>4.5.1 模型原型图</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/2356897452565.png"><br>对于JS代码可以分为两类：</p>
<ol>
<li>初始化执行代码（同步代码）：包含绑定dom事件监听，设置定时器，发送ajax请求的代码</li>
<li>回调执行代码（异步代码）：处理回调逻辑</li>
</ol>
<p><b>JS引擎执行代码的基本流程：</b>初始化代码 ➡ 回调代码</p>
<p><b>模型的两个重要组成部分：</b>事件管理模块、回调队列</p>
<p><b>🍎 模型的运转流程：</b>执行初始化代码，将事件回调函数交给对应模块管理 ➡ 当事件发生时，管理模块会将回调函数及其数据添加到回调队列中 ➡ 只有当初始化代码执行完成后（可能需要一段时间），才会遍历读取回调队列中的回调函数执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行fn1()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击了btn&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行fn2()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn2</span>();</span><br></pre></td></tr></table></figure>
<p>上述代码的执行结果不唯一，首先确定的结果是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">执行<span class="title function_">fn1</span>()</span><br><span class="line">执行<span class="title function_">fn2</span>()</span><br></pre></td></tr></table></figure>
<p>剩余的<code>执行了定时器</code>和<code>点击了btn</code>，需要看点击btn的时机，如果点击btn在前，则执行顺序为<code>点击了btn</code>、<code>执行了定时器</code>，否则为<code>执行了定时器</code>、<code>点击了btn</code>。但是无论怎样<code>执行fn1()</code>和<code>执行fn2()</code>的顺序是不会改变的，因为这个为初始化执行代码。</p>
<h4 id="4-5-2-相关概念"><a href="#4-5-2-相关概念" class="headerlink" title="4.5.2 相关概念"></a>4.5.2 相关概念</h4><ul>
<li>执行栈（execution stack）：所有代码都是在此空间中执行的</li>
<li>浏览器内核（browser core）:js引擎模块（在主线程）、其他模块（在主/分线程处理）</li>
<li>任务队列（task queue）、消息队列（message queue）、事件队列（event queue）：同一个callback queue</li>
<li>事件轮询（event loop）：从任务队列中循环取出回调函数放入执行栈中处理（一个接一个）</li>
</ul>
<h3 id="4-6-H5-Web-Workers（多线程）"><a href="#4-6-H5-Web-Workers（多线程）" class="headerlink" title="4.6 H5 Web Workers（多线程）"></a>4.6 H5 Web Workers（多线程）</h3><p>H5提供了JS分线程的实现，取名为：<code>Web Workers</code>，我们可以将一些大计算量的代码交由web Worker 运行而不冻结用户界面。但是子线程完全受主线程控制，且不操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>相关API：</p>
<ul>
<li><code>Worker</code>：构造函数，加载分线程执行的JS文件</li>
<li><code>Worker.prototype.onmessage</code>：用于接收另一个线程的回调函数</li>
<li><code>Worker.prototype.postMessage</code>：向另一个线程发送消息</li>
</ul>
<p>不足之处：</p>
<ol>
<li><code>Worker</code>内代码不能操作DOM（更新UI）</li>
<li>不能跨域加载JS</li>
<li>不是每个浏览器都支持这个新特性</li>
<li>速度慢</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;number&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> number = input.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建一个Worker对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;work.js&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 绑定接收消息的监听</span></span></span><br><span class="line"><span class="language-javascript">    worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;主线程接收分线程返回的数据&#x27;</span> + event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 向分线程发送消息</span></span></span><br><span class="line"><span class="language-javascript">    worker.<span class="title function_">postMessage</span>(number);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;主线程向分线程发送数据&#x27;</span> + number);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// work.js文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="title function_">fn</span>(n - <span class="number">1</span>) + <span class="title function_">fn</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> onmessage = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;分线程接收主线程发送的数据&#x27;</span> + event.<span class="property">data</span>);</span><br><span class="line">  <span class="keyword">var</span> result = <span class="title function_">fn</span>(event.<span class="property">data</span>);</span><br><span class="line">  <span class="title function_">postMessage</span>(result);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;分线程向主线程发送数据&#x27;</span> + result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142438.png"><br>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142359.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142107.png"></p>
<p>主线程中的<code>this</code>是<code>window</code>，而work线程中的<code>this</code>是一个专门为 <code>Worker</code> 定制的全局对象。</p>
<h2 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h2><h4 id="JS分号问题"><a href="#JS分号问题" class="headerlink" title="JS分号问题"></a>JS分号问题</h4><ul>
<li>JS一条语句的后面可以不加分号</li>
<li>是否加分号是编码风格问题，没有应该不应该，只有开发者喜欢与否</li>
<li>下面两种情况不加分号会报错<br>※ 小括号开头的前一条语句 （匿名函数自调用）<br>※ 中方括号开头的前一条语句<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>小括号开头的前一条语句 （匿名函数自调用）</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">;(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line">错误理解：</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>中方括号开头的前一条语句</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">;[<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">错误理解：</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>[<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
⭐解决方法：在行首加分号</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表【Leetcode】</title>
    <url>/2022/02/24/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220224221951.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220224222027.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目需要解决两个问题：</p>
<ol>
<li>如何判断链表中有环？</li>
<li>链表存在环，如何查找到入口？</li>
</ol>
<p><b>如何判断链表中有环？</b><br>可以采用快慢指针法，慢指针一次走一步，快指针一次走两步，如果链表中存在环，两指针一定会在环内相遇。</p>
<p><b>链表存在环，如何查找到入口？</b></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20220224221327.jpg"></p>
<p>这表明，<b>从头结点出发一个指针，从相遇结点 也出发一个指针，这两个指针每次只走一个结点， 那么当这两个指针相遇的时候就是 环形入口的结点。</b></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [fast,slow] = [head,head];</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>)&#123;</span><br><span class="line">        <span class="comment">// slow+1，fast+2，一定会相遇，相遇就要抓住相遇点</span></span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">            <span class="keyword">let</span> meet = fast; <span class="comment">// 相遇点</span></span><br><span class="line">            <span class="keyword">let</span> start = head; <span class="comment">// 开始节点</span></span><br><span class="line">            <span class="keyword">while</span>(meet !== start)&#123;</span><br><span class="line">                meet = meet.<span class="property">next</span>;<span class="comment">// 相遇点指针</span></span><br><span class="line">                start = start.<span class="property">next</span>; <span class="comment">// 头节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> meet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>青训营-数据可视化基础</title>
    <url>/2022/02/21/%E9%9D%92%E8%AE%AD%E8%90%A5-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="01-数据可视化的概念和基本原则"><a href="#01-数据可视化的概念和基本原则" class="headerlink" title="01 数据可视化的概念和基本原则"></a>01 数据可视化的概念和基本原则</h2><h4 id="什么是数据可视化？"><a href="#什么是数据可视化？" class="headerlink" title="什么是数据可视化？"></a>什么是数据可视化？</h4><p>Anything that converts <b>data</b> into a <b>visual representation</b> (like charts,graphs,maps,sometimes even just tables)</p>
<h4 id="为什么数据可视化？"><a href="#为什么数据可视化？" class="headerlink" title="为什么数据可视化？"></a>为什么数据可视化？</h4><ol>
<li>记录信息</li>
<li>分析推理</li>
<li>证实假设</li>
<li>交流思想</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221124425.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221124441.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221124458.png"></p>
<p>可视化实现了 从看到物体 到 获取知识。<br>可视化可以更加直观的展现数据之间的关系，便于分析与研究。</p>
<h4 id="可视化设计原则"><a href="#可视化设计原则" class="headerlink" title="可视化设计原则"></a>可视化设计原则</h4><p>能够<b>正确</b>地表达数据中的信息而<b>不产生偏差与歧义</b></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125543.png"></p>
<h4 id="常见的错误可视化"><a href="#常见的错误可视化" class="headerlink" title="常见的错误可视化"></a>常见的错误可视化</h4><ol>
<li>透视失真</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125153.png"></p>
<ol start="2">
<li>图形设计 &amp; 数据尺度</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125240.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125309.png"></p>
<ol start="3">
<li>数据上下文</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125347.png"></p>
<blockquote>
<p>一个出色的可视化设计可在最短的时间内，是用最少的空间、用最少的笔墨为观众提供最多的信息内涵。</p>
</blockquote>
<h4 id="Data-ink-Ratio"><a href="#Data-ink-Ratio" class="headerlink" title="Data-ink Ratio"></a>Data-ink Ratio</h4><p>最大化数据墨水占比 Data-ink Ratio</p>
<ul>
<li>可视化图形由墨水和空白区域构成</li>
<li>数据墨水：可视化图形当中不可擦除的核心部分被称为“数据墨水”</li>
<li>擦除数据墨水将减少图形所传达的信息</li>
<li>数据墨水占比：可视化图形中用于展示核心数据的“墨水”在整体可视化所使用的墨水中的比例</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125942.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221130007.png"></p>
<h2 id="02-视觉感知"><a href="#02-视觉感知" class="headerlink" title="02 视觉感知"></a>02 视觉感知</h2><p>可视化致力于外部认知，即怎样利用大脑以外的资源来增强大脑本身的认知能力。</p>
<h4 id="感知"><a href="#感知" class="headerlink" title="感知"></a>感知</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221130218.png"></p>
<h4 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221130240.png"></p>
<p>人类的视觉系统观察的是变化，而不是绝对值，并且容易被边界吸引。<br>在可视化设计第过程中，设计者需要充分考虑到人类感知系统的这些现象，以使得设计的可视化结果不会存在阻碍或者误导用户的可视化元素。</p>
<h2 id="03-数据可视化工具"><a href="#03-数据可视化工具" class="headerlink" title="03 数据可视化工具"></a>03 数据可视化工具</h2><h4 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h4><p>D3.js用于数据可视化的开源的JavaScript函数库。<br><a href="https://www.d3js.org.cn/">D3.js官网</a></p>
<h4 id="Vega"><a href="#Vega" class="headerlink" title="Vega"></a>Vega</h4><p>Vega是一种可视化语法。通过其声明式语言，可以用json格式描述可视化的视觉外观和交互行为，并使用Canvas或SVG生成视图。<br><a href="http://vega.github.io/">Vega官网</a></p>
<h4 id="G2"><a href="#G2" class="headerlink" title="G2"></a>G2</h4><p>G2 是一套基于图形语法理论的可视化底层引擎，以数据驱动，提供图形语法与交互语法，具有高度的易用性和扩展性。使用 G2，你可以无需关注图表各种繁琐的实现细节，一条语句即可使用 Canvas 或 SVG 构建出各种各样的可交互的统计图表。<br><a href="https://g2.antv.vision/zh/docs/manual/about-g2">G2官网</a></p>
<h4 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221131327.png"></p>
<p><a href="https://echarts.apache.org/zh/index.html">Echarts官网</a></p>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
  </entry>
  <entry>
    <title>数组中第K个独一无二的字符串【Leetcode】</title>
    <url>/2022/02/19/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E4%B8%AA%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><b>独一无二的字符串</b> 指的是在一个数组中只出现过 <b>一次</b> 的字符串。</p>
<p>给你一个字符串数组 <code>arr</code> 和一个整数 <code>k</code> ，请你返回 <code>arr</code> 中第 <code>k</code> 个 <b>独一无二的字符串</b> 。如果 <b>少于</b> <code>k</code> 个独一无二的字符串，那么返回 <code>空字符串 &quot;&quot;</code> 。</p>
<p>注意，按照字符串在原数组中的 <b>顺序</b> 找到第 k 个独一无二字符串。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220219142148.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用Map统计数组中元素的个数，筛选Map中数量为1的键，将其放入数组中。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kthDistinct = <span class="keyword">function</span>(<span class="params">arr, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> arr)&#123;</span><br><span class="line">        map.<span class="title function_">set</span>(i,(map.<span class="title function_">get</span>(i)|| <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// extra = extra || 0;</span></span><br><span class="line">        <span class="comment">// 如果extra 为undefined或者null,false, extra=0 ;否则为原值 --&gt; 很常见的非空判断。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(map)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> map)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">        <span class="keyword">if</span>(item[<span class="number">1</span>] === <span class="number">1</span>) res.<span class="title function_">push</span>(item[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res[k-<span class="number">1</span>]||<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220219142709.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220219142653.png"></p>
<h4 id="知识点-–-常见的非空判断"><a href="#知识点-–-常见的非空判断" class="headerlink" title="知识点 – 常见的非空判断"></a>知识点 – 常见的非空判断</h4><p><code>extra = extra || 0;</code></p>
<p>如果<code>extra</code> 为<code>undefined</code>或者<code>null</code>,<code>false</code>, <code>extra=0</code> ；否则为原值。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的Map详解</title>
    <url>/2022/02/19/JavaScript%E7%9A%84Map%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>在ES6之前，JS实现“键/值”式存储可以使用<code>Object</code>来高效地完成，也就是使用对象属性作为键，再使用属性来引用值。</p>
<p>ES6中出现Map，<code>Map</code>是一种新的集合类型。<code>Map</code>对象保存键-值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<h2 id="Map和Object的区别"><a href="#Map和Object的区别" class="headerlink" title="Map和Object的区别"></a>Map和Object的区别</h2><ul>
<li><code>Map</code>的键值是有序的（FIFO原则，First Input First Output），而添加到对象中的键则不是</li>
<li><code>Map</code>的键值对个数可以通过<code>size</code>属性获取，而<code>Object</code>的键值对个数只能手动计算</li>
<li><code>Object</code> 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li>
</ul>
<h2 id="Map对象的方法"><a href="#Map对象的方法" class="headerlink" title="Map对象的方法"></a>Map对象的方法</h2><ul>
<li><code>set(key, val)</code> ：向Map中添加新元素</li>
<li><code>get(key)</code>: 通过键值查找特定的数值并返回</li>
<li><code>has(key)</code>: 判断Map对象中是否有key所对应的值，有返回true,否则返回false</li>
<li><code>delete(key)</code>: 通过键值从Map中移除对应的数据</li>
<li><code>clear()</code>: 将这个Map中的所有元素删除</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;a&#x27;</span>,<span class="number">111</span>],[<span class="string">&#x27;b&#x27;</span>,<span class="number">222</span>]]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m1); <span class="comment">// &#123;&#x27;a&#x27; =&gt; 111, &#x27;b&#x27; =&gt; 222&#125;</span></span><br><span class="line"></span><br><span class="line">m1.<span class="title function_">get</span>(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// 111</span></span><br><span class="line">m1.<span class="title function_">has</span>(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">m1.<span class="title function_">set</span>(<span class="string">&#x27;c&#x27;</span>,<span class="number">333</span>) <span class="comment">// &#123;&#x27;a&#x27; =&gt; 111, &#x27;b&#x27; =&gt; 222, &#x27;c&#x27; =&gt; 333&#125;</span></span><br><span class="line">m1.<span class="title function_">delete</span>(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m1); <span class="comment">// &#123;&#x27;a&#x27; =&gt; 111, &#x27;c&#x27; =&gt; 333&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Map的遍历方法"><a href="#Map的遍历方法" class="headerlink" title="Map的遍历方法"></a>Map的遍历方法</h2><ul>
<li><code>keys()</code>：返回键名的遍历器</li>
<li><code>values()</code>：返回键值的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>], [<span class="string">&#x27;b&#x27;</span>,  <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">// &quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> map)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;a&quot;, 1]</span></span><br><span class="line"><span class="comment">// [&quot;b&quot;, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;a&quot; 1</span></span><br><span class="line"><span class="comment">// &quot;b&quot; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of...遍历map等同于使用map.entries()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;a&quot; 1</span></span><br><span class="line"><span class="comment">// &quot;b&quot; 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用Map解题：<a href="https://qw-null.github.io/2022/02/19/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E4%B8%AA%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90Leetcode%E3%80%91/">数组中第K个独一无二的字符串【Leetcode】</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网ACM模式输入输出</title>
    <url>/2022/02/14/%E7%89%9B%E5%AE%A2%E7%BD%91ACM%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<blockquote>
<p>凡事预则立，不预则废。</p>
</blockquote>
<p><a href="https://ac.nowcoder.com/acm/contest/5657">练习地址</a></p>
<h2 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A + B (1)"></a>A + B (1)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214221602.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = <span class="title function_">readline</span>())&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = line.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">parseInt</span>(lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">parseInt</span>(lines[<span class="number">1</span>]);</span><br><span class="line">    <span class="title function_">print</span>(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-2"><a href="#A-B-2" class="headerlink" title="A + B (2)"></a>A + B (2)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214222656.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> len = <span class="title function_">readline</span>();</span><br><span class="line"><span class="keyword">while</span>(len--)&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = <span class="title function_">readline</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">parseInt</span>(lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">parseInt</span>(lines[<span class="number">1</span>]);</span><br><span class="line">    <span class="title function_">print</span>(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-3"><a href="#A-B-3" class="headerlink" title="A + B (3)"></a>A + B (3)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214224250.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = <span class="title function_">readline</span>())&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = line.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">parseInt</span>(lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">parseInt</span>(lines[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(a===<span class="number">0</span> &amp;&amp; b===<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="title function_">print</span>(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-4"><a href="#A-B-4" class="headerlink" title="A + B (4)"></a>A + B (4)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220215231917.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220215232009.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = <span class="title function_">readline</span>())&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = line.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = <span class="built_in">parseInt</span>(lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">        res += <span class="built_in">parseInt</span>(lines[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">print</span>(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-5"><a href="#A-B-5" class="headerlink" title="A + B (5)"></a>A + B (5)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220215232728.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220215232745.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> len = <span class="title function_">readline</span>();</span><br><span class="line"><span class="keyword">while</span>(len--)&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = <span class="title function_">readline</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> end = <span class="built_in">parseInt</span>(lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=end;++i)&#123;</span><br><span class="line">        res += <span class="built_in">parseInt</span>(lines[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">print</span>(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="A-B-6"><a href="#A-B-6" class="headerlink" title="A + B (6)"></a>A + B (6)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220145030.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220145111.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = <span class="title function_">readline</span>())&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = line.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = (lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">        sum += <span class="built_in">parseInt</span>(lines[len+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">print</span>(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="A-B-7"><a href="#A-B-7" class="headerlink" title="A + B (7)"></a>A + B (7)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220145904.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220145920.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = <span class="title function_">readline</span>())&#123;</span><br><span class="line">    lines = line.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(lines[<span class="number">0</span>])===<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="title function_">print</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;lines.<span class="property">length</span>;++i)&#123;</span><br><span class="line">        sum += <span class="built_in">parseInt</span>(lines[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">print</span>(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串排序（1）"><a href="#字符串排序（1）" class="headerlink" title="字符串排序（1）"></a>字符串排序（1）</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220152332.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220152405.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> len = <span class="title function_">readline</span>();</span><br><span class="line"><span class="keyword">let</span> arr = <span class="title function_">readline</span>().<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="title function_">print</span>(arr.<span class="title function_">sort</span>().<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="字符串排序（2）"><a href="#字符串排序（2）" class="headerlink" title="字符串排序（2）"></a>字符串排序（2）</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220182815.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220182905.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = <span class="title function_">readline</span>())&#123;</span><br><span class="line">    lines = line.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="title function_">print</span>(lines.<span class="title function_">sort</span>().<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串排序（3）"><a href="#字符串排序（3）" class="headerlink" title="字符串排序（3）"></a>字符串排序（3）</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220184015.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220184036.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = <span class="title function_">readline</span>())&#123;</span><br><span class="line">    lines = line.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="title function_">print</span>(lines.<span class="title function_">sort</span>().<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>牛客网输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title>有序数组中的单一元素【Leetcode】</title>
    <url>/2022/02/14/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0-Leetcode/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">题目链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p>
<p>请你找出并返回只出现一次的那个数。</p>
<p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214202717.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求解决方案必须满足 <code>O(log n)</code> 时间复杂度，可以使用二分查找解题。</p>
<p>对于子序列而言，可以通过子序列长度来判断结果是否存在。</p>
<ul>
<li>如果长度为 偶数 ，则结果 不存在</li>
<li>如果长度为 奇数 ，则结果 存在 【因为成双成对的元素中存在一个单身狗】</li>
</ul>
<p>在二分查找过程中存在3种情况：</p>
<ol>
<li>中间元素就是结果，此时 <code>nums[mid]!==nums[mid-1] &amp;&amp; nums[mid]!==nums[mid+1]</code>【最好的情况了】</li>
<li>中间元素与前一个元素相同，此时 <code>nums[mid]===nums[mid-1]</code></li>
<li>中间元素与后一个元素相同，此时 <code>nums[mid]===nums[mid+1]</code><br>对于2,3两种情况，需要通过左右两个子序列的长度判断结果存在哪一侧。</li>
</ol>
<p>当结束二分查找还没有返回结果，那么此时一定是<code>left&gt;right</code>，那么结果就是<code>nums[right]</code></p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNonDuplicate = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">//必须满足 O(log n) 时间复杂度 --&gt; 二分查找</span></span><br><span class="line">    <span class="comment">//对于子序列而言：偶数-&gt;不存在，奇数-&gt;存在</span></span><br><span class="line">    <span class="keyword">let</span> [left,right]=[<span class="number">0</span>,nums.<span class="property">length</span>-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left+(right-left&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]===nums[mid-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="comment">//此时要判断两边的长度是奇数还是偶数</span></span><br><span class="line">            <span class="keyword">if</span>((right-mid)%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">                right = mid-<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]===nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid-left)%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">                left = mid+<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[right];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="更多的思考"><a href="#更多的思考" class="headerlink" title="更多的思考"></a>更多的思考</h2><p>其实如果抛开题目要求的解决方案必须满足 <code>O(log n)</code> 时间复杂度，还可以采取位运算的方法。</p>
<h4 id="异或操作"><a href="#异或操作" class="headerlink" title="异或操作"></a>异或操作</h4><p>异或是一种基于二进制的位运算，用符号<code>XOR</code>或者 <code>^</code> 表示，其运算法则是对运算符两侧数的每一个二进制位进行比较，同值取0，异值取1。</p>
<p>例如：<code>1^4=3</code> —&gt; <code>(001) ^ (100) = (101)</code></p>
<p><b>异或操作的运算法则</b></p>
<ol>
<li>a ^ b = b ^ a</li>
<li>a ^ b ^ c = (a ^ b) ^ c = a ^ (b ^ c)</li>
<li>d = a ^ b ^ c 可以推出 a = d ^ b ^c</li>
<li>a ^ b ^ a = b 【<em>很重要的一个性质</em>】</li>
</ol>
<p><b>异或操作的典型题目</b></p>
<p>Q1: 对于一个有多个数值的数组，只有一个是唯一的，其他都是成对的，怎样快速找到这个唯一值。</p>
<p>其实就是这道题目的另一种说法，因此本题抛开时间复杂度的话，还可以使用异或操作的方法解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNonDuplicate = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.<span class="property">length</span>;++i)&#123;</span><br><span class="line">        res^=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Q2: 给你1-1000个连续自然数，然后从中随机去掉两个，再打乱顺序，要求只遍历一次，求出被去掉的两个数。</p>
<p>方法1：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214210137.png"><br>方法2：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214210512.png"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目实战：尚品汇</title>
    <url>/2022/02/13/Vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9A%E5%B0%9A%E5%93%81%E6%B1%87/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Vf4y1T7bw?share_source=copy_web">尚硅谷VUE项目实战-尚品汇(大型\重磅)</a></p>
<h2 id="0-项目简介"><a href="#0-项目简介" class="headerlink" title="0 项目简介"></a>0 项目简介</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213145705.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213145730.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213150118.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213150219.png"></p>
<h2 id="1-项目初始化"><a href="#1-项目初始化" class="headerlink" title="1 项目初始化"></a>1 项目初始化</h2><p><b>★vue-cli脚手架初始化项目</b></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213151031.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213152327.png"><br>– 选择vue2版本</p>
<p><b>★认识项目的组成</b></p>
<ul>
<li> <code>node_modules</code>文件夹：项目依赖</li>
<li> <code>public</code>文件夹：一般放置一些静态资源（图片），需要注意，放在public文件夹中的静态资源，webpack进行打包时，会原封不动的打包到dist文件夹中。</li>
<li><code>src</code>文件夹（程序员源代码文件夹）：</li>
</ul>
<ul>
<li><ul>
<li><code>assets</code>文件夹：一般也是放置静态资源（一般放置多个组件共用的静态资源），需要注意，放置在assets文件夹里面的静态资源，在webpack打包的时候，webpack会把静态资源当作一个模块，打包到JS文件里面。</li>
</ul>
</li>
<li><ul>
<li><code>components</code>文件夹：一般放置的是非路由组件（全局组件）</li>
</ul>
</li>
<li><ul>
<li><code>App.vue</code>文件：唯一的根组件。Vue的组件都是<code>.vue</code>文件</li>
</ul>
</li>
<li><ul>
<li><code>main.js</code>文件：程序入口文件，也是整个程序中最先执行的文件</li>
</ul>
</li>
</ul>
<ul>
<li><code>babel.config.js</code>文件：配置文件（babel相关）</li>
<li><code>package.json</code>文件：认为是项目的‘身份证’，记录项目叫什么，项目当中有哪些依赖、项目怎么运行。</li>
<li><code>package-lock.json</code>文件：缓存性文件</li>
<li><code>README.md</code>文件：说明性文件</li>
</ul>
<p><b>★项目的其他配置</b></p>
<p><b>1.项目运行起来时，让浏览器自动打开</b></p>
<p>修改 package.json 文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-cli-service serve --open&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-cli-service build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-cli-service lint&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><b>2.eslint校验功能关闭</b></p>
<p>方法：在根目录下创建<code>vue.config.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 关闭eslint</span></span><br><span class="line">  <span class="attr">lintOnSave</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>3.配置别名（例如将src配置别名为@）</b></p>
<p>方法：在根目录下创建<code>jsconfig.json</code>文件<br>@代表的是src文件夹，当文件过多时可以方便查找</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;src/*&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="comment">// 下列文件夹中不可使用</span></span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;dist&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><b>★项目路由的分析</b></p>
<p>vue-router</p>
<p>前端所谓的路由：k-v键值对。<br>key：URL（地址栏中的路径）<br>value：相应的路由组件</p>
<p>注意：项目上中下结构</p>
<ul>
<li>路由组件：<br>Home首页路由组件、Search路由组件、login登录路由</li>
<li>非路由组件：<br>Header<br>Footer 在【首页、搜索页】，但在 【登录 | 注册】 页面是没有</li>
</ul>
<h2 id="2-完成非路由组件Header与Footer的业务"><a href="#2-完成非路由组件Header与Footer的业务" class="headerlink" title="2 完成非路由组件Header与Footer的业务"></a>2 完成非路由组件Header与Footer的业务</h2><p>在项目中，不再以 HTML+CSS 为主，主要搞业务逻辑。</p>
<p>开发项目时：</p>
<ol>
<li>书写静态页面（HTML + CSS）</li>
<li>拆分组件</li>
<li>获取服务器的数据动态展示</li>
<li>完成相应的动态业务逻辑</li>
</ol>
<p>注意：</p>
<ol>
<li>创建组件的时候，需要保证 组件结构 + 组件样式 + 图片资源 正确</li>
<li>项目采用less样式，但浏览器不识别less样式，需要通过less、less-loader进行处理less，把less样式变为css样式，浏览器才能识别。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 安装less和less-loader【注意：less-loader不能安装最新版，否则报错】</span><br><span class="line"></span><br><span class="line">npm install --save less less-loader@5</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>如果想让组件识别less样式，需要在style标签的身上加上 <code>lang=&quot;less&quot;</code></li>
</ol>
<h4 id="2-1-使用组件的步骤（非路由组件）"><a href="#2-1-使用组件的步骤（非路由组件）" class="headerlink" title="2.1 使用组件的步骤（非路由组件）"></a>2.1 使用组件的步骤（非路由组件）</h4><ul>
<li>创建或者定义</li>
<li>引入</li>
<li>注册</li>
<li>使用</li>
</ul>
<h4 id="2-2-路由组件的搭建"><a href="#2-2-路由组件的搭建" class="headerlink" title="2.2 路由组件的搭建"></a>2.2 路由组件的搭建</h4><p>vue-router<br>安装命令：<code>npm install --save vue-router@3</code></p>
<p>上面对项目的分析可知，路由组件应该有四个：Home、Search、Login、Register</p>
<ul>
<li><code>components</code>文件夹：经常放置非路由组件（共用全局组件）</li>
<li><code>pages | views</code>文件夹：经常放置路由组件</li>
</ul>
<h5 id="2-2-1-配置路由"><a href="#2-2-1-配置路由" class="headerlink" title="2.2.1 配置路由"></a>2.2.1 配置路由</h5><p>项目当中配置路由一般放置在<code>router</code>文件夹中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router下的index.js文件</span></span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>);</span><br><span class="line"><span class="comment">//引入路由组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Search</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/Search&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/Login&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Register</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/Register&#x27;</span></span><br><span class="line"><span class="comment">//配置路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// 配置路由</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Login</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/register&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Register</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/search&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Search</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-小结"><a href="#2-2-2-小结" class="headerlink" title="2.2.2 小结"></a>2.2.2 小结</h5><p><b>路由组件与非路由组件的区别？</b></p>
<ol>
<li>路由组件一般放置在 <code>pages | views</code>文件夹，非路由组件一般放置<code>components</code>文件夹中</li>
<li>路由组件一般需要在<code>router</code>文件夹中进行注册（使用的即为组件的名字），非路由组件在使用的时候，一般都是以标签的形式使用</li>
<li>注册完路由，不管路由组件还是非路由组件身上都有<code>$route</code>和<code>$router</code>属性</li>
</ol>
<ul>
<li><p><code>$route</code> :一般获取路由信息【路径、query、params等】</p>
</li>
<li><p><code>$router</code> :一般进行编程式导航，进行路由跳转【push | replace】</p>
</li>
</ul>
<h5 id="2-2-3-路由跳转"><a href="#2-2-3-路由跳转" class="headerlink" title="2.2.3 路由跳转"></a>2.2.3 路由跳转</h5><p>路由跳转有两种形式：</p>
<ul>
<li>声明式导航<code>router-link</code></li>
<li>编程式导航<code>$router.push | $router.replace</code></li>
</ul>
<p>声明式导航能做的，编程式导航都能做。编程式导航除了可以进行路由跳转，还可以做一些其他的业务逻辑。</p>
<h4 id="2-3-Footer组件的显示与隐藏"><a href="#2-3-Footer组件的显示与隐藏" class="headerlink" title="2.3 Footer组件的显示与隐藏"></a>2.3 Footer组件的显示与隐藏</h4><p>Footer组件：在Home、Search显示Footer组件；在登录、注册时隐藏</p>
<p>显示或者隐藏组件：<code>v-if | v-show</code><br>两者使用<code>v-show</code>更好一些，原因：<code>v-if</code>控制显示与否是通过操作DOM实现的，<code>v-if</code>会频繁的操作DOM，损耗性能。<code>v-show</code>仅仅通过样式显示元素（<code>display:block</code>）或者隐藏元素（<code>display:none</code>）。</p>
<ul>
<li>我们可以依据路由身上的<code>$route</code>获取当前路由的信息，通过路由路径（<code>this.$route.path</code>）判断Footer显示与隐藏。</li>
<li>配置路由的时候，可以给路由添加路由元信息【meta】，路由需要配置对象，它的key不能乱写，需要依据开发文档。</li>
</ul>
<h4 id="2-4-路由传参"><a href="#2-4-路由传参" class="headerlink" title="2.4 路由传参"></a>2.4 路由传参</h4><p><b>路由跳转有几种方式？</b></p>
<p>路由跳转有两种形式：</p>
<ul>
<li>声明式导航<code>router-link</code>（务必要有 to 属性）</li>
<li>编程式导航<code>$router.push | $router.replace</code>（可以书写一些自己的业务）</li>
</ul>
<p><b>路由传参，参数有几种写法？</b></p>
<ul>
<li><code>params</code>参数：属于路径当中的一部分，需要注意，在配置路由时，需要占位</li>
<li><code>query</code>参数：不属于路径当中的一部分，类似于ajax中的queryString <code>/home?k=v&amp;k=v</code>会直接拼接到地址后面,不需要占</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由传递参数：</span></span><br><span class="line">  <span class="comment">// 第一种：字符串形式</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&quot;/search/&quot;</span> + <span class="variable language_">this</span>.<span class="property">keyword</span> + <span class="string">&quot;?k=&quot;</span> + <span class="variable language_">this</span>.<span class="property">keyword</span>.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  <span class="comment">// 第二种：模板字符串</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/search/ $&#123;this.keyword&#125; ?k= $&#123;this.keyword.toUpperCase())&#x27;</span>)</span><br><span class="line">  <span class="comment">// 第三种：对象【推荐】</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123; <span class="attr">keyword</span>: <span class="variable language_">this</span>.<span class="property">keyword</span> &#125;,</span><br><span class="line">    <span class="attr">query</span>: &#123; <span class="attr">k</span>: <span class="variable language_">this</span>.<span class="property">keyword</span>.<span class="title function_">toUpperCase</span>() &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>路由配置时占位符写法：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220215104243.png"></p>
<h5 id="路由传参的相关面试题"><a href="#路由传参的相关面试题" class="headerlink" title="路由传参的相关面试题"></a>路由传参的相关面试题</h5><p><b>题目1：</b>路由传递参数（对象写法）path是否可以结合params参数一起使用？</p>
<p>答案：路由跳转传参的时候，对象的写法可以是name、path的形式，但是需要注意的是，path这种写法不能与params参数一起使用。params参数只能和name形式结合使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三种：对象【推荐】</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123; <span class="attr">keyword</span>: <span class="variable language_">this</span>.<span class="property">keyword</span> &#125;,</span><br><span class="line">    <span class="attr">query</span>: &#123; <span class="attr">k</span>: <span class="variable language_">this</span>.<span class="property">keyword</span>.<span class="title function_">toUpperCase</span>() &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><b>题目2：</b>如何指定params参数可传可不传？</p>
<p>如果路由要求传递params参数，但是你就不传递params参数，会发现跳转后的URL存在问题。<br><code>已传递params参数：http://localhost:8080/#/search/aaa?k=AAA</code><br><code>未传递params参数：http://localhost:8080/#/?k=AAA</code>可以发现丢失<code>search</code></p>
<p>答案：如何指定params参数可传可不传，在配置路由的时候，在占位符的后面添加一个问号【代表params参数可传递或者不传递】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/search/:keyword?&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Search</span>,</span><br><span class="line">  <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><b>题目3：</b>params参数可以传递也可以不传递，但是如果传递的是空串，如何解决？</p>
<p>传递空串的params参数会导致路径出现问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; <span class="attr">keyword</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">query</span>: &#123; <span class="attr">k</span>: <span class="variable language_">this</span>.<span class="property">keyword</span>.<span class="title function_">toUpperCase</span>() &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>传递后的路径：<br><code>http://localhost:8080/#/?k=AAA</code></p>
<p>答案：使用undefined解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; <span class="attr">keyword</span>: <span class="string">&#x27;&#x27;</span> || <span class="literal">undefined</span> &#125;,</span><br><span class="line">  <span class="attr">query</span>: &#123; <span class="attr">k</span>: <span class="variable language_">this</span>.<span class="property">keyword</span>.<span class="title function_">toUpperCase</span>() &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><b>题目4：</b>路由组件能不能传递props数据？</p>
<ul>
<li><p>第一种：布尔值写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/search/:keyword?&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Search</span>,</span><br><span class="line">  <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">  <span class="comment">// 第一种：布尔值写法</span></span><br><span class="line">  <span class="attr">props</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在search页面通过props接收：<br><code>props:[&#39;keyword&#39;]</code></p>
</li>
<li><p>第二种：对象写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/search/:keyword?&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">Search</span>,</span><br><span class="line">  <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">  <span class="comment">// 第二种：对象写法</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在search页面通过props接收：<br><code>props:[&#39;a&#39;,&#39;b&#39;]</code></p>
<ul>
<li>第三种：函数写法：可以params参数，query参数，通过props传递给路由组件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: <span class="function">(<span class="params">$route</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">keyword</span>: $route.<span class="property">params</span>.<span class="property">keyword</span>,</span><br><span class="line">    <span class="attr">k</span>: $route.<span class="property">query</span>.<span class="property">k</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="★★进一步的思考"><a href="#★★进一步的思考" class="headerlink" title="★★进一步的思考"></a>★★进一步的思考</h5><p><b>编程式导航跳转到当前路由（参数不变），多次执行会抛出NavigationDuplicated的警告错误？</b></p>
<p>路由跳转有两种形式：编程式导航和声明式导航，上述问题不会出现在声明式导航中的，因为vue-router底层已经处理好了。</p>
<p>编程式导航进行路由跳转的时候出现这种错误的原因是当前的<code>vue-router</code>的版本是<code>3.5.3</code>，它引入了<code>promise</code>，因此可以通过给<code>push</code>方法传递相应的成功、失败的回调函数，捕获当前错误进行解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; <span class="attr">ketword</span>:<span class="variable language_">this</span>.<span class="property">keyword</span> &#125;,</span><br><span class="line">  <span class="attr">query</span>: &#123; <span class="attr">k</span>:<span class="variable language_">this</span>.<span class="property">keyword</span>.<span class="title function_">toUpperCase</span>()&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">()=&gt;</span>&#123;&#125;,</span><br><span class="line"><span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>但是上述这种解决方法治标不治本，在别的组件中<code>push | replace</code>，编程式导航还是要类似的错误。因此需要更加通用的解决方法。解决之前需要明确几点信息：</p>
<ul>
<li><p><code>this</code>：指的是当前组件实例（search）</p>
</li>
<li><p><code>this.$router</code>属性：当前的这个属性，属性值VueRouter类的一个实例，当在入口文件注册路由的时候，给组件实例添加<code>$router | $route</code>属性</p>
</li>
<li><p><code>push</code>:VueRouter类的一个实例</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">VueRouter</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象的方法</span></span><br><span class="line"><span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//函数的上下文为VueRouter类的一个实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     ----------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> $router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>();</span><br><span class="line"></span><br><span class="line">$router.<span class="title function_">push</span>(xxx);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终解决方法：重写push、replace方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js文件</span></span><br><span class="line"><span class="comment">// 先把VueRouter原型对象的push、replace方法保存一份</span></span><br><span class="line"><span class="keyword">let</span> originPush = <span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>;</span><br><span class="line"><span class="keyword">let</span> originReplace = <span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">replace</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call|apply区别</span></span><br><span class="line">  <span class="comment">// 相同点：都可以调用函数一次，都可以篡改函数的上下文一次</span></span><br><span class="line">  <span class="comment">// 不同点：call与apply传递参数：call传递参数用逗号隔开，apply方法执行需要传递数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写push | replace方法</span></span><br><span class="line"><span class="comment">// 第一个参数：告诉原来的push方法，你往哪里跳转（传递哪些参数）</span></span><br><span class="line"><span class="comment">// 第二个参数：成功的回调，第三个参数：失败的回调</span></span><br><span class="line"><span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">location, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (resolve &amp;&amp; reject) &#123;</span><br><span class="line">    originPush.<span class="title function_">call</span>(<span class="variable language_">this</span>, location, rosolve, reject)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    originPush.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">location</span>, <span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123; &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">replace</span> = <span class="keyword">function</span> (<span class="params">location, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (resolve &amp;&amp; reject) &#123;</span><br><span class="line">    originReplace.<span class="title function_">call</span>(<span class="variable language_">this</span>, location, resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    originReplace.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">location</span>, <span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Home组件"><a href="#3-Home组件" class="headerlink" title="3 Home组件"></a>3 Home组件</h2><h4 id="3-1-组件拆分步骤"><a href="#3-1-组件拆分步骤" class="headerlink" title="3.1 组件拆分步骤"></a>3.1 组件拆分步骤</h4><ol>
<li>先将静态页面完成</li>
<li>拆分出静态组件</li>
<li>获取服务器的数据进行展示</li>
<li>完成动态业务</li>
</ol>
<h4 id="3-2-全局组件的使用方法"><a href="#3-2-全局组件的使用方法" class="headerlink" title="3.2 全局组件的使用方法"></a>3.2 全局组件的使用方法</h4><p>首先明确全局组件的引入，注册需要在程序入口<code>main.js</code>中实现</p>
<p>例如，引如一个名为TypeNav的全局组件，<code>mian.js</code>中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">TypeNav</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/Home/TypeNav&#x27;</span></span><br><span class="line"><span class="comment">// 第一个参数：全局组件的名字   第二个参数：哪一个组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="title class_">TypeNav</span>.<span class="property">name</span>, <span class="title class_">TypeNav</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-axios"><a href="#4-axios" class="headerlink" title="4 axios"></a>4 axios</h2><h4 id="4-1-为什么需要二次封装axios"><a href="#4-1-为什么需要二次封装axios" class="headerlink" title="4.1 为什么需要二次封装axios?"></a>4.1 为什么需要二次封装axios?</h4><p>请求拦截器、响应拦截器：</p>
<ul>
<li>请求拦截器可以在发送请求之前处理一些业务</li>
<li>响应拦截器，当服务器数据返回以后，可以处理一些事情</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 安装axios</span><br><span class="line">npm install --save axios</span><br></pre></td></tr></table></figure>

<h4 id="4-2-项目中api文件夹【axios】"><a href="#4-2-项目中api文件夹【axios】" class="headerlink" title="4.2 项目中api文件夹【axios】"></a>4.2 项目中api文件夹【axios】</h4><p>在接口中，路径都带有<code>/api</code>，因此可将<code>/api</code>设置为baseURL<br>api下的request.js文件的基本结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于axios进行二次封装</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.利用axios对象的方法create去创建一个axios实例</span></span><br><span class="line"><span class="keyword">const</span> requests = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="comment">// 配置对象</span></span><br><span class="line">  <span class="comment">// 基础路径，发送请求的路径都会出现api</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;/api&#x27;</span>,</span><br><span class="line">  <span class="comment">// 代表请求超时时间为5s</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求拦截器：在发送请求之前，请求拦截器可以检测到，可以在请求发送出去之前做一些事情</span></span><br><span class="line">requests.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//config：配置对象，对象里面有一个属性很重要-&gt;headers请求头</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">requests.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 成功的回调函数：服务器相应数据回来以后，相应拦截器可以检测到，可以做一些事情</span></span><br><span class="line">  <span class="keyword">return</span> res.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 响应失败的回调函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> requests;</span><br></pre></td></tr></table></figure>

<p>其中的一些配置内容可以参考<a href="http://www.axios-js.com/zh-cn/docs/">axios文档</a></p>
<h4 id="4-3-接口的统一管理"><a href="#4-3-接口的统一管理" class="headerlink" title="4.3 接口的统一管理"></a>4.3 接口的统一管理</h4><ul>
<li>项目很小：完全可以在组件的生命周期函数中发送</li>
<li>项目很大：需要在<code>api</code>文件夹下的<code>index.js</code>中统一管理</li>
</ul>
<h5 id="4-3-1-跨域问题"><a href="#4-3-1-跨域问题" class="headerlink" title="4.3.1 跨域问题"></a>4.3.1 跨域问题</h5><p>什么是跨域？协议、域名、端口号不同的请求，称之为跨域。</p>
<p>例如：<br><a href="http://localhost:8080/#/home">http://localhost:8080/#/home</a>  – 前端项目本地服务<br><a href="http://39.98.123.211/">http://39.98.123.211</a> – 后台服务器</p>
<p>解决跨域的方法：<code>JSONP</code> <code>CROS</code> <code>代理</code></p>
<ul>
<li>代理方法<br>在<code>webpack.config.js</code>文件 或者 <code>vue.config.js</code>文件中设置代理<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,<span class="comment">//目标服务器</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;, <span class="comment">// 路径重写</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-nprogress"><a href="#5-nprogress" class="headerlink" title="5 nprogress"></a>5 nprogress</h2><p>这是一个类似youtube、Medium等网站上的小进度条插件。纳米级的进度条，涓涓细流动画告诉你的用户，一些事情正在发生！<br>安装命令：<code>npm install --save nprogress</code></p>
<p><b>项目当中如何使用？</b></p>
<p>可以在项目接口的请求拦截器【进度条开始】和响应拦截器【进度条结束】中使用。</p>
<p>注意：在使用时要引入 <code>nprogress.css</code> 文件，否则无法显示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入进度条</span></span><br><span class="line"><span class="keyword">import</span> nprogress <span class="keyword">from</span> <span class="string">&#x27;nprogress&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入进度条样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;nprogress/nprogress.css&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start方法：进度条开始 done方法：进度条结束</span></span><br><span class="line">nprogress.<span class="title function_">start</span>();</span><br><span class="line">nprogress.<span class="title function_">done</span>();</span><br></pre></td></tr></table></figure>
<p>❤ 如果想要修改进度条的颜色，可在<code>node_modules</code>中找到<code>nprogress</code>下的<code>nprogress.css</code>，修改其中的样式即可</p>
<h2 id="6-vuex状态管理库"><a href="#6-vuex状态管理库" class="headerlink" title="6 vuex状态管理库"></a>6 vuex状态管理库</h2><p>vuex是官方提供的一个状态管理库，可以集中式管理项目中组件共用的数据。<br>切记，并不是所有的项目都需要vuex，如果项目很小，完全不需要vuex，如果项目很大，组件很多，数据很多，数据维护很费劲，则使用vuex。</p>
<p>安装命令：<code>npm install --save vuex</code></p>
<h4 id="6-1-vuex核心概念"><a href="#6-1-vuex核心概念" class="headerlink" title="6.1 vuex核心概念"></a>6.1 vuex核心概念</h4><p>state<br>mutations<br>actidons<br>getters<br>modules</p>
<p>详情见 <a href="https://qw-null.github.io/2021/06/01/Vuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">vuex学习笔记</a></p>
<h4 id="6-2-vuex实现模块式开发"><a href="#6-2-vuex实现模块式开发" class="headerlink" title="6.2 vuex实现模块式开发"></a>6.2 vuex实现模块式开发</h4><p>如果项目过大，组件过多，接口也很多，数据很多，可以让vuex实现模块式开发。</p>
]]></content>
      <categories>
        <category>Vue实战项目</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>青训营-如何写好JS</title>
    <url>/2022/02/11/%E9%9D%92%E8%AE%AD%E8%90%A5-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BDJS/</url>
    <content><![CDATA[<h2 id="01-各司其责"><a href="#01-各司其责" class="headerlink" title="01 各司其责"></a>01 各司其责</h2><p>JavaScript – Behavioral<br>CSS – Presentational<br>HTML – Structual</p>
<h5 id="例子-夜间模式的实现"><a href="#例子-夜间模式的实现" class="headerlink" title="例子 夜间模式的实现"></a>例子 夜间模式的实现</h5><ol>
<li>版本一</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeBtn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">innerHTML</span> === <span class="string">&#x27;太阳模式&#x27;</span>) &#123;</span><br><span class="line">    body.<span class="property">style</span>.<span class="property">backgroundcolor</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">    body.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">    e.<span class="property">target</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;月亮模式&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    body.<span class="property">style</span>.<span class="property">backgroundcolor</span> = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">    body.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">    e.<span class="property">target</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;太阳模式&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实现功能没有问题，但是存在 使用JS操作CSS应该实现的功能 的问题。</p>
<ol start="2">
<li>版本二</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeBtn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> body = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line">  <span class="keyword">if</span> (body.<span class="property">className</span> !== <span class="string">&#x27;night&#x27;</span>) &#123;</span><br><span class="line">    body.<span class="property">className</span> = <span class="string">&#x27;night&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    body.<span class="property">className</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>版本二的优点是通过JS控制状态的变化，具体的样式则交由CSS来实现。</p>
<ol start="3">
<li>版本三<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;modeCheckBox&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;modeBtn&quot;</span> <span class="attr">for</span>=<span class="string">&quot;modeCheckBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#modeCheckBox</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeCheckBox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
要实现的功能仅为纯展示功能，因此可以通过HTML+CSS来实现即可。</li>
</ol>
<p><b>小结：</b></p>
<ul>
<li>HTML/CSS/JS 各司其责</li>
<li>避免不必要的由JS直接操作样式</li>
<li>可以通过class来表示状态</li>
<li>纯展示类交互寻求零JS方案</li>
</ul>
<p>自己动手实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%BD%95%E5%88%B6_2022_02_11_17_11_54_118.gif"></p>
<p><a href="https://codepen.io/qw-null/pen/mdqwJxM">在线效果</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>ChangeMode<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;modeCheckBox&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;modeBtn&quot;</span> <span class="attr">for</span>=<span class="string">&quot;modeCheckBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">justify-content</span>:center;</span><br><span class="line">  <span class="attribute">align-items</span>:center;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeCheckBox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeCheckBox</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeBtn</span>&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>:<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>:pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeBtn</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;🌞&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeCheckBox</span><span class="selector-pseudo">:checked</span> + <span class="selector-id">#modeBtn</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;🌜&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.dark</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bright</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">changeMode</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> modeCheck = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;modeCheckBox&quot;</span>);</span><br><span class="line">  modeCheck.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modeCheck.<span class="property">checked</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;dark&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bright&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">changeMode</span>();</span><br></pre></td></tr></table></figure>

<p>实现时通过js控制body的类名来改变效果。</p>
<p>🌞与🌜的切换是通过<code>input + label</code>的方式实现：</p>
<p>input选中时显示🌜，未选中显示🌞。</p>
<p><em>之前写过的一个项目的手机版的下拉菜单图标的展示也是通过这种方式进行切换。</em></p>
<h2 id="02-组件封装"><a href="#02-组件封装" class="headerlink" title="02 组件封装"></a>02 组件封装</h2><p>组件是指Web页面上抽出来一个个包含模板（HTML）、功能（JS）和样式（CSS）的单元。</p>
<p>好的组件具备封装性、正确性、拓展性、复用性。</p>
<p>(有些难)</p>
<h2 id="03-过程抽象"><a href="#03-过程抽象" class="headerlink" title="03 过程抽象"></a>03 过程抽象</h2><p>用来处理局部细节控制的一些方法</p>
<p>函数式编程思想的基础应用</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211203005.png"></p>
<p>什么是过程抽象呢？举个例子，比如你有间小房子，房子有门、有窗，这里门和窗也就是数据。那么你可以开门，也可以开窗，开门和开窗就属于过程。我们不仅仅可以抽象数据，还可以抽象这个过程。</p>
<h5 id="例子-操作次数限制"><a href="#例子-操作次数限制" class="headerlink" title="例子 操作次数限制"></a>例子 操作次数限制</h5><ul>
<li>一些异步交互</li>
<li>一次性的HTTP请求</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Task1：学习 html<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Task2：学习 css<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Task3：学习 JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> ulElem = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> liElems = ulElem.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">liElems.<span class="title function_">forEach</span>(<span class="function"><span class="params">liElem</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    liElem.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        e.<span class="property">target</span>.<span class="property">className</span> = <span class="string">&#x27;completed&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            ulElem.<span class="title function_">removeChild</span>(e.<span class="property">target</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">2000</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码实现的效果是完成一个任务之后，点击后将其删除，但是需要点击2s之后才能完成删除，如果在2s之内再去点击 已经点击了要删除的任务，就会报错。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211204137.png"><br>报错的原因实际上就是点击了已经删除的数据项，已经不存在，所以也就无法删除。</p>
<p>因此，解决方法也很简单了，只要限制只能执行一次删除造作就好了。因此可以封装一个高级函数<code>once</code>，这个函数的目标就是保证删除操作只能执行一次，确保操作安全。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">once</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fn)&#123;</span><br><span class="line">      <span class="keyword">const</span> res = fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">      fn = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">liElems.<span class="title function_">forEach</span>(<span class="function"><span class="params">liElem</span> =&gt;</span> &#123;</span><br><span class="line">    liElem.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="title function_">once</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">className</span> = <span class="string">&#x27;completed&#x27;</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            ulElem.<span class="title function_">removeChild</span>(e.<span class="property">target</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码中的高级函数<code>once</code>实际上就是为了让函数只执行一次。为了能够让“只执行一次”的需求覆盖不同的事件处理，我们可以将这个需求剥离出来。这个过程称为<b style="color:red;">过程抽象</b>。</p>
<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><ul>
<li>以函数作为参数</li>
<li>以函数作为返回值</li>
<li>常用于作为函数修饰器</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211205700.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211205725.png"></p>
<p><b>函数节流</b></p>
<p>概念：限制一个函数在一定时间内只能执行一次。</p>
<blockquote>
<p>举个栗子，坐火车或地铁，过安检的时候，在一定时间（例如10秒）内，只允许一个乘客通过安检入口，以配合安检人员完成安检工作。上例中，每10秒内，仅允许一位乘客通过，分析可知，“函数节流”的要点在于，在 一定时间 之内，限制 一个动作 只 执行一次 。</p>
</blockquote>
<p><B>Q: 为什么需要函数节流？</B><br>前端开发过程中，有一些函数或者事件会在多时间内被多次触发，例如 <code>onresize</code>、<code>scroll</code>、<code>mousehover</code>等，这些事件的触发频率很高，如果在这些函数内部执行了其他函数，尤其是DOM操作的函数，会严重浪费计算机的资源，降低程序速度，甚至造成浏览器卡死、崩溃。因此需要限制执行次数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定时器方案</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay = <span class="number">200</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数节流的使用场景：</p>
<ol>
<li>懒加载、滚动加载、加载更多或监听滚动条位置；</li>
<li>百度搜索框，搜索联想功能；</li>
<li>防止高频点击提交，防止表单重复提交；</li>
</ol>
<p><b>函数防抖</b><br>概念：函数防抖（debounce），就是指触发事件后，在 n 秒内函数只能执行一次，如果触发事件后在 n 秒内又触发了事件，则会重新计算函数延执行时间。</p>
<blockquote>
<p>举个栗子，坐电梯的时候，如果电梯检测到有人进来（触发事件），就会多等待 10 秒，此时如果又有人进来（10秒之内重复触发事件），那么电梯就会再多等待 10 秒。在上述例子中，电梯在检测到有人进入 10 秒钟之后，才会关闭电梯门开始运行，因此，“函数防抖”的关键在于，在 一个事件 发生 一定时间 之后，才执行 特定动作。</p>
</blockquote>
<p><B>Q: 为什么需要函数防抖？</B><br>前端开发过程中，有一些函数或者事件会在多时间内被多次触发，例如 <code>onresize</code>、<code>scroll</code>、<code>mousehover</code>等，这些事件的触发频率很高，如果在这些函数内部执行了其他函数，尤其是DOM操作的函数，会严重浪费计算机的资源，降低程序速度，甚至造成浏览器卡死、崩溃。因此需要限制执行次数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn,wait</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数防抖的使用场景：</p>
<ol>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求；</li>
<li>用户名、手机号、邮箱输入验证；</li>
<li>浏览器窗口大小改变后，只需窗口调整完后，再执行 resize 事件中的代码，防止重复渲染。</li>
</ol>
<p><b>iterative</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检验是否可迭代</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isIterable</span> = obj =&gt; obj !== <span class="literal">null</span></span><br><span class="line">    &amp;&amp; <span class="keyword">typeof</span> obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">iterative</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">subject, ...rest</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isIterable</span>(subject)) &#123;</span><br><span class="line">            <span class="comment">// 把所有的执行结果存储于 result 中并返回</span></span><br><span class="line">            <span class="keyword">const</span> result = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> obj <span class="keyword">of</span> subject) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>(fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [obj, ...rest]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [subject, ...rest]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="纯函数-amp-非纯函数"><a href="#纯函数-amp-非纯函数" class="headerlink" title="纯函数 &amp; 非纯函数"></a>纯函数 &amp; 非纯函数</h4><p><b>纯函数：</b>输入值确定，则输出值就会确定，不会因为执行次序，执行环境等的改变而改变</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x,y</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述计算两个数之和的方法，不论在什么时候，两个加数确定则最终结果就会确定。</p>
<p><b>非纯函数：</b>执行顺序，执行环境不同会造成最终呈现的结果不同。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">setColor</span>(<span class="params">elems, color</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">const</span> elem <span class="keyword">of</span> elems) &#123;</span></span><br><span class="line"><span class="language-javascript">            elem.<span class="property">style</span>.<span class="property">color</span> = color;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> els1 = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;li:nth-child(2n+1)&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> els2 = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;li:nth-child(3n+1)&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setColor</span>(els2, <span class="string">&#x27;blue&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setColor</span>(els1, <span class="string">&#x27;red&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，两个 <code>setColor</code> 的调用顺序如果更换，执行的结果会不一样，所以它的结果会受外部环境的影响，是非纯函数。</p>
<p>使用高阶函数，可以减少系统里面非纯函数的数量，从而使得系统的稳定性和可靠性加强。</p>
<p>比如说，我们现在需要实现两个函数，一个是 <code>setColor(elem, color)</code>，一次改变一个元素的颜色，还有一个 <code>setColors(elems, color)</code>，一次改变多个元素的颜色。显然这两个函数都是非纯函数，但是我们可以选择直接定义：</p>
<p><code>const setColors = iterative(setColor);</code></p>
<p>这样就减少了一个非纯函数，有利于我们进行单元测试。</p>
<h4 id="命令式-amp-声明式"><a href="#命令式-amp-声明式" class="headerlink" title="命令式 &amp; 声明式"></a>命令式 &amp; 声明式</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220212225631.png"></p>
<p>命令式代码更加强调执行的过程，强调怎么做。</p>
<hr>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220212225909.png"></p>
<p>声明式代码强调是什么，而不是过程。</p>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>最简分数</title>
    <url>/2022/02/11/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/simplified-fractions/">题目链接</a></p>
<p>给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于  n 的 最简 分数 。分数可以以 任意 顺序返回。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211105400.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目本意实际上是判断两个数是否为互质数，如果是则构成的分数返回。</p>
<p>判断两个数是否为互质数有两种方法：欧几里得算法和更相减损法。</p>
<ol>
<li>欧几里得算法<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211111302.png"><br>算法过程：大数放a中，小数放b中。大数除以小数，余数为零，则小数为最大公约数，不为零则将余数与b比较大的放a,小的放b,如此往复！</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//欧几里得算法（辗转相除法）</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">gcd</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a&lt;b) [a,b] = [b,a];</span><br><span class="line">      <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="title function_">gcd</span>(b,a%b);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>更相减损法<br>算法过程：用两个数中的较大值减去较小值，直至两数相等，得到的相等的数就是两个数的最大公约数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更相减损法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">GXJS</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) a-=b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;b) b-=a;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><ol>
<li><p>欧几里得算法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> simplifiedFractions = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">//欧几里得算法（辗转相除法）</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">gcd</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;b) [a,b] = [b,a];</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="title function_">gcd</span>(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res =[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">gcd</span>(i,j)===<span class="number">1</span>) res.<span class="title function_">push</span>(i+<span class="string">&#x27;/&#x27;</span>+j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">                </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>更相减损法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> simplifiedFractions = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="comment">//更相减损法</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">GXJS</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b) a-=b;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;b) b-=a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res =[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">// if(gcd(i,j)===1) res.push(i+&#x27;/&#x27;+j);</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">GXJS</span>(i,j)===<span class="number">1</span>) res.<span class="title function_">push</span>(i+<span class="string">&#x27;/&#x27;</span>+j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>移除链表元素</title>
    <url>/2022/02/10/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">题目链接</a></p>
<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点。</p>
<p>示例1：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220210195551.png"></p>
<p><b>输入：</b> head = [1,2,6,3,4,5,6], val = 6<br><b>输出：</b> [1,2,3,4,5]</p>
<p>示例2：<br><b>输入：</b> head = [], val = 1<br><b>输出：</b> []</p>
<p>示例3：<br><b>输入：</b> head = [7,7,7,7], val = 7<br><b>输出：</b> []</p>
<p>提示：</p>
<ul>
<li>列表中的节点数目在范围 [0, 104] 内</li>
<li>1 &lt;= Node.val &lt;= 50</li>
<li>0 &lt;= val &lt;= 50</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题目实际上就是删除链表中特定值的节点。</p>
<p>单链表删除节点的操作是将节点.next指向下下个节点，因此如果直接遍历当前节点的话，需要进行记忆当前节点的前一个节点。</p>
<p><b>😊虚拟头节点</b></p>
<p>对此，我们不妨换种思路，如果直接遍历当前节点的下一个节点则不必再去记忆当前节点的前一个节点，但同时会产生一个问题，就是如果当前单链表没有节点，则cur.next不存在。另外如果需要移除的节点是头节点，则操作比起删除其他节点会麻烦一些。解决办法是虚拟一个头节点。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head); <span class="comment">//避免head为空时，cur.next不存在以及删除头节点操作繁琐</span></span><br><span class="line">    <span class="keyword">let</span> cur = res;</span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">next</span>.<span class="property">val</span> === val)&#123;</span><br><span class="line">            cur.<span class="property">next</span> = cur.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="property">next</span>;<span class="comment">//虚拟头节点之后，结果需要去掉虚拟的头节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>函数this的绑定规则</title>
    <url>/2022/02/08/%E5%87%BD%E6%95%B0this%E7%9A%84%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1.默认绑定"></a>1.默认绑定</h2><p>当函数调用类型为独立函数调用时，函数的this为默认绑定，指向全局变量；在严格模式下，this将绑定到undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>foo()</code>为独立函数调用，foo()中的this指向全局变量（严格模式下则指向undefined）</p>
<h2 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2.隐式绑定"></a>2.隐式绑定</h2><p>当函数的调用位置有上下文对象时，或者说函数在被调用时<span style="color:red;"><b>被某个对象拥有或者包含时</b></span>，隐式绑定规则就会把函数调用中的this绑定到这个上下文对象。</p>
<p>如下，foo在调用时this便隐式绑定到obj上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">  foo</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>知识点：隐式绑定丢失的情况（待补充！！）</p>
<h2 id="3-显示绑定"><a href="#3-显示绑定" class="headerlink" title="3.显示绑定"></a>3.显示绑定</h2><p>使用call、apply和bind显示的绑定函数调用时的this的指向</p>
<h2 id="4-new"><a href="#4-new" class="headerlink" title="4.new"></a>4.new</h2><p>当使用new调用函数时，会发生this的指向绑定，但此处发生的绑定与函数本身无关</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】求只包含两种元素的最长连续子序列</title>
    <url>/2022/01/29/%E6%B1%82%E5%8F%AA%E5%8C%85%E5%90%AB%E4%B8%A4%E7%A7%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">题目链接</a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220129182956.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220129183031.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220129183102.png"></p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>题目最终求解的是只包含两种元素的最长的连续子序列。<br>因此需要明确已下几点：</p>
<ul>
<li>如何保证水果的种类只有两种？</li>
<li>当子序列中水果种类已经有两种，如何删除旧的水果种类，添加新的水果种类？</li>
</ul>
<p>对于上述两个问题，答案如下：</p>
<p>设置一个保存水果种类的数组，初始化时填入第一棵树的水果种类。 <code> ftype = [fruits[0]]</code><br>当走到下一棵树时，先判断是否是已经保存的水果种类 <code>ftype.includes(fruits[j]</code>,如果没有包含，则存在下面两种情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 只有一种水果，将新的水果种类加入种类数组中</span></span><br><span class="line"><span class="keyword">if</span>(ftype.<span class="property">length</span>&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    ftype[<span class="number">1</span>] = fruits[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 当前水果种类已经达到两种：去掉第一种水果，加入新的水果种类</span></span><br><span class="line"><span class="comment">// 此时就要用到第一种水果的结束位置这一变量</span></span><br><span class="line">i= firstFruit;<span class="comment">//更新开始采摘的位置（滑动窗口左边界）</span></span><br><span class="line">ftype[<span class="number">0</span>]=fruits[j-<span class="number">1</span>];</span><br><span class="line">ftype[<span class="number">1</span>]=fruits[j];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，解题时还要注意对于当前种类水果最后一个位置的保存。</p>
<h2 id="解题代码："><a href="#解题代码：" class="headerlink" title="解题代码："></a>解题代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> totalFruit = <span class="keyword">function</span>(<span class="params">fruits</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;<span class="comment">//最终结果</span></span><br><span class="line">    <span class="keyword">let</span> subLen = <span class="number">0</span>;<span class="comment">//子序列长度（个数）</span></span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>;<span class="comment">//采摘开始的位置</span></span><br><span class="line">    <span class="keyword">let</span> firstFruit = <span class="number">0</span>;<span class="comment">//第一种水果的结束位置</span></span><br><span class="line">    <span class="keyword">let</span> ftype = [fruits[i]];<span class="comment">//采摘的水果种类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;fruits.<span class="property">length</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ftype.<span class="title function_">includes</span>(fruits[j]))&#123;<span class="comment">//水果种类未包含</span></span><br><span class="line">            <span class="comment">// 两种情况：1.水果种类少于两种，记录</span></span><br><span class="line">            <span class="comment">// 2.水果种类多余两种</span></span><br><span class="line">            <span class="keyword">if</span>(ftype.<span class="property">length</span>&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//水果种类少于两种</span></span><br><span class="line">                ftype[<span class="number">1</span>] = fruits[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//水果种类多余两种:去掉第一种水果，加入新的水果种类</span></span><br><span class="line">                i= firstFruit;<span class="comment">//更新开始采摘的位置（滑动窗口左边界）</span></span><br><span class="line">                ftype[<span class="number">0</span>]=fruits[j-<span class="number">1</span>];</span><br><span class="line">                ftype[<span class="number">1</span>]=fruits[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fruits[j]!==fruits[firstFruit])&#123;</span><br><span class="line">            <span class="comment">//更新第一种水果的结束位置</span></span><br><span class="line">            firstFruit = j;</span><br><span class="line">        &#125;</span><br><span class="line">        subLen=j-i+<span class="number">1</span>;</span><br><span class="line">        res = res&gt;subLen?<span class="attr">res</span>:subLen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="补充知识："><a href="#补充知识：" class="headerlink" title="补充知识："></a>补充知识：</h2><p><code>Array.includes()</code>方法用来判断一个数组是否包含一个指定的值。<br><code>arr.includes(searchElement, fromIndex)</code></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">searchElement</td>
<td align="left">必须。需要查找的元素值。</td>
</tr>
<tr>
<td align="left">fromIndex</td>
<td align="left">可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</td>
</tr>
</tbody></table>
<p>返回值：<br>包含元素返回true，不包含元素返回false。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>【leetcode】长度最小的子数组</title>
    <url>/2022/01/28/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%90leetcode%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">题目链接</a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。<br>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr] </code>，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220128221650.png"></p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><ol>
<li><p>方法一：暴力解法<br>通过两个for循环，找出所有满足和 ≥ target的情况，然后取最小值。时间复杂度为O($ n^2 $)。</p>
</li>
<li><p>方法二：滑动窗口法<br>所谓的滑动窗口就是不断调节子序列的起始位置和终止位置，从而得出想要的结果。</p>
</li>
</ol>
<p>模式说明：<br>输入是一个数组或字符串，求解的结果是具有某种特质的子数组或子字符串。这种情况下下，可以使用滑动窗口的方法求解。</p>
<p>应用滑动窗口的<b>注意事项</b>：</p>
<ul>
<li>可以通过两个指针来标识窗口的边界</li>
<li>窗口的长度可固定也可改变，取决于求解问题的性质</li>
<li>维护一个或一组和窗口相关联的状态变量，能有效降低计算量和算法复杂度</li>
</ul>
<h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><p>方法一：暴力解法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>; <span class="comment">// 存放最终结果,找最小的值-&gt;初始值应为最大的数</span></span><br><span class="line">    <span class="keyword">let</span> [sum,subLen] = [<span class="number">0</span>,<span class="number">0</span>];<span class="comment">//子序列的和，长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;nums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="comment">//当子序列的值&gt;=target</span></span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">                subLen = j-i+<span class="number">1</span>;</span><br><span class="line">                res = res&lt;subLen?<span class="attr">res</span>:subLen;<span class="comment">//取满足要求的最小长度</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res===<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>?<span class="number">0</span>:res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：滑动窗口法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 子序列之和，子序列长度，最终结果</span></span><br><span class="line">    <span class="keyword">let</span> [sum,subLen,res]=[<span class="number">0</span>,<span class="number">0</span>,<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>];</span><br><span class="line">    <span class="comment">//*定义子序列起始位置【窗口开始位置】</span></span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">            subLen=j-i+<span class="number">1</span>;</span><br><span class="line">            res = res&lt;subLen?<span class="attr">res</span>:subLen;</span><br><span class="line">            sum-=nums[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res!==<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>?<span class="attr">res</span>:<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>字节青训营-HTTP实用指南</title>
    <url>/2022/01/23/%E9%9D%92%E8%AE%AD%E8%90%A5-HTTP%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="01-初识HTTP"><a href="#01-初识HTTP" class="headerlink" title="01 初识HTTP"></a>01 初识HTTP</h2><p>浏览器地址栏输入URL，到显示界面，经历的过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123145912.png"></p>
<h4 id="HTTP介绍"><a href="#HTTP介绍" class="headerlink" title="HTTP介绍"></a>HTTP介绍</h4><p>Hyper Text Transfer Protocol，超文本传输协议</p>
<ul>
<li>应用层协议，基于TCP</li>
<li>请求响应</li>
<li>简单可扩展</li>
<li>无状态</li>
</ul>
<h2 id="02-协议分析"><a href="#02-协议分析" class="headerlink" title="02 协议分析"></a>02 协议分析</h2><h4 id="发展："><a href="#发展：" class="headerlink" title="发展："></a>发展：</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123151034.png"></p>
<h4 id="报文："><a href="#报文：" class="headerlink" title="报文："></a>报文：</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123151331.png"></p>
<h4 id="字段分析："><a href="#字段分析：" class="headerlink" title="字段分析："></a>字段分析：</h4><h5 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GET</td>
<td align="left">请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据</td>
</tr>
<tr>
<td align="left">POST</td>
<td align="left">用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用</td>
</tr>
<tr>
<td align="left">PUT</td>
<td align="left">用于请求有效载荷替换目标资源的所有当前表示</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">删除指定资源</td>
</tr>
<tr>
<td align="left">HEAD</td>
<td align="left">请求一个 与GET请求的响应 相同的响应</td>
</tr>
<tr>
<td align="left">CONNECT</td>
<td align="left">建立一个到由目标资源标识的服务器的隧道</td>
</tr>
<tr>
<td align="left">OPTIONS</td>
<td align="left">用于描述目标资源的通信选项</td>
</tr>
<tr>
<td align="left">TRACE</td>
<td align="left">沿着到目标资源的路径执行一个消息环回测试</td>
</tr>
<tr>
<td align="left">PATCH</td>
<td align="left">用于对资源应用部分修改</td>
</tr>
</tbody></table>
<p>特性：<br>Safe(安全的)：上述方法中，对于其中不会修改服务器数据的方法，我们认为其是安全的，例如，GET、HEAD、OPTIONS<br>Idempotent(幂等的)：对于同样的请求执行一次与执行多次的效果是一样的，服务器的状态也是一样的，例如，GET、HEAD、OPTIONS、PUT、DELETE</p>
<p><i style="background:#ccffcc"><b>所有的safe方法都是idempotent的</b></i></p>
<h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123154523.png"></p>
<ul>
<li>200 OK-客户端请求成功</li>
<li>301 - 资源（网页等）被永久转移到其他URL</li>
<li>302 - 临时跳转</li>
<li>401 Unauthorized - 请求未经授权</li>
<li>404 - 请求资源不存在</li>
<li>500 - 服务器内部错误</li>
<li>504 Gated Timeout - 网关或代理的服务器无法在规定时间内获得想要的响应</li>
</ul>
<h5 id="常用请求头"><a href="#常用请求头" class="headerlink" title="常用请求头"></a>常用请求头</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">接收类型，表示浏览器支持的MIME类型（对标服务器端返回的Content-Type）</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">客户端发送出去实体内容的类型</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">指定请求和响应遵循的缓存机制，例如no-cache</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">对应服务器端的Last-Modified,用来匹配看文件是否变得，只能精确到1s之内</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">缓存控制，在这个时间内不会请求，直接使用缓存，服务器端事件</td>
</tr>
<tr>
<td align="left">Max-age</td>
<td align="left">代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">对应服务端的ETag，用来匹配文件是否变动（非常精确）</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">有cookie并且同域访问时会自动带上</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">该页面的来源URL（适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段）</td>
</tr>
<tr>
<td align="left">Origin</td>
<td align="left">最初的请求是从哪里发起的（只会精确到端口），Origin比Referer更尊重隐私</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">用户客户端的一些必要的信息，如UA头部等</td>
</tr>
</tbody></table>
<h5 id="常用的响应头"><a href="#常用的响应头" class="headerlink" title="常用的响应头"></a>常用的响应头</h5><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123162231.png"></p>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123164131.png"></p>
<p>must-revalidate会与max-age结合使用，如果缓存中设置了must-revalidate且max-age到期，即使本地有缓存也无法使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124094913.png"></p>
<h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>当用户第一次访问并登陆一个网站的时候，cookie的设置以及发送会经历以下4个步骤：</p>
<p>(1)客户端发送一个请求到服务器  →  (2)服务器发送一个HttpResponse响应到客户端，其中包含Set-Cookie的头部  →  (3)客户端保存cookie，之后向服务器发送请求时，HttpRequest请求中会包含一个Cookie的头部  →  (4)服务器返回响应数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124100217.png"></p>
<table>
<thead>
<tr>
<th align="left">属性项</th>
<th align="left">属性项介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NAME=VALUE</td>
<td align="left">键值对，可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">Cookie的有效期，在设置的某个时间点后该 Cookie 就会失效</td>
</tr>
<tr>
<td align="left">Domain</td>
<td align="left">限制Cookie 生效的域名，默认为创建cookie的服务域名</td>
</tr>
<tr>
<td align="left">Path</td>
<td align="left">限制指定Cookie的发送范围的文件目录，默认为当前</td>
</tr>
<tr>
<td align="left">Secure</td>
<td align="left">仅在HTTPS安全连接时，才可以发送Cookie</td>
</tr>
<tr>
<td align="left">HTTPOnly</td>
<td align="left">Javascript脚本无法获得Cookie</td>
</tr>
<tr>
<td align="left">SameSite</td>
<td align="left">①None同站、跨站请求都可以发送<br>②Strict仅在同站发送<br>③允许与顶级导航一起发送，并将与第三方网站发起的GET请求一起发送</td>
</tr>
</tbody></table>
<h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>HTTP/2更快、更稳定、更简单</p>
<ul>
<li>帧（frame）：HTTP/2通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li>
<li>消息：与逻辑请求或响应消息对应的完整的一系列帧。</li>
<li>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。</li>
</ul>
<p>HTTP/2连接是永久的，而且仅需要每个来源的一个连接。<br>流控制：阻止 发送方 向 接收方 发送大量数据的机制。<br>服务器推送能力。</p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>https是http经过TSL/SSL加密后得到的</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124110308.png"></p>
<h2 id="03-场景分析"><a href="#03-场景分析" class="headerlink" title="03 场景分析"></a>03 场景分析</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124110955.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124111106.png"></p>
<h4 id="静态资源方案"><a href="#静态资源方案" class="headerlink" title="静态资源方案"></a>静态资源方案</h4><p>静态资源方案：缓存 + CDN + 文件名hash<br>其中：文件名hash可以确保当前文件是最新的</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124112530.png"></p>
<p>通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务</p>
<h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124115113.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124115305.png"></p>
<p>解决方法：</p>
<ul>
<li>CORS</li>
<li>代理服务器</li>
<li><ul>
<li>同源策略是浏览器的安全策略，不是HTTP的</li>
</ul>
</li>
<li>Iframe - 不方便，限制过多，实际场景中使用较少</li>
</ul>
<h4 id="下一次进入页面为什么能记住登陆状态？"><a href="#下一次进入页面为什么能记住登陆状态？" class="headerlink" title="下一次进入页面为什么能记住登陆状态？"></a>下一次进入页面为什么能记住登陆状态？</h4><p>鉴权：<br>Session + cookie</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124120535.png"></p>
<p>JWT(JSON web token)</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124144602.png"></p>
<h4 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h4><ol>
<li>AJAX之XHR<br>XHR：XMLHttpRequest<br>xhr.readyState属性</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124145225.png"></p>
<ol start="2">
<li>AJAX之Fetch</li>
</ol>
<ul>
<li>XMLHttpRequest的升级版</li>
<li>使用promise</li>
<li>模块化设计，Response，Request，Header对象</li>
<li>通过数据流处理对象，支持分块读取</li>
</ul>
<ol start="3">
<li>axios库</li>
</ol>
<ul>
<li>支持浏览器、nodejs环境</li>
<li>丰富的拦截器</li>
</ul>
<h4 id="用户体验方面"><a href="#用户体验方面" class="headerlink" title="用户体验方面"></a>用户体验方面</h4><ol>
<li>网络优化</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124151100.png"></p>
<ol start="2">
<li>稳定性</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124151133.png"></p>
<ul>
<li>重试是保证稳定的有效手段，但要防止加剧恶劣情况</li>
<li>缓存合理使用，作为最后一道防线</li>
</ul>
<h2 id="05拓展"><a href="#05拓展" class="headerlink" title="05拓展"></a>05拓展</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124151328.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124151403.png"></p>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
  </entry>
  <entry>
    <title>字节青训营-Web标准与前端开发</title>
    <url>/2022/01/19/%E9%9D%92%E8%AE%AD%E8%90%A54-Web%E6%A0%87%E5%87%86%E4%B8%8E%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="01-关于前端开发"><a href="#01-关于前端开发" class="headerlink" title="01.关于前端开发"></a>01.关于前端开发</h2><h3 id="1-起源、架构、变迁"><a href="#1-起源、架构、变迁" class="headerlink" title="1.起源、架构、变迁"></a>1.起源、架构、变迁</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119102240.png"></p>
<p>web最基本的架构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119102430.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119102729.png"></p>
<h3 id="2-前端应用的领域"><a href="#2-前端应用的领域" class="headerlink" title="2.前端应用的领域"></a>2.前端应用的领域</h3><p>浏览器:</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119103438.png"></p>
<p>服务器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119103711.png"><br>Deno可以了解一下！</p>
<p>终端和跨端：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119103754.png"></p>
<h3 id="3-语言、框架、工具"><a href="#3-语言、框架、工具" class="headerlink" title="3.语言、框架、工具"></a>3.语言、框架、工具</h3><p>语言：<br>HTML、CSS、JavaScript、WebAssembly</p>
<p>框架：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119104211.png"></p>
<p>*深入理解现代浏览器：</p>
<p><a href="https://blog.csdn.net/qihoo_tech/article/details/91921777">详情</a></p>
<p>*An overview of HTTP:</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview">详情</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119105012.png"></p>
<h3 id="4-前端学习路线图"><a href="#4-前端学习路线图" class="headerlink" title="4.前端学习路线图"></a>4.前端学习路线图</h3><p><a href="https://roadmap.sh/frontend">详情</a></p>
<h2 id="02-关于Web标准"><a href="#02-关于Web标准" class="headerlink" title="02.关于Web标准"></a>02.关于Web标准</h2><h3 id="1-了解Web标准组织"><a href="#1-了解Web标准组织" class="headerlink" title="1.了解Web标准组织"></a>1.了解Web标准组织</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119110421.png"></p>
<h3 id="2-W3C与Ecma会员"><a href="#2-W3C与Ecma会员" class="headerlink" title="2.W3C与Ecma会员"></a>2.W3C与Ecma会员</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119111139.png"></p>
<h3 id="3-W3C流程"><a href="#3-W3C流程" class="headerlink" title="3.W3C流程"></a>3.W3C流程</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119111111.png"></p>
<h3 id="4-TC39流程"><a href="#4-TC39流程" class="headerlink" title="4.TC39流程"></a>4.TC39流程</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119111226.png"></p>
<h3 id="5-如何参与"><a href="#5-如何参与" class="headerlink" title="5.如何参与"></a>5.如何参与</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119111342.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119111505.png"></p>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
  </entry>
  <entry>
    <title>Promise学习</title>
    <url>/2022/01/18/Promise%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1GA411x7z1?share_source=copy_web">尚硅谷Web前端Promise教程从入门到精通（2021抢先版）</a></p>
<h2 id="1-Promise介绍与基本使用"><a href="#1-Promise介绍与基本使用" class="headerlink" title="1.Promise介绍与基本使用"></a>1.Promise介绍与基本使用</h2><h3 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1.1 理解"></a>1.1 理解</h3><p>1.抽象表达</p>
<ul>
<li>Promise是一门新的技术（ES6规范）</li>
<li><span style="background-color:yellow;">Promise是JS中进行异步编程的新解决方案</span><br>备注：旧方案是单纯使用回调函数</li>
</ul>
<p>2.具体表达</p>
<ul>
<li>从语法上来说：Promise是一个构造函数</li>
<li>从功能上来说：Promise对象用来封装一个异步操作并且可以获取其成功/失败的结果值</li>
</ul>
<p>异步编程：(使用回调函数方式)</p>
<ul>
<li>fs文件操作<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(&#x27;fs&#x27;).readFile(&#x27;./index.html&#x27;,(err,data)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>数据库操作</li>
<li>AJAX<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.get(&#x27;/server&#x27;,(data)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>定时器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;&#125;,2000);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-2-为什么要用Promise？"><a href="#1-2-为什么要用Promise？" class="headerlink" title="1.2 为什么要用Promise？"></a>1.2 为什么要用Promise？</h3><h4 id="1-2-1指定回调函数方式更加灵活"><a href="#1-2-1指定回调函数方式更加灵活" class="headerlink" title="1.2.1指定回调函数方式更加灵活"></a>1.2.1指定回调函数方式更加灵活</h4><ol>
<li>旧的：必须在启动异步任务前指定</li>
<li>promise:启动异步任务=&gt;返回promise对象=&gt;给promise对象绑定回调函数（甚至可以在异步任务结束后指定/多个）</li>
</ol>
<h4 id="1-2-2支持链式调用，可以解决回调地狱问题"><a href="#1-2-2支持链式调用，可以解决回调地狱问题" class="headerlink" title="1.2.2支持链式调用，可以解决回调地狱问题"></a>1.2.2支持链式调用，可以解决回调地狱问题</h4><p><b>1.什么是回调地狱?</b><br>回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210703102534.png" alt="回调地狱常见情形"></p>
<p><b>2.回调地狱的缺点？</b><br>不便于阅读<br>不便于异常处理</p>
<p><b>3.解决方案？</b><br>promise链式调用</p>
<h5 id="Case-1-Promise初体验"><a href="#Case-1-Promise初体验" class="headerlink" title="Case 1:Promise初体验"></a>Case 1:Promise初体验</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Promise初体验<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>Promise初体验<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击抽奖<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//生成随机数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">rand</span>(<span class="params">m, n</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (n - m + <span class="number">1</span>)) + m - <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 点击按钮，2s后显示是否中奖（30%概率中奖）</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 若中奖弹出  恭喜恭喜，奖品为10RMB劳斯莱斯优惠券</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 若未中奖弹出 再接再厉</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//获取元素对象</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//绑定单击事件</span></span></span><br><span class="line"><span class="language-javascript">  btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 常规写法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   //30%  1-100</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   //获取从1-100的一个随机数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   let n = rand(1, 100);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   //判断</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   if (n &lt;= 30) &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(&#x27;恭喜恭喜，奖品为10RMB劳斯莱斯优惠券&#x27;)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   &#125; else &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(&#x27;再接再厉&#x27;)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;, 1000);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2.promise 形式实现</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// resolve 解决 函数类型的数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// reject 拒绝 函数类型的数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//30%  1-100</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//获取从1-100的一个随机数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> n = <span class="title function_">rand</span>(<span class="number">1</span>, <span class="number">100</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//判断</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (n &lt;= <span class="number">30</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">//成功</span></span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">resolve</span>(n); <span class="comment">//将promise对象的状态设置为【成功】</span></span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">//失败</span></span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">reject</span>(n); <span class="comment">//将promise对象的状态设置为【失败】</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//调用 then 方法</span></span></span><br><span class="line"><span class="language-javascript">    p.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//成功时的回调函数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&#x27;恭喜恭喜，奖品为10RMB劳斯莱斯优惠券,你的中奖号码为&#x27;</span> + value)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//失败时的回调函数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(<span class="string">&#x27;再接再厉，你的号码为&#x27;</span> + reason)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Case-2-Promise实践练习-fs模块"><a href="#Case-2-Promise实践练习-fs模块" class="headerlink" title="Case 2:Promise实践练习-fs模块"></a>Case 2:Promise实践练习-fs模块</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//引入模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.回调函数形式</span></span><br><span class="line"><span class="comment">// fs.readFile(&#x27;./content.txt&#x27;, (err, data) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   //如果出错，则抛出错误</span></span><br><span class="line"><span class="comment">//   if (err) throw err;</span></span><br><span class="line"><span class="comment">//   // 如果正确，则输出文件内容</span></span><br><span class="line"><span class="comment">//   console.log(data.toString());</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Promise形式</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(<span class="string">&#x27;content.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//如果出错</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err);</span><br><span class="line">    <span class="comment">//如果成功</span></span><br><span class="line">    <span class="title function_">resolve</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用then方法</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Case-3-Promise实践练习-AJAX请求"><a href="#Case-3-Promise实践练习-AJAX请求" class="headerlink" title="Case 3:Promise实践练习-AJAX请求"></a>Case 3:Promise实践练习-AJAX请求</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Promise 封装 AJAX<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>Promise 封装 AJAX操作<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击发送AJAX<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//接口地址：https://api.apiopen.top/getJoke</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//获取元素对象</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;btn信息&#x27;</span>, btn);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//创建Promise</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//1.创建对象</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//2.初始化</span></span></span><br><span class="line"><span class="language-javascript">      xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//3.发送</span></span></span><br><span class="line"><span class="language-javascript">      xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//4.处理响应结果</span></span></span><br><span class="line"><span class="language-javascript">      xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">//判断响应状态码2xx</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//控制台输出响应体</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">resolve</span>(xhr.<span class="property">response</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//控制台输出响应状态码</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">reject</span>(xhr.<span class="property">status</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//调用then方法</span></span></span><br><span class="line"><span class="language-javascript">    p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Case-4-Promise封装练习-fs模块"><a href="#Case-4-Promise封装练习-fs模块" class="headerlink" title="Case 4:Promise封装练习-fs模块"></a>Case 4:Promise封装练习-fs模块</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个函数 mineReadFile 读取文件内容</span></span><br><span class="line"><span class="comment">// 参数：path 文件路径</span></span><br><span class="line"><span class="comment">// 返回：promise 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mineReadFile</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFile</span>(path, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//判断</span></span><br><span class="line">      <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err);</span><br><span class="line">      <span class="comment">//成功</span></span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;content.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//输出内容</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Case-5-util-promisify方法"><a href="#Case-5-util-promisify方法" class="headerlink" title="Case 5:util.promisify方法"></a>Case 5:util.promisify方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util.promisify 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入util模块</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="comment">//引入fs模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//返回一个新的函数</span></span><br><span class="line"><span class="keyword">let</span> mineReadFile = util.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;content.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="1-3-Promise的状态"><a href="#1-3-Promise的状态" class="headerlink" title="1.3 Promise的状态"></a>1.3 Promise的状态</h3><p>  实例对象中的一个属性 [PromiseState]</p>
<ul>
<li>pending 未决定的</li>
<li>resolved / fullfiled 成功</li>
<li>rejected 失败</li>
</ul>
<h5 id="1-3-1-Promise的状态的改变"><a href="#1-3-1-Promise的状态的改变" class="headerlink" title="1.3.1 Promise的状态的改变"></a>1.3.1 Promise的状态的改变</h5><ol>
<li>pending 变为 resolved</li>
<li>pending 变为 rejected<br>说明：只有这两种状态改变的方式，且一个promise对象只能改变一次<br>   无论变为成功还是失败，都会有一个结果数据<br>   成功的结果数据一般称为value，失败的结果数据一般称为reason</li>
</ol>
<h3 id="1-4-Promise的值"><a href="#1-4-Promise的值" class="headerlink" title="1.4 Promise的值"></a>1.4 Promise的值</h3><p>实例对象中的另一个属性 [RromiseResult]<br>保存着异步任务 [成功/失败] 的结果</p>
<ul>
<li>resolve函数</li>
<li>reject函数</li>
</ul>
<h3 id="1-5-Promise的基本流程"><a href="#1-5-Promise的基本流程" class="headerlink" title="1.5 Promise的基本流程"></a>1.5 Promise的基本流程</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210709104619.png"></p>
<h2 id="2-Promise-API"><a href="#2-Promise-API" class="headerlink" title="2.Promise API"></a>2.Promise API</h2><h4 id="2-1-Promise-构造函数-Promise-excutor"><a href="#2-1-Promise-构造函数-Promise-excutor" class="headerlink" title="2.1-Promise 构造函数: Promise (excutor) {}"></a>2.1-Promise 构造函数: Promise (excutor) {}</h4><blockquote>
<p>(1) executor 函数: 执行器 (resolve, reject) =&gt; {}<br>(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {}<br>(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {}<br>说明: executor 会在 Promise 内部立即同步调用，异步操作在执行器中执行，换话说Promise支持同步也支持异步操作</p>
</blockquote>
<h4 id="2-2-Promise-prototype-then-方法-onResolved-onRejected-gt"><a href="#2-2-Promise-prototype-then-方法-onResolved-onRejected-gt" class="headerlink" title="2.2-Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}"></a>2.2-Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}</h4><blockquote>
<p>(1) onResolved 函数: 成功的回调函数 (value) =&gt; {}<br>(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {}<br>说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</p>
</blockquote>
<h4 id="2-3-Promise-prototype-catch-方法-onRejected-gt"><a href="#2-3-Promise-prototype-catch-方法-onRejected-gt" class="headerlink" title="2.3-Promise.prototype.catch 方法: (onRejected) =&gt; {}"></a>2.3-Promise.prototype.catch 方法: (onRejected) =&gt; {}</h4><blockquote>
<p>(1) onRejected 函数: 失败的回调函数 (reason) =&gt; {}<br>说明: then()的语法糖, 相当于: then(undefined, onRejected)</p>
</blockquote>
<h4 id="2-4-Promise-resolve-方法-value-gt"><a href="#2-4-Promise-resolve-方法-value-gt" class="headerlink" title="2.4-Promise.resolve 方法: (value) =&gt; {}"></a>2.4-Promise.resolve 方法: (value) =&gt; {}</h4><blockquote>
<p>（1）value: 成功的数据或 promise 对象<br>说明：返回一个成功/失败的promise对象，直接改变promise状态</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">521</span>);</span><br><span class="line"><span class="comment">// * 如果传入的参数为非Promise类型对象，则返回的结果为成功Promise对象</span></span><br><span class="line"><span class="comment">// * 如果传入的参数为Promise对象，则参数的结果决定了resolve的结果</span></span><br><span class="line"><span class="comment">// 即：传入的promise对象的状态决定了p2的状态（成功 or 失败）</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve(&#x27;ok&#x27;);</span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;))</span><br><span class="line"><span class="comment">// console.log(p2);</span></span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="2-5-Promise-reject-方法-reason-gt"><a href="#2-5-Promise-reject-方法-reason-gt" class="headerlink" title="2.5-Promise.reject 方法: (reason) =&gt; {}"></a>2.5-Promise.reject 方法: (reason) =&gt; {}</h4><blockquote>
<p>（1）reason: 失败的原因<br>说明：返回一个失败的promise对象(不论传入什么，返回结果的状态都是失败，即使传入的为成功的promise对象，状态也是失败)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">521</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;iloveyou&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1结果&#x27;</span>, p1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2结果&#x27;</span>, p2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p3结果&#x27;</span>, p3);</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210709151507.png"></p>
<h4 id="2-6-Promise-all-方法-promises-gt"><a href="#2-6-Promise-all-方法-promises-gt" class="headerlink" title="2.6-Promise.all 方法: (promises) =&gt; {}"></a>2.6-Promise.all 方法: (promises) =&gt; {}</h4><blockquote>
<p>promises:包含n个promise的数组<br>说明：返回一个新的promise，只有所有的promise都成功才成功，只要有一个失败，就直接失败</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有的promise都成功</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Yeah&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210709153134.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise中有一个失败</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210709153226.png"></p>
<h4 id="2-7-Promise-race-方法-promises-gt"><a href="#2-7-Promise-race-方法-promises-gt" class="headerlink" title="2.7 Promise.race 方法: (promises) =&gt; {}"></a>2.7 Promise.race 方法: (promises) =&gt; {}</h4><blockquote>
<p>promises:包含n个promise的数组<br>说明：返回一个新的promise,第一个完成的promise结果状态就是最终的结果状态</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Yeah&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119150233.png"><br>状态为p1的状态，结果为p1的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Yeah&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119150538.png"><br>因为p1中有定时器，因此p2是第一个执行的，所以状态和结果都与p2的一致。</p>
<h2 id="3-Promise关键问题"><a href="#3-Promise关键问题" class="headerlink" title="3.Promise关键问题"></a>3.Promise关键问题</h2><h4 id="3-1-如何修改对象的状态"><a href="#3-1-如何修改对象的状态" class="headerlink" title="3.1 如何修改对象的状态"></a>3.1 如何修改对象的状态</h4><p>三种方式：resolve函数、reject函数、throw抛出错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.resolve 函数</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>); <span class="comment">//状态：pending =&gt; filfilled (resolved)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.rejected 函数</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>); <span class="comment">//状态：pending =&gt; rejected</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.抛出错误</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;出问题了&#x27;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-2-能否执行多个回调"><a href="#3-2-能否执行多个回调" class="headerlink" title="3.2 能否执行多个回调"></a>3.2 能否执行多个回调</h4><p>Q: 一个promise指定多个成功/失败回调函数，都会调用吗？<br>A：当promise改变为对应状态时都会调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定回调 - 1</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定回调 - 2</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-改变状态与指定回调的顺序问题"><a href="#3-3-改变状态与指定回调的顺序问题" class="headerlink" title="3.3 改变状态与指定回调的顺序问题"></a>3.3 改变状态与指定回调的顺序问题</h4><p>改变promise状态和指定回调函数谁先谁后？</p>
<ol>
<li>都有可能，正常情况下是先指定回调再改变状态，但也可以先改变状态再指定回调</li>
<li>如何先改变状态再指定回调？<br>① 在执行器中直接调用resolve() / reject()<br>② 延迟更长时间才调用then()</li>
<li>什么时候才能得到数据？<br>① 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据<br>② 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先改变状态，再执行回调</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先执行回调，再改变状态</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-4-then方法返回结果由什么决定"><a href="#3-4-then方法返回结果由什么决定" class="headerlink" title="3.4 then方法返回结果由什么决定"></a>3.4 then方法返回结果由什么决定</h4><p>promise.then()返回的新的promise的结果状态由什么决定？</p>
<ol>
<li>简单表达：由then()指定的回调函数执行的结果决定</li>
<li>详细表达：<br>① 如果抛出异常，新promise变为rejected，reason为抛出的异常<br>② 如果返回的是非promise的任意值，新promise变为resolved，value为返回值<br>③ 如果返回的是另一个新promise，此promise的结果就会成为新promise的结果</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119163613.png"></p>
<h4 id="3-5-串联多个任务"><a href="#3-5-串联多个任务" class="headerlink" title="3.5 串联多个任务"></a>3.5 串联多个任务</h4><p>promise如何串联多个操作任务？</p>
<ol>
<li>promise的then()返回一个新的promise，可以看成then()的链式调用</li>
<li>通过then的链式调用串联多个同步/异步任务</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value1:&#x27;</span>,value1)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value2:&#x27;</span>,value2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119170913.png"><br>说明：<br>value1是new Promise的返回值success，value2是value1（promise）的返回值，因其未定义，所以为undefined</p>
<h4 id="3-6-异常穿透"><a href="#3-6-异常穿透" class="headerlink" title="3.6 异常穿透"></a>3.6 异常穿透</h4><ol>
<li>当使用promise的then链式调用时，可以在最后指定失败的回调</li>
<li>前面任何操作出现了异常，都会传到最后失败的回调中处理</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;value1:&#x27;, value1)</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;Error&#x27;</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value2:&#x27;</span>, value2)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-7-中断promise链"><a href="#3-7-中断promise链" class="headerlink" title="3.7 中断promise链"></a>3.7 中断promise链</h4><ol>
<li>当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数</li>
<li>唯一方法：在回调函数中返回一个pending状态的promise对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value1:&#x27;</span>, value1)</span><br><span class="line">  <span class="comment">// 有且只有一种方法：返回一个pending状态的promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value2:&#x27;</span>, value2)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-Promise自定义封装-手写Promise"><a href="#4-Promise自定义封装-手写Promise" class="headerlink" title="4.Promise自定义封装(手写Promise)"></a>4.Promise自定义封装(手写Promise)</h2><h4 id="4-1-初始结构搭建"><a href="#4-1-初始结构搭建" class="headerlink" title="4.1 初始结构搭建"></a>4.1 初始结构搭建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加then方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-resolve与reject的结构搭建"><a href="#4-2-resolve与reject的结构搭建" class="headerlink" title="4.2 resolve与reject的结构搭建"></a>4.2 resolve与reject的结构搭建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">  <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加then方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-resolve与reject的代码实现"><a href="#4-3-resolve与reject的代码实现" class="headerlink" title="4.3 resolve与reject的代码实现"></a>4.3 resolve与reject的代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">PromiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//保存实例对象的 this 的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 1.修改对象的状态(promiseState)</span></span><br><span class="line">    self.<span class="property">PromiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span>; <span class="comment">// resolved</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值(promiseResult)</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 1.修改对象的状态(promiseState)</span></span><br><span class="line">    self.<span class="property">PromiseState</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="comment">// 2.设置对象结果值(promiseResult)</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">  <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加then方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-throw抛出异常改变状态"><a href="#4-4-throw抛出异常改变状态" class="headerlink" title="4.4 throw抛出异常改变状态"></a>4.4 throw抛出异常改变状态</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-5-Promise对象状态只能修改一次"><a href="#4-5-Promise对象状态只能修改一次" class="headerlink" title="4.5 Promise对象状态只能修改一次"></a>4.5 Promise对象状态只能修改一次</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-6-then方法执行回调"><a href="#4-6-then方法执行回调" class="headerlink" title="4.6 then方法执行回调"></a>4.6 then方法执行回调</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">promiseResult</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">promiseResult</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-7-异步任务回调的执行"><a href="#4-7-异步任务回调的执行" class="headerlink" title="4.7 异步任务回调的执行"></a>4.7 异步任务回调的执行</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callback</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">callback</span>.<span class="property">onResolved</span>) &#123;</span><br><span class="line">      self.<span class="property">callback</span>.<span class="title function_">onResolved</span>(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">callback</span>.<span class="property">onRejected</span>) &#123;</span><br><span class="line">      self.<span class="property">callback</span>.<span class="title function_">onRejected</span>(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">promiseResult</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">promiseResult</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callback</span> = &#123;</span><br><span class="line">      <span class="attr">onResolved</span>: onResolved,</span><br><span class="line">      <span class="attr">onRejected</span>: onRejected</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-指定多个回调的实现"><a href="#4-8-指定多个回调的实现" class="headerlink" title="4.8 指定多个回调的实现"></a>4.8 指定多个回调的实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">promiseResult</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">promiseResult</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">onResolved</span>: onResolved,</span><br><span class="line">      <span class="attr">onRejected</span>: onRejected</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-9-同步任务下then方法返回结果的实现"><a href="#4-9-同步任务下then方法返回结果的实现" class="headerlink" title="4.9 同步任务下then方法返回结果的实现"></a>4.9 同步任务下then方法返回结果的实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">promiseResult</span>);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">promiseResult</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行成功回调函数</span></span><br><span class="line">            <span class="keyword">let</span> result = <span class="title function_">onResolved</span>(self.<span class="property">promiseResult</span>);</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">              result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(v);</span><br><span class="line">              &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(r);</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> result = <span class="title function_">onRejected</span>(self.<span class="property">promiseResult</span>)</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">              result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(v);</span><br><span class="line">              &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(r);</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-10-异步任务下then方法返回结果的实现"><a href="#4-10-异步任务下then方法返回结果的实现" class="headerlink" title="4.10 异步任务下then方法返回结果的实现"></a>4.10 异步任务下then方法返回结果的实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">callback</span> (type) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">promiseResult</span>);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-11-then方法的完善与优化"><a href="#4-11-then方法的完善与优化" class="headerlink" title="4.11 then方法的完善与优化"></a>4.11 then方法的完善与优化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">callback</span> (type) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">promiseResult</span>);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-11-catch方法、异常穿透、值传递"><a href="#4-11-catch方法、异常穿透、值传递" class="headerlink" title="4.11 catch方法、异常穿透、值传递"></a>4.11 catch方法、异常穿透、值传递</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">callback</span> (type) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">promiseResult</span>);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span> (<span class="params">onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-12-Promise-resolve-的封装"><a href="#4-12-Promise-resolve-的封装" class="headerlink" title="4.12 Promise.resolve()的封装"></a>4.12 Promise.resolve()的封装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">callback</span> (type) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">promiseResult</span>);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span> (<span class="params">onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 resolve  方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">      value.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//状态设置为成功</span></span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-13-Promise-reject-的封装"><a href="#4-13-Promise-reject-的封装" class="headerlink" title="4.13 Promise.reject()的封装"></a>4.13 Promise.reject()的封装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">callback</span> (type) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">promiseResult</span>);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span> (<span class="params">onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 resolve  方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">      value.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//状态设置为成功</span></span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 reject 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-14-Promise-all-的封装"><a href="#4-14-Promise-all-的封装" class="headerlink" title="4.14 Promise.all()的封装"></a>4.14 Promise.all()的封装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">callback</span> (type) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">promiseResult</span>);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span> (<span class="params">onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 resolve  方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">      value.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//状态设置为成功</span></span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 reject 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 all 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回结果为promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 声明变量-&gt; 保证所有的promise都成功才可以执行resolve()</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 存放成功结果</span></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">// 遍历 promises</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 得知对象的状态是成功</span></span><br><span class="line">        <span class="comment">// 每个promise对象都成功</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 将当前promise对象成功的结果存入到数组中</span></span><br><span class="line">        arr[i] = v;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (count === promises.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="comment">// 修改状态</span></span><br><span class="line">          <span class="title function_">resolve</span>(arr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-14-Promise-race-的封装"><a href="#4-14-Promise-race-的封装" class="headerlink" title="4.14 Promise.race()的封装"></a>4.14 Promise.race()的封装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">callback</span> (type) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">promiseResult</span>);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span> (<span class="params">onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 resolve  方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">      value.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//状态设置为成功</span></span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 reject 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 all 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回结果为promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 声明变量-&gt; 保证所有的promise都成功才可以执行resolve()</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 存放成功结果</span></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">// 遍历 promises</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 得知对象的状态是成功</span></span><br><span class="line">        <span class="comment">// 每个promise对象都成功</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 将当前promise对象成功的结果存入到数组中</span></span><br><span class="line">        arr[i] = v;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (count === promises.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="comment">// 修改状态</span></span><br><span class="line">          <span class="title function_">resolve</span>(arr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 race 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改返回对象的状态为【成功】</span></span><br><span class="line">        <span class="title function_">resolve</span>(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改返回对象的状态为【失败】</span></span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-15-then方法回调的异步执行"><a href="#4-15-then方法回调的异步执行" class="headerlink" title="4.15 then方法回调的异步执行"></a>4.15 then方法回调的异步执行</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220125163632.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span> (executor) &#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">callback</span> (type) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">promiseResult</span>);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(onResolved);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(onRejected);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span> (<span class="params">onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 resolve  方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">      value.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//状态设置为成功</span></span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 reject 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 all 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回结果为promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 声明变量-&gt; 保证所有的promise都成功才可以执行resolve()</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 存放成功结果</span></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">// 遍历 promises</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 得知对象的状态是成功</span></span><br><span class="line">        <span class="comment">// 每个promise对象都成功</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 将当前promise对象成功的结果存入到数组中</span></span><br><span class="line">        arr[i] = v;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (count === promises.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="comment">// 修改状态</span></span><br><span class="line">          <span class="title function_">resolve</span>(arr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 race 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改返回对象的状态为【成功】</span></span><br><span class="line">        <span class="title function_">resolve</span>(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改返回对象的状态为【失败】</span></span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-16-封装Promise类"><a href="#4-16-封装Promise类" class="headerlink" title="4.16 封装Promise类"></a>4.16 封装Promise类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="comment">// 添加属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">promiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">promiseResult</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resolve函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolve</span> (data) &#123;</span><br><span class="line">      <span class="comment">// 判断</span></span><br><span class="line">      <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">      self.<span class="property">promiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">      <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">      self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reject</span> (data) &#123;</span><br><span class="line">      <span class="comment">// 判断</span></span><br><span class="line">      <span class="keyword">if</span> (self.<span class="property">promiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">      self.<span class="property">promiseState</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">      <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">      self.<span class="property">promiseResult</span> = data;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">      <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//then方法</span></span><br><span class="line">  then (onResolved, onRejected) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 封装函数</span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">callback</span> (type) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">          <span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">promiseResult</span>);</span><br><span class="line">          <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">            <span class="comment">// 结果是promise对象</span></span><br><span class="line">            result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(v);</span><br><span class="line">            &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="title function_">reject</span>(r);</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">            <span class="title function_">resolve</span>(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onResolved);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onRejected);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">promiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 保存回调函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">callback</span>(onResolved);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">callback</span>(onRejected);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//catch方法</span></span><br><span class="line">  <span class="keyword">catch</span> (onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加resolve方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve (value) &#123;</span><br><span class="line">    <span class="comment">// 返回Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">        value.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(v);</span><br><span class="line">        &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(r);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//状态设置为成功</span></span><br><span class="line">        <span class="title function_">resolve</span>(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加 reject 方法</span></span><br><span class="line">  <span class="keyword">static</span> reject (reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加 all 方法</span></span><br><span class="line">  <span class="keyword">static</span> all (promises) &#123;</span><br><span class="line">    <span class="comment">// 返回结果为promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 声明变量-&gt; 保证所有的promise都成功才可以执行resolve()</span></span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 存放成功结果</span></span><br><span class="line">      <span class="keyword">let</span> arr = [];</span><br><span class="line">      <span class="comment">// 遍历 promises</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 得知对象的状态是成功</span></span><br><span class="line">          <span class="comment">// 每个promise对象都成功</span></span><br><span class="line">          count++;</span><br><span class="line">          <span class="comment">// 将当前promise对象成功的结果存入到数组中</span></span><br><span class="line">          arr[i] = v;</span><br><span class="line">          <span class="comment">// 判断</span></span><br><span class="line">          <span class="keyword">if</span> (count === promises.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="comment">// 修改状态</span></span><br><span class="line">            <span class="title function_">resolve</span>(arr);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(r);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加 race 方法</span></span><br><span class="line">  <span class="keyword">static</span> race (promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 修改返回对象的状态为【成功】</span></span><br><span class="line">          <span class="title function_">resolve</span>(v);</span><br><span class="line">        &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 修改返回对象的状态为【失败】</span></span><br><span class="line">          <span class="title function_">reject</span>(r);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-async-与-await"><a href="#5-async-与-await" class="headerlink" title="5.async 与 await"></a>5.async 与 await</h2><h4 id="5-1-async函数"><a href="#5-1-async函数" class="headerlink" title="5.1 async函数"></a>5.1 async函数</h4><ol>
<li>函数的返回值为promise对象</li>
<li>promise对象的结果由async函数执行的返回值决定</li>
</ol>
<p>async函数返回值的规则与then方法的规则是一致的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 1.如果返回值是一个非Promise类型的数据</span></span><br><span class="line">      <span class="comment">// promiseState为fulfilled，promiseResult为返回的值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">521</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.如果返回的是一个Promise对象</span></span><br><span class="line">      <span class="comment">// promiseState为返回promise对象的状态，promiseResult为返回的promise对象的值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&#x27;ERR&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.抛出异常</span></span><br><span class="line">      <span class="comment">// promiseState为reject，promiseResult为抛出异常的值</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;error&#x27;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-await表达式"><a href="#5-2-await表达式" class="headerlink" title="5.2 await表达式"></a>5.2 await表达式</h4><ol>
<li>await右侧的表达式一般为promise对象，但也可以是其他的值</li>
<li>如果表达式是promise对象，await返回的是promise成功的值</li>
<li>如果表达式是其他值，直接将此值作为await的返回值</li>
</ol>
<p><b>注意</b></p>
<ul>
<li>await必须写在async函数中，但async函数中可以没有await</li>
<li>如果await的promise失败了，就会抛出异常，需要通过try…catch捕获处理</li>
</ul>
<p><code>await 10;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220126094102.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220126095436.png"></p>
<h4 id="5-3-async和await结合"><a href="#5-3-async和await结合" class="headerlink" title="5.3  async和await结合"></a>5.3  async和await结合</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> mineReadFile = util.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数的方式</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;1.txt&#x27;</span>, <span class="function">(<span class="params">err, data1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(<span class="string">&#x27;2.txt&#x27;</span>, <span class="function">(<span class="params">err, data2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;3.txt&#x27;</span>, <span class="function">(<span class="params">err, data3</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data1 + data2 + data3);</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// async 与 await</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span> () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    <span class="keyword">let</span> data1 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;1.txt&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> data2 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;2.txt&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> data3 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;3.txt&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data1 + data2 + data3);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>async 与 await方式非常简洁，且捕获异常也十分简单。</p>
<h4 id="5-4-async-与-await结合发送AJAX"><a href="#5-4-async-与-await结合发送AJAX" class="headerlink" title="5.4 async 与 await结合发送AJAX"></a>5.4 async 与 await结合发送AJAX</h4><p>情景：点击获取段子按钮，发送ajax请求，获取数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>async与await结合发送AJAX<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>获取段子<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sendAJAX</span>(<span class="params">url</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//1.创建对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.初始化</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//3.发送</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//4.处理响应结果</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//判断响应状态码2xx</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="comment">//控制台输出响应体</span></span></span><br><span class="line"><span class="language-javascript">              <span class="title function_">resolve</span>(xhr.<span class="property">response</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="comment">//控制台输出响应状态码</span></span></span><br><span class="line"><span class="language-javascript">              <span class="title function_">reject</span>(xhr.<span class="property">status</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 获取段子信息</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> duanzi = <span class="keyword">await</span> <span class="title function_">sendAJAX</span>(<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(duanzi);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS实现点击div添加选中样式</title>
    <url>/2022/01/18/CSS%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BBdiv%E6%B7%BB%E5%8A%A0%E9%80%89%E4%B8%AD%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="情景"><a href="#情景" class="headerlink" title="情景:"></a>情景:</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220118144305.png"><br>四个按钮，选中其中一个后，为其添加样式且要保持样式，当选择其他的按钮后，之前选中按钮样式取消，选中按钮样式添加。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用input标签和label标签。</p>
<ul>
<li>input标签表示单选按钮，保证只能有一个按钮可以选中（name相同）。隐藏不显示。</li>
<li>label标签用于显示文字和设置选中背景颜色。</li>
</ul>
<p>实现点击之后才进行切换的效果：<br>将lable指向相应的input标签的id并使用伪类:checked来实现选择切换的效果。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;catebtn&quot;</span> <span class="attr">id</span>=<span class="string">&quot;news&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;news&quot;</span>&gt;</span>公司新闻<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;catebtn&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dongtai&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;dongtai&quot;</span>&gt;</span>行业动态<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;catebtn&quot;</span> <span class="attr">id</span>=<span class="string">&quot;baodao&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;baodao&quot;</span>&gt;</span>媒体报道<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;catebtn&quot;</span> <span class="attr">id</span>=<span class="string">&quot;zhishi&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;zhishi&quot;</span>&gt;</span>行业知识<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">label</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.1rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">label</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#026eb7</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-id">#news</span><span class="selector-pseudo">:checked</span>+<span class="selector-tag">label</span>,</span><br><span class="line"><span class="selector-id">#dongtai</span><span class="selector-pseudo">:checked</span>+<span class="selector-tag">label</span>,</span><br><span class="line"><span class="selector-id">#baodao</span><span class="selector-pseudo">:checked</span>+<span class="selector-tag">label</span>,</span><br><span class="line"><span class="selector-id">#zhishi</span><span class="selector-pseudo">:checked</span>+<span class="selector-tag">label</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#026eb7</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>字节青训营-理解css</title>
    <url>/2022/01/16/%E9%9D%92%E8%AE%AD%E8%90%A52-%E7%90%86%E8%A7%A3css/</url>
    <content><![CDATA[<h2 id="CSS是什么？"><a href="#CSS是什么？" class="headerlink" title="CSS是什么？"></a>CSS是什么？</h2><p>css(cascading style sheets):用来定义页面元素的样式。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0323042c94648ebb71b785f0b3a70d1~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="页面使用css"><a href="#页面使用css" class="headerlink" title="页面使用css"></a>页面使用css</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 1. 外链形式</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/assets/style.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 2.嵌入形式</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 3.内联形式</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red;&quot;</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="css如何工作？"><a href="#css如何工作？" class="headerlink" title="css如何工作？"></a>css如何工作？</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a53824239cb443b8f6ca103b4b99c32~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="选择器Selector"><a href="#选择器Selector" class="headerlink" title="选择器Selector"></a>选择器Selector</h2><p>找出页面中元素的位置，以便给其设置样式</p>
<p>选择页面元素的方式：</p>
<ul>
<li>标签名、类名、id</li>
<li>属性</li>
<li>DOM树中的位置</li>
</ul>
<p>选择器种类：通配选择器、标签选择器、id选择器、类选择器、属性选择器、伪类选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 属性选择器</span><br><span class="line"><span class="selector-attr">[disabled]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择器的组合使用"><a href="#选择器的组合使用" class="headerlink" title="选择器的组合使用"></a>选择器的组合使用</h2><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">语法</th>
<th align="left">说明</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">直接组合</td>
<td align="center">AB</td>
<td align="left">满足A的同时满足B</td>
<td align="center"><code>input:focus</code></td>
</tr>
<tr>
<td align="left">后代组合</td>
<td align="center">A B</td>
<td align="left">选中B，如果他是A的子孙</td>
<td align="center"><code>nav a </code></td>
</tr>
<tr>
<td align="left">亲子组合</td>
<td align="center">A &gt; B</td>
<td align="left">选中B，如果他是A的子元素</td>
<td align="center"><code>selection &gt; p</code></td>
</tr>
<tr>
<td align="left">兄弟选择器</td>
<td align="center">A ~ B</td>
<td align="left">选中B，如果他在A后且和A同级</td>
<td align="center"><code>h2 ~ p</code></td>
</tr>
<tr>
<td align="left">相邻选择器</td>
<td align="center">A + B</td>
<td align="left">选中B，如果他<b>紧跟</b>在A的后面</td>
<td align="center"><code>h2 + p</code></td>
</tr>
</tbody></table>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>RGB</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a228ad26abb4bcaa8d5ea27ba31dc32~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>HSL</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/392aec0267444896883b6e5f64ef8208~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4c43482dfad478cac01c596feb73575~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd845c3faa8a4c748df64b56e37ec421~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>color：用来设置字体颜色</p>
<p>font-size:字体大小</p>
<ul>
<li>和font-size相关的单位：</li>
<li>em 相当于当前元素的一个font-size</li>
<li>rem相当于根元素的一个font-size</li>
</ul>
<p>font-family:字体族（字体的格式），可选值：（字体分类）</p>
<ul>
<li>serif 衬线字体</li>
<li>sans-serif 非衬线字体</li>
<li>monospave 等宽字体</li>
</ul>
<p>指定字体类别，浏览器会自动使用该类别下的字体，font-family可以同时指定多个字体，多个字体间使用,隔开，字体生效时优先使用第一个，第一个无法使用则使用第二个，以此类推</p>
<p>@font-face可以将服务器中的字体直接提供给用户去使用。</p>
<p>存在问题：</p>
<ul>
<li>1.加载速度</li>
<li>2.版权</li>
<li>3.字体格式</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac410a72e0c642e39256fc7f5f534699~tplv-k3u1fbpfcp-zoom-1.image"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;myfont&#x27;</span>; <span class="comment">/* 指定字体名字 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">/* 服务器端中的地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;myfont&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>font-weight 字重，字体加粗<br>可选值：</p>
<ul>
<li>normal 默认值，不加粗</li>
<li>blod 加粗</li>
<li>100-900 九个级别（没什么用）</li>
</ul>
<p>font-style 字体风格<br>可选值：</p>
<ul>
<li>normal 正常的</li>
<li>italic 斜体</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font</span>: style weight size/height family;</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/368829e3fe43434a99e9a1ddce0a06ea~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>text-aligh 设置文字对齐样式<br>可选值：</p>
<ul>
<li>left 左对齐 </li>
<li>center 居中对齐 </li>
<li>right 右对齐 </li>
<li>justify 两端对齐（对最后一行的文字不生效）</li>
</ul>
<p>letter-spacing:调整文字字母之间的间距<br>word-spacing:调整单词之间的距离<br>text-index:设置文字缩进</p>
<p>text-decoration 设置文本修饰<br>可选值：</p>
<ul>
<li>none 默认值，什么都没有</li>
<li>underline 下划线</li>
<li>line-through 删除线</li>
<li>overline 上划线</li>
</ul>
<p>white-space 设置网页如何处理空白<br>可选值：</p>
<ul>
<li>normal 默认值，正常</li>
<li>nowrap 不换行</li>
<li>pre 保留空白（源代码中文本格式不做处理，保留）</li>
<li>pre-wrap 一行内容显示不全会换行</li>
<li>pre-line 会保留换行</li>
</ul>
<h2 id="调试CSS"><a href="#调试CSS" class="headerlink" title="调试CSS"></a>调试CSS</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15843ca7bdfa44be9daca4ffc9257cb0~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>某些属性会自动继承其父元素的计算值，除非显式指定一个值。<br>一般与文字相关的样式都会被继承，与宽度、高度、盒模型相关的不会被继承。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 显示继承</span><br><span class="line">*&#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.some-widget</span>&#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a93cd90dc08e431abc172a2ca646f94d~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="CSS求值过程"><a href="#CSS求值过程" class="headerlink" title="CSS求值过程"></a>CSS求值过程</h2><p>如何从一个DOM节点生成一棵渲染树或渲染节点</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09d977f8411a4823bc1bf64381fa3542~tplv-k3u1fbpfcp-zoom-1.image"></p>
<ul>
<li>第一步：筛选出节点对应的样式（样式个数：0~多个）</li>
<li>第二步：筛选出样式中优先级最高的样式</li>
<li>第三步：查看样式是否为空，若是空的，则依据继承或者初始值</li>
<li>第四步：将一些相对值转化为绝对值（rem → px、相对路径 →  绝对路径等），这些绝对值是在浏览器未进行实际布局的情况下得到的具体值，其中会包含百分数。</li>
<li>第五步：将计算值进一步计算，即将百分比转化为具体数值等</li>
<li>第六步：上一步的计算值中可能会出现100.2px、超出min-width或max-width的情况，需要进一步将其转化为整数值</li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局相关技术：常规流、浮动、绝对定位</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e93f05f2ccaf46beb0939b197cfdfb2b~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="width和height"><a href="#width和height" class="headerlink" title="width和height"></a>width和height</h4><ul>
<li>指定content box 的宽度和高度；</li>
<li>取值为长度、百分比、auto【百分比时，只有元素的容器指定width和height的具体值时才会生效】</li>
</ul>
<h4 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/441bde485d5d4fa38e2f48007a75702c~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>设置数值为百分数时，是相对于元素容器宽度</p>
<h4 id="border"><a href="#border" class="headerlink" title="border"></a>border</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a312738c01b4bc5b10a4123a1a94bbd~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>使用border属性生成三角形 → <a href="https://qw-null.github.io/2021/09/22/CSS%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/#2-%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2">详情</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">50px</span> solid red;</span><br><span class="line">  <span class="attribute">border-top</span>:<span class="number">50px</span> solid green;</span><br><span class="line">  <span class="attribute">border-right</span>:<span class="number">50px</span> solid blue;</span><br><span class="line">  <span class="attribute">border-bottom</span>:<span class="number">50px</span> solid yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca9e85b6ce224e0abab99b0b32343f34~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5950db38bc4b4843a2c889591fb82bb8~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><b>margin collapse问题（边距折叠）</b><br>仅仅发生在垂直方向上，水平方向上不会存在这个问题</p>
<ol>
<li>兄弟元素：兄弟元素间的相邻垂直外边距会取两者之间的较大值（正值），特殊情况：如果相邻的外边距一正一负，则取两者的和；如果相邻的外边距都是负值，则取两者中绝对值较大的</li>
<li>父子元素：父子元素间的相邻外边距，子元素的会传递给父元素（上外边距）</li>
</ol>
<h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p>默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定。<br>box-sizing 用来设置盒子尺寸的计算方式（设置width和height的作用）<br>可选值：</p>
<ul>
<li>content-box 默认值，宽度和高度用来设置内容区的大小</li>
<li>border-box 宽度和高度用来设置整个盒子可见框的大小（width和height指的是内容区、内边距和边框的总大小）</li>
</ul>
<h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><p>overflow属性用来设置父元素如何处理溢出的子元素<br>可选值：</p>
<ul>
<li>visible，默认值，子元素会从父元素中溢出，在父元素外部的位置显示</li>
<li>hidden，溢出的内容将会被裁剪不会显示</li>
<li>scroll，生成两个滚动条，通过滚动条来查看完整内容</li>
<li>auto，根据需要生成滚动条</li>
</ul>
<h4 id="块级-VS-行级"><a href="#块级-VS-行级" class="headerlink" title="块级 VS 行级"></a>块级 VS 行级</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f73e0eda7fd48078e965f79efc442e6~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b604b67902f46b6b0381e98a4aa3b1c~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h4><p>可选值：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0db732fa41da45fc9f92e79c2739ec85~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="常规流-Normal-Flow-文档流"><a href="#常规流-Normal-Flow-文档流" class="headerlink" title="常规流 Normal Flow (文档流)"></a>常规流 Normal Flow (文档流)</h4><ul>
<li>根元素、浮动和绝对定位的元素会脱离常规流</li>
<li>其他元素都在常规流之中</li>
<li>常规流中的盒子，在某种排版上下文中参与布局，可通过display属性设置</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8262764db73b437a8090b9a0a1b133ae~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h5 id="行级排版上下文"><a href="#行级排版上下文" class="headerlink" title="行级排版上下文"></a>行级排版上下文</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b0f2ac6b711436e9c299a24ee0a034e~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h5 id="块级排版上下文"><a href="#块级排版上下文" class="headerlink" title="块级排版上下文"></a>块级排版上下文</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/787387e2b30f4a279f0eb9cb47060e19~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h5 id="Flex-Box"><a href="#Flex-Box" class="headerlink" title="Flex Box"></a>Flex Box</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4e8bf862b9b47c98a290965e55685f4~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
flex-direction 指定容器中弹性元素的排列方式（主轴方向）

<p>   可选值：</p>
<ul>
<li>row 默认值，弹性元素在容器中水平排列（自左向右）</li>
<li>row-reverse 弹性元素在容器中反向水平排列（自右向左）</li>
<li>column 弹性元素纵向排列（自上向下）</li>
<li>column-reverse 弹性元素反向纵向排列（自下向上）</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffb6b591c2b64756af3876ad527a1a66~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de37ef63f41746a38c172e0b6dae4583~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
justify-content 如何分配主轴上的空白空间（主轴上的元素如何排列）

<p>   可选值：</p>
<ul>
<li>flex-start 元素沿着主轴的起边排列</li>
<li>flex-end 元素沿着主轴的终边排列</li>
<li>center 元素居中排列</li>
<li>space-around 空白分布到元素的两个</li>
<li>space-between 空白均匀分布到元素间</li>
<li>space-evenly 空白分布到元素的单侧</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01cb8f4b015040a58c05231eee8c38e4~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
align-items 定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式（元素间关系）

<p>   可选值：</p>
<ul>
<li>stretch 默认值，将元素的长度设置为相同的值</li>
<li>flex-start 元素不会拉伸，沿着辅轴起边对齐</li>
<li>flex-end 元素不会拉伸，沿着辅轴终边对齐</li>
<li>center 居中对齐</li>
<li>baseline 基线对齐</li>
</ul>
<p>  ** align-self 用来覆盖当前弹性元素上的align-items</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c9fe55c05bc4e3ab2bb914449a2359a~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3d3694162d942ada4dcceb0ac00ef7a~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
Flexibility

<ul>
<li>可以设置子项的弹性：当容器有剩余空间时，会伸展；容器空间不够时，会收缩。</li>
<li>flex-grow 有剩余空间时的伸展能力</li>
<li>flex-shrink 容器空间不足时收缩的能力</li>
<li>flex-basis 没有伸展或收缩时的基础长度</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b61f6dfc2e0b473a95dc952d36b19507~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h5 id="Grid-布局"><a href="#Grid-布局" class="headerlink" title="Grid 布局"></a>Grid 布局</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0af06cb54fc043c28538c5f755b612dc~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>Flex仅可以设置一个方向的布局，Grid是一个二维布局方式</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a28a40f5fdc04a95aac76a533beca73b~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
划分网格：

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/397276cb11a245fa8eeb1306659b1965~tplv-k3u1fbpfcp-zoom-1.image"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: <span class="number">30%</span> <span class="number">30%</span> auto;</span><br><span class="line"><span class="attribute">grid-template-rows</span>: <span class="number">100px</span> auto;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fed64fe6060240128f8fefa4c792a760~tplv-k3u1fbpfcp-zoom-1.image"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">// fr表示一份</span><br><span class="line">// 含义：除去第一部分<span class="number">100px</span>外，剩余的第二部分、第三部分各占剩余部分的一份。</span><br><span class="line"><span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">1</span>fr;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56556798271c413885435dfc7fc71057~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
grid line网格线：

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/080fb704459b472699e90be75af5e271~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>grid area 网格区域：<br>网格区域使用网格线表示</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd7708ed23f24aa39f1afcc2f5fdfd77~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fae3b461f78c4000b6d2076ecb9a3809~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="浮动-Float"><a href="#浮动-Float" class="headerlink" title="浮动 Float"></a>浮动 Float</h4><p>通过浮动可以使一个元素向其父元素的左侧或者右侧移动，通过float属性来设置元素的浮动。<br>float可选值:</p>
<ul>
<li>none 默认值，元素不浮动</li>
<li>left 元素向左浮动</li>
<li>right 元素向右浮动</li>
</ul>
<h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>定位(position)，是一种更加高级的布局手段，通过定位可以将元素摆放在页面的任意位置，使用position属性来设置定位<br>可选值：</p>
<ul>
<li>static 默认值，元素是静止的没有开启定位</li>
<li>relative 开启元素相对定位</li>
<li>absolute 开启元素绝对定位</li>
<li>fixed 开启元素的固定定位</li>
<li>sticky 开启元素的粘滞定位</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5784d5476cf4490180f20e81e285f002~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/949b3423a1084ffe9fecd71f8a8d2126~tplv-k3u1fbpfcp-zoom-1.image"></p>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>字节青训营-前端与HTML</title>
    <url>/2022/01/16/%E9%9D%92%E8%AE%AD%E8%90%A51-%E5%89%8D%E7%AB%AF%E4%B8%8EHTML/</url>
    <content><![CDATA[<h2 id="0-什么是前端？"><a href="#0-什么是前端？" class="headerlink" title="0.什么是前端？"></a>0.什么是前端？</h2><p>使用web技术栈，解决多端【PC/移动浏览器、客户端、小程序、VR/AR等】图形用户界面下人机交互问题<br>前端技术栈：html(内容) + css(样式) + js(行为)</p>
<h2 id="1-HTML"><a href="#1-HTML" class="headerlink" title="1.HTML"></a>1.HTML</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116115240.png"></p>
<p>浏览器会将html文件解析成一棵DOM树<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116120500.png"></p>
<h3 id="1-1-HTML-语法"><a href="#1-1-HTML-语法" class="headerlink" title="1.1 HTML 语法"></a>1.1 HTML 语法</h3><p>标签属性不区分大小写（推荐：小写）、属性值使用双引号包裹、空标签可以不闭合、某些属性值可以省略（readonly、required）</p>
<ul>
<li>空标签<br>没有闭合标签的标签被称作为空标签。<br>常见的空标签：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span> 换行标签，通常用于文本格式换行</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> /&gt;</span>  用于为基于Web的表单创建交互式控件，以便接受来自用户的数据。</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> /&gt;</span> 代表文档中的一个图像。</span><br><span class="line"><span class="tag">&lt;<span class="name">isindex</span> /&gt;</span> 使浏览器显示一个对话框，提示用户输入单行文本。</span><br><span class="line"><span class="tag">&lt;<span class="name">area</span> /&gt;</span> 在图片上定义一个热点区域</span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> /&gt;</span> 指定用于一个文档中包含的所有相对URL的基本URL。</span><br><span class="line"><span class="tag">&lt;<span class="name">basefont</span> /&gt;</span> 用来设置文档的默认字体大小。（目前已废弃 ）</span><br><span class="line"><span class="tag">&lt;<span class="name">bgsound</span> /&gt;</span> IE浏览器中设置网页背景音乐的元素。</span><br><span class="line"><span class="tag">&lt;<span class="name">col</span> /&gt;</span> 定义表格中的列，并用于定义所有公共单元格上的公共语义。它通常位于`<span class="tag">&lt;<span class="name">colgroup</span>&gt;</span>`元素内。</span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> /&gt;</span> 用于表示一个外部应用或交互式内容的集合点，换句话说，就是一个插件。 </span><br><span class="line"><span class="tag">&lt;<span class="name">frame</span> /&gt;</span> ，它定义了一个特定区域，另一个 HTML 文档可以在里面展示。(已废弃)</span><br><span class="line"><span class="tag">&lt;<span class="name">keygen</span> /&gt;</span>  为了方便生成密钥材料和提交作为 [HTML form]的一部分的公钥.这种机制被用于设计基于 Web 的证书管理系统。(已废弃)</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> /&gt;</span> 指定了外部资源与当前文档的关系. 这个元素的使用方法包括为导航定义关系框架.这个元素经常用来链接css文件。</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> /&gt;</span> 元素表示那些不能由其它HTML元相关元素 (<span class="tag">&lt;<span class="name">base</span>&gt;</span>, <span class="tag">&lt;<span class="name">link</span>&gt;</span>, <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">, <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-xml"> 或 <span class="tag">&lt;<span class="name">title</span>&gt;</span>) 之一表示的任何元数据信息.</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="language-handlebars"><span class="tag">&lt;<span class="name">nextid</span> /&gt;</span>  是一个过时的 HTML 元素, 它使下一个 web 设计工具能够为其定位点生成自动名称标签。它是由该 web 编辑工具自动生成的, 不需要手动调整或输入。这个元素的区别是成为第一个元素, 成为一个 &quot;丢失的标签&quot; 被淘汰的官方公共 DTD 的 HTML 版本。</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="language-handlebars"><span class="tag">&lt;<span class="name">param</span> /&gt;</span>  定义了 <span class="tag">&lt;<span class="name">object</span>&gt;</span>的参数</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="language-handlebars"><span class="tag">&lt;<span class="name">plaintext</span> /&gt;</span> 将起始标签后面的任何东西渲染为纯文本，不会解释为 HTML。它没有闭合标签，因为任何后面的东西都会看做纯文本。(已废弃)</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="language-handlebars"><span class="tag">&lt;<span class="name">spacer</span> /&gt;</span> 它可以向页面插入间隔。它由 Netscape 设计，用于实现单像素布局图像的相同效果，Web 设计师用它来向页面添加空白，而不需要实际使用图片。（已废弃）</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xml"><span class="language-handlebars"><span class="tag">&lt;<span class="name">wbr</span> /&gt;</span> 一个文本中的位置，其中浏览器可以选择来换行，虽然它的换行规则可能不会在这里换行。</span></span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-2-HTML-标签"><a href="#1-2-HTML-标签" class="headerlink" title="1.2 HTML 标签"></a>1.2 HTML 标签</h3><ol>
<li><p>h1~h6 标题标签</p>
</li>
<li><p>列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 1.有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Aa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Bb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 2.无序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Cc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Dd<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 3.自定义列表</span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>学校：<span class="tag">&lt;/<span class="name">dt</span>&gt;</span> <span class="comment">&lt;!-- 代表title --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>UCAS<span class="tag">&lt;/<span class="name">dd</span>&gt;</span> <span class="comment">&lt;!-- title -&gt; value --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>校区<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>雁栖湖校区<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>玉泉路校区<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116123525.png"></p>
</li>
<li><p>链接<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116132541.png"></p>
</li>
<li><p>视频、音频</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>输入<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116124307.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116124609.png"><br>选择框：type=”checkbox”<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116124631.png"></p>
<hr/>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116124721.png"><br>单选框：type=”radio” 、通过name属性的值控制单选<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116124835.png"></p>
<hr></li>
</ol>
<p>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116125023.png"><br>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116125040.png"><br>  <hr></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116125151.png"><br>  通过list设置为用户的提示信息，datalist标签指定快捷输入数据<br>6. 引用</p>
<ul>
<li>blockquote：<br>&lt;blockquote&gt; 标签定义摘自另一个源的块引用。<br>浏览器通常会对 &lt;blockquote&gt; 元素进行缩进。<br>属性：cite →指定引用的来源</li>
<li>cite:<br> &lt;cite&gt; 标签通常表示它所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。按照惯例，引用的文本将以斜体显示。</li>
<li>q：<br>&lt;q&gt;标签用于定义短引文（行内引文）。浏览器将自动为短引文添加引号。</li>
</ul>
<p>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116130237.png"><br>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116130434.png"></p>
<ol start="7">
<li><p>代码标签<br>&lt;code&gt;&lt;/code&gt;<br>引用多行代码时，使用&lt;pre&gt;包裹&lt;code&gt;<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116130638.png"></p>
</li>
<li><p>表示强调<br>&lt;strong&gt;&lt;strong&gt; → 加粗<br>&lt;em&gt;&lt;em&gt;</p>
</li>
<li><p>页面内容划分<br> <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116131124.png"></p>
</li>
</ol>
<h3 id="1-3-HTML-语义化"><a href="#1-3-HTML-语义化" class="headerlink" title="1.3 HTML 语义化"></a>1.3 HTML 语义化</h3><p>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码，同时让浏览器的爬虫和机器能很好地解析。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116131858.png"></p>
<p>Q：为什么要语义化？</p>
<ul>
<li>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构：<span style="background:yellow;"><b>为了裸奔时好看</b></span>；</li>
<li><span style="background:yellow;"><b>用户体验</b></span>：例如title、alt用于解释名词或解释图片信息、label标签的活用；</li>
<li><span style="background:yellow;"><b>有利于SEO</b></span>：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li>
<li>方便其他设备<span style="background:yellow;"><b>解析</b></span>（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li>
<li><span style="background:yellow;"><b>便于团队开发和维护</b></span>，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li>
</ul>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Git教程</title>
    <url>/2021/11/22/Git%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV15J411973T?share_source=copy_web">尚硅谷Git教程全套完整版</a></p>
<h2 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1.版本控制"></a>1.版本控制</h2><p>使用版本控制可以将某个文件回溯到之前的状态，设置将某个项目回退到过去某个时间点的状态。</p>
<h4 id="集中化的版本控制系统-SVN）"><a href="#集中化的版本控制系统-SVN）" class="headerlink" title="集中化的版本控制系统 (SVN）"></a>集中化的版本控制系统 (SVN）</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211122145302.png"><br>优点：代码存放在单一的服务器上，便于项目管理<br>缺点：</p>
<ol>
<li><p>中央服务器的单点故障<br>如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p>
<blockquote>
<p><span style="color:blue;">(并不是说服务器故障了就没有办法写代码了,只是在服务器故障的情况下,编写的代码是没有办法得到保障的.试想 svn 中央服务器挂机一天.你还拼命写了一天代码,其中 12 点之前的代码都是高质量可靠的,而且有很多闪光点.而 12 点之后的代码由于你想尝试一个比较大胆的想法,将代码改的面目全非了.这样下来你 12 点之前做的工作也都白费了 有记录的版本只能是 svn 服务器挂掉时保存的版本!)</span></p>
</blockquote>
</li>
<li><p>中央服务器磁盘发生故障</p>
<blockquote>
<p>要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而客户端偶然提取出来的保存在本地的某些快照数据就成了恢复数据的希望。但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
</blockquote>
</li>
</ol>
<p>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211122151436.png"></p>
<p>SVN每次存的都是版本之间的差异代码，需要硬盘空间相对小一些，但是回滚的速度会很慢<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211220100343.png"></p>
<h4 id="分布式的版本控制系统-（Git）"><a href="#分布式的版本控制系统-（Git）" class="headerlink" title="分布式的版本控制系统 （Git）"></a>分布式的版本控制系统 （Git）</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211122152040.png"><br><em>客户端并不只是提取最新版本的文件快照，而是把代码仓库完整地镜像下来</em></p>
<p>Git每次存储的都是项目的完整快照，需要的硬盘空间会相对大一些（Git团队对代码做了极致的压缩，最终需要的实际空间比SVN多不了多少），Git的回滚速度极快<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211122154932.png"></p>
<p>优点：完全的分布式<br>缺点：学习成本高</p>
<h2 id="2-Git底层概念"><a href="#2-Git底层概念" class="headerlink" title="2.Git底层概念"></a>2.Git底层概念</h2><h4 id="2-1-基础Linux命令"><a href="#2-1-基础Linux命令" class="headerlink" title="2.1 基础Linux命令"></a>2.1 基础Linux命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clear <span class="comment"># 清除屏幕</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;test content&#x27;</span> <span class="comment">#往控制台输出信息 echo &#x27;test content&#x27; &gt; test.txt</span></span><br><span class="line">ll <span class="comment">#将当前目录下的 子文件&amp;子目录平铺在控制台</span></span><br><span class="line">find 目录名 <span class="comment">#将对应目录下的子孙文件&amp;子孙目录平铺在控制台</span></span><br><span class="line">find 目录名 -<span class="built_in">type</span> f <span class="comment"># 将对应目录下的文件平铺在控制台</span></span><br><span class="line"><span class="built_in">rm</span> 文件名 <span class="comment">#删除文件</span></span><br><span class="line"><span class="built_in">mv</span> 源文件 重命名文件 <span class="comment">#重命名</span></span><br><span class="line"><span class="built_in">cat</span> 文件的url <span class="comment">#查看对应文件的内容</span></span><br><span class="line">vim 文件的url（在英文模式下）</span><br><span class="line">  按i进入插入模式 进行文件的编辑</span><br><span class="line">  按esc键 + 按:键 进入命令的执行</span><br><span class="line">    q! <span class="comment">#强制退出（不保存）</span></span><br><span class="line">    wq <span class="comment">#保存退出</span></span><br><span class="line">    <span class="built_in">set</span> nu <span class="comment">#设置行号</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-初始化新仓库与-git目录"><a href="#2-2-初始化新仓库与-git目录" class="headerlink" title="2.2 初始化新仓库与.git目录"></a>2.2 初始化新仓库与.git目录</h4><p>首次使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git版本信息</span></span><br><span class="line">git --version</span><br><span class="line"><span class="comment"># git配置</span></span><br><span class="line">git config --global user.name <span class="string">&quot;我的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;我的邮箱&quot;</span></span><br><span class="line"><span class="comment"># 查看当前配置</span></span><br><span class="line">git config --list</span><br><span class="line"><span class="comment"># 修改时使用相同的命令进行覆盖</span></span><br><span class="line"><span class="comment"># git config --global user.name &quot;我的用户名&quot;</span></span><br><span class="line"><span class="comment"># git config --global user.email &quot;我的邮箱&quot;</span></span><br></pre></td></tr></table></figure>
<p>初始化新仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">1. 初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</span><br><span class="line">2. 要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：git init</span><br></pre></td></tr></table></figure>
<p>.git目录<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211220142540.png"></p>
<h4 id="2-3-Git区域与对象"><a href="#2-3-Git区域与对象" class="headerlink" title="2.3 Git区域与对象"></a>2.3 Git区域与对象</h4><h5 id="2-3-1-区域"><a href="#2-3-1-区域" class="headerlink" title="2.3.1 区域"></a>2.3.1 区域</h5><ol>
<li>工作区（Working Directory）<br>本地代码，日常书写代码目录，肉眼可见区域（沙箱环境：git不会对其进行管理）</li>
<li>暂存区（Stage 或 Index）<br>数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。</li>
<li>版本库（commit History）<br>git commit 后给你生成版本的地方,注意push是提交到远程仓库而不是版本库,请勿混淆</li>
</ol>
<h6 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h6><blockquote>
<p>每个项目都有一个git目录（.git），它是用来保存元数据和对象数据库的地方，每次克隆镜像仓库时，实际上就是拷贝这个目录里的数据。<br>①、在工作目录中修改某些文件<br>   从项目中取出某个版本的所有文件和目录,用以开始后续工作的叫做工作目录,这些文件实际上都是从Git目录中的压缩对象数据库中提取出来的,接下去就可以在工作目录中对这些文件进行编辑<br>②、保存到暂存区域,对暂存区做快照<br>   暂存区域只不过是个简单的文件,一般都放在Git目录中,有时候人们会把这个区域的文件叫做索引文件,不过标准说法还是叫暂存区域<br>③、提交更新<br>   将保存区在暂存区域的文件快照永久转储到本地数据库(Git目录)中</p>
</blockquote>
<p>   可以从文件所处的位置来判断状态</p>
<h5 id="2-3-2对象（Git底层概念）"><a href="#2-3-2对象（Git底层概念）" class="headerlink" title="2.3.2对象（Git底层概念）"></a>2.3.2对象（Git底层概念）</h5><ol>
<li><p>Git对象</p>
<p>key : value 组成的键值对,key是value对应的hash，键值对在git内部都是一个blob类型<br>git对象存储文件内容<br>git对象代表文件的一次次版本</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">》了解即可《</span><br><span class="line">① 直接写入git对象方法与读取(存入<span class="string">&quot;.git/objects&quot;</span>)</span><br><span class="line"><span class="comment">#将打印内容写入对象(git数据库)并且返回其相应哈希值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;写入的对象内容&quot;</span> | git hash-object -w --stdin </span><br><span class="line"></span><br><span class="line"><span class="comment">#读取内容并不能直接cat读取,因为git存入时已经加密,需要如下代码 -p:内容  -t:类型</span></span><br><span class="line">git cat-file -p 存入对象的哈希值(此值可以由上一步得到) </span><br><span class="line"></span><br><span class="line"><span class="comment">#将文件写入git对象,即我们常见的版本控制中出现的</span></span><br><span class="line">git hash-object -w ./test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Git存储的数据  返回其文件夹内的所有哈希文件</span></span><br><span class="line">find .git/objects -<span class="built_in">type</span> f </span><br></pre></td></tr></table></figure></li>
<li><p>树对象<br>树对象代表项目的一次次快照</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">》了解即可《</span><br><span class="line">构建树对象</span><br><span class="line">我们可以通过 update-index , write-tree , read-tree 等命令来构建树对象并且塞到暂存区</span><br><span class="line"></span><br><span class="line">① 利用 update-index 命令 创建暂存区</span><br><span class="line">利用 update-index 命令 为test.txt文件的首个版本创建一个暂存区,并通过write-tree命令生成树对象</span><br><span class="line"></span><br><span class="line"><span class="comment">#1生成一个树对象</span></span><br><span class="line">git update-index --add --cacheinfo 100664(文件状态码:普通文件) 哈希值 对应文件名</span><br><span class="line"><span class="comment">#生成快照(树对象)</span></span><br><span class="line">git write-tree</span><br><span class="line"><span class="comment">#2 将第一个树对象加入第二个树对象,使其成为新的树对象</span></span><br><span class="line">git read-tree -prefix=bak 哈希值(树对象的)  </span><br><span class="line">git write-tree</span><br><span class="line">② 查看暂存区当前样子</span><br><span class="line">git ls-files -s</span><br></pre></td></tr></table></figure></li>
<li><p>提交对象 – 链式<br>我们可以通过调用commit-tree命令创建一个提交对象,为此需要指定一个树对象的SHA-1值,为此需要指定一个树对象的SHA-1值 , 以及该提交的父提交对象(如果有的话,第一次将暂存区做快照就没有父对象)</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220105231626.png"></p>
<h4 id="2-4小结"><a href="#2-4小结" class="headerlink" title="2.4小结"></a>2.4小结</h4><ol>
<li>底层命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git对象：</span><br><span class="line">   git hash-object -w fileUrl //生成一个key（hash值）:value（压缩后的文件内容）键值对存到.git/objects</span><br><span class="line">tree对象</span><br><span class="line">   git update-index --add --cacheinfo 100644 hash test.txt //往暂存区添加一条记录（让git对象 对应上 文件名）存到.git/index</span><br><span class="line">   git write-tree //生成树对象存到.git/objects</span><br><span class="line">commit对象</span><br><span class="line">   echo &#x27;first commit&#x27; | git commit-tree treehash //生成一个提交对象存到.git/objects</span><br><span class="line">对以上对象的查询</span><br><span class="line">   git cat-file -p hash  //拿对应对象的内容</span><br><span class="line">   git cat-file -t hash  //拿对应对象的类型</span><br></pre></td></tr></table></figure></li>
<li>查看暂存区（需要记忆）<br><code>git  ls-files  -s</code></li>
</ol>
<h2 id="3-Git高层命令"><a href="#3-Git高层命令" class="headerlink" title="3.Git高层命令"></a>3.Git高层命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init                     初始化仓库</span><br><span class="line">git add ./                   将修改添加到暂存区</span><br><span class="line">git commit -a                Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</span><br><span class="line">git commit -m  注释          将暂存区提交到版本库</span><br><span class="line">git status                   查看文件的状态</span><br><span class="line">git diff                     查看哪些修改还没有暂存</span><br><span class="line">git diff --staged            查看哪些修改以及被暂存，还没有提交</span><br><span class="line">git log                      查看操作日志</span><br><span class="line">git rm 文件名                删除工作目录中对应的文件，再将修改添加到暂存区</span><br><span class="line">git mv 原文件名  新文件名     将工作目录中文件进行重命名，再将修改添加到暂存区</span><br><span class="line">---</span><br><span class="line">git branch                   显示分支列表</span><br><span class="line">git branch 分支名            创建分支</span><br><span class="line">git checkout 分支名          切换分支</span><br><span class="line">git branch -d 分支名         删除分支（**不能在本分支上删除该分支，需切出去）</span><br><span class="line">git branch -v                查看每一个分支的最后一次提交</span><br><span class="line">git branch -D 分支名         强制删除分支</span><br><span class="line">git branch name commitHash   新建一个分支并且使分支指向对应的提交对象，commitHash通过下面的命令查找</span><br><span class="line">git log --oneline --decorate --graph --all     查看项目的分叉历史</span><br></pre></td></tr></table></figure>
<h5 id="3-1-git操作最基本流程"><a href="#3-1-git操作最基本流程" class="headerlink" title="3.1 git操作最基本流程"></a>3.1 git操作最基本流程</h5><p>创建工作目录 ——&gt;  对工作目录进行修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add ./</span><br><span class="line">   + 对应底层命令 ：</span><br><span class="line">   git hash-object -w 文件名（修改了多少个工作目录中的文件，此命令就要被执行多少次）</span><br><span class="line">   git update-index...</span><br><span class="line">git commit -m <span class="string">&quot;注释内容&quot;</span></span><br><span class="line">   + 对应底层命令 ： </span><br><span class="line">   git write-tree **</span><br><span class="line">   git commit-tree **</span><br></pre></td></tr></table></figure>
<p>检查当前文件的状态<br>命令： <code>git  status</code><br>作用：确定文件当前处于什么状态<br>工作目录下面的所有文件都不外乎这两种状态：<span style="color:red;">已跟踪</span> 或 <span style="color:red;">未跟踪</span><br>已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是<span style="color:red;">已提交</span>，<span style="color:red;">已修改</span>或者<span style="color:red;">已暂存</span></p>
<p>查看操作日志<br>命令：<code>git log</code><br>作用：在提交了若干更新，又或者克隆了某个项目之后，想回顾下提交历史。<br>其他：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 规整查看信息的格式</span><br><span class="line">git log --pretty=oneline</span><br><span class="line">git log --oneline</span><br></pre></td></tr></table></figure>

<h5 id="3-2-git的分支"><a href="#3-2-git的分支" class="headerlink" title="3.2 git的分支"></a>3.2 git的分支</h5><p>创建分支<br>命令：<code>git branch</code><br>作用：为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支：<code>git branch testing</code>。这会在当前所在的提交对象上创建一个指针</p>
<p>Git 的分支本质上是一个提交对象，HEAD是一个指针，默认指向master分支，切换分支时就是让HEAD指向不同的分支</p>
<p>分支切换会改变你工作目录中的文件。在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支</p>
<ul>
<li>git切换分支会改变三个地方：HEAD、暂存区、工作目录</li>
<li>最佳实践：每次切换分支前，当前分支一定要处于已提交状态</li>
<li>切换分支时，如果当前分支上有未暂存的修改 或者 有未提交的暂存（第一次），分支可以切换成功，但是这种操作可能会污染其他分支</li>
</ul>
<h5 id="3-3小结"><a href="#3-3小结" class="headerlink" title="3.3小结"></a>3.3小结</h5><p>已下命令需要记忆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">git --version</span><br><span class="line"></span><br><span class="line"># 初始化配置</span><br><span class="line">git config --global user.name &quot;qw&quot;</span><br><span class="line">git config --global user.email qw@qq.com</span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"># 初始化仓库</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"># C（新增）-- 在工作目录中新增文件</span><br><span class="line">git status</span><br><span class="line">git add ./</span><br><span class="line">git commit -m &quot;msg&quot;</span><br><span class="line"></span><br><span class="line"># U（修改）-- 在工作目录中修改文件</span><br><span class="line">git status</span><br><span class="line">git add ./</span><br><span class="line">git commit -m &quot;msg&quot;</span><br><span class="line"></span><br><span class="line"># D（删除 &amp; 重命名）--在工作目录中删除文件</span><br><span class="line">git rm 要删除的文件</span><br><span class="line">git mv 老文件  新文件</span><br><span class="line">git status</span><br><span class="line">git commit -m &quot;msg&quot;</span><br><span class="line"></span><br><span class="line"># R（查询）</span><br><span class="line">git status // 查看工作目录中的文件状态（已跟踪【已提交，已暂存，已修改】 未跟踪）</span><br><span class="line">fir diff // 查看未暂存的修改</span><br><span class="line">git diff --cache // 查看未提交的暂存</span><br><span class="line">git log --oneline // 查看提交记录</span><br><span class="line"></span><br><span class="line"># 分支</span><br><span class="line">git log --oneline --decorate --graph --all // 查看整个项目的分支图</span><br><span class="line">git branch // 查看分支列表</span><br><span class="line">git branch -v // 查看分支指向的最新的提交</span><br><span class="line">git branch name // 在当前提交对象上创建新的分支</span><br><span class="line">git branch name commithash // 在指定的提交对象上创建新的分支</span><br><span class="line">git checkout name //切换分支</span><br><span class="line">git branch -d name //删除空的分支或删除已经被合并的分支</span><br><span class="line">git branch -D name // 强制删除分支</span><br></pre></td></tr></table></figure>

<h2 id="4-Git存储"><a href="#4-Git存储" class="headerlink" title="4.Git存储"></a>4.Git存储</h2><p>有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是 <code>git stash</code> 命令。</p>
<figure class="highlight plaintext"><figcaption><span>stash ```命令会将未完成的修改保存到一个栈上，而你</span></figcaption><table><tr><td class="code"><pre><span class="line">可以在任何时候重新应用这些改动(```git stash apply```)</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">git stash list    // 查看存储</span><br><span class="line">git stash apply stash@&#123;2&#125;   // 如果不指定一个储藏，Git 认为指定的是最近的储藏</span><br><span class="line">git stash pop     // 来应用储藏然后立即从栈上扔掉它,常使用</span><br><span class="line">git stash drop    // 加上将要移除的储藏的名字来移除它</span><br></pre></td></tr></table></figure>

<h2 id="5-Git后悔药"><a href="#5-Git后悔药" class="headerlink" title="5.Git后悔药"></a>5.Git后悔药</h2><p>三种情景：</p>
<ol>
<li>工作区：如何撤销自己在工作目录中的修改<br><code>git checkout -- filename</code></li>
<li>暂存区：如何撤销自己的暂存<br><code>git reset HEAD filename</code></li>
<li>版本库：如何撤销自己的提交【注释写错】<br><code> git commit --amend  // 重新提交注释信息</code></li>
</ol>
<h5 id="5-1-reset-三部曲-原理"><a href="#5-1-reset-三部曲-原理" class="headerlink" title="5.1 reset 三部曲(原理)"></a>5.1 reset 三部曲(原理)</h5><p>&star; 1.移动 HEAD<br>reset 做的第一件事是移动 HEAD 的指向。<br><code>git reset --soft HEAD~</code></p>
<ul>
<li>只动HEAD（带着分支一起移动）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220110230239.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220110230304.png"></p>
<p>看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 <code>git commit </code>命令。 当你在运行 <code>git commit </code>时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。<br>当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 <code>git commit</code> 来完成 <code>git commit --amend </code>所要做的事情了。</p>
<p>&star;  2.更新暂存区（索引）<br><code>git reset --mixed HEAD~</code></p>
<ul>
<li>动HEAD（带着分支一起移动）</li>
<li>动暂存区</li>
</ul>
<p>&star; 3.更新工作目录<br><code>git reset --hard HEAD~</code></p>
<ul>
<li>动HEAD（带着分支一起移动）</li>
<li>动暂存区</li>
<li>动工作目录<br><span style="color:red;">必须注意，–hard 标记是 reset 命令唯一的危险用法，它也是 Git 会 真正地销毁数据的仅有的几个操作之一。 </span></li>
</ul>
<p>git checkout commithash 与 git reset –hard commithash区别：</p>
<ol>
<li>checkout 只动HEAD、–hard动HEAD而且带着分支一起走</li>
<li>checkout对工作目录是安全的、–hard是强制覆盖工作目录</li>
</ol>
<p>路径reset</p>
<p>前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220110233703.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220110233729.png"></p>
<h2 id="6-数据恢复"><a href="#6-数据恢复" class="headerlink" title="6.数据恢复"></a>6.数据恢复</h2><p>在你使用 Git 的时候，你可能会意外丢失一次提交。 通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。 如果这些事情已经发生，该如何找回你的提交呢？<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220111103150.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220111103238.png"><br>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。<br>当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一<br>次你提交或改变分支，引用日志都会被更新<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220111103454.png"><br>git reflog 并不能显示足够多的信息。为了使显示的信息更加有用，<br>我们可以执行 git log -g，这个命令会以标准日志的格式输出引用日志</p>
<p>&star; 恢复</p>
<p>看起来下面的那个就是你丢失的提交，你可以通过创建一个新的分支指向这个提交来恢复它。 例如，你可以创建一个名为 recover-branch 的分支指向这个提交（ab1afef）</p>
<p><code>git branch recover-branch ab1afef</code></p>
<p>现在有一个名为 recover-branch 的分支是你的 master 分支曾经指向的地方，再一次使得前两次提交可到达了。</p>
<h2 id="7-打tag"><a href="#7-打tag" class="headerlink" title="7.打tag"></a>7.打tag</h2><p>Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git tag // 列出标签</span><br><span class="line">git show tagname // 查看特定标签</span><br><span class="line">git tag v1.0 // 创建标签1</span><br><span class="line">git tag v1.0 commithash // 创建标签2</span><br><span class="line">git tag -d tagname // 删除标签</span><br><span class="line">git checkout tagname // 检出标签（会造成头部分离，需要再创建一个分支避免）</span><br><span class="line">   + git checkout -b branchname</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220111231847.jpg"><br><a href="https://github.com/qw-null/BlogImages/blob/master/git%E5%A4%8D%E4%B9%A0.pdf">文件地址</a></p>
<h2 id="8-团队协作"><a href="#8-团队协作" class="headerlink" title="8.团队协作"></a>8.团队协作</h2><ol>
<li>项目经理初始化远程仓库<br>一定要初始化一个空的仓库，在GitHub上操作</li>
<li>项目经理创建本地仓库<br><code>git remote 别名 仓库地址（可选）</code><br><code>git init</code><br>将源码复制进来（项目内容）<br>修改用户名、邮箱<br><code>git add .</code><br><code>git commit</code></li>
<li>项目经理推送本地仓库到远程仓库<br>清理windows凭据<br><code>git push 别名/项目地址 分支名</code>（输入项目经理的github用户名和密码；推送完之后会附带生成远程跟踪分支）</li>
<li>项目邀请成员 &amp; 成员接受邀请<br>在GitHub上操作</li>
<li>成员克隆远程仓库<br><code>git clone 仓库地址</code>（在本地生成.git文件，默认为远程仓库配了别名 origin）<br>只有在克隆的时候，本地分支master和远程分支 别名/master 是有同步关系的</li>
<li>成员贡献代码<br>修改源码文件<br><code>git add</code><br><code>git commit</code><br><code>git push 别名 分支</code>（输入成员的github用户名和密码；推送完之后会附带生成远程跟踪分支）</li>
<li>项目经理更新修改<br><code>git fetch 别名</code>（将修改同步到远程跟踪分支上）<br><code>git merge 远程跟踪分支</code></li>
</ol>
<h5 id="8-1正常的数据推送和拉取步骤"><a href="#8-1正常的数据推送和拉取步骤" class="headerlink" title="8.1正常的数据推送和拉取步骤"></a>8.1正常的数据推送和拉取步骤</h5><ol>
<li>确保本地分支已经跟踪了远程跟踪分支</li>
<li>拉取数据：<code>git pull</code></li>
<li>上传数据：<code>git push</code></li>
</ol>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】删除有序数组中的重复项</title>
    <url>/2021/11/18/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>说明：</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line">int len = <span class="title function_">removeDuplicates</span>(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="title function_">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>数组中的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。<br><b>双指针法：</b>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211118113717.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211118113752.png"><br>说明：当 nums[fast] === nums[slow] 时，代码中无需进行处理，只需要考虑 nums[fast] != nums[slow] 的情况。<br>当 nums[fast] != nums[slow] 时，slow前进 –&gt; nums[slow] 需要使用 nums[fast] 覆盖 –&gt; fast前进</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化快、慢指针</span></span><br><span class="line">    <span class="keyword">let</span> [fast, slow] = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (fast = <span class="number">0</span>; fast &lt; nums.<span class="property">length</span>; ++fast)&#123;</span><br><span class="line">        <span class="comment">// 处理nums[fast] != nums[slow]的情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line">    <span class="comment">// slow表示的是数组元素下标，长度需要将其+1</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建vue项目</title>
    <url>/2021/10/25/%E6%90%AD%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1-搭建项目"><a href="#1-搭建项目" class="headerlink" title="1.搭建项目"></a>1.搭建项目</h2><h3 id="1-1使用Vue-UI搭建"><a href="#1-1使用Vue-UI搭建" class="headerlink" title="1.1使用Vue UI搭建"></a>1.1使用Vue UI搭建</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211025155720.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211025155936.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211025160332.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211025160951.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211025161257.png"></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>前端接口传值方式(body参数和query参数)</title>
    <url>/2021/10/13/%E5%89%8D%E7%AB%AF%E6%8E%A5%E5%8F%A3%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>前端通过接口向后端服务器请求数据，最常用到是Get请求和Post请求</p>
<ul>
<li>get请求只能传query参数，query参数都是拼在请求地址上的<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getMemberInfo</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;orgmanage/org/findMember/&#x27;</span> + id,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="comment">/* 获取用户信息 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params">token</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/user/info&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123; token &#125;	<span class="comment">// params就是query参数</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>post可以传body和query两种形式的参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/user/login&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data,	<span class="comment">// data就是body参数</span></span><br><span class="line">    <span class="comment">//请求头部设置</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript练习题【牛客网】（持续使用中）</title>
    <url>/2021/10/09/JavaScript%E7%BB%83%E4%B9%A0%E9%A2%98%E3%80%90%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%91/</url>
    <content><![CDATA[<h4 id="1-JavaScript定义var-a-”30”-var-b-8-则执行-a-b-会得到（）"><a href="#1-JavaScript定义var-a-”30”-var-b-8-则执行-a-b-会得到（）" class="headerlink" title="1.JavaScript定义var a=”30”,var b=8,则执行 a%b 会得到（）"></a>1.JavaScript定义var a=”30”,var b=8,则执行 a%b 会得到（）</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211009092934.png"></p>
<p>【解析】<br>B<br>运算中‘+’号，数字隐式转换成字符串。其余的运算符号是字符串隐式转换成数字。</p>
<h4 id="2-下面这段JS程序的执行结果是："><a href="#2-下面这段JS程序的执行结果是：" class="headerlink" title="2.下面这段JS程序的执行结果是："></a>2.下面这段JS程序的执行结果是：</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211009093457.png"><br>A. [1,2,3,4]<br>B. [1,2,3]<br>C. [4]<br>D. [2,3,4]</p>
<p>【解析】<br>B<br>JS中slice()方法是选取数组的的一部分，并返回一个新数组。</p>
<h4 id="3-执行以下程序段后，x的值是（-）。"><a href="#3-执行以下程序段后，x的值是（-）。" class="headerlink" title="3.执行以下程序段后，x的值是（ ）。"></a>3.执行以下程序段后，x的值是（ ）。</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211009093823.png"><br>A. 1<br>B. 2<br>C. 3<br>D. 4</p>
<p>【解析】<br>C<br>switch中没有break</p>
<h4 id="4-以下代码执行后，-num-的值是？"><a href="#4-以下代码执行后，-num-的值是？" class="headerlink" title="4.以下代码执行后， num 的值是？"></a>4.以下代码执行后， num 的值是？</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211009094034.png"><br>A. -1<br>B. 3<br>C. 1<br>D. 2</p>
<p>【解析】<br>A</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.匿名函数，需要通过变量引用指向函数的运行结果。</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="keyword">function</span>(<span class="params">x,y</span>)&#123;      <span class="comment">//赋值式函数</span></span><br><span class="line"><span class="keyword">return</span> x-y;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.有名函数，可以单独定义。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x,y</span>)&#123;         <span class="comment">//声明式函数</span></span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际调用</span></span><br><span class="line"><span class="keyword">var</span> num=<span class="title function_">foo</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//调用赋值式函数  return x-y  为  -1</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211009094556.png"><br>知识点：<a href="https://www.cnblogs.com/lvonve/p/9871226.html">js变量提升与函数提升的详细过程</a></p>
]]></content>
      <categories>
        <category>JS学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/09/24/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210924102353.png"></p>
<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>链表（Linked List）是一种物理存储单元上<b style="color:red;">非连续、非顺序</b>的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的，由一系列节点组成。<br>每个节点包含两部分：1.存储数据元素的数据域；2.存储下一个节点地址的指针域。3.最后一个节点的指针域指向null。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210924102803.png"></p>
<ul>
<li>data 表示节点存放的数据</li>
<li>next 表示下一个节点指向的内存空间</li>
</ul>
<h4 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h4><p>代码表示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">LinkedNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// val表示该节点上存储的值</span></span><br><span class="line"><span class="comment">// next表示该节点的下一个节点</span></span><br><span class="line"><span class="comment">// 一般的单向链表的尾节点指向null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><p>一般链表的第一个节点为hed，用来表示这是一个链表存储，在创建链表的时候将链表的第一个节点默认设置为head。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建链表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">LinkedList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="keyword">new</span> <span class="title class_">LinkedNode</span>(<span class="string">&#x27;head&#x27;</span>);     <span class="comment">//头节点</span></span><br><span class="line">    <span class="comment">// 若链表节点为数值，则创建时为this.head = new LinkedNode(521);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表长度"><a href="#链表长度" class="headerlink" title="链表长度"></a>链表长度</h4><p>为了方便链表操作，可以记录链表长度，在操作链表时要对长度进行相应的加减。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表长度</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">LinkedList</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="keyword">new</span> <span class="title class_">LinkedNode</span>(<span class="string">&#x27;head&#x27;</span>);   <span class="comment">// 头节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = <span class="number">0</span>; <span class="comment">// 链表的默认长度为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h4><p>根据next指针遍历下去，直到为null。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">let</span> current = head;</span><br><span class="line"><span class="keyword">while</span>(current)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(current.<span class="property">val</span>)</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>向链表中间插入一个元素，可以如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210924121621.png"><br>插入节点的步骤：</p>
<ul>
<li>存储插入位置的前一个节点</li>
<li>存储插入位置的后一个节点</li>
<li>将插入位置的前一个节点的 next 指向插入节点</li>
<li>将插入节点的 next 指向前面存储的 next 节点<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> current = head;</span><br><span class="line"><span class="keyword">while</span>(current &lt; position&gt;)&#123;</span><br><span class="line">    previous = current;</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line">previous.<span class="property">next</span> = node;</span><br><span class="line">node.<span class="property">next</span> = current;</span><br></pre></td></tr></table></figure>
如果在头节点进行插入操作的时候，会实现previousNode节点为undefined，不适合上述方式。解放方式可以是在头节点前面添加一个虚拟头节点，保证插入行为一致。</li>
</ul>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>链表任意位置删除节点，如下图操作：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210924144130.png"><br>删除节点的步骤：</p>
<ul>
<li>获取删除节点的前一个结点</li>
<li>获取删除节点的后一个结点</li>
<li>将前一个结点的next指向后一个结点</li>
<li>将删除节点的next指向为null<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(current != node)&#123;</span><br><span class="line">    previous = current;</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">    nextNode = current.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br><span class="line">previous.<span class="property">next</span> = nextNode;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等。<br>当缓存空间被占满时，我们可能会使用LRU最近最常使用策略去清除，实现LRU算法的是数据结构是链表，思路如下：</p>
<p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表</p>
<ul>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表头部</li>
<li>如果此数据没在缓存链表中</li>
<li><ul>
<li>如果此时缓存未满，可直接在链表头部插入新节点存储此数据</li>
</ul>
</li>
<li><ul>
<li>如果此时缓存已满，则删除链表尾部节点，再在链表头部插入新节点</li>
</ul>
</li>
</ul>
<p>由于链表插入删除效率极高，达到O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据的情况的时候，都可以使用链表</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS奇淫技巧</title>
    <url>/2021/09/22/CSS%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>CSS奇淫技巧</p>
<h3 id="1-提示框"><a href="#1-提示框" class="headerlink" title="1.提示框"></a>1.提示框</h3><p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210922164322.gif"><br>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bruce flex-ct-y&quot;</span> <span class="attr">data-title</span>=<span class="string">&quot;使用attr()抓取节点属性&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;hover-tips btn-1&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">data-msg</span>=<span class="string">&quot;Hello World&quot;</span>&gt;</span>提示框<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hover-tips</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="number">#66f</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">	&amp;<span class="selector-class">.btn-1</span> &#123;</span><br><span class="line">		&amp;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">			<span class="attribute">position</span>: absolute;</span><br><span class="line">			<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">			<span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">			<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">			<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">			<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">			<span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">#000</span>, <span class="number">0.5</span>);</span><br><span class="line">			<span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">			<span class="attribute">text-align</span>: center;</span><br><span class="line">			<span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">			<span class="attribute">content</span>: <span class="built_in">attr</span>(data-msg);</span><br><span class="line">			<span class="attribute">transition</span>: all <span class="number">300ms</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		&amp;<span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">			<span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">100%</span> + <span class="number">20px</span>);</span><br><span class="line">			<span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在按钮上触发悬浮状态:hover时，通过attr()获取节点的data-msg并赋值到::after的content上</p>
<h3 id="2-绘制三角形"><a href="#2-绘制三角形" class="headerlink" title="2.绘制三角形"></a>2.绘制三角形</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;triangle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">50px</span> solid red;</span><br><span class="line">  <span class="attribute">border-top</span>:<span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220105102020.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">50px</span> solid red;</span><br><span class="line">  <span class="attribute">border-top</span>:<span class="number">50px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220105102125.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">50px</span> solid red;</span><br><span class="line">  <span class="attribute">border-top</span>:<span class="number">50px</span> solid green;</span><br><span class="line">  <span class="attribute">border-right</span>:<span class="number">50px</span> solid blue;</span><br><span class="line">  <span class="attribute">border-bottom</span>:<span class="number">50px</span> solid yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220105102312.png"></p>
<h3 id="3-实现点击div添加选中样式"><a href="#3-实现点击div添加选中样式" class="headerlink" title="3.实现点击div添加选中样式"></a>3.实现点击div添加选中样式</h3><p><a href="https://qw-null.github.io/2022/01/18/CSS%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BBdiv%E6%B7%BB%E5%8A%A0%E9%80%89%E4%B8%AD%E6%A0%B7%E5%BC%8F/#%E6%83%85%E6%99%AF">实现点击div添加选中样式</a></p>
]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>13个JavaScript数组技巧</title>
    <url>/2021/09/22/JavaScript%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>数组是JS最常见的概念之一，它为我们提供了处理存储数据的许多可能性。在刷题过程中常会用的一些技巧，对数组中的元素进行操作。</p>
<h3 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1.数组去重"></a>1.数组去重</h3><p>两种方法：</p>
<ul>
<li>使用.from()方法</li>
<li>使用拓展运算符…<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  fruits = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;watermelon&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line"><span class="keyword">let</span> uniqueFruits = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(fruits))</span><br><span class="line"><span class="comment">// returns [“banana”, “apple”, “orange”, “watermelon”, “grape”]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="keyword">let</span> uniqueFruits2 = [...<span class="keyword">new</span> <span class="title class_">Set</span>(fruits)]</span><br><span class="line"><span class="comment">// returns [“banana”, “apple”, “orange”, “watermelon”, “grape”]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-替换数组中特定的值"><a href="#2-替换数组中特定的值" class="headerlink" title="2.替换数组中特定的值"></a>2.替换数组中特定的值</h3><p>使用.splice(start , value to remove , value to add),其中三个参数分别指明从哪里开始、要更改多少个值、更改时使用的替换值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  fruits = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;watermelon&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line">fruits.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&quot;potato&quot;</span>,<span class="string">&quot;tomato&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits) </span><br><span class="line"><span class="comment">//returns  [&quot;potato&quot;, &quot;tomato&quot;, &quot;orange&quot;, &quot;watermelon&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;grape&quot;, &quot;apple&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="3-不使用-map-映射数组"><a href="#3-不使用-map-映射数组" class="headerlink" title="3.不使用.map()映射数组"></a>3.不使用.map()映射数组</h3><p>也许每个人都知道数组的.map()方法，但是可以使用另一种方案来获得相似的效果，并且代码非常简洁。这里我们可用.from()方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> friends = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Mark&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Maria&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Monica&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Martha&#x27;</span>, <span class="attr">age</span>: <span class="number">19</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> friendsNames = <span class="title class_">Array</span>.<span class="title function_">from</span>(friends, <span class="function">(<span class="params">&#123;name&#125;</span>) =&gt;</span> name)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(friendsNames) </span><br><span class="line"><span class="comment">//returns [&quot;John&quot;, &quot;Peter&quot;, &quot;Mark&quot;, &quot;Maria&quot;, &quot;Monica&quot;, &quot;Martha&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="补充知识：使用-map-映射数组"><a href="#补充知识：使用-map-映射数组" class="headerlink" title="补充知识：使用.map()映射数组"></a>补充知识：使用.map()映射数组</h4><p>一般写法：</p>
<ul>
<li>创建Map</li>
<li>将需要查询的数据，按照 “key - value” 的形式存储到map对象中，其中key为关键字，value为查询的信息</li>
<li>查询时根据key查找对应的value<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="comment">// return [2,4,6]</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210922095015.png"></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉花括号的写法（只有一个return的时候，&#123;&#125;可以省略）</span></span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个小例子：判断成绩是否及格</span></span><br><span class="line"><span class="keyword">let</span> scroe = [<span class="number">12</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>, <span class="number">33</span>, <span class="number">100</span>, <span class="number">59</span>]</span><br><span class="line"><span class="keyword">let</span> result = scroe.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;= <span class="number">60</span> ? <span class="string">&#x27;及格&#x27;</span> : <span class="string">&#x27;不及格&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210922095712.png"></p>
<h3 id="4-清空数组"><a href="#4-清空数组" class="headerlink" title="4.清空数组"></a>4.清空数组</h3><p>清空数组仅需要将数组的长度设为0即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;watermelon&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;apple&quot;</span>];</span><br><span class="line"></span><br><span class="line">fruits.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits); <span class="comment">// returns []</span></span><br></pre></td></tr></table></figure>

<h3 id="5-数组转对象"><a href="#5-数组转对象" class="headerlink" title="5.数组转对象"></a>5.数组转对象</h3><p>数组转换为对象的最快方法是使用扩展运算符…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;watermelon&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fruitsObj = &#123;...fruits&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruitsObj) </span><br><span class="line"><span class="comment">// returns &#123;0: “banana”, 1: “apple”, 2: “orange”, 3: “watermelon”&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-用数据填充数组"><a href="#6-用数据填充数组" class="headerlink" title="6.用数据填充数组"></a>6.用数据填充数组</h3><p>在刷题时，一般会初始化一个具有相同值的数组。使用.fill()可以快速实现这一需求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newArray = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">fill</span>(<span class="string">&#x27;1&#x27;</span>) <span class="comment">// 数组长度为10，填充内容为‘1’</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray) </span><br><span class="line"><span class="comment">// returns [“1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”]</span></span><br></pre></td></tr></table></figure>

<h3 id="7-合并数组"><a href="#7-合并数组" class="headerlink" title="7.合并数组"></a>7.合并数组</h3><p>两种方法：</p>
<ul>
<li>.concat()方法</li>
<li>扩展运算符…<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;orange&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> meat = [<span class="string">&quot;beaf&quot;</span>,<span class="string">&quot;fish&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> vegetables = [<span class="string">&quot;potato&quot;</span>,<span class="string">&quot;cucumber&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="title function_">concat</span>(meat).<span class="title function_">concat</span>(vegetables))</span><br><span class="line"><span class="comment">// return [&quot;apple&quot;, &quot;orange&quot;, &quot;beaf&quot;, &quot;fish&quot;, &quot;potato&quot;, &quot;cucumber&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> food = [...fruits,...meat,...vegetables]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(food)</span><br><span class="line"><span class="comment">// return [&quot;apple&quot;, &quot;orange&quot;, &quot;beaf&quot;, &quot;fish&quot;, &quot;potato&quot;, &quot;cucumber&quot;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-求数组交集"><a href="#8-求数组交集" class="headerlink" title="8.求数组交集"></a>8.求数组交集</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numOne = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> numTwo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> duplicatedValues = [...<span class="keyword">new</span> <span class="title class_">Set</span>(numOne)].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span>=&gt;</span> numTwo.<span class="title function_">includes</span>(item))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(duplicatedValues); <span class="comment">// returns [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="9-从数组中删除虚值"><a href="#9-从数组中删除虚值" class="headerlink" title="9.从数组中删除虚值"></a>9.从数组中删除虚值</h3><p>在Javascript中，虚值有false, 0, „”, null, NaN, undefined。现在，我们可以找到如何从数组中删除此类值。为此，我们将使用.filter（）方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixedArr = [<span class="number">0</span>, “blue”, “”, <span class="title class_">NaN</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, “white”, <span class="literal">false</span>];</span><br><span class="line"><span class="keyword">var</span> trueArr = mixedArr.<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trueArr); <span class="comment">// returns [“blue”, 9, true, “white”]</span></span><br></pre></td></tr></table></figure>

<h3 id="10-从数组中获取随机值"><a href="#10-从数组中获取随机值" class="headerlink" title="10.从数组中获取随机值"></a>10.从数组中获取随机值</h3><p>可以根据数组长度获取随机索引号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&quot;blue&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;navy&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> randomColor = colors[(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (colors.<span class="property">length</span>)))]</span><br></pre></td></tr></table></figure>

<h3 id="11-反转数组"><a href="#11-反转数组" class="headerlink" title="11. 反转数组"></a>11. 反转数组</h3><p>使用.reverse()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&quot;blue&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;navy&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> reversedColors = colors.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reversedColors); </span><br><span class="line"><span class="comment">// returns [&#x27;purple&#x27;, &#x27;pink&#x27;, &#x27;navy&#x27;, &#x27;green&#x27;, &#x27;white&#x27;, &#x27;blue&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="12-lastIndexOf（）方法"><a href="#12-lastIndexOf（）方法" class="headerlink" title="12.lastIndexOf（）方法"></a>12.lastIndexOf（）方法</h3><p>lastIndexOf（）方法:查找给定元素的最后一次出现的索引。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> lastIndex = nums.<span class="title function_">lastIndexOf</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lastIndex); <span class="comment">// returns 9</span></span><br></pre></td></tr></table></figure>

<h3 id="13-求数组中的所有值的和"><a href="#13-求数组中的所有值的和" class="headerlink" title="13.求数组中的所有值的和"></a>13.求数组中的所有值的和</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> sum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// returns 14</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【leetcode】650.只有两个键的键盘</title>
    <url>/2021/09/19/%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<h2 id="650-只有两个键的键盘"><a href="#650-只有两个键的键盘" class="headerlink" title="650. 只有两个键的键盘"></a>650. 只有两个键的键盘</h2><p>最初记事本上只有一个字符 ‘A’ 。你每次可以对这个记事本进行两种操作：</p>
<ul>
<li>Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。</li>
<li>Paste（粘贴）：粘贴 上一次 复制的字符。</li>
</ul>
<p>给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 ‘A’ 。返回能够打印出 n 个 ‘A’ 的最少操作次数。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210919163546.png"></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210919173359.jpg"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSteps = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">// n=1的情况</span></span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">// 质数情况</span></span><br><span class="line">        res[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">2</span>;j&lt;=<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(i);++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j === <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//合数情况</span></span><br><span class="line">                res[i] = res[j]+res[i/j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>判断一个数是否为素数：<br>判断该数在 2-√n 中是否有因数即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPrime</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(n);++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i===<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 不是素数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 是素数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>力扣Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Echarts快速上手</title>
    <url>/2021/09/14/Echarts%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<h2 id="Echarts使用五部曲"><a href="#Echarts使用五部曲" class="headerlink" title="Echarts使用五部曲"></a>Echarts使用五部曲</h2><ul>
<li>步骤1：下载并引入echarts.js文件</li>
<li>步骤2：准备一个 <mark><b>具备大小</b></mark>的DOM容器</li>
<li>步骤3：初始化echarts实例对象</li>
<li>步骤4：指定配置项和数据（option）</li>
<li>步骤5：将配置项设置给echarts实例对象</li>
</ul>
<h3 id="步骤1：下载并引入echarts-js文件"><a href="#步骤1：下载并引入echarts-js文件" class="headerlink" title="步骤1：下载并引入echarts.js文件"></a>步骤1：下载并引入echarts.js文件</h3><p>安装方式：</p>
<ul>
<li>从npm获取<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install echarts --save</span><br></pre></td></tr></table></figure>
详见<a href="https://echarts.apache.org/handbook/zh/basics/import/">在项目中引入 Apache ECharts</a></li>
<li>从 CDN 获取<br>从 jsDelivr 引用 <a href="https://www.jsdelivr.com/package/npm/echarts">echarts</a></li>
<li>从 GitHub 获取<br><a href="https://github.com/apache/echarts">apache/echarts</a> 项目的 release 页面可以找到各个版本的链接。点击下载页面下方 Assets 中的 Source code，解压后 dist 目录下的 echarts.js 即为包含完整 ECharts 功能的文件</li>
</ul>
<p>引入文件为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914093547.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914093752.png"></p>
<h3 id="步骤2：准备一个-具备大小的DOM容器"><a href="#步骤2：准备一个-具备大小的DOM容器" class="headerlink" title="步骤2：准备一个 具备大小的DOM容器"></a>步骤2：准备一个 <mark><b>具备大小</b></mark>的DOM容器</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914100708.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914100731.png"></p>
<h3 id="步骤3：初始化echarts实例对象"><a href="#步骤3：初始化echarts实例对象" class="headerlink" title="步骤3：初始化echarts实例对象"></a>步骤3：初始化echarts实例对象</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914100559.png"></p>
<h3 id="步骤4：指定配置项和数据（option）"><a href="#步骤4：指定配置项和数据（option）" class="headerlink" title="步骤4：指定配置项和数据（option）"></a>步骤4：指定配置项和数据（option）</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914101109.png"></p>
<h3 id="步骤5：将配置项设置给echarts实例对象"><a href="#步骤5：将配置项设置给echarts实例对象" class="headerlink" title="步骤5：将配置项设置给echarts实例对象"></a>步骤5：将配置项设置给echarts实例对象</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914101150.png"></p>
<h2 id="Echarts的基础配置（option）"><a href="#Echarts的基础配置（option）" class="headerlink" title="Echarts的基础配置（option）"></a>Echarts的基础配置（option）</h2><blockquote>
<p>需要了解的主要配置：series xAxis yAxis grid tooltip title legend color toolbox</p>
</blockquote>
<ul>
<li>series 系列图标配置 决定显示那种类型的图表</li>
<li>xAxis 设置x轴的相关配置（boundaryGap是否让坐标轴和线条之间有缝隙）</li>
<li>yAxis 设置x轴的相关配置</li>
<li>grid 网格配置 可以控制线性图、柱状图等图表的大小（containLabel 显示图标刻度标签[true / false]）</li>
<li>tooltip 提示框组件（触发方式trigger [axis / item] ）</li>
<li>title 标题组件–设置图表的标题</li>
<li>legend 图例组件</li>
<li>color 调色板配置 设置线条颜色</li>
<li>toolbox 工具箱组件 可以另存为图片等功能</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914104751.png"></p>
<h3 id="图表跟随屏幕自动去适应"><a href="#图表跟随屏幕自动去适应" class="headerlink" title="图表跟随屏幕自动去适应"></a>图表跟随屏幕自动去适应</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    myChart.<span class="title function_">resize</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914145903.png"></p>
]]></content>
      <categories>
        <category>Echarts</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>实现水平垂直居中[不知自身宽高情况]</title>
    <url>/2021/09/13/%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<p>translate()函数是css3的新特性。<b>在不知道自身宽高的情况下，可以利用它来进行水平垂直居中。</b></p>
<p>当使用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>; </span><br></pre></td></tr></table></figure>
<p>是以左上角为原点，故不处于中心位置。translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。</p>
<blockquote>
<p>与负margin-left和margin-top实现居中不同的是，margin-left必须知道自身的宽高，而translate可以在不知道宽高的情况下进行居中，tranlate（）函数中的百分比是相对于自身宽高的百分比，所以能进行居中。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">    -moz-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>【leetcode】找到需要补充粉笔的学生编号</title>
    <url>/2021/09/10/%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%85%E7%B2%89%E7%AC%94%E7%9A%84%E5%AD%A6%E7%94%9F%E7%BC%96%E5%8F%B7/</url>
    <content><![CDATA[<p>描述：一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。</p>
<p>给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。</p>
<p>请你返回需要 补充 粉笔的学生 编号 。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210910170244.png"></p>
<p>提示：</p>
<ul>
<li>chalk.length == n</li>
<li>1 &lt;= n &lt;= 105</li>
<li>1 &lt;= chalk[i] &lt;= 105</li>
<li>1 &lt;= k &lt;= 109</li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>思路：<br>1.学生需要粉笔总数 % 粉笔总数<br>2.将得到的结果依次减去学生需要粉笔总数（0 - n-1）,当结果&lt;0，此时i即为需要补充粉笔的同学编号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chalkReplacer = <span class="keyword">function</span>(<span class="params">chalk, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;<span class="comment">//存储chalk元素之和</span></span><br><span class="line">    <span class="keyword">let</span> tempk;<span class="comment">//保存k%sum</span></span><br><span class="line">    chalk.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;)</span><br><span class="line">    tempk = k%sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;chalk.<span class="property">length</span>;++i)&#123;</span><br><span class="line">        tempk -= chalk[i];</span><br><span class="line">        <span class="keyword">if</span>(tempk&lt;<span class="number">0</span>) <span class="keyword">return</span> i; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/09/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-js%E7%89%88/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220829150312.png"></p>
<h2 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h2><p>快速排序（Quicksort），简称快排。在平均状况下，排序n个项目要 O(nlogn) 次比较。在最坏状况下则需要O(n<sup>2</sup>)次比较，但这种状况并不常见。</p>
<p>快速排序使用分治法策略来把一个序列（arr）分为较小和较大的2个子序列，然后递归地排序两个子序列。</p>
<p>快速排序步骤为：</p>
<ul>
<li>1.挑选基准值：从数列中挑出一个元素，称为“基准”</li>
<li>2.分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成</li>
<li>3.递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li>
</ul>
<blockquote>
<p>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p>
</blockquote>
<p>【上述内容参考自<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">维基百科</a>】<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210906102722.jpg"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="comment">//递归终止条件：数组长度为0或1</span></span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span>&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 取数组中间位置索引以及元素</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> pivot = arr[index]; <span class="comment">//  直接取数据即可，没必要采用该方式let pivot = arr.splice(index, 1)</span></span><br><span class="line">    <span class="comment">// left：存储小于中间元素的元素集合</span></span><br><span class="line">    <span class="comment">// right：存储大于等于中间元素的元素集合</span></span><br><span class="line">    <span class="keyword">let</span> left = [];</span><br><span class="line">    <span class="keyword">let</span> right = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;pivot) left.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&gt;pivot) right.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>(pivot,<span class="title function_">quickSort</span>(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2.冒泡排序"></a>2.冒泡排序</h2><p>冒泡排序是一种最基础的交换排序。之所以叫做冒泡排序，因为每一个元素都可以像小气泡一样，根据自身大小一点一点向数组的一侧移动。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220816212759.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params"> arr </span>) &#123;</span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=arr.<span class="property">length</span>-<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j-<span class="number">1</span>]&gt;arr[j])</span><br><span class="line">                [arr[j-<span class="number">1</span>],arr[j]] = [arr[j],arr[j-<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">l,r</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = [];</span><br><span class="line">    <span class="keyword">while</span>(l.<span class="property">length</span>&gt;<span class="number">0</span>&amp;&amp;r.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[<span class="number">0</span>]&lt;r[<span class="number">0</span>]) temp.<span class="title function_">push</span>(l.<span class="title function_">shift</span>());</span><br><span class="line">        <span class="keyword">else</span> temp.<span class="title function_">push</span>(r.<span class="title function_">shift</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp.<span class="title function_">concat</span>(l).<span class="title function_">concat</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span>&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> mid = arr.<span class="property">length</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">mergeSort</span>(arr.<span class="title function_">slice</span>(<span class="number">0</span>,mid));</span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">mergeSort</span>(arr.<span class="title function_">slice</span>(mid));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">merge</span>(left,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
  </entry>
  <entry>
    <title>【leetcode】比较版本号</title>
    <url>/2021/09/03/%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h2><p>描述：给你两个版本号 version1 和 version2 ，请你比较它们。</p>
<p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p>
<p>返回规则如下：</p>
<ul>
<li>如果 version1 &gt; version2 返回 1，</li>
<li>如果 version1 &lt; version2 返回 -1，</li>
<li>除此之外返回 0。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210903142913.png"></p>
<p>提示：</p>
<ul>
<li>1 &lt;= version1.length, version2.length &lt;= 500</li>
<li>version1 和 version2 仅包含数字和 ‘.’</li>
<li>version1 和 version2 都是 有效版本号</li>
<li>version1 和 version2 的所有修订号都可以存储在 32 位整数 中</li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>思路：</p>
<ul>
<li>1.通过.将字符串进行分割，得到数组</li>
<li>2.取二者的最大长度，作为数组长度，不足长度的使用 0 补全</li>
<li>3.比较数组相同位置的元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> compareVersion = <span class="keyword">function</span>(<span class="params">version1, version2</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.通过.将字符串进行分割</span></span><br><span class="line">    <span class="keyword">let</span> v1 = version1.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> v2 = version2.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 2.取二者的最大长度，作为数组长度</span></span><br><span class="line">    <span class="keyword">let</span> len = (v1.<span class="property">length</span>&gt;v2.<span class="property">length</span> ? v1.<span class="property">length</span>:v2.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="comment">// 不足长度的使用 0 补全</span></span><br><span class="line">        <span class="keyword">let</span> num1 = v1[i]?<span class="built_in">parseInt</span>(v1[i]):<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> num2 = v2[i]?<span class="built_in">parseInt</span>(v2[i]):<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 3.比较数组相同位置的元素</span></span><br><span class="line">        <span class="keyword">if</span>(num1&gt;num2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num1&lt;num2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有位置都比较完成，表明二者一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>力扣Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ60 把二叉树打印成多行[剑指offer]</title>
    <url>/2021/09/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210901094843.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210901094918.png"><br>[中等、队列]</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>解题思路：</p>
<ul>
<li>树的层次遍历+使用两个变量（a.记录当前行的节点数目 b.记录下一行的节点数目）</li>
<li>每一行的节点都要放到一个数组内部</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Print</span>(<span class="params">pRoot</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> res = []; <span class="comment">//最终结果</span></span><br><span class="line">    <span class="keyword">let</span> queue = [];<span class="comment">// 层次遍历queue</span></span><br><span class="line">    <span class="keyword">let</span> temprow = [];<span class="comment">// 存放每一层的结点</span></span><br><span class="line">    <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> res;</span><br><span class="line">    queue.<span class="title function_">push</span>(pRoot);</span><br><span class="line">    <span class="keyword">let</span> nextLevel = <span class="number">0</span>;<span class="comment">//下一层结点数</span></span><br><span class="line">    <span class="keyword">let</span> nowLevel = <span class="number">1</span>;<span class="comment">// 本层结点数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">         <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line">        temprow.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">        nowLevel--;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span>) &#123;</span><br><span class="line">            nextLevel++;</span><br><span class="line">            queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">right</span>) &#123;</span><br><span class="line">            nextLevel++;</span><br><span class="line">            queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nowLevel === <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(temprow);</span><br><span class="line">            temprow = [];</span><br><span class="line">            nowLevel = nextLevel;</span><br><span class="line">            nextLevel = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>ElementUI树形结构样式修改</title>
    <url>/2021/08/31/elementUI%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h3 id="0-最终效果图"><a href="#0-最终效果图" class="headerlink" title="0.最终效果图"></a>0.最终效果图</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210831152413.png"></p>
<blockquote>
<p>PS:基于<a href="https://element.eleme.cn/#/zh-CN/component/tree">ElementUI中的树形控件进行实现</a></p>
</blockquote>
<p>原效果图：<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210831153551.png"></p>
<h3 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h3><p>分为4各步骤：</p>
<ul>
<li>更换父子节点以及根节点的图标</li>
<li>调整父子节点的缩进</li>
<li>绘制结点间的关系线</li>
<li>更换最前方的小三角形图标</li>
</ul>
<h4 id="1-1-更换父子节点以及根节点的图标"><a href="#1-1-更换父子节点以及根节点的图标" class="headerlink" title="1.1 更换父子节点以及根节点的图标"></a>1.1 更换父子节点以及根节点的图标</h4><p>实现思路：通过data.class的值来确定父子节点和根节点【树形结构的数据中要包含class字段】，分别为其加上不同的图标，图标使用<svg-icon>展示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-tree</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:data</span>=<span class="string">&quot;data&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:props</span>=<span class="string">&quot;defaultProps&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-expand-all</span></span></span><br><span class="line"><span class="tag">    <span class="attr">indent</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;tree-line&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">highlight-current</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:expand-on-click-node</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">node-click</span>=<span class="string">&quot;handleNodeClick&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123; node, data &#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;custom-tree-node&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父级icon --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 0&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;danghui&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:#ff0000;font-size:10px;&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--非父节点非根节点icon--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;dangOrg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:#ff0000;font-size:10px;&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 子集icon --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;dangMember&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:10px;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; node.label &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-tree</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-调整父子节点的缩进"><a href="#1-2-调整父子节点的缩进" class="headerlink" title="1.2 调整父子节点的缩进"></a>1.2 调整父子节点的缩进</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.el-tree-node</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>; <span class="comment">/* 缩进量 */</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-class">.el-tree-node__children</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>; <span class="comment">/* 缩进量 */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-绘制结点间的关系线"><a href="#1-3-绘制结点间的关系线" class="headerlink" title="1.3 绘制结点间的关系线"></a>1.3 绘制结点间的关系线</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 竖线 */</span></span><br><span class="line"><span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    //<span class="attribute">left</span>: -<span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="number">#D1CECE</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 当前层最后一个节点的竖线高度固定 */</span></span><br><span class="line"><span class="selector-class">.el-tree-node</span><span class="selector-pseudo">:last-child</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">38px</span>; // 可以自己调节到合适数值</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 横线 */</span></span><br><span class="line"><span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="comment">/* left: -3px; */</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#D1CECE</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 去掉最顶层的虚线，放最下面样式才不会被上面的覆盖了 */</span></span><br><span class="line">&amp; &gt; <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">border-top</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">&amp; &gt; <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-更换最前方的小三角形图标"><a href="#1-4-更换最前方的小三角形图标" class="headerlink" title="1.4 更换最前方的小三角形图标"></a>1.4 更换最前方的小三角形图标</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 展开关闭的icon修改 */</span></span><br><span class="line">  <span class="selector-class">.el-tree-node__expand-icon</span><span class="selector-class">.expanded</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.el-icon-caret-right</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;\e783&quot;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:element-icons <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.el-tree-node__expand-icon</span><span class="selector-class">.expanded</span><span class="selector-class">.el-icon-caret-right</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;\e781&quot;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:element-icons <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Q:content属性的值如何取到？<br>A:打开<a href="https://element.eleme.cn/#/zh-CN/component/icon">ElementUI图标库</a>,F12选中需要的图标，在样式中即可获取到。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210831160209.png"></p>
<h3 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2.完整代码"></a>2.完整代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-tree</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:data</span>=<span class="string">&quot;data&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:props</span>=<span class="string">&quot;defaultProps&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-expand-all</span></span></span><br><span class="line"><span class="tag">    <span class="attr">indent</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;tree-line&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">highlight-current</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:expand-on-click-node</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">node-click</span>=<span class="string">&quot;handleNodeClick&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123; node, data &#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;custom-tree-node&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父级icon --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 0&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;danghui&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:#ff0000;font-size:10px;&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--非父节点非子节点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;dangOrg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:#ff0000;font-size:10px;&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 子集icon --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;dangMember&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:10px;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; node.label &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-tree</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: [&#123;</span><br><span class="line">    <span class="comment">// class:0 一级节点  class:1非父节点，非子节点     class:2子节点</span></span><br><span class="line">    <span class="attr">label</span>: <span class="string">&#x27;一级 1&#x27;</span>,</span><br><span class="line">    <span class="attr">class</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">label</span>: <span class="string">&#x27;二级 1-1&#x27;</span>,</span><br><span class="line">        <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">label</span>: <span class="string">&#x27;三级 1-1-1&#x27;</span>,</span><br><span class="line">        <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;一级 2&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;二级 2-1&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">                    <span class="attr">label</span>: <span class="string">&#x27;三级 2-1-1&#x27;</span>,</span><br><span class="line">                    <span class="attr">class</span>: <span class="number">2</span></span><br><span class="line">                &#125;]</span><br><span class="line">                &#125;, </span><br><span class="line">                &#123;</span><br><span class="line">                <span class="attr">label</span>: <span class="string">&#x27;二级 2-2&#x27;</span>,</span><br><span class="line">                <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">children</span>: [&#123;</span><br><span class="line">                    <span class="attr">label</span>: <span class="string">&#x27;三级 2-2-1&#x27;</span>,</span><br><span class="line">                    <span class="attr">class</span>: <span class="number">2</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&#x27;一级 3&#x27;</span>,</span><br><span class="line">    <span class="attr">class</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;二级 3-1&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;三级 3-1-1&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">2</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;二级 3-2&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;三级 3-2-1&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">2</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="attr">defaultProps</span>: &#123;</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;children&#x27;</span>,</span><br><span class="line">        <span class="attr">label</span>: <span class="string">&#x27;label&#x27;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.tree-line</span>&#123;</span><br><span class="line">  <span class="selector-class">.el-tree-node</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>; // 缩进量</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.el-tree-node__children</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>; // 缩进量</span><br><span class="line">  &#125;</span><br><span class="line">  // 竖线</span><br><span class="line">  <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    //<span class="attribute">left</span>: -<span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="number">#D1CECE</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  // 当前层最后一个节点的竖线高度固定</span><br><span class="line">  <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">:last-child</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">38px</span>; // 可以自己调节到合适数值</span><br><span class="line">  &#125;</span><br><span class="line">  // 横线</span><br><span class="line">  <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    //<span class="attribute">left</span>: -<span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#D1CECE</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  // 去掉最顶层的虚线，放最下面样式才不会被上面的覆盖了</span><br><span class="line">  &amp; &gt; <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">border-top</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp; &gt; <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">  // 展开关闭的<span class="attribute">icon</span>修改</span><br><span class="line">  <span class="selector-class">.el-tree-node__expand-icon</span><span class="selector-class">.expanded</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.el-icon-caret-right</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;\e783&quot;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:element-icons <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.el-tree-node__expand-icon</span><span class="selector-class">.expanded</span><span class="selector-class">.el-icon-caret-right</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;\e781&quot;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:element-icons <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ62 二叉搜索树的第k个结点 [ 剑指offer ]</title>
    <url>/2021/08/25/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210825142603.png"></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li>法一：<br>将二叉搜索树的中序遍历的结果存入数组中，取数组的第k个结果。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">KthNode</span>(<span class="params">pRoot, k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pRoot || k&lt;<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">gotoArr</span>(pRoot)[k-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gotoArr</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="comment">// 中序遍历结果存入数组</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="title function_">gotoArr</span>(root.<span class="property">left</span>);</span><br><span class="line">    res.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="title function_">gotoArr</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>存在问题：需要将所有结点遍历完，时间复杂度高</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 》》改进版《《</span></span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">let</span> key; <span class="comment">// flag：确定是否取到结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">KthNode</span>(<span class="params">pRoot, k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pRoot || k&lt;<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    key = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">gotoArr</span>(pRoot)[k-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gotoArr</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="comment">// 中序遍历结果存入数组</span></span><br><span class="line">    <span class="keyword">if</span>(res.<span class="property">length</span> === key) <span class="keyword">return</span>; <span class="comment">//取到结果，停止</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span>) <span class="title function_">gotoArr</span>(root.<span class="property">left</span>);</span><br><span class="line">    res.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">right</span>) <span class="title function_">gotoArr</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>法二：<br>中序遍历二叉搜索树，搜索至第k个结点时，停止。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">KthNode</span>(<span class="params">root, k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || k&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 为了追踪k值，将中序遍历函数定义在里面</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">root</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>) res = <span class="title function_">traverse</span>(root.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">            <span class="comment">// 左子树未查找到结果</span></span><br><span class="line">            <span class="keyword">if</span>(k===<span class="number">1</span>) res=root;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span>) res = <span class="title function_">traverse</span>(root.<span class="property">right</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">traverse</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="补充知识点："><a href="#补充知识点：" class="headerlink" title="补充知识点："></a>补充知识点：</h3><h5 id="二叉搜索树："><a href="#二叉搜索树：" class="headerlink" title="二叉搜索树："></a>二叉搜索树：</h5><p>a. 定义:</p>
<p>二分搜索树（Binary Search Tree），也称为二叉查找树 、二叉搜索树 、有序二叉树或排序二叉树。满足以下几个条件：</p>
<ul>
<li>若它的左子树不为空，左子树上所有节点的值都小于它的根节点。</li>
<li>若它的右子树不为空，右子树上所有的节点的值都大于它的根节点。<br>它的左、右子树也都是二分搜索树。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210825150004.png"></li>
</ul>
<p>b. 二分搜索树有着高效的插入、删除、查询操作。</p>
<p>平均时间的时间复杂度为 O(log n)，最差情况为 O(n)。二分搜索树与堆不同，不一定是完全二叉树，底层不容易直接用数组表示故采用链表来实现二分搜索树。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210825150259.png"></p>
<p>c. 二分查找法过程<br>二分查找法的思想在 1946 年提出，查找问题是计算机中非常重要的基础问题，对于有序数列，才能使用二分查找法。如果我们要查找一元素，先看数组中间的值V和所需查找数据的大小关系，分三种情况：</p>
<ul>
<li>1、等于所要查找的数据，直接找到</li>
<li>2、若小于 V，在小于 V 部分分组继续查询</li>
<li>2、若大于 V，在大于 V 部分分组继续查询</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210825150526.png"><br>代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [start,end] = [<span class="number">0</span>,nums.<span class="property">length</span>-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> middle,midItem;<span class="comment">// 中间元素索引以及内容</span></span><br><span class="line">    <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">        middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>((start+end)/<span class="number">2</span>);</span><br><span class="line">        midItem = nums[middle];</span><br><span class="line">        <span class="keyword">if</span>(midItem === target)&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(midItem &gt; target)&#123;</span><br><span class="line">            end = middle-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            start = middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ39 平衡二叉树 [剑指offer]</title>
    <url>/2021/08/22/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210822195233.png"></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>（一）<br>计算左子树和右子树高度，判断二者高度差是否不大于1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IsBalanced_Solution</span>(<span class="params">pRoot</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="title function_">getTreeDeep</span>(pRoot.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">let</span> r = <span class="title function_">getTreeDeep</span>(pRoot.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(l-r)&lt;=<span class="number">1</span> &amp;&amp; <span class="title class_">IsBalanced</span>_Solution(pRoot.<span class="property">left</span>) &amp;&amp; <span class="title class_">IsBalanced</span>_Solution(pRoot.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTreeDeep</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">getTreeDeep</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">getTreeDeep</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (left&gt;right?<span class="attr">left</span>:right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>存在问题：节点重复遍历，影响效率</li>
</ul>
<p>（二）<br>改进策略：在求树的高度的同时判断是否平衡，如果不平衡返回-1，否则返回树的高度。<br>当左子树返回-1时，不需要再对右子树进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IsBalanced_Solution</span>(<span class="params">pRoot</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getTreeDeep</span>(pRoot)!==-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTreeDeep</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">getTreeDeep</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">if</span>(left === -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">getTreeDeep</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">if</span>(right === -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(left-right)&gt;<span class="number">1</span> ? -<span class="number">1</span> : <span class="number">1</span> + (left&gt;right?<span class="attr">left</span>:right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ38 二叉树的深度[剑指offer]</title>
    <url>/2021/08/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210821135542.png"><br>[简单、递归]</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>树的深度 = max(左子树深度，右子树深度)+1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TreeDepth</span>(<span class="params">pRoot</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot===<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="title class_">TreeDepth</span>(pRoot.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">let</span> right = <span class="title class_">TreeDepth</span>(pRoot.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (left&gt;right?<span class="attr">left</span>:right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还有层次遍历的方法，待补充……</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ18 二叉树的镜像[剑指offer]</title>
    <url>/2021/08/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210820140027.png"><br>[简单、递归]</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>交换二叉树的左右子树</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Mirror</span>(<span class="params"> pRoot </span>) &#123;</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot === <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> pRoot;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [pRoot.<span class="property">left</span>,pRoot.<span class="property">right</span>] = [pRoot.<span class="property">right</span>,pRoot.<span class="property">left</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Mirror</span>(pRoot.<span class="property">left</span>);</span><br><span class="line">    <span class="title class_">Mirror</span>(pRoot.<span class="property">right</span>);</span><br><span class="line">    <span class="keyword">return</span> pRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>二叉树的答题模板</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">TreeNode root</span>)&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="title function_">traverse</span>(root.<span class="property">left</span>)</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="title function_">traverse</span>(root.<span class="property">right</span>)</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的中心思想：</p>
<ul>
<li>考虑出口 （ if 部分）</li>
<li>处理当前节点</li>
<li>递归处理下个节点</li>
</ul>
<p>二叉树问题的递归出口，一般包括：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.节点为空（到达叶子节点）</span></span><br><span class="line">pRoot === <span class="literal">null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ2 替换空格[剑指offer]</title>
    <url>/2021/08/19/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210819213607.png"><br>[简单、字符串、正则表达式]</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>法（一）：1.查找出空格  2.替换 【可能存在多个空格，因此需要循环】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceSpace</span>(<span class="params"> s </span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.<span class="property">length</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] === <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            res += <span class="string">&#x27;%20&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法（二）：正则表达式（全局匹配）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceSpace</span>(<span class="params"> s </span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">replace</span>(<span class="regexp">/\s/g</span>,<span class="string">&#x27;%20&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>1.正则表达式 - 修饰符（标记）<br>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。<br>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/pattern/flags <span class="comment">//(其中，pattern为要匹配的内容，flags为修饰符)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210819214842.png"></p>
<p>2.新建正则对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regx = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> s.<span class="title function_">replace</span>(regx,<span class="string">&#x27;%20&#x27;</span>);</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ7 斐波那契数列[剑指offer]</title>
    <url>/2021/08/15/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210815144636.png"><br>[简单、动态规划]</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>斐波那契数列可以采用递归解法，但是递归法重复计算部分太多，因此选择使用动态规划解答。<br>动态规划的特点是：最优子结构、无后效性、子问题重叠。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fibonacci</span>(<span class="params">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> [a,b] = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        b=a+b;</span><br><span class="line">        a=b-a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="title class_">Fibonacci</span> : <span class="title class_">Fibonacci</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210813183104.jpg"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210813183119.jpg"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210813183134.jpg"></p>
<h2 id="【补充点】"><a href="#【补充点】" class="headerlink" title="【补充点】"></a>【补充点】</h2><h3 id="1-JS创建正则表达式"><a href="#1-JS创建正则表达式" class="headerlink" title="1.JS创建正则表达式"></a>1.JS创建正则表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.字面量创建方式（两个斜杠之间的，都是用来描述规则的元字符）</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/\d+/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构造函数模式创建，有两个参数：元字符字符串，修饰符字符串</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\d+&#x27;</span>)</span><br><span class="line"><span class="comment">//当需要把变量加入到正则表达式中时，不能使用字面量的方式创建，只能用构造函数去创建</span></span><br><span class="line"><span class="comment">// var patt=new RegExp(pattern,modifiers);</span></span><br><span class="line"><span class="comment">//pattern（模式） 描述了表达式的模式</span></span><br><span class="line"><span class="comment">//modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配</span></span><br></pre></td></tr></table></figure>
<h3 id="正则表达式由两部分组成"><a href="#正则表达式由两部分组成" class="headerlink" title="正则表达式由两部分组成"></a>正则表达式由两部分组成</h3><ul>
<li>元字符</li>
<li>修饰符</li>
</ul>
<h4 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.量词元字符：设置出现的次数</span></span><br><span class="line">*      零到多次</span><br><span class="line">+      一到多次</span><br><span class="line">?      零次或者一次</span><br><span class="line">&#123;n&#125;    出现n次</span><br><span class="line">&#123;n, &#125;  出现n到多次</span><br><span class="line">&#123;n, m&#125; 出现n到m次</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.特殊元字符：单个或者组合在一起代表特殊的含义</span></span><br><span class="line">\   转义字符（普通-&gt;特殊-&gt;普通）</span><br><span class="line">.   除\<span class="title function_">n</span>(换行符)以外的任意字符</span><br><span class="line">^   以哪一个元字符作为开始</span><br><span class="line">$   以哪一个元字符作为结束</span><br><span class="line">\n  换行符</span><br><span class="line">\d  <span class="number">0</span>~<span class="number">9</span>之间的一个数字</span><br><span class="line">\D  非<span class="number">0</span>~<span class="number">9</span>之间的一个数字</span><br><span class="line">\w  数字、字母、下划线中的任意一个字符</span><br><span class="line">\W  非数字、字母、下划线中的任意一个字符</span><br><span class="line">\s  一个空白字符（包含空格、制表符、换页符等）</span><br><span class="line">\t  一个制表符（一个<span class="variable constant_">TAB</span>键：四个空格）</span><br><span class="line">\b  匹配一个单词的边界</span><br><span class="line">x|y x或者y中的一个字符</span><br><span class="line">[xyz] x、y、z中的一个字符</span><br><span class="line">[^xy] 除了xy以外的任意一个字符</span><br><span class="line">[a-z] 指定a-z这个范围中的任意一个字符 [<span class="number">0</span>-9a-zA-<span class="variable constant_">Z_</span>] === \w</span><br><span class="line">[^a-z] 除了a-z这个范围中的任意一个字符</span><br><span class="line">()     正则中的分组符号</span><br><span class="line">(?:)   只匹配不捕获</span><br><span class="line">(?=)   正向预查</span><br><span class="line">(?!)   负向预查</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.普通元字符：代表本身的含义</span></span><br><span class="line">/js/  此正则匹配的就是 <span class="string">&quot;js&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="常用修饰符：i-m-g"><a href="#常用修饰符：i-m-g" class="headerlink" title="常用修饰符：i m g"></a>常用修饰符：i m g</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">i</span>: ignoreCase   忽略单词大小写匹配</span><br><span class="line"><span class="attr">m</span>: multiline    可以进行多行匹配</span><br><span class="line"><span class="attr">g</span>: <span class="variable language_">global</span>       全局匹配</span><br><span class="line"></span><br><span class="line">/A/.<span class="title function_">test</span>(<span class="string">&#x27;lalalala&#x27;</span>)    <span class="comment">//false</span></span><br><span class="line">/A/i.<span class="title function_">test</span>(<span class="string">&#x27;lalalala&#x27;</span>)   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="元字符详细解析"><a href="#元字符详细解析" class="headerlink" title="元字符详细解析"></a>元字符详细解析</h4><blockquote>
<p>^ $</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^\d/</span>  <span class="comment">//必须以数字开头</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;js&#x27;</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;2021js&#x27;</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;js2021&#x27;</span>)) <span class="comment">//false</span></span><br><span class="line">----------------------------------------</span><br><span class="line">reg = <span class="regexp">/\d$/</span>  <span class="comment">//必须以数字结束</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;js&#x27;</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;2021js&#x27;</span>)) <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;js2021&#x27;</span>)) <span class="comment">//true</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">//^ $两个都不加：字符串中包含符合规则的内容即可</span></span><br><span class="line">reg = <span class="regexp">/\d+/</span>：字符串中包含<span class="number">1</span>到多个数字即可</span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">//^ $两个都加：字符串只能是和规则一致的内容</span></span><br><span class="line">reg = <span class="regexp">/^\d+$/</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">//验证手机号（11为，以1开头）</span></span><br><span class="line">reg = <span class="regexp">/^1\d&#123;10&#125;$/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>\</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^2.3$/</span>   <span class="comment">// .不是小数点，是\n外的任意字符</span></span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;2.3&#x27;</span>)  <span class="comment">//true</span></span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;2@3&#x27;</span>)  <span class="comment">//true</span></span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;23&#x27;</span>)   <span class="comment">//false</span></span><br><span class="line">----------------------------------------</span><br><span class="line">reg = <span class="regexp">/^2\.3$/</span>    <span class="comment">//只能代表2.3了</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">//匹配&quot;\d&quot;</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;\\d&quot;</span>   <span class="comment">//在字符串中\也有特殊含义</span></span><br><span class="line">reg = <span class="regexp">/^\d$/</span>  <span class="comment">//不能匹配str</span></span><br><span class="line">reg = <span class="regexp">/^\\d$/</span></span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&quot;\\d&quot;</span>)  <span class="comment">//正确匹配str</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>x|y</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^18|29$/</span></span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;29&#x27;</span>)</span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;129&#x27;</span>)</span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;189&#x27;</span>)</span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;1829&#x27;</span>)</span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;829&#x27;</span>)</span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;182&#x27;</span>)</span><br><span class="line"><span class="comment">//以上结果全为true</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">//------直接x|y会存在很乱的优先级问题，可以用小括号处理 =&gt; 小括号：分组</span></span><br><span class="line">reg = <span class="regexp">/^(18|29)$/</span>  <span class="comment">//只能是18或者29</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[]</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 中括号中出现的字符一般都代表字符本身的含义</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[@+]+$/</span>   <span class="comment">//@或者+ 出现一到多次</span></span><br><span class="line"></span><br><span class="line">reg = <span class="regexp">/^[\d]$/</span>   <span class="comment">// \d在[]中代表0-9的一个数字</span></span><br><span class="line">reg = <span class="regexp">/^[\\d]$/</span>  <span class="comment">//  \ 或者 d</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">// 2. 中括号中不存在多位数</span></span><br><span class="line">reg = <span class="regexp">/^[18]$/</span>   <span class="comment">//只能匹配1或者8，不能匹配18</span></span><br><span class="line">reg = <span class="regexp">/^[10-29]$/</span>   <span class="comment">// 1或者0-2或者9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题目汇总(CSS部分)</title>
    <url>/2021/07/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="margin和padding的区别"><a href="#margin和padding的区别" class="headerlink" title="margin和padding的区别"></a>margin和padding的区别</h3><ul>
<li>margin是指从自身边框到另一个容器边框之间的距离，指两个容器之间的距离。（外边距）</li>
<li>padding是指自身边框到自身内部的另一个容器之间的距离，指容器内距离。（内边框）</li>
</ul>
<p>1.语法结构：(以margin为例，padding相同)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>:<span class="number">10px</span>;  //左外边距<span class="number">10px</span></span><br><span class="line">// 还有 <span class="attribute">margin-right</span>,<span class="attribute">margin-top</span>,<span class="attribute">margin-bottom</span></span><br><span class="line"><span class="attribute">margin</span>:<span class="number">10px</span>; // 上下左右外边距均为<span class="number">10px</span></span><br><span class="line">marin:<span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span> <span class="number">40px</span>;//上<span class="number">10px</span> 右<span class="number">20px</span> 下<span class="number">30px</span> 左<span class="number">40px</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>margin只有一个值表示上右下左。如果 margin 只有两个值第一个值表示上下，第二个值为左右。margin有三个值表示上,左右,下。margin有四个值表示上下左右四个方向。</p>
</blockquote>
<p>2.区别：<br>（1）二者相邻是否会抵消</p>
<ul>
<li>上下相连的两个盒子之间的空白需要相互抵消时，比如15px+20px的margin，将得到20px的空白。(保留下最大的)</li>
<li>上下相连的两个盒子之间的空白希望等于两者之和时，比如15px+20px的padding，将得到35px的空白。（会相加）<br>例子：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.content1</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-bottom</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.content2</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">250px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210727232843.png"><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.content2</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">5px</span> yellow solid;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding-top</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210728000622.png"><br>（2）负值问题</li>
<li>padding 设置为负值无效</li>
<li>margin 设置为负值：（1）元素本身没有宽度，会增加元素宽度；（2）元素本身有宽度，会产生位移；（3）margin-top为负值，不管是否设置高度，都不会增加高度，而是会产生向上的位移；（4）margin-bottom为负值的时候不会位移,而是会减少自身供css读取的高度【理解：本元素的高度和定位不受影响，但时候其后的元素会向上位移100px，因为后元素（粉）所能看到的前元素（绿）的申明高度因为负margin的缘故减少了100px 】</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 情况（2）</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"> <span class="selector-class">.content</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.content1</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: red;  </span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.content2</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">5px</span> yellow solid;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css">&lt;/&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210728094233.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 情况（4）</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content3&quot;</span>&gt;</span>后续元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.content</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.content1</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red;  </span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.content2</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">5px</span> yellow solid;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-bottom</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.content3</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210728103755.png"></p>
<h3 id="介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？"><a href="#介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？"></a>介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h3><p>相关知识点：</p>
<blockquote>
<blockquote>
<p>（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）<br>（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分<br>IE盒模型和W3C标准盒模型的区别：<br>（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding<br>（2）IE盒模型：属性width，height包含content、border和padding，指的是content<br>+padding+border。<br>在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；<br>如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE<br>盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</p>
</blockquote>
</blockquote>
<p>回答：<br>盒模型都是由四个部分组成的，分别是margin、border、padding和content。</p>
<p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的<br>范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。</p>
<p>一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里iconfont使用方法</title>
    <url>/2021/07/20/%E9%98%BF%E9%87%8Ciconfont%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>阿里巴巴iconfont的使用方式分为两种：1.本地使用  2.线上引用<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211013192203.jpg" width="150%" height="150%"/></p>
<p><a href="https://www.iconfont.cn/">iconfont-阿里巴巴矢量图标库</a></p>
<h2 id="0-前期准备"><a href="#0-前期准备" class="headerlink" title="0.前期准备"></a>0.前期准备</h2><p>使用时先到网站上选中需要使用的图标添加至项目<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720101011.png?1000x"></p>
<h2 id="1-本地使用"><a href="#1-本地使用" class="headerlink" title="1.本地使用"></a>1.本地使用</h2><p>1.下载项目至本地<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720101230.png"><br>2.解压到项目中<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720103442.png"><br>3.在页面中引入样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>iconfont的使用--本地引入<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="keyword">@font-face</span> &#123;</span></span><br><span class="line"><span class="language-css">		  <span class="attribute">font-family</span>: <span class="string">&#x27;iconfont&#x27;</span>;</span></span><br><span class="line"><span class="language-css">		  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;./iconfont/iconfont.woff2?t=1626747157081&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span></span><br><span class="line"><span class="language-css">		       <span class="built_in">url</span>(<span class="string">&#x27;./iconfont/iconfont.woff?t=1626747157081&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),</span></span><br><span class="line"><span class="language-css">		       <span class="built_in">url</span>(<span class="string">&#x27;./iconfont/iconfont.ttf?t=1626747157081&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>);</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.iconfont</span> &#123;</span></span><br><span class="line"><span class="language-css">		  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span> <span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">		  <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">		  <span class="attribute">font-style</span>: normal;</span></span><br><span class="line"><span class="language-css">		  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="language-css">		  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span>&gt;</span><span class="symbol">&amp;#xe89a;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>@font-face中的url需要依据项目修改</li>
<li>使用方式：    &lt;span class=”iconfont”&gt;&amp;#xe89a;&lt;/span&gt;</li>
</ul>
<h2 id="2-线上引用"><a href="#2-线上引用" class="headerlink" title="2.线上引用"></a>2.线上引用</h2><h4 id="2-1-unicode引用"><a href="#2-1-unicode引用" class="headerlink" title="2.1 unicode引用"></a>2.1 unicode引用</h4><p>将本地使用代码中的@font-face进行替换即可<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720111233.png"></p>
<h4 id="2-2-Font-class形式引入："><a href="#2-2-Font-class形式引入：" class="headerlink" title="2.2 Font class形式引入："></a>2.2 Font class形式引入：</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720111005.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>iconfont的使用--线上引用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://at.alicdn.com/t/font_2686372_j1gr8zzfq9.css&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.iconfont</span> &#123;</span></span><br><span class="line"><span class="language-css">		  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span> <span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">		  <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">		  <span class="attribute">font-style</span>: normal;</span></span><br><span class="line"><span class="language-css">		  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="language-css">		  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-chazuo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在Vue中使用方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--App.vue中引入样式文件，用线上链接即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	<span class="keyword">@import</span> <span class="string">&quot;xxxxxxx/iconfont.css&quot;</span>;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--class方式引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-qianbao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-3-symbol引用"><a href="#2-3-symbol引用" class="headerlink" title="2.3 symbol引用"></a>2.3 symbol引用</h4><ul>
<li>支持多色图标了，不再受单色限制。</li>
<li>通过一些技巧，支持像字体那样，通过,来调整样式。</li>
<li>兼容性较差，支持 ie9+及现代浏览器。</li>
<li>浏览器渲染svg的性能一般，还不如png。<blockquote>
<p>使用步骤：</p>
</blockquote>
</li>
</ul>
<p>1.第一步：拷贝项目下面生成的symbol代码：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720112720.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://拷贝的地址&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.第二步：加入通用css代码（引入一次就行）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-class">.icon</span> &#123;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">1em</span>; <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">       <span class="attribute">vertical-align</span>: -<span class="number">0.15em</span>;</span><br><span class="line">       fill: currentColor;</span><br><span class="line">       <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>3.第三步：挑选相应图标并获取类名，应用于页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#icon-xxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>iconfont的使用--线上引用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://at.alicdn.com/t/font_2686372_j1gr8zzfq9.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">src</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.iconfont</span> &#123;</span></span><br><span class="line"><span class="language-css">		  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span> <span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">		  <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">		  <span class="attribute">font-style</span>: normal;</span></span><br><span class="line"><span class="language-css">		  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="language-css">		  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#icon-chazuo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>阿里iconfont</category>
      </categories>
      <tags>
        <tag>阿里iconfont</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML+CSS学习笔记</title>
    <url>/2021/07/18/HTML-CSS/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1XJ411X7Ud?p=1">【尚硅谷】Web前端零基础入门HTML5+CSS3基础教程丨初学者从入门到精通</a></p>
<p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99">+ 课程配套资料 +</a></p>
<p>网页分成三部分：</p>
<ul>
<li>结构HTML</li>
<li>表现CSS</li>
<li>行为JavaScript</li>
</ul>
<h1 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h1><p>HTML(Hypertext Markup Language)  超文本标记语言。</p>
<h2 id="1-标签"><a href="#1-标签" class="headerlink" title="1.标签"></a>1.标签</h2><p>标签一般成对出现，但是存在一些自结束标签（单标签），如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span>、<span class="tag">&lt;<span class="name">img</span>/&gt;</span>、<span class="tag">&lt;<span class="name">input</span>&gt;</span>、<span class="tag">&lt;<span class="name">input</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h2><p>注释不能嵌套</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释内容 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-标签的属性（P7）"><a href="#3-标签的属性（P7）" class="headerlink" title="3.标签的属性（P7）"></a>3.标签的属性（P7）</h2><p>在标签（开始标签或自结束标签）还可以设置属性;<br>属性和标签中的内容应该使用空格隔开</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span> 标签属性 <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- color为font标签的属性 --&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-文档声明-P8"><a href="#4-文档声明-P8" class="headerlink" title="4.文档声明 (P8)"></a>4.文档声明 (P8)</h2><ul>
<li>文档声明用来告诉浏览器当前网页版本</li>
<li>html5的文档声明 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span> / <span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-字符编码（P10）"><a href="#5-字符编码（P10）" class="headerlink" title="5.字符编码（P10）"></a>5.字符编码（P10）</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网页字符集通过&lt;meta&gt;设置</span></span><br><span class="line"><span class="comment">&lt;meta&gt;需要放在&lt;head&gt;&lt;/head&gt;中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-实体（转义字符）"><a href="#6-实体（转义字符）" class="headerlink" title="6.实体（转义字符）"></a>6.实体（转义字符）</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">实体语法：</span><br><span class="line">- &amp;实体名字;</span><br><span class="line">(空格：<span class="symbol">&amp;nbsp;</span></span><br><span class="line">大于号：<span class="symbol">&amp;gt;</span></span><br><span class="line">小于号：<span class="symbol">&amp;lt;</span></span><br><span class="line">版权符号：<span class="symbol">&amp;copy;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7-meta标签"><a href="#7-meta标签" class="headerlink" title="7.meta标签"></a>7.meta标签</h2><p>meta主要用于设置网页中的一些元数据，元数据不是给用户看的<br>charset - 指定网页的字符集<br>name - 指定的数据的名称<br>content - 指定的数据的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML5,前端,CSS3&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">keywords表示网站的关键字，可以同时指定多个关键字，关键字之间使用，隔开</span><br><span class="line"></span><br><span class="line">description 用于指定网站的描述</span><br></pre></td></tr></table></figure>

<h2 id="8-语义化标签-块元素、行内元素（P16-P18）"><a href="#8-语义化标签-块元素、行内元素（P16-P18）" class="headerlink" title="8.语义化标签 + 块元素、行内元素（P16-P18）"></a>8.语义化标签 + 块元素、行内元素（P16-P18）</h2><p>块元素：在页面中独占一行的元素（block element），网页中一般通过块元素进行布局</p>
<ul>
<li>p标签表示页面中的一个段落，块元素</li>
<li>h1~h6标签，标题，块元素</li>
<li>hgroup标签用来为标题分组，可以将一组相关的标题同时放入到hgroup</li>
</ul>
<p>行内元素：在页面中不会独占一行的元素（inline element），主要用于包裹文字</p>
<ul>
<li>em标签表示语音语调的加重,行内元素</li>
<li>strong标签表示强调 </li>
</ul>
<p>一般情况下，会在块元素中放置行内元素，而不会在行内元素中放置块元素；<br>块元素中基本什么元素都能放，特殊情况：p元素中不能放置块元素</p>
<h2 id="9-列表list（P19）"><a href="#9-列表list（P19）" class="headerlink" title="9.列表list（P19）"></a>9.列表list（P19）</h2><p>html中列表一共三种：</p>
<ul>
<li>有序列表</li>
<li>无序列表</li>
<li>定义列表<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.有序列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.无序列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3.定义列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
定义列表效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211011141506.png"></li>
</ul>
<h2 id="10-超链接（P20）"><a href="#10-超链接（P20）" class="headerlink" title="10.超链接（P20）"></a>10.超链接（P20）</h2><p>超链接：可以从一个页面跳转到其他页面，或者当前页面的其他位置<br>使用a标签定义超链接<br>  属性：<br>    href → 指定跳转的目标路径<br>    target → 用来指定超链接打开的位置<br>   <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220316192446.png"></p>
<p>超链接，行内元素，在a标签中可以嵌套除自身外的任何元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>的作用和<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>相同</span><br></pre></td></tr></table></figure>
<h3 id="相对路径（P21）"><a href="#相对路径（P21）" class="headerlink" title="相对路径（P21）"></a>相对路径（P21）</h3><p>当需要跳转到服务器内部的页面是，一般使用相对路径，相对路径都会使用.或..开头，如果不写./或../则相当于写了./<br>./表示当前文件所在的目录<br>../表示当前文件所在目录的上一级目录</p>
<h2 id="11-图片标签（P23-P24）"><a href="#11-图片标签（P23-P24）" class="headerlink" title="11.图片标签（P23,P24）"></a>11.图片标签（P23,P24）</h2><p>img标签是一个自结束标签<br>属性：</p>
<ul>
<li>src属性指定的是外部图片路径（路径规则和超链接相同）</li>
<li>width 图片宽度</li>
<li>height 图片高度<br>-宽度和高度如果只修改了一个，则另一个会等比例缩放</li>
</ul>
<p>图片格式：</p>
<ul>
<li>jepg(jpg)-支持的颜色比较丰富，不支持透明效果，不支持动图</li>
<li>gif-支持的颜色比较少，支持简单透明，支持动图</li>
<li>png-支持的颜色丰富，支持复杂透明，不支持动图</li>
<li>webp-这种格式是谷歌新推出的专门用来表示网页中的图片的一种格式，具备其他图片格式的所有优点，而且文件特别小/缺点：兼容性差/</li>
<li>base64-将图片使用base64进行编码，这样可以直接通过字符形式引入图片，一般用于需要和网页同时加载的图片才会使用base64</li>
</ul>
<h2 id="12-内联框架（P25）"><a href="#12-内联框架（P25）" class="headerlink" title="12.内联框架（P25）"></a>12.内联框架（P25）</h2><p>iframe标签，用于在当前页面中引入其他页面<br>属性：</p>
<ul>
<li>src指定要引入的网页的路径 </li>
<li>frameborder 指定内联框架的边框</li>
</ul>
<h2 id="13-音视频播放（P26）"><a href="#13-音视频播放（P26）" class="headerlink" title="13.音视频播放（P26）"></a>13.音视频播放（P26）</h2><p>音视频文件引入时，默认情况下不允许用户自己控制播放停止。</p>
<p>audio标签 用来向页面中引入外部音频文件<br>属性：controls 是否允许用户控制播放<br>autoplay 音频文件是否自动播放<br>loop 音频文件是否循环播放</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;***&quot;</span> <span class="attr">contorls</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>video标签 引入视频文件<br>使用方式和audio标签一致</p>
<p>video标签示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;250&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/media/cc0-videos/flower.webm&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/media/cc0-videos/flower.mp4&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    Sorry, your browser doesn&#x27;t support embedded videos.</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当视频的媒体数据加载期间发生错误时执行 JavaScript :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">onerror</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="14-表格（P96-P97）"><a href="#14-表格（P96-P97）" class="headerlink" title="14.表格（P96-P97）"></a>14.表格（P96-P97）</h2><p>网页中通过table标签来创建表格<br>在table中使用tr表示表格中的一行，有几个tr就有几行，在tr中使用td表示一个单元格，有几个td就有几个单元格<br>colspan 横向的合并单元格； rowsoan 纵向合并单元格</p>
<p>可以将一个表格分为三部分：</p>
<ol>
<li>头部 thead</li>
<li>主体 tbody</li>
<li>底部 tfoot</li>
</ol>
<p>th 表示头部单元格</p>
<h4 id="14-1-表格的样式（P98）"><a href="#14-1-表格的样式（P98）" class="headerlink" title="14.1 表格的样式（P98）"></a>14.1 表格的样式（P98）</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.border-spacing 指定边框之间的距离 */</span></span><br><span class="line">  <span class="comment">/* 此时边框的宽度为2px */</span></span><br><span class="line">  <span class="attribute">border-spacing</span>：<span class="number">0px</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 2.border-collapse: collapse; 设置边框的合并 */</span></span><br><span class="line">   <span class="comment">/* 此时边框的宽度为1px */</span></span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n)&#123;</span><br><span class="line">  <span class="comment">/* 调整表格偶数行的背景颜色 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果表格中没有使用tbody而直接使用tr，那么浏览器会自动创建一个tbody，并且将所有的tr都放到tbody中，因此tr不再是tbody的子元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &gt; <span class="selector-tag">tr</span> &#123;</span><br><span class="line">  <span class="comment">/* 此时效果无法生效 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下元素在td中是垂直居中的，可以通过 vertical-align 来修改</p>
<h2 id="15-表单（P99）"><a href="#15-表单（P99）" class="headerlink" title="15.表单（P99）"></a>15.表单（P99）</h2><p>网页中的表单用于将本地的数据提交给远程的服务器，使用form标签来创建一个表单<br>form的属性：</p>
<ul>
<li>action 表单要提交的服务器的地址<br>表单项：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文本框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;数据提交给服务器必须指定唯一的名称&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;指定显示文字&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 密码框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;**&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 单选按钮 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 像这种选择框，必须要指定一个value属性，value属性最终会作为用户的填写的值传递给服务器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- checked可以将单选按钮设置为默认选中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;**&quot;</span> <span class="attr">value</span>=<span class="string">&quot;**&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;**&quot;</span> <span class="attr">value</span>=<span class="string">&quot;**&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下拉列表 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- selected 属性设置默认选中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">selected</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 重置按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 普通按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
autocomplete=”off” 关闭自动补全<br>readonly 将表单项设置为只读，数据会提交到服务器端<br>disabled 将表单项设置为禁用，数据不会提交到服务器端<br>autofocus 设置表单项自动获取焦点</li>
</ul>
<h1 id="二、CSS（P27-P28）"><a href="#二、CSS（P27-P28）" class="headerlink" title="二、CSS（P27-P28）"></a>二、CSS（P27-P28）</h1><p>CSS 层叠样式表<br>网页实际上是一个多层结构，通过CSS可以分别为网页的每一层来设计样式，而最终我们能看到的只是网页的最上边一层<br>使用方式：</p>
<ul>
<li>内联样式/行内样式：在标签内部通过style属性来设置元素样式</li>
<li><ul>
<li>问题：样式只对一个标签生效、希望影响多个元素必须在每一个元素中都复制一遍，并且样式发生变化时，我们必须要一个一个的修改，不方便维护</li>
</ul>
</li>
<li><ul>
<li>注意：开发时绝对不要使用内联样式</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>内部样式表：将样式编写到head中的style标签里然后通过CSS选择器来选中元素并为其设置各种样式，可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用</li>
<li>内部样式更加方便对样式进行复用</li>
<li><ul>
<li>问题：内部样式表只能对一个网页起作用，内部样式不能跨页面复用</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>外部样式表：将CSS样式编写到外部CSS文件中，然后通过link标签引入外部CSS文件<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;****&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>意味着只要想使用这些样式的网页都可以对其进行引用，使样式可以在不同页面之间进行复用</li>
<li>将样式编写到外部的CSS文件中，可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户的体验</li>
</ul>
<h2 id="1-CSS基本语法（P29）"><a href="#1-CSS基本语法（P29）" class="headerlink" title="1.CSS基本语法（P29）"></a>1.CSS基本语法（P29）</h2><p>CSS注释 - /* 注释内容 */<br>CSS的基本语法：<br>  选择器 声明块</p>
<ul>
<li>选择器：通过选择器可以选中页面中的指定元素（比如p的作用是选中页面中所有的p元素）</li>
<li>声明块：通过声明块来指定要为元素设置的样式。</li>
<li><ul>
<li>声明块由一个一个的声明组成</li>
</ul>
</li>
<li><ul>
<li>声明是一个名值对结构,一个样式名对应一个样式值，名和值之间以:连接，以;结尾</li>
</ul>
</li>
</ul>
<h2 id="2-常用选择器（P30）"><a href="#2-常用选择器（P30）" class="headerlink" title="2.常用选择器（P30）"></a>2.常用选择器（P30）</h2><p>1.元素选择器</p>
<ul>
<li>作用：根据标签名来选中指定的元素</li>
<li>语法：标签名{}</li>
<li>例子：p{}、 h1{} 、div{}</li>
</ul>
<p>2.id选择器</p>
<ul>
<li>作用：根据元素的id属性值选中一个元素</li>
<li>语法：#id属性值{}</li>
<li>例子：#box{}、#red{}</li>
</ul>
<p>3.类选择器<br>class是一个标签属性，它和id类似，不同的是class可以重复使用，通过class属性可以为元素分组,可以同时为一个元素指定多个class属性</p>
<ul>
<li>作用：根据元素class属性值选中一组元素</li>
<li>语法：.class属性值{}</li>
</ul>
<p>4.通配选择器</p>
<ul>
<li>作用：选中页面中的所有元素</li>
<li>语法：*{}</li>
</ul>
<h2 id="3-复合选择器（P31）"><a href="#3-复合选择器（P31）" class="headerlink" title="3.复合选择器（P31）"></a>3.复合选择器（P31）</h2><p>1.交集选择器</p>
<ul>
<li>作用：选中同时符合多个条件的元素</li>
<li>语法：选择器1选择器2选择器3……选择器n{}</li>
<li><ul>
<li>注意点：交集选择器中如果有元素选择器，必须使用元素选择器开头（例如：<strong>div.red{}</strong>不能写成<strong>.reddiv{}</strong>）</li>
</ul>
</li>
</ul>
<p>2.选择器分组（并集选择器）</p>
<ul>
<li>作用：同时选择多个选择器对应的元素</li>
<li>语法：选择器1,选择器2,选择器3,……,选择器n{}（例如：#b1,.p1,h1,span,div.red{}）</li>
</ul>
<h2 id="4-关系选择器（P32）"><a href="#4-关系选择器（P32）" class="headerlink" title="4.关系选择器（P32）"></a>4.关系选择器（P32）</h2><p>父元素–直接包含子元素的元素叫做父元素<br>子元素–直接被父元素包含的元素是子元素<br>祖先元素–直接或间接包含后代元素的元素叫做祖先元素、–一个元素的父元素也是它的祖先元素<br>后代元素–直接或间接被祖先元素包含的元素叫做后代元素<br>兄弟元素–拥有相同父元素的元素是兄弟元素</p>
<p>1.子元素选择器</p>
<ul>
<li>作用：选中指定父元素的指定子元素</li>
<li>语法：父元素 &gt; 子元素{}</li>
</ul>
<p>2.后代元素选择器</p>
<ul>
<li>作用：选中指定元素内的指定后代元素</li>
<li>语法：祖先 &nbsp; 后代{}（例如：div &nbsp; span {}）</li>
</ul>
<p>3.兄弟元素选择器</p>
<ul>
<li>作用：选择下一个兄弟元素</li>
<li>语法：前一个+下一个{}(只有两个元素紧挨着才会生效)<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>紧跟着1<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>非紧挨着2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">div + span&#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!-- 只有 紧跟着1 颜色是红色 --&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>4.选择下面所有的兄弟元素</p>
<ul>
<li>语法：兄 ~ 弟{}</li>
</ul>
<h2 id="5-属性选择器（P33）"><a href="#5-属性选择器（P33）" class="headerlink" title="5.属性选择器（P33）"></a>5.属性选择器（P33）</h2><p>[属性名] 选择含有指定属性的元素<br>[属性名=属性值] 选择含有指定属性和属性值的元素<br>[属性名^=属性值] 选择属性值以指定值开头的元素<br>[属性名$=属性值] 选择属性值以指定值结尾的元素<br>[属性名*=属性值] 选择属性值中含有某值的元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title=abc]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title^=abc]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title$=abc]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title*$*=abc]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-伪类选择器"><a href="#6-伪类选择器" class="headerlink" title="6.伪类选择器"></a>6.伪类选择器</h2><ol>
<li>伪类（不存在的类，特殊的类） （P34）</li>
</ol>
<ul>
<li>伪类用来描述一个元素的特殊状态，比如：第一个子元素、被点击元素、鼠标移入的元素……</li>
<li>伪类一般情况下都是使用:开头，如 </li>
<li><ul>
<li>:first-child 第一个子元素</li>
</ul>
</li>
<li><ul>
<li>:last-child 最后一个子元素</li>
</ul>
</li>
<li><ul>
<li>:nth-child(n) 选中第n个子元素(特殊值：<strong>1.</strong> n,第n个，n的范围0到正无穷；<strong>2.</strong>2n或even 表示选中偶数位的元素；<strong>3.</strong>2n+1或odd 表示选中奇数位的元素)</li>
</ul>
</li>
</ul>
<h2 id="以上这些伪类都是根据所有元素进行排序"><a href="#以上这些伪类都是根据所有元素进行排序" class="headerlink" title="以上这些伪类都是根据所有元素进行排序"></a>以上这些伪类都是根据所有元素进行排序</h2><ul>
<li><ul>
<li>:first-of-type</li>
</ul>
</li>
<li><ul>
<li>:last-of-type</li>
</ul>
</li>
<li><ul>
<li>:nth-of-type()</li>
</ul>
</li>
</ul>
<h2 id="这几个伪类的功能和上述的类似，不同点是它们在同类型元素中进行排序"><a href="#这几个伪类的功能和上述的类似，不同点是它们在同类型元素中进行排序" class="headerlink" title="这几个伪类的功能和上述的类似，不同点是它们在同类型元素中进行排序"></a>这几个伪类的功能和上述的类似，不同点是它们在同类型元素中进行排序</h2><ul>
<li><ul>
<li>:not() 否定伪类：将符合条件的元素从选择器中去除<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220103175630.png"><br>将所有的p标签背景都换成黄色，除了class为hello的</li>
</ul>
</li>
</ul>
<p>2.a元素的伪类（P35）</p>
<ul>
<li>:link 用于选取未被访问的链接</li>
<li>:visited 用来表示访问过的链接（由于隐私的原因，所以visited这个伪类只能修改链接的颜色）<br>上述两个伪类只对a元素生效</li>
<li>:hover 用来表示鼠标移入的状态</li>
<li>:active 用来表示鼠标点击的状态</li>
</ul>
<h2 id="7-伪元素选择器（P36）"><a href="#7-伪元素选择器（P36）" class="headerlink" title="7.伪元素选择器（P36）"></a>7.伪元素选择器（P36）</h2><p>伪元素，表示页面中一些特殊的并不真实存在的元素（特殊位置），伪元素使用::开头</p>
<ul>
<li>::first-letter 表示第一个字母</li>
<li>::first-line 表示第一行</li>
<li>::selection 表示选中的内容</li>
</ul>
<hr>
<ul>
<li>::before 元素的开始位置</li>
<li>::after 元素的最后位置</li>
</ul>
<p>注意：before 和 after 必须结合content属性来使用</p>
<h4 id="练习项目：餐厅选择器"><a href="#练习项目：餐厅选择器" class="headerlink" title="[练习项目：餐厅选择器]"></a>[练习项目：餐厅选择器]</h4><p><a href="https://github.com/qw-null/CSS-selector-practice/tree/master">餐厅选择器</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211015160542.png"></p>
<h2 id="8-样式的继承（P38）"><a href="#8-样式的继承（P38）" class="headerlink" title="8.样式的继承（P38）"></a>8.样式的继承（P38）</h2><p>样式的继承，我们为一个元素设置的样式同时也会应用到它的后代元素上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  我是一个P元素</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是P元素中的span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是P元素外的span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211016152351.png"></p>
<p>注意：并不是所有的样式都会被继承（比如：背景相关的，布局相关等的这些样式都不会被继承）</p>
<h2 id="9-选择器的权重（P39）"><a href="#9-选择器的权重（P39）" class="headerlink" title="9.选择器的权重（P39）"></a>9.选择器的权重（P39）</h2><p>样式的冲突：</p>
<ul>
<li>当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值，此时就发生了样式的冲突</li>
</ul>
<p>发生样式冲突时，应用哪个样式由选择器的权重（优先级）决定<br>选择器权重：</p>
<ul>
<li>内联样式–1000</li>
<li>id选择器–100</li>
<li>类和伪类选择器–10</li>
<li>元素选择器–1</li>
<li>通配选择器–0</li>
<li>继承的样式–没有优先级</li>
</ul>
<p>比较优先级时，需要将所有的选择器的优先级进行相加，最后优先级越高，则越优先显示（分组选择器是单独计算的）<br>选择器的累加不会超过其最大的数量级（类选择器再高也不会超过id选择器）<br>如果优先级计算相同，此时优先使用靠下的样式<br>可以在某一个样式后面添加!important，此时该样式会获得最高的优先级，甚至超过内联样式【注意：在开发中，一定要慎用！】</p>
<h2 id="10-长度单位"><a href="#10-长度单位" class="headerlink" title="10.长度单位"></a>10.长度单位</h2><h4 id="像素和百分比（P40）"><a href="#像素和百分比（P40）" class="headerlink" title="像素和百分比（P40）"></a>像素和百分比（P40）</h4><ul>
<li>像素：屏幕（显示器）实际上是由一个个的小点构成的，不同屏幕的像素大小是不同的，像素越小的屏幕显示效果越清晰，所以同样的200px在不同的设备下显示效果不同</li>
<li>百分比：也可以将属性值设置为相对于其父元素（<em>这种说法不严谨</em>）属性的百分比</li>
</ul>
<h4 id="em和rem（P41）"><a href="#em和rem（P41）" class="headerlink" title="em和rem（P41）"></a>em和rem（P41）</h4><ul>
<li>em：em是相对于元素的字体大小来计算，1em=1font-size,em会根据字体大小的改变而改变、</li>
<li>rem：rem是相对于根元素的字体大小来计算</li>
</ul>
<h2 id="11-文档流（P44）"><a href="#11-文档流（P44）" class="headerlink" title="11.文档流（P44）"></a>11.文档流（P44）</h2><ul>
<li>网页是一个多层结构，一层摞着一层，通过CSS可以分别为每一层来设置样式，作为用户只能看到最顶层内容，在这些层中，最底下一层称为文档流，文档流是网页的基础</li>
<li>我们所创建的元素默认都是在文档流中进行排列</li>
<li>元素主要是有两个状态</li>
<li><ul>
<li>在文档流中</li>
</ul>
</li>
<li><ul>
<li>不在文档流中（脱离文档流）</li>
</ul>
</li>
</ul>
<h5 id="元素在文档流中的特点："><a href="#元素在文档流中的特点：" class="headerlink" title="元素在文档流中的特点："></a>元素在文档流中的特点：</h5><ul>
<li>块元素</li>
<li><ul>
<li>块元素在文档流中独占一行</li>
</ul>
</li>
<li><ul>
<li>默认宽度是父元素的全部（会把父元素撑满）</li>
</ul>
</li>
<li><ul>
<li>默认高度是被内容撑开（子元素）</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>行内元素</li>
<li><ul>
<li>行内元素不会独占页面的一行，只占自身大小</li>
</ul>
</li>
<li><ul>
<li>行内元素在页面中由左向右水平排列，如果一行之中不能容纳下所有行内元素，则元素会换到第二行继续自左向右排列</li>
</ul>
</li>
<li><ul>
<li>行内元素的默认宽度和高度都是被内容撑开</li>
</ul>
</li>
</ul>
<h2 id="12-盒模型-box-model（P45）"><a href="#12-盒模型-box-model（P45）" class="headerlink" title="12.盒模型 box model（P45）"></a>12.盒模型 box model（P45）</h2><p>CSS将页面中的所有元素都设置为一个矩形的盒子，将元素设置为矩形的盒子后，对页面布局就变成将不同的盒子摆放到不同的位置<br>每一个盒子都由内容区（content）、边框（border）、内边距（padding）、外边距（margin）  组成<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211018114632.png"></p>
<ul>
<li>内容区（content）：元素中所有的子元素和文本内容都在内容区中排列。</li>
<li><ul>
<li>内容区的大小有width和height两个属性来设置</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>边框（border）：边框属于盒子边缘。<em>边框的大小会影响到整个盒子的大小</em>（P46）</li>
<li><ul>
<li>设置边框需要设置三个样式：边框宽度（border-width）、边框颜色（border-color）、边框样式（border-style）</li>
</ul>
</li>
<li> 边框宽度（border-width），默认值一般都是3个像素，可以用来指定四个方向的边框的宽度</li>
<li><ul>
<li><b>四个值：</b>上、右、下、左；<b>三个值：</b>上、左右、下；<b>两个值：</b>上下、左右</li>
</ul>
</li>
<li><ul>
<li>除了border-width还有一组border-xxx-width，其中xxx可以是left、right、top、bottom，用来单独指定某一个边的宽度</li>
</ul>
</li>
<li>border-style指定边框的样式，默认值为none</li>
<li><ul>
<li>值：solid 表示实线；dotted表示点状虚线；dashed表示虚线；double表示双线</li>
</ul>
</li>
<li>border简写属性，通过该属性可以同时设置边框所有的相关样式。例如：<br>border:10px red solid;</li>
</ul>
<hr>
<ul>
<li>内边距（padding）(P47)<br>内容区和边框之间的距离是内边距，一共四个方向的内边距（padding-top、padding-bottom、padding-left、padding-right）</li>
<li><ul>
<li>内边距的设置会影响到盒子的大小，背景颜色会延伸到内边距上</li>
</ul>
</li>
<li><ul>
<li>padding内边距的简写属性，可以同时指定四个方向的内边距，规则和border-width一样 </li>
</ul>
</li>
</ul>
<p>一个盒子的可见框的大小，由内容区、内边距和边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算</p>
<hr>
<ul>
<li>外边距（margin）(P48)<br>外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置，一共四个方向的外边距（margin-top、margin-bottom、margin-left、margin-right）</li>
<li><ul>
<li>元素在页面中是按照自左向右顺序排列，所以默认设置左和上外边距则会移动元素，而设置下和右外边距会移动其他元素</li>
</ul>
</li>
<li><ul>
<li>margin也可以设置为负值，如果是负值则元素会向相反的方向移动</li>
</ul>
</li>
<li><ul>
<li>margin外边距的简写属性，可以同时指定四个方向的外边距，规则和border-width一样</li>
</ul>
</li>
</ul>
<h2 id="13-盒子模型水平方向的布局（P49）"><a href="#13-盒子模型水平方向的布局（P49）" class="headerlink" title="13.盒子模型水平方向的布局（P49）"></a>13.盒子模型水平方向的布局（P49）</h2><p>元素的水平方向的布局：元素在其父元素中水平方向的位置由以下几个属性共同决定：margin-left、border-left、padding-left、width、padding-right、border-right、margin-right</p>
<p>一个元素在其父元素中，水平布局必须满足以下等式：<br>子元素的margin-left+border-left+padding-left+width+padding-right+border-right+margin-right=其父元素内容区的宽度（必须满足）</p>
<ul>
<li>上述等式必须满足，如果相加结果使等式不成立，则称为过度约束，则等式会自动调整</li>
<li>调整情况：如果这七个值中没有auto的情况，则浏览器会自动调整margin-right值以使等式满足</li>
<li>这七个值中有三个值可以设置为auto：width、margin-left、margin-right，如果某个值为auto，则会自动调整为auto的那个值以使得等式成立</li>
<li>设置元素在其父元素中水平居中<br>width:500px; /* 必须指定宽度值 */<br>margin: 0 auto;  </li>
</ul>
<h2 id="14-盒子模型垂直方向的布局（P50）"><a href="#14-盒子模型垂直方向的布局（P50）" class="headerlink" title="14.盒子模型垂直方向的布局（P50）"></a>14.盒子模型垂直方向的布局（P50）</h2><p>子元素是在父元素的内容区中排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出，使用<b>overflow属性</b>来设置父元素如何处理溢出的子元素<br>overflow属性可选值：</p>
<ul>
<li>visible,默认值，子元素会从父元素中溢出，在父元素外部的位置显示</li>
<li>hidden，溢出的内容将会被裁剪不会显示</li>
<li>scroll，生成两个滚动条，通过滚动条来查看完整内容</li>
<li>auto，根据需要生成滚动条</li>
</ul>
<p>overflow-x，overflow-y分别处理水平方向和垂直方向子元素溢出问题，取值和overflow相同。</p>
<h2 id="15-盒子模型外边距的折叠（P51）"><a href="#15-盒子模型外边距的折叠（P51）" class="headerlink" title="15.盒子模型外边距的折叠（P51）"></a>15.盒子模型外边距的折叠（P51）</h2><p>外边距的重叠（折叠）：</p>
<ul>
<li><p>相邻的垂直方向外边距会发生重叠现象</p>
</li>
<li><p>兄弟元素</p>
</li>
<li><ul>
<li>兄弟元素间的相邻垂直外边距会取两者之间的较大值（正值），特殊情况：如果相邻的外边距一正一负，则取两者的和；如果相邻的外边距都是负值，则取两者中绝对值较大的</li>
</ul>
</li>
<li><ul>
<li>兄弟元素之间的外边距的重叠，对于开发是有利的，所以不需要进行处理</li>
</ul>
</li>
<li><p>父子元素</p>
</li>
<li><ul>
<li>父子元素间的相邻外边距，子元素的会传递给父元素（上外边距）</li>
</ul>
</li>
<li><ul>
<li>父子外边距折叠会影响到页面布局，必须进行处理</li>
</ul>
</li>
</ul>
<h2 id="16-行内元素的盒模型（P52）"><a href="#16-行内元素的盒模型（P52）" class="headerlink" title="16.行内元素的盒模型（P52）"></a>16.行内元素的盒模型（P52）</h2><p>行内元素的盒模型：</p>
<ul>
<li>行内元素不支持设置宽度和高度</li>
<li>行内元素可以设置padding，但是垂直方向padding不会影响页面的布局</li>
<li>行内元素可以设置border，垂直方向的border不会影响页面的布局</li>
<li>行内元素可以设置margin，垂直方向的margin不会影响布局</li>
</ul>
<p>display属性，用来设置元素显示类型<br>可选值：</p>
<ul>
<li>inline 将元素设置为行内元素</li>
<li>block 将元素设置为块元素</li>
<li>inline-block 将元素设置为行内块元素（行内块，既可以设置宽度和高度，又不会独占一行）</li>
<li>table 将元素设置为一个表格</li>
<li>none 元素不在页面显示</li>
</ul>
<p>visibility 用来设置元素的显示状态<br>可选值：</p>
<ul>
<li><b>visible</b> 默认值，元素在页面中正常显示;</li>
<li><b>hidden</b>元素在页面中隐藏，不显示，但是依然占据页面的位置</li>
</ul>
<h2 id="17-浏览器的默认样式"><a href="#17-浏览器的默认样式" class="headerlink" title="17.浏览器的默认样式"></a>17.浏览器的默认样式</h2><p>浏览器的默认样式：</p>
<ul>
<li>通常情况下，浏览器都会为元素设置一些默认样式，默认样式的存在会影响到页面的布局，通常情况下编写网页时必须要去除浏览器的默认样式（PC端的页面）</li>
<li>引入css文件清除默认样式</li>
<li><ul>
<li><a href="https://meyerweb.com/eric/tools/css/reset/">CSS Tools: Reset CSS</a></li>
</ul>
</li>
<li><ul>
<li><a href="https://github.com/necolas/normalize.css/">normalize.css</a></li>
</ul>
</li>
</ul>
<h2 id="练习题（P54-P58）"><a href="#练习题（P54-P58）" class="headerlink" title="练习题（P54-P58）"></a>练习题（P54-P58）</h2><p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P54%E5%B8%83%E5%B1%80%E7%BB%83%E4%B9%A0">京东图片列表，京东左侧导航栏，网易新闻列表</a></p>
<h2 id="18-盒子的大小（P58）"><a href="#18-盒子的大小（P58）" class="headerlink" title="18.盒子的大小（P58）"></a>18.盒子的大小（P58）</h2><p>默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定。<br>box-sizing 用来设置盒子尺寸的计算方式（设置width和height的作用）<br>可选值：</p>
<ul>
<li>content-box 默认值，宽度和高度用来设置内容区的大小</li>
<li>border-box 宽度和高度用来设置整个盒子可见框的大小（width和height指的是内容区、内边距和边框的总大小）</li>
</ul>
<h2 id="19-轮廓阴影和圆角（P59）"><a href="#19-轮廓阴影和圆角（P59）" class="headerlink" title="19.轮廓阴影和圆角（P59）"></a>19.轮廓阴影和圆角（P59）</h2><p>outline 用来设置元素的轮廓线，用法和border相同，【outline和border不同点是outline不会影响可见框的大小】</p>
<p>box-shadow用来设置元素的阴影效果，阴影不会影响页面布局<br>box-shadow:水平偏移量 &nbsp; 垂直偏移量&nbsp;模糊半径&nbsp; 颜色;</p>
<ul>
<li>第一个值：水平偏移量，设置阴影的水平位置，正值向右移动，负值向左移动</li>
<li>第二个值：垂直偏移量，设置阴影的垂直位置，正值向下移动，负值向上移动</li>
<li>第三个值：阴影的模糊半径</li>
<li>第四个值：阴影颜色，一般使用rgba保证阴影的透明度</li>
</ul>
<p>border-radius设置圆角，还可以单独设置border-top-left-radius、border-top-right-radius、border-bottom-left-radius、border-bottom-right-radius<br>border-radius可以分别指定四个角的圆角</p>
<ul>
<li>四个值：左上、右上、右下、左下</li>
<li>三个值：左上、右上/左下、右下</li>
<li>两个值：左上/右下、右上/左下</li>
</ul>
<h2 id="20-浮动（P60-P61）"><a href="#20-浮动（P60-P61）" class="headerlink" title="20.浮动（P60-P61）"></a>20.浮动（P60-P61）</h2><p>通过浮动可以使一个元素向其父元素的左侧或者右侧移动，通过float属性来设置元素的浮动。<br>float可选值:</p>
<ul>
<li>none 默认值，元素不浮动</li>
<li>left 元素向左浮动</li>
<li>right 元素向右浮动</li>
</ul>
<p>元素设置浮动以后，会完全从文档流中脱离，不再占用文档流中的位置，因此元素下边的还在文档流中的元素会自动向上移动</p>
<p>浮动的特点：</p>
<ul>
<li>1.浮动元素会完全脱离文档流，不再占据文档流中的位置</li>
<li>2.设置浮动以后元素会向父元素的左侧或右侧移动</li>
<li>3.浮动元素默认不会从父元素中移出</li>
<li>4.浮动元素向左或向右移动时，不会超过它前面的其他浮动元素</li>
<li>5.如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移</li>
<li>6.浮动元素不会超过它上面的浮动的兄弟元素，最多是和其兄弟元素一样高</li>
<li>7.浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，因此可以利用浮动来实现文字环绕图片效果</li>
<li>8.元素设置浮动以后，将会从文档流中脱离，从文档流中脱离后，元素的一些特点也会发生改变</li>
</ul>
<p>简单总结：浮动目前来讲主要作用就是让页面中的元素可以水平排列，通过浮动可以制作一些水平方向的布局</p>
<p><span style="font-size:20px;font-weight:700;">脱离文档流的特点：</span></p>
<ul>
<li>块元素：</li>
<li><ul>
<li>1.块元素不再独占页面一行</li>
</ul>
</li>
<li><ul>
<li>2.脱离文档流之后，默认宽度和高度都是被内容撑开</li>
</ul>
</li>
<li>行内元素：</li>
<li><ul>
<li>行内元素脱离文档流之后会变成块元素，特点和块元素一样</li>
</ul>
</li>
</ul>
<p>脱离文档流之后，不需要再区分块元素和行内元素</p>
<h2 id="浮动练习–导航条（P62）"><a href="#浮动练习–导航条（P62）" class="headerlink" title="浮动练习–导航条（P62）"></a>浮动练习–导航条（P62）</h2><p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P62%E5%AF%BC%E8%88%AA%E6%9D%A1%E7%BB%83%E4%B9%A0">导航条</a><br>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211026103344.png"></p>
<h2 id="21-高度塌陷和BFC（P64）"><a href="#21-高度塌陷和BFC（P64）" class="headerlink" title="21.高度塌陷和BFC（P64）"></a>21.高度塌陷和BFC（P64）</h2><p><b>高度塌陷问题：</b><br>在浮动布局中，父元素高度默认是被子元素撑开，当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离，将会无法撑起父元素的高度，导致父元素的高度丢失。<br>父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱，所以高度塌陷是浮动布局中比较常见的一个问题，必须要进行处理。</p>
<p><b>BFC（Block Formatting Context，块级格式化环境）</b><br>BFC是一个CSS中的一个隐含属性，可以为一个元素开启BFC，开启BFC后，该元素会变成一个独立的布局区域</p>
<p>元素开启BFC后的特点：</p>
<ul>
<li>开启BFC的元素不会被浮动元素所覆盖</li>
<li>开启BFC的元素子元素和父元素外边距不会重叠</li>
<li>开启BFC的元素可以包含浮动的子元素</li>
</ul>
<p>可以通过一些特殊的方式来开启元素的BFC：</p>
<ul>
<li>1.设置元素的浮动<b>【不推荐】</b></li>
<li>2.将元素设置为行内块元素（inline-block）<b>【不推荐】</b></li>
<li>3.将元素的overflow设置为一个非visible的值</li>
<li><ul>
<li>常用方式：为元素设置overflow:hidden开启其BFC，以使其可以包含浮动元素，<b>overflow:hidden要赋值给不想要被影响的元素</b></li>
</ul>
</li>
</ul>
<p> 推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。</p>
<h2 id="22-解决高度塌陷问题"><a href="#22-解决高度塌陷问题" class="headerlink" title="22.解决高度塌陷问题"></a>22.解决高度塌陷问题</h2><h4 id="22-1-clear属性（P66）"><a href="#22-1-clear属性（P66）" class="headerlink" title="22.1 clear属性（P66）"></a>22.1 clear属性（P66）</h4><p>例子引入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#bfa</span>;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box3</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211028105107.png"><br>由于box1的浮动，导致box3位置上移，也就是box3受到了box1浮动的影响，位置发生了改变。<br>如果我们不希望某个元素因为其他元素浮动的影响而改变位置，可以通过clear属性来清除浮动元素对当前元素产生的影响。</p>
<p>clear属性</p>
<ul>
<li>作用：清除浮动元素对当前元素所产生的影响</li>
<li>可选值：</li>
<li><ul>
<li>left 清除左侧浮动元素对当前元素产生的影响</li>
</ul>
</li>
<li><ul>
<li>right 清除右侧浮动元素对当前元素的影响</li>
</ul>
</li>
<li><ul>
<li>both 清除两侧中最大影响的那侧（谁的高度大，就清除谁的）</li>
</ul>
</li>
</ul>
<p>原理：设置清除浮动以后，浏览器会自动为元素添加一个上边距，以使其位置不受其他元素影响</p>
<p>例子：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211028141359.png"></p>
<h4 id="22-2-使用after伪类解决高度塌陷问题（P67）"><a href="#22-2-使用after伪类解决高度塌陷问题（P67）" class="headerlink" title="22.2.使用after伪类解决高度塌陷问题（P67）"></a>22.2.使用after伪类解决高度塌陷问题（P67）</h4><p>使用after伪类解决高度塌陷问题是解决高度塌陷的最终解决方案<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211028142356.png"></p>
<h4 id="补充知识：解决外边距重叠问题（P68）"><a href="#补充知识：解决外边距重叠问题（P68）" class="headerlink" title="补充知识：解决外边距重叠问题（P68）"></a>补充知识：解决外边距重叠问题（P68）</h4><p>问题情景：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211028142844.png"><br>解决方案：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211028143400.png"></p>
<p>clearfix这个样式可以同时解决高度塌陷和外边距重叠的问题，当遇到这些问题时，可以直接使用clearfix进行解决</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>:table;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23-position定位"><a href="#23-position定位" class="headerlink" title="23.position定位"></a>23.position定位</h2><p>定位(position)，是一种更加高级的布局手段，通过定位可以将元素摆放在页面的任意位置，使用position属性来设置定位<br>可选值：</p>
<ul>
<li>static 默认值，元素是静止的没有开启定位</li>
<li>relative 开启元素相对定位</li>
<li>absolute 开启元素绝对定位</li>
<li>fixed 开启元素的固定定位</li>
<li>sticky 开启元素的粘滞定位</li>
</ul>
<h4 id="23-1-相对定位relative（P69）"><a href="#23-1-相对定位relative（P69）" class="headerlink" title="23.1 相对定位relative（P69）"></a>23.1 相对定位relative（P69）</h4><p>position：relative;开启元素的相对定位。<br>特点：</p>
<ul>
<li>1.元素开启相对定位，如果不设置偏移量，元素不会发生任何的变化</li>
<li><ul>
<li>偏移量（offset）：当元素开启了定位之后，可以通过偏移量来设置元素的位置。</li>
</ul>
</li>
<li><ul>
<li>包含的值：</li>
</ul>
</li>
<li><ul>
<li>top———定位元素和定位位置上边的距离、bottom———定位元素和定位位置下边的距离【定位元素垂直方向的位置由top、bottom两个属性控制，通常情况下只会使用其一】</li>
</ul>
</li>
<li><ul>
<li>left———定位元素和定位位置左边的距离、right———定位元素和定位位置右边的距离【定位元素水平方向的位置由left、right两个属性控制，通常情况下只会使用其一】</li>
</ul>
</li>
<li>2.相对定位是参照于元素在文档流中的位置进行定位</li>
<li>3.相对定位会提升元素的层级</li>
<li>4.相对定位不会使元素脱离文档流</li>
<li>5.相对定位不会改变的的元素的性质，块元素还是块元素，行内元素还是行内元素</li>
</ul>
<h4 id="23-2-绝对定位absolute（P70）"><a href="#23-2-绝对定位absolute（P70）" class="headerlink" title="23.2 绝对定位absolute（P70）"></a>23.2 绝对定位absolute（P70）</h4><p>position：absolute;开启元素的绝对定位。<br>特点：</p>
<ul>
<li>1.元素开启绝对定位，如果不设置偏移量，<b><u>元素的位置</u></b>不会发生任何的变化</li>
<li>2.开启绝对定位后，元素会从文档流中脱离</li>
<li>3.绝对定位会改变元素的性质，行内变成块，块的高度被内容撑开</li>
<li>4.绝对定位会使得元素提升一个层级</li>
<li>5.绝对定位是相对于其包含块进行定位的</li>
<li><ul>
<li>包含块（containing block）</li>
</ul>
</li>
<li><ul>
<li>正常情况下包含块就是离当前元素最近的<b>祖先<u>块元素</u></b></li>
</ul>
</li>
<li><ul>
<li>绝对定位的包含块：包含块就是离它最近的开启了定位的祖先元素，如果所有祖先元素都没有开启定位，则根元素就是它的包含块</li>
</ul>
</li>
<li><ul>
<li>html（根元素、初始包含快）</li>
</ul>
</li>
</ul>
<h4 id="23-3-固定定位fixed（P71）"><a href="#23-3-固定定位fixed（P71）" class="headerlink" title="23.3 固定定位fixed（P71）"></a>23.3 固定定位fixed（P71）</h4><p>position:fixed;开启元素的固定定位。固定定位也是一种绝对定位，因此固定定位的大部分特点和绝对定位一样，唯一不同的是固定定位永远参照于浏览器的视口进行定位。<br>固定定位的元素不会随网页的滚动条滚动。</p>
<h4 id="23-4-粘滞定位sticky（P72）"><a href="#23-4-粘滞定位sticky（P72）" class="headerlink" title="23.4 粘滞定位sticky（P72）"></a>23.4 粘滞定位sticky（P72）</h4><p>position:sticky;开启元素的粘滞定位。粘滞定位和相对定位的特点基本一致，不同的是粘滞定位可以在元素到达某个位置时将其固定<br><strong>兼容性很差,了解即可</strong></p>
<h4 id="补充知识：绝对定位（P73）"><a href="#补充知识：绝对定位（P73）" class="headerlink" title="补充知识：绝对定位（P73）"></a>补充知识：绝对定位（P73）</h4><p>当开启绝对定位后：水平方向的布局等式就需要添加left和right两个值。<br>left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 包含块内容区的宽度</p>
<p>开启绝对定位后，水平方向的布局等式就需要添加left和right两个值，此时的规则和之前一样只是多添加了两个值。<br>当发生过度约束，如果9个值中没有auto，则自动调整right的值以使等式成立。<br>可以设置为auto的值：margin、width、left、right</p>
<p>垂直方向布局的等式也必须要满足：top + margin-top/bottom + padding-top/bottom + border-top/bottom + height = 包含块的高度</p>
<h5 id="使得元素水平垂直居中："><a href="#使得元素水平垂直居中：" class="headerlink" title="使得元素水平垂直居中："></a>使得元素水平垂直居中：</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.box2</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101104011.png"><br>关键代码：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101104122.png"></p>
<h2 id="24-元素的层级（P74）"><a href="#24-元素的层级（P74）" class="headerlink" title="24.元素的层级（P74）"></a>24.元素的层级（P74）</h2><p>对于开启了定位的元素，可以通过z-index属性来指定元素的层级，z-index需要一个整数作为参数，值越大元素的层级越高，元素的层级越高越优先显示。<br>如果元素层级一样，则优先显示靠下的元素。<br><strong>祖先元素的层级再高也不会盖住后代元素</strong></p>
<h2 id="京东轮播图布局练习"><a href="#京东轮播图布局练习" class="headerlink" title="京东轮播图布局练习"></a>京东轮播图布局练习</h2><p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P75%E4%BA%AC%E4%B8%9C%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%B8%83%E5%B1%80">京东轮播图布局</a></p>
<h2 id="25-字体相关的样式（P76）"><a href="#25-字体相关的样式（P76）" class="headerlink" title="25.字体相关的样式（P76）"></a>25.字体相关的样式（P76）</h2><p>color：用来设置字体颜色<br>font-size:字体大小</p>
<ul>
<li>和font-size相关的单位：</li>
<li>em 相当于当前元素的一个font-size</li>
<li>rem相当于根元素的一个font-size</li>
</ul>
<p>font-family:字体族（字体的格式），可选值：（字体分类）</p>
<ul>
<li>serif 衬线字体</li>
<li>sans-serif 非衬线字体</li>
<li>monospave 等宽字体</li>
</ul>
<p>指定字体类别，浏览器会自动使用该类别下的字体，font-family可以同时指定多个字体，多个字体间使用,隔开，字体生效时优先使用第一个，第一个无法使用则使用第二个，以此类推</p>
<p>@font-face可以将服务器中的字体直接提供给用户去使用。<br>存在问题：</p>
<ul>
<li>1.加载速度</li>
<li>2.版权</li>
<li>3.字体格式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101144230.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;myfont&#x27;</span>; <span class="comment">/* 指定字体名字 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">/* 服务器端中的地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;myfont&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-1-图标字体iconfont（P77-P78）"><a href="#25-1-图标字体iconfont（P77-P78）" class="headerlink" title="25.1 图标字体iconfont（P77-P78）"></a>25.1 图标字体iconfont（P77-P78）</h4><p>在网页中经常需要使用一些图标，可以通过图片来引入图标，但是图片大小本身比较大，并且非常不灵活。所以在使用图标时，我们还可以将图标直接设置为字体，然后通过font-face的形式来对字体进行引入，这样我们就可以通过使用字体的形式来使用图标。</p>
<p>font awesome使用步骤：</p>
<ul>
<li>1.<a href="https://fontawesome.com/">下载</a></li>
<li>2.解压</li>
<li>3.将css和webfonts移动到项目中<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101150302.png"></li>
<li>4.将all.css引入到网页中<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;(项目中的地址)**/css/all.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101150532.png"></li>
<li>5.使用图标字体</li>
<li><ul>
<li>直接通过类名来使用图标字体<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/your-path-to-fontawesome/css/all.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span> <span class="comment">&lt;!--load all styles --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="comment">&lt;!-- uses solid style --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;far fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="comment">&lt;!-- uses regular style --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fal fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="comment">&lt;!-- uses light style --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--brand icon--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fab fa-github-square&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="comment">&lt;!-- uses brands style --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
通过伪元素来设置图标字体</li>
</ul>
</li>
<li>1.找到要设置图标的 元素通过before或after选中</li>
<li>2.在content中设置字体编码</li>
<li>3.设置字体的样式<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在文件all.css中查找 */</span></span><br><span class="line"><span class="comment">/* fab */</span></span><br><span class="line"><span class="attribute">font-family</span>:<span class="string">&#x27;Font Awesome 5 Brands&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fas */</span></span><br><span class="line"><span class="attribute">font-family</span>:<span class="string">&#x27;Font Awesome 5 Free&#x27;</span>;</span><br><span class="line"><span class="attribute">font-weight</span>: <span class="number">900</span>; </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="25-2-Iconfont阿里图标库（P79）"><a href="#25-2-Iconfont阿里图标库（P79）" class="headerlink" title="25.2 Iconfont阿里图标库（P79）"></a>25.2 Iconfont阿里图标库（P79）</h4><p>使用：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101155211.png"><br>使用到的下载文件：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101155317.png"><br>通过伪类的方法使用：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101155445.png"></p>
<h4 id="25-3-字体的简写属性（P81）"><a href="#25-3-字体的简写属性（P81）" class="headerlink" title="25.3 字体的简写属性（P81）"></a>25.3 字体的简写属性（P81）</h4><p>font可以设置字体相关的所有属性，语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font</span>: 字体大小/行高  字体族</span><br><span class="line">行高可以省略不写，如果不写会使用默认值</span><br></pre></td></tr></table></figure>
<p>font-weight 字重，字体加粗<br>可选值：</p>
<ul>
<li>normal 默认值，不加粗</li>
<li>blod 加粗</li>
<li>100-900 九个级别（没什么用）</li>
</ul>
<p>font-style 字体风格<br>可选值：</p>
<ul>
<li>normal 正常的</li>
<li>italic 斜体</li>
</ul>
<h2 id="26-行高（P80）"><a href="#26-行高（P80）" class="headerlink" title="26.行高（P80）"></a>26.行高（P80）</h2><p>行高（line height）: </p>
<ul>
<li>指的是文字占有的实际高度</li>
<li>可以通过line-height来设置行高，可以直接指定一个大小（px,em）,也可以直接为行高设置一个整数【行高为整数的话，将会是字体指定的倍数】</li>
<li>行高还经常用来设置文字的行间距【行间距 = 行高 - 字体大小】</li>
</ul>
<p>字体框：就是字体存在的盒子，设置font-size实际上就是在设置字体框的高度</p>
<p>行高会在字体框的上下平均分配，可以将line-height和height的值设为一致，使得单行文字在一个元素中垂直居中。</p>
<h2 id="27-文本的水平和垂直对齐（P82）"><a href="#27-文本的水平和垂直对齐（P82）" class="headerlink" title="27.文本的水平和垂直对齐（P82）"></a>27.文本的水平和垂直对齐（P82）</h2><p>text-align 文本的水平对齐<br>可选值：</p>
<ul>
<li>left 左对齐 </li>
<li>center 居中对齐 </li>
<li>right 右对齐 </li>
<li>justify 两端对齐</li>
</ul>
<p>vertical-align 设置元素垂直对齐的方式<br>可选值：</p>
<ul>
<li>baseline 默认值，基线对齐</li>
<li>top 顶部对齐</li>
<li>bottom 底部对齐</li>
<li>middle 居中对齐</li>
</ul>
<p>补充知识点：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>:<span class="number">1px</span> red solid;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211104093836.png"><br>解决方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>:bottom;</span><br><span class="line">  <span class="comment">/* vertical-align:top;vertical-align:middle;也可以实现同样的效果 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="28-其他文本样式（P83）"><a href="#28-其他文本样式（P83）" class="headerlink" title="28.其他文本样式（P83）"></a>28.其他文本样式（P83）</h2><p>text-decoration 设置文本修饰<br>可选值：</p>
<ul>
<li>none 默认值，什么都没有</li>
<li>underline 下划线</li>
<li>line-through 删除线</li>
<li>overline 上划线</li>
</ul>
<p>white-space 设置网页如何处理空白<br>可选值：</p>
<ul>
<li>normal 默认值，正常</li>
<li>nowrap 不换行</li>
<li>pre 保留空白（源代码中文本格式不做处理，保留）</li>
</ul>
<p>超出文本框的文字设置省略号</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet consectetuir adipisicim</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box2</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">white-space</span>:nowrap;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">overflow</span>:hidden;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-overflow</span>:ellipsis;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211104100706.png"></p>
<h2 id="练习题（P84-P86）"><a href="#练习题（P84-P86）" class="headerlink" title="练习题（P84-P86）"></a>练习题（P84-P86）</h2><p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P84%E4%BA%AC%E4%B8%9C%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%9D%A1">京东顶部导航条</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211105154415.png"></p>
<h2 id="29-背景（P88）"><a href="#29-背景（P88）" class="headerlink" title="29.背景（P88）"></a>29.背景（P88）</h2><p>&hearts; background-color 设置背景颜色<br>&hearts; background-image 设置背景图片</p>
<ul>
<li>可以同时设置背景颜色和背景图片，这样背景颜色将会成为图片的背景色</li>
<li>如果背景的图片小于元素，则背景图片会自动在元素中平铺，将元素铺满</li>
<li>如果背景的图片大于元素，背景图片将无法完全显示，只显示元素大小</li>
<li>如果背景的图片和元素一样大，则会直接正常显示</li>
</ul>
<p>&hearts; background-repeat 用来设置背景的重复方式<br>可选值：<br>repeat 默认值，背景会沿着x轴 y轴双方向重复<br>repeat-x 沿着x轴方向重复<br>repeat-y 沿着y轴方向重复<br>no-repeat 背景图片不重复 </p>
<p>&hearts; background-position 用来设置背景图片的位置<br>设置方式：通过top,left,right,bottom,center几个表示方位的词来设置背景图片的位置<br>使用方位词时必须同时指定两个值，如果只写一个值，则第二个值默认是center<br>通过偏移量来指定背景图片的位置，顺序是水平偏移量+垂直偏移量</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-position</span>:top center;</span><br><span class="line"><span class="attribute">background-position</span>:-<span class="number">10px</span> <span class="number">10px</span>;</span><br></pre></td></tr></table></figure>

<p>&hearts; background-clip设置背景的范围，可选值：<br>border-box 默认值，背景会出现在边框的下边<br>padding-box 背景不会出现在边框，只出现在内容区和内边距<br>content-box 背景只会出现在内容区</p>
<p>&hearts;background-origin 背景图片的偏移量计算的原点<br>可选值：<br>padding-box 默认值，background-position从内边距处开始计算<br>content-box 背景图片的偏移量从内容区处计算<br>border-box 背景图片的偏移量从边框处开始计算</p>
<p>&hearts;background-size 设置背景图片的大小<br>可选值：</p>
<ul>
<li>第一个值表示宽度，第二个值表示高度，如果只写一个值，则第二个值默认是auto【background:100% 100%;】</li>
<li>cover 图片的比例不变，将元素铺满</li>
<li>contain 图片比例不变，将图片在元素中完整显示</li>
</ul>
<p>&hearts;background 背景相关的简写属性，所有背景相关的样式都可以通过该样式来设置，并且该样式没有顺序要求，也没有哪个属性必须写的<br>&star; 注意：baxkground-size 必须写在background-position的后边，并且使用/隔开；background-origin，background-clip两个样式，background-origin要在background-clip的前边</p>
<h2 id="背景练习题（P92）"><a href="#背景练习题（P92）" class="headerlink" title="背景练习题（P92）"></a>背景练习题（P92）</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211110102651.png"><br>&spades;  存在问题：<br>图片属于网页中的外部资源，外部资源都需要浏览器单独发送请求加载，浏览器加载外部资源时是按需加载，用则加载，不用则不加载。<br>上边的练习，link会首先加载，而hover和active会在指定状态时才会加载</p>
<h2 id="30-雪碧图（P92）"><a href="#30-雪碧图（P92）" class="headerlink" title="30.雪碧图（P92）"></a>30.雪碧图（P92）</h2><p>解决图片显示问题：<br>可以将多个小图片同意保存到一个大图片中，然后通过调整background-position来显示图片，这样图片会同时加载到网页中，就可以有效避免出现闪烁问题，这个技术在网页中应用十分广泛，被称为CSS-Sprite，这种图称为雪碧图。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211110113539.png"></p>
<p>&hearts; 雪碧图的使用步骤：</p>
<ol>
<li>先确定要使用的图标</li>
<li>测量图标的大小</li>
<li>根据测量的结果创建一个元素</li>
<li>将雪碧图设置为元素的背景图片</li>
<li>设置一个偏移量以显示正确图片</li>
</ol>
<p>雪碧图的特点：<br>一次性将多个图片加载进页面，降低请求的次数，加快访问速度，提升用户体验</p>
<h2 id="31-线性渐变（P93）"><a href="#31-线性渐变（P93）" class="headerlink" title="31.线性渐变（P93）"></a>31.线性渐变（P93）</h2><h4 id="31-1-linear-gradient"><a href="#31-1-linear-gradient" class="headerlink" title="31.1 linear-gradient()"></a>31.1 linear-gradient()</h4><p>通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果<br>！！渐变是图片，需要通过 <b>background-image</b> 来设置<br>线性渐变：颜色沿着一条直线发生变化 </p>
<ul>
<li>linear-gradient(red,yellow) 红色在开头，黄色在结尾，中间是过渡区域</li>
<li>线性渐变的开头，我们可以指定一个渐变的方向</li>
<li>linear-gradient(to top , red , yellow)</li>
<li><ul>
<li>to left / to right / to bottom / to top</li>
</ul>
</li>
<li>linear-gradient(45deg , red , yellow)</li>
<li><ul>
<li>deg表示度数</li>
</ul>
</li>
<li><ul>
<li>turn 表示圈</li>
</ul>
</li>
</ul>
<p>渐变可以同时指定多个颜色，多个颜色默认情况下平均分布，<br>也可以手动指定渐变的分布情况，例如：<b>linear-gradient(red 100px , yellow 50px)</b></p>
<h4 id="31-2-repeating-linear-gradient"><a href="#31-2-repeating-linear-gradient" class="headerlink" title="31.2 repeating-linear-gradient()"></a>31.2 repeating-linear-gradient()</h4><p>repeating-linear-gradient() 可以平铺的线性渐变</p>
<p>background-image:repeating-linear-gradient(red 50px , yellow 100px)<br>效果：（元素高度200px）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211110142040.png"></p>
<h4 id="31-2-径向渐变（P94）"><a href="#31-2-径向渐变（P94）" class="headerlink" title="31.2 径向渐变（P94）"></a>31.2 径向渐变（P94）</h4><p>radial-gradient() 径向渐变(放射性的效果)</p>
<ul>
<li>默认情况下，径向渐变的形状是根据元素的形状来计算的</li>
<li><ul>
<li>正方形 —&gt; 圆形</li>
</ul>
</li>
<li><ul>
<li>长方形 —&gt; 椭圆形</li>
</ul>
</li>
<li>也可以手动指定径向渐变的大小</li>
<li><ul>
<li>circle - 圆形 / ellipse - 椭圆形</li>
</ul>
</li>
<li>也可以指定渐变的位置</li>
</ul>
<p>radial-gradient(大小 at 位置 , 颜色 位置 , 颜色 位置 , ……)</p>
<ul>
<li>大小：</li>
<li><ul>
<li>circle 圆形</li>
</ul>
</li>
<li><ul>
<li>ellipse 椭圆形</li>
</ul>
</li>
<li><ul>
<li>closest-side 近边</li>
</ul>
</li>
<li><ul>
<li>closest-corner 近角</li>
</ul>
</li>
<li><ul>
<li>farthest-side 远边</li>
</ul>
</li>
<li><ul>
<li>farthest-corner 远角</li>
</ul>
</li>
<li>位置：top / right / left / center / bottom</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(circle , red , yellow)</span><br><span class="line"></span><br><span class="line">background-image: <span class="built_in">radial-gradient</span>(<span class="number">100px</span> <span class="number">50px</span> at top left , red , yellow)  </span><br><span class="line">//<span class="number">100px</span> <span class="number">50px</span>指定大小；at top left指定位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="练习项目：小米商城"><a href="#练习项目：小米商城" class="headerlink" title="练习项目：小米商城"></a>练习项目：小米商城</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211224104600.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211224104907.png"><br><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P101%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E-%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0">项目地址</a></p>
<hr>
<h2 id="32-动画效果"><a href="#32-动画效果" class="headerlink" title="32.动画效果"></a>32.动画效果</h2><h4 id="32-1-过渡效果（P115）"><a href="#32-1-过渡效果（P115）" class="headerlink" title="32.1 过渡效果（P115）"></a>32.1 过渡效果（P115）</h4><p>过渡（transition）：</p>
<ul>
<li><p>通过过渡可以指定一个属性发生变化时的切换方式</p>
</li>
<li><p>通过过渡可以创建一些非常好的效果，提升用户体验</p>
</li>
<li><p>transition-property<br>指定要执行过渡的属性,多个属性之间使用,隔开；<br>如果所有属性都需要过渡，则使用all关键字；<br>大部分属性都支持过渡效果，注意过渡时必须是从一个有效值向另一个有效值进行过渡；</p>
</li>
<li><p>transition-duration<br>指定过渡效果持续的时间<br>时间单位：s和ms，1s = 1000ms</p>
</li>
<li><p>transition-timing-function<br>过渡的时序函数<br>可选值：<br> ease 默认值，慢速开始，先加速，再减速<br> linear 匀速运动<br> ease-in 加速运动<br> ease-out 减速运动<br> ease-in-out 先加速，后减速<br> cubic-bezier() 来指定时序函数 <a href="https://cubic-bezier.com/">cubic-bezier网址</a><br> steps() 分步执行过渡效果，可以设置第二个数值【end-在时间结束时执行过渡（默认值）；start-在时间开始时执行过渡,示例：steps(2,end)】</p>
</li>
<li><p>transition-delay<br>过渡效果的延迟，等待一段时间后再执行过渡</p>
</li>
</ul>
<p>使用transition可以同时设置过渡相关的所有属性的，只有一个要求，如果要写延迟，则两个时间中第一个是持续时间，第二个是延迟时间</p>
<h4 id="32-2-过渡练习：米兔（P116）"><a href="#32-2-过渡练习：米兔（P116）" class="headerlink" title="32.2 过渡练习：米兔（P116）"></a>32.2 过渡练习：米兔（P116）</h4><p>动画：动画和过渡类似，都是可以实现一些动态的效果，不同的是过渡需要在某个属性发生变化时才会触发，动画可以自动触发动态效果</p>
<ul>
<li><p>设置动画效果，必须设置一个关键帧，关键帧设置了动画执行每一个步骤</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 关键帧 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> test &#123;</span><br><span class="line">  <span class="comment">/* from表示动画的开始位置,也可以使用0% */</span></span><br><span class="line">  <span class="selector-tag">from</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* to表示动画的结束位置,也可以使用100% */</span></span><br><span class="line">  <span class="selector-tag">to</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">700px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>animation-name:指定当前元素生效的关键帧的名字</p>
</li>
<li><p>animation-duration:指定动画的执行时间</p>
</li>
<li><p>animation-delay:指定动画的延迟时间</p>
</li>
<li><p>animation-iteration-count:指定动画执行的次数<br>可选值：数字（次数）、infinite 无限次</p>
</li>
<li><p>animation-direction:指定动画的运行方向<br>可选值：<br>normal - 默认值，从from向to运行<br>reverse - 从to向from运行<br>alternate - 从from到to，再从to到from，再从from到to …… 运行<br>alternate-reverse - 从to到from，再从from到to，再从to到from…… 运行</p>
</li>
<li><p>animation-play-state:设置动画的执行状态<br>可选值：<br>running 默认值，动画执行<br>paused 动画暂停</p>
</li>
<li><p>animation-fill-mode:设置动画的填充模式<br>可选值：<br>none 默认值，动画执行完毕元素回到原来位置<br>forwards 动画执行完毕，元素会停止在动画结束位置<br>backwards 动画延时等待时，元素就会处于开始位置<br>both 结合了forwards和backwards</p>
</li>
</ul>
<h2 id="33-变形（P120-P121）"><a href="#33-变形（P120-P121）" class="headerlink" title="33.变形（P120-P121）"></a>33.变形（P120-P121）</h2><p>变形就是通过css来改变元素的形状或者位置，变形不会影响到页面的布局。<br>transform： 用来设置元素的变形效果<br>平移：<br>translateX() - 沿着X轴方向平移<br>translateY() - 沿着Y轴方向平移<br>translateZ() - 沿着Z轴方向平移<br>平移元素时，百分比是相对于自身计算的</p>
<h4 id="★元素居中显示★"><a href="#★元素居中显示★" class="headerlink" title="★元素居中显示★"></a>★元素居中显示★</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1.已知元素大小情况： */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.不知元素大小情况 */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://qw-null.github.io/2021/09/13/%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/">实现水平垂直居中[不知自身宽高情况]</a></p>
<p>变形不会影响到页面的布局,不会导致元素脱离文档流，因此可以用于实现选中元素的浮动效果。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211224172635.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211224172708.png"></p>
<p>translateZ():Z轴平移，调整元素在z轴的位置，正常情况就是调整元素和人眼之间的距离，距离越大，元素离人越近<br>z轴平移属于立体效果（近大远小），默认情况下网页是不支持透视，如果需要看见效果，必须要设置网页的视距</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="comment">/* 设置当前网页的视距为800px,人眼距离网页的距离 */</span></span><br><span class="line">  <span class="attribute">perspective</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* 此时translateZ效果才会生效 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">800px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-旋转（P122）"><a href="#34-旋转（P122）" class="headerlink" title="34.旋转（P122）"></a>34.旋转（P122）</h2><p>通过旋转可以使元素沿着x、y或z旋转指定的角度<br>rotateX()<br>rotateY()<br>rotateZ()</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">45deg</span>);</span><br><span class="line">  <span class="comment">/* 45deg-&gt;45° ；1turn-&gt;旋转一圈 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>backface-visibility：是否显示元素的背面<br>可选值：visible - 默认值，可以看到背面；hidden - 无法看到背面</p>
<p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P123%E9%92%9F%E8%A1%A8">旋转练习 - 钟表</a><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211225172211.png"></p>
<p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P124%E5%A4%8D%E4%BB%87%E8%80%85%E8%81%94%E7%9B%9F">旋转练习 - 立方体</a><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211225171609.png"></p>
<h2 id="35-缩放（P125）"><a href="#35-缩放（P125）" class="headerlink" title="35.缩放（P125）"></a>35.缩放（P125）</h2><p>对元素进行缩放,当数值&gt;1表示对元素进行放大，当数值&lt;1表示对元素进行缩小。<br>scaleX() - 对元素的水平方向进行放大或者缩小<br>scaleY() - 对元素的垂直方向进行放大或者缩小<br>scale() - 对元素进行放大或缩小 </p>
<p>transform-origin 设置元素变形的远点<br>可选值：<br>center - 默认值，元素中间<br>0，0 - 元素最左上角</p>
<h2 id="36-less-P126"><a href="#36-less-P126" class="headerlink" title="36.less (P126)"></a>36.less (P126)</h2><p>less是一门css的预处理语言，通过less可以编写更少的代码实现更强大的样式<br>在less中添加了许多新特性，像对变量的支持、对mixin的支持……，less的语法大体上和css语法一致，但是less中增添了许多对css的拓展，所以浏览器无法直接执行less代码，要执行就必须将less转换为css</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.注释</span><br><span class="line"><span class="comment">// less中的单行注释，注释中的内容不会被解析到css中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  css中的注释，内容会被解析到css文件中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.变量</span><br><span class="line">变量中可以存储一个任意值，并且在需要时可任意的修改变量的值</span><br><span class="line">变量的语法： @变量名</span><br><span class="line">使用变量时，如果是直接使用则以 @变量名 的形式使用即可</span><br><span class="line">作为类名，或者一部分值使用时必须以 @&#123;变量名&#125; 的形式使用</span><br><span class="line"><span class="variable">@length:</span><span class="number">100px</span></span><br><span class="line"><span class="variable">@c</span>:box3;</span><br><span class="line"><span class="selector-class">.@&#123;c&#125;</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">@length</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&quot;@&#123;c&#125;/1.jpg&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">变量重名时，会优先使用比较近的变量</span><br><span class="line">可在声明变量前就使用变量</span><br><span class="line"><span class="selector-tag">---</span></span><br><span class="line"><span class="selector-tag">&amp;</span> 表示外层的父元素</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.entend</span>() 对当前选择器扩展指定选择器的样式（选择器分组）</span><br><span class="line">示例：<span class="selector-class">.p2</span><span class="selector-class">.extend</span>(.p1)&#123;</span><br><span class="line">        <span class="attribute">color</span>:red;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mixin</span> 混合</span><br><span class="line"><span class="selector-class">.p3</span>&#123;</span><br><span class="line">  <span class="comment">// 直接对指定的样式进行引用，这里就相当于将p1的样式在这里进行了复制</span></span><br><span class="line">  <span class="selector-class">.p1</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用类选择器时可以在选择器后边添加一个括号，这时实际上就创建了一个<span class="selector-tag">mixins</span></span><br><span class="line"><span class="selector-class">.p4</span>()&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">混合函数 在混合函数中可以直接设置变量,使用时按照顺序传递参数</span><br><span class="line"><span class="selector-class">.test</span>(<span class="variable">@w</span>)&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">@w</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="selector-class">.test</span>(<span class="number">100px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在<span class="selector-tag">less</span>中所有数值都可以直接进行运算</span><br><span class="line"><span class="selector-tag">width</span>: <span class="number">100px</span> + <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span>用于将其他<span class="selector-tag">less</span>文件引入当前<span class="selector-tag">less</span>文件中</span><br><span class="line">@<span class="selector-tag">import</span> &quot;<span class="selector-tag">color</span><span class="selector-class">.less</span>&quot;</span><br></pre></td></tr></table></figure>
<p>★less中的除法计算要放在括号中，不然会失效</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: (<span class="number">100</span> / <span class="number">4</span> rem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="37-弹性盒（P131）"><a href="#37-弹性盒（P131）" class="headerlink" title="37.弹性盒（P131）"></a>37.弹性盒（P131）</h2><p>flex(弹性盒、伸缩盒)：是css中的又一种布局手段，它主要用来代替浮动来完成页面。<br>flex可以使元素具有弹性，让元素可以跟随页面得到大小的改变而改变</p>
<ul>
<li>弹性容器<br>要使用弹性盒，必须先将一个元素设置为弹性容器，通过display来设置弹性容器<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>:flex; //设置为块级弹性容器</span><br><span class="line"><span class="attribute">display</span>:inline-flex; //设置为行内的弹性容器</span><br></pre></td></tr></table></figure></li>
<li>弹性元素<br>弹性容器的子元素是弹元素（弹性项），一个元素可以同时是弹性容器和弹性元素</li>
</ul>
<p>主轴：弹性元素的排列方向称为主轴<br>侧轴：与主轴垂直方向的称为侧轴</p>
<p><i style="color:green;font-size:18px;">☻</i> 弹性容器的样式：</p>
<ol>
<li><p>flex-direction 指定容器中弹性元素的排列方式（主轴方向）<br>可选值：<br> row 默认值，弹性元素在容器中水平排列（自左向右）<br> row-reverse 弹性元素在容器中反向水平排列（自右向左）<br> column 弹性元素纵向排列（自上向下）<br> column-reverse 弹性元素反向纵向排列（自下向上）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117114131.png"></p>
</li>
<li><p>flex-grow 指定弹性元素的伸展系数<br>当父元素有多余空间时，子元素如何伸展</p>
</li>
<li><p>flex-shrink 指定弹性元素的收缩系数<br>当父元素中的空间不足以容纳所有子元素时，如何对子元素进行收缩</p>
</li>
<li><p>flex-wrap 设置弹性元素是否在弹性容器中自动换行<br>可选值：<br>nowrap 默认值，元素不会自动换行<br>wrap 元素沿着辅轴方向自动换行<br>wrap-reverse 元素沿着辅轴反方向换行</p>
</li>
</ol>
<p>★flex-flow 是 flex-wrap和flex-direction的简写属性,例如：flex-flow: row wrap;</p>
<ol start="5">
<li><p>justify-content 如何分配主轴上的空白空间（主轴上的元素如何排列）<br>可选值：<br>flex-start 元素沿着主轴的起边排列<br>flex-end 元素沿着主轴的终边排列<br>center 元素居中排列<br>space-around 空白分布到元素的两个<br>space-between 空白均匀分布到元素间<br>space-evenly 空白分布到元素的单侧<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117135730.png"></p>
</li>
<li><p>align-items 定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式（元素间关系）<br>可选值：<br>stretch 默认值，将元素的长度设置为相同的值<br>flex-start 元素不会拉伸，沿着辅轴起边对齐<br>flex-end 元素不会拉伸，沿着辅轴终边对齐<br>center 居中对齐<br>baseline 基线对齐</p>
</li>
</ol>
<p>  ** align-self 用来覆盖当前弹性元素上的align-items<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117135907.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117140115.png"></p>
<p><i style="color:green;font-size:18px;">☻</i> 弹性元素的样式：</p>
<ol>
<li>弹性元素的缩减系数：<br>缩减系数的计算方式比较复杂，缩减多少是根据缩减系数和元素大小来计算（flex-grow和flex-shrink）。</li>
<li>元素基础长度<br>flex-basis 指定的是元素在主轴上的基础长度。如果主轴是横向的，则该值指定的就是元素的宽度，如果主轴是纵向的，则该值指定的就是元素的高度。<br>默认值是auto，表示参考元素自身的高度或宽度。如果传递了一个具体的数值，则以该值为准。</li>
</ol>
<p>★flex可以设置弹性元素所有的三个样式。<br>格式：flex: 增长 缩减 基础；（例如：flex: 1 1 auto;）</p>
<ol start="3">
<li>order 决定弹性元素的排列顺序（依据order指定的数值）。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117140405.png"></li>
</ol>
<h2 id="38-像素（P136-P138）"><a href="#38-像素（P136-P138）" class="headerlink" title="38.像素（P136 - P138）"></a>38.像素（P136 - P138）</h2><p>像素：屏幕是由一个一个发光的小点构成，这一个个的小点就是像素。前端开发中像素要分为两种情况讨论：css像素 和 物理像素。</p>
<ul>
<li>物理像素：上述所说的小点就是物理像素。</li>
<li>css像素：编写网页时所用的像素是css像素。浏览器在显示网页时，需要将css像素转换为物理像素，然后再呈现。</li>
</ul>
<p>一个css像素最终由几个物理像素显示，由浏览器决定。默认情况下，在PC端 一个css像素 = 一个物理像素</p>
<p>视口（viewport）:屏幕中用来显示网页的区域。<br>可以通过查看视口的大小来观察css像素和物理像素的比值</p>
<p>在不同的屏幕，单位像素的大小是不同的，像素越小屏幕会越清晰</p>
<p>可以通过meta标签来设置视口大小</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置视口大小 device-width表示设备的宽度（完美视口） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将网页的视口设置为完美视口</span></span><br><span class="line"><span class="comment">结论：书写移动端的页面，就把上边这段代码加上 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>完美视口：<br>每一款移动设备设计时，都会有一个最佳的像素比，一般只需要将像素比设置为该值即可得到一个最佳效果。将像素比设置为最佳像素比的视口大小成为完美视口。</p>
<p>vw表示的是视口的宽度（viewport width）<br>100vw = 一个视口的宽度<br>1vw = 1%视口宽度</p>
<p>☻ 网页中字体大小最小是12px，不能设置一个比12px还小的字体，如果设置一个小于12px的字体，则字体自动设置为12px。</p>
<h2 id="39-媒体查询（P143）"><a href="#39-媒体查询（P143）" class="headerlink" title="39.媒体查询（P143）"></a>39.媒体查询（P143）</h2><p>响应式布局：网页可以根据不同设备或窗口大小呈现出不同的效果，使用响应式布局可以使一个网页适用于所有设备<br>响应式布局的关键是媒体查询。<br>媒体查询：通过媒体查询可以为不同的设备或设备不同的状态来分别设置样式。<br>语法：@media 查询规则{}</p>
<p>媒体类型：<br>all - 所有设备<br>print - 打印设备<br>screen - 带屏幕的设备<br>speech - 屏幕阅读器<br>可以使用逗号连接多个媒体类型，这样它们之间就是一个或的关系；<br>可以在媒体类型前添加一个only，表示只有。only的使用主要是为了兼容一些老版本的浏览器。</p>
<p>媒体特性：<br>width - 视口的宽度<br>height - 视口的高度<br>min-width - 视口的最小宽度（视口大于指定宽度时生效）<br>max-width - 视口的最大宽度（视口小于指定宽度时生效）</p>
<p>样式切换的分界点，我们称其为断点，也就是网页的样式在这个点会发生变化。 </p>
<p>小于768px - 超小屏幕 [max-width = 768px]<br>大于768px - 小屏幕 [min-width = 768px]<br>大于992px - 中型屏幕 [min-width = 992px]<br>大于1200px - 大屏幕 [min-width = 1200px]</p>
<p>响应式设计原则：<br>  1.移动端优先<br>  2.渐进增强（由移动端逐渐向网页过渡）</p>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Grid网格布局笔记</title>
    <url>/2021/07/13/Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1-什么是Grid布局？"><a href="#1-1-什么是Grid布局？" class="headerlink" title="1.1 什么是Grid布局？"></a>1.1 什么是Grid布局？</h3><ul>
<li>Flex布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。</li>
<li>Grid布局将页面容器划分为“行”和“列”，产生单元格，然后指定“项目”所在的单元格，可以看作二维布局。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713140049.png"><h3 id="1-2-布局方式—常用的3种"><a href="#1-2-布局方式—常用的3种" class="headerlink" title="1.2 布局方式—常用的3种"></a>1.2 布局方式—常用的3种</h3><h4 id="1-2-1-传统布局方式"><a href="#1-2-1-传统布局方式" class="headerlink" title="1.2.1 传统布局方式"></a>1.2.1 传统布局方式</h4>利用position属性 + display属性 + float属性布局, 兼容性最好, 但是效率低, 麻烦!<h4 id="1-2-1-flex布局"><a href="#1-2-1-flex布局" class="headerlink" title="1.2.1 flex布局"></a>1.2.1 flex布局</h4>有自己的一套属性, 效率高, 学习成本低, 兼容性强!<h4 id="1-2-1-grid布局"><a href="#1-2-1-grid布局" class="headerlink" title="1.2.1 grid布局"></a>1.2.1 grid布局</h4>网格布局(grid)是最强大的布局方案, 但是知识点比较多, 学习成本相对较高, 目前兼容性不如flex布局!</li>
</ul>
<h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h2><ul>
<li><p>采用网格布局的区域，称为”容器”（container）。</p>
</li>
<li><p>容器内部采用网格定位的子元素，称为”项目”（item）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，最外层的&lt;div&gt;元素就是容器，内层的三个&lt;div&gt;元素就是项目。</p>
<blockquote>
<p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的&lt;p&gt;元素就不是项目。Grid 布局只对项目生效。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713141153.png"></p>
</li>
<li><p>网格线：划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713141238.png"></p>
<p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p>
<h3 id="2-1-容器属性"><a href="#2-1-容器属性" class="headerlink" title="2.1 容器属性"></a>2.1 容器属性</h3><h4 id="2-1-1-display属性"><a href="#2-1-1-display属性" class="headerlink" title="2.1.1 display属性"></a>2.1.1 display属性</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定一个容器采用网格布局。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-5&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-6&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-7&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-8&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-9&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#container</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">grid-template-rows</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e4e9</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item-1</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#ef342a</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item-2</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#f68f26</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item-3</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#4ba946</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item-4</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#0376c2</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item-5</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#c077af</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item-6</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#f8d29d</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item-7</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#b5a87f</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item-8</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#d0e4a9</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item-9</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#4dc7ec</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713144424.png"></p>
<p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713144912.png"></p>
<blockquote>
<p>注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p>
</blockquote>
<h4 id="2-1-2-grid-template-columns-属性和grid-template-rows-属性"><a href="#2-1-2-grid-template-columns-属性和grid-template-rows-属性" class="headerlink" title="2.1.2 grid-template-columns 属性和grid-template-rows 属性"></a>2.1.2 grid-template-columns 属性和grid-template-rows 属性</h4><ul>
<li>grid-template-columns属性定义每一列的列宽</li>
<li>grid-template-rows属性定义每一行的行高<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">300px</span> <span class="number">100px</span> <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">150px</span> <span class="number">120px</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
指定一个三行三列的网格，列宽为300px,100px,200px和行高是100px,150px,120px<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713151714.png"><br>除了使用绝对单位，也可以使用百分比。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-辅助函数repeat"><a href="#1-辅助函数repeat" class="headerlink" title="(1) 辅助函数repeat()"></a>(1) 辅助函数repeat()</h6>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。repeat()重复某种模式也是可以的。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">20px</span> <span class="number">80px</span>);</span><br></pre></td></tr></table></figure>
上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713152142.png"></li>
</ul>
<h6 id="2-auto-fill-关键字"><a href="#2-auto-fill-关键字" class="headerlink" title="(2) auto-fill 关键字"></a>(2) auto-fill 关键字</h6><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713153005.png"></p>
<h6 id="3-fr-关键字"><a href="#3-fr-关键字" class="headerlink" title="(3) fr 关键字"></a>(3) fr 关键字</h6><p>为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示两个相同宽度的列。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713153417.png"><br>fr可以与绝对长度的单位结合使用，这时会非常方便。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713153548.png"></p>
<h6 id="4-minmax"><a href="#4-minmax" class="headerlink" title="(4) minmax()"></a>(4) minmax()</h6><p>minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure>
<p>上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。</p>
<h6 id="5-auto关键字"><a href="#5-auto关键字" class="headerlink" title="(5) auto关键字"></a>(5) auto关键字</h6><p>auto关键字表示由浏览器自己决定长度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。</p>
<h6 id="（6）网格线的名称"><a href="#（6）网格线的名称" class="headerlink" title="（6）网格线的名称"></a>（6）网格线的名称</h6><p>grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。<br>网格布局允许同一根线有多个名字，比如[fifth-line row-5]。</p>
<h6 id="（7）布局实例"><a href="#（7）布局实例" class="headerlink" title="（7）布局实例"></a>（7）布局实例</h6><p>grid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码将左边栏设为70%，右边栏设为30%。</p>
<p>传统的十二网格布局，写起来也很容易。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">12</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-grid-row-gap-属性，grid-column-gap-属性，grid-gap-属性"><a href="#2-1-3-grid-row-gap-属性，grid-column-gap-属性，grid-gap-属性" class="headerlink" title="2.1.3 grid-row-gap 属性，grid-column-gap 属性，grid-gap 属性"></a>2.1.3 grid-row-gap 属性，grid-column-gap 属性，grid-gap 属性</h4><ul>
<li>grid-row-gap属性设置行与行的间隔（行间距）</li>
<li>grid-column-gap属性设置列与列的间隔（列间距）</li>
<li>grid-gap 属性是grid-row-gap和grid-column-gap的合并简写形式<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row</span>-<span class="attribute">gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>-<span class="attribute">gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713155129.png"></li>
</ul>
<p>grid-gap 属性是grid-row-gap和grid-column-gap的合并简写形式，语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-gap</span>: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p>
</blockquote>
<h4 id="2-1-4-grid-template-areas-属性"><a href="#2-1-4-grid-template-areas-属性" class="headerlink" title="2.1.4 grid-template-areas 属性"></a>2.1.4 grid-template-areas 属性</h4><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">                       <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">                       <span class="string">&#x27;g h i&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713161356.png"><br>多个单元格合并成一个区域的写法如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>: <span class="string">&#x27;a a a&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;b b b&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;c c c&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码将9个单元格分成a、b、c三个区域。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713161535.png"><br>布局实例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>: <span class="string">&quot;header header header&quot;</span></span><br><span class="line">                     <span class="string">&quot;main main sidebar&quot;</span></span><br><span class="line">                     <span class="string">&quot;footer footer footer&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。</p>
<p>如果某些区域不需要利用，则使用”点”（.）表示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>: </span><br><span class="line">            <span class="string">&quot;a a .&quot;</span></span><br><span class="line">            <span class="string">&quot;a a .&quot;</span></span><br><span class="line">            <span class="string">&quot;. b c&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713162146.png"></p>
<h4 id="2-1-5-grid-auto-flow-属性"><a href="#2-1-5-grid-auto-flow-属性" class="headerlink" title="2.1.5 grid-auto-flow 属性"></a>2.1.5 grid-auto-flow 属性</h4><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713162818.png"><br>这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-auto-flow</span>: column;</span><br></pre></td></tr></table></figure>
<p>上面代码设置了column以后，放置顺序就变成了下图。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713162945.png"></p>
<p>下面的例子让1号项目和2号项目各占据两个单元格，然后在默认的grid-auto-flow: row 情况下，会产生下面这样的布局。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713170446.png"><br>上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。</p>
<p>现在修改设置，设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-auto-flow</span>: row dense;</span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713170539.png"></p>
<p>如果将设置改为column dense，表示”先列后行”，并且尽量填满空格。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grid-auto-flow</span>: column dense;</span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713171202.png"><br>上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。</p>
<h4 id="2-1-6-justify-items-属性，align-items-属性，place-items-属性"><a href="#2-1-6-justify-items-属性，align-items-属性，place-items-属性" class="headerlink" title="2.1.6 justify-items 属性，align-items 属性，place-items 属性"></a>2.1.6 justify-items 属性，align-items 属性，place-items 属性</h4><p>justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  justify-items: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-items</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个属性的写法完全相同，都可以取下面这些值。</p>
<blockquote>
<ul>
<li>start：对齐单元格的起始边缘。(左对齐 / 上对齐)</li>
<li>end：对齐单元格的结束边缘。（右对齐 / 下对齐）</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  justify-items: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，单元格的内容左对齐，效果如下图。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713174744.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，单元格的内容头部对齐，效果如下图。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713174838.png"></p>
<p>place-items属性是align-items属性和justify-items属性的合并简写形式。语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-items: &lt;align-items&gt; &lt;justify-items&gt;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-7-justify-content-属性，align-content-属性，place-content-属性"><a href="#2-1-7-justify-content-属性，align-content-属性，place-content-属性" class="headerlink" title="2.1.7 justify-content 属性，align-content 属性，place-content 属性"></a>2.1.7 justify-content 属性，align-content 属性，place-content 属性</h4><p>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  <span class="attribute">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713205759.png"></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713205830.png"></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713210130.png"></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713210219.png"></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713210344.png"></p>
<p>place-content属性是align-content属性和justify-content属性的合并简写形式,语法形式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: space-around space-evenly;</span><br></pre></td></tr></table></figure>
<p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p>
<h4 id="2-1-8-grid-auto-columns-属性，grid-auto-rows-属性"><a href="#2-1-8-grid-auto-columns-属性，grid-auto-rows-属性" class="headerlink" title="2.1.8 grid-auto-columns 属性，grid-auto-rows 属性"></a>2.1.8 grid-auto-columns 属性，grid-auto-rows 属性</h4><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。<br>grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-5&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-6&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-7&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-8&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-9&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#container</span>&#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">grid-auto-rows</span>: <span class="number">50px</span>; </span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e4e9</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.item-1</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#ef342a</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.item-2</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#f68f26</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.item-3</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#4ba946</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.item-4</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#0376c2</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.item-5</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#c077af</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.item-6</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#f8d29d</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.item-7</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#b5a87f</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.item-8</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#d0e4a9</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">grid-row-start</span>: <span class="number">4</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.item-9</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#4dc7ec</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">grid-row-start</span>: <span class="number">5</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">grid-column-start</span>: <span class="number">3</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713225142.png"></p>
<h4 id="2-1-8grid-template-属性，grid-属性"><a href="#2-1-8grid-template-属性，grid-属性" class="headerlink" title="2.1.8grid-template 属性，grid 属性"></a>2.1.8grid-template 属性，grid 属性</h4><ul>
<li><p>grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。</p>
</li>
<li><p>grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p>
</li>
</ul>
<p>从易读易写的角度考虑，还是建议不要合并属性。</p>
<h3 id="2-2-项目属性"><a href="#2-2-项目属性" class="headerlink" title="2.2 项目属性"></a>2.2 项目属性</h3><h4 id="2-1-1-grid-column-start-属性，grid-column-end-属性，grid-row-start-属性，grid-row-end-属性"><a href="#2-1-1-grid-column-start-属性，grid-column-end-属性，grid-row-start-属性，grid-row-end-属性" class="headerlink" title="2.1.1 grid-column-start 属性，grid-column-end 属性，grid-row-start 属性，grid-row-end 属性"></a>2.1.1 grid-column-start 属性，grid-column-end 属性，grid-row-start 属性，grid-row-end 属性</h4><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p>
<blockquote>
<ul>
<li>grid-column-start属性：左边框所在的垂直网格线</li>
<li>grid-column-end属性：右边框所在的垂直网格线</li>
<li>grid-row-start属性：上边框所在的水平网格线</li>
<li>grid-row-end属性：下边框所在的水平网格线</li>
</ul>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210714094703.png"><br>上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210714095102.png"></p>
<p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: header-start;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: header-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，1号项目的左边框距离右边框跨越2个网格。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210714095416.png"><br>这与下面的代码效果完全一样。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。</p>
</blockquote>
<h4 id="2-1-2-grid-column-属性，grid-row-属性"><a href="#2-1-2-grid-column-属性，grid-row-属性" class="headerlink" title="2.1.2  grid-column 属性，grid-row 属性"></a>2.1.2  grid-column 属性，grid-row 属性</h4><p>grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。语法格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">  <span class="attribute">grid-row</span>: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目item-1占据的区域，包括第一行 + 第二行、第一列 + 第二列。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210714095857.png"></p>
<h4 id="2-1-3-grid-area-属性"><a href="#2-1-3-grid-area-属性" class="headerlink" title="2.1.3 grid-area 属性"></a>2.1.3 grid-area 属性</h4><p>grid-area属性指定项目放在哪一个区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，1号项目位于e区域，效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210714100643.png"><br>grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-4-justify-self-属性，align-self-属性，place-self-属性"><a href="#2-1-4-justify-self-属性，align-self-属性，place-self-属性" class="headerlink" title="2.1.4 justify-self 属性，align-self 属性，place-self 属性"></a>2.1.4 justify-self 属性，align-self 属性，place-self 属性</h4><p>justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。</p>
<p>align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>place-self属性是align-self属性和justify-self属性的合并简写形式。语法格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: &lt;align-self&gt; &lt;justify-self&gt;;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: center center;</span><br></pre></td></tr></table></figure>
<p>如果省略第二个值，place-self属性会认为这两个值相等。</p>
<p><strong>参考文章：</strong></p>
<p>1.<a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程-阮一峰</a></p>
<p>2.<a href="https://www.jianshu.com/p/3762f214cd6f">(超详细)强大的grid布局-雨溪滩</a></p>
]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Router二三事</title>
    <url>/2021/07/08/Vue%20Router%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="1-初步使用"><a href="#1-初步使用" class="headerlink" title="1.初步使用"></a>1.初步使用</h2><p>安装命令：<code>npm install vue-router </code></p>
<p>创建<code>router</code>文件夹以及内部的<code>index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router - index.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../components/a.vue&#x27;</span>) &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&#x27;/b&#x27;</span>, <span class="attr">component</span>:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../components/b.vue&#x27;</span>) &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&#x27;/c&#x27;</span>, <span class="attr">component</span>:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../components/c.vue&#x27;</span>) &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<p>在项目的<code>main.js</code>文件中引入router即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js 文件部分内容</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;@/router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  …… ,</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以在<code>App.vue</code>文件中通过<code> &lt;router-view /&gt;</code>使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-进一步配置"><a href="#2-进一步配置" class="headerlink" title="2.进一步配置"></a>2.进一步配置</h2><h4 id="情景一：访问不存在的路由"><a href="#情景一：访问不存在的路由" class="headerlink" title="情景一：访问不存在的路由"></a>情景一：访问不存在的路由</h4><p>项目中访问不存在的路由，需要跳转到404页面。需要在<code>router</code>下的<code>index.js</code>文件中配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router - index.js文件部分内容</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  …… ,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;/404&quot;</span>,<span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/error-page/404&quot;</span>)&#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&#x27;*&#x27;</span>, <span class="attr">redirect</span>:<span class="string">&#x27;/404&#x27;</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<h4 id="情景二：路由模式的设置"><a href="#情景二：路由模式的设置" class="headerlink" title="情景二：路由模式的设置"></a>情景二：路由模式的设置</h4><p>路由有两种模式：<code>hash模式</code> 和 <code>history模式</code>，设置时通过<code>mode</code>字段配置，默认模式为hash模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router - index.js文件部分内容</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line">…… ,</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  <span class="attr">mode</span>:<span class="string">&#x27;hash&#x27;</span> <span class="comment">// &#x27;history&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<h4 id="情景三：渲染多级路由"><a href="#情景三：渲染多级路由" class="headerlink" title="情景三：渲染多级路由"></a>情景三：渲染多级路由</h4><p>渲染多级路由通过<code>children</code>字段来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router - index.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../components/a.vue&#x27;</span>), <span class="attr">children</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;aa&#x27;</span>, <span class="attr">component</span>:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../components/aa.vue&#x27;</span>)&#125;</span><br><span class="line">  ] &#125;,</span><br><span class="line">  ……</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<p>在<code>a.vue</code>文件中通过标签<code>&lt;router-view/&gt;</code>来使用<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220708130141.png"></p>
<h4 id="情景四；路由跳转"><a href="#情景四；路由跳转" class="headerlink" title="情景四；路由跳转"></a>情景四；路由跳转</h4><p>路由跳转使用<code>&lt;router-link&gt;</code>标签实现<br>请注意，我们没有使用常规的 <code>a</code> 标签，而是使用一个自定义组件 <code>router-link</code> 来创建链接。这使得 <code>Vue Router</code> 可以在不重新加载页面的情况下更改 <code>URL</code>，处理 <code>URL</code> 的生成以及编码。我们将在后面看到如何从这些功能中获益。</p>
]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>axios入门与源码分析（尚硅谷2021最新版）</title>
    <url>/2021/07/02/axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B72021%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1wr4y1K7tq?from=search&seid=5757211588371183468">尚硅谷2021最新版axios入门与源码解析</a></p>
<h2 id="第1章：axios的理解和使用"><a href="#第1章：axios的理解和使用" class="headerlink" title="第1章：axios的理解和使用"></a>第1章：axios的理解和使用</h2><h2 id="第2章：axios源码分析"><a href="#第2章：axios源码分析" class="headerlink" title="第2章：axios源码分析"></a>第2章：axios源码分析</h2>]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>元素抖动</title>
    <url>/2021/06/17/%E5%85%83%E7%B4%A0%E6%8A%96%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="0-需求说明"><a href="#0-需求说明" class="headerlink" title="0.需求说明"></a>0.需求说明</h2><p>表单中同意用户协议未选择时，让该部分抖动，可以给用户友好的提示。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/123.gif"></p>
<h2 id="1-实现方法"><a href="#1-实现方法" class="headerlink" title="1.实现方法"></a>1.实现方法</h2><h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">id</span>=<span class="string">&quot;agree&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span>同意<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;agreelink&quot;</span>&gt;</span>《用户协议》<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;submit()&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">submit</span>(<span class="params"></span>) &#123;<span class="comment">//监测同意协议是否点击</span></span><br><span class="line">  <span class="keyword">let</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;agree&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>($(<span class="string">&quot;#checkbox&quot;</span>).<span class="title function_">is</span>(<span class="string">&quot;:checked&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!$(<span class="string">&quot;#checkbox&quot;</span>).<span class="title function_">is</span>(<span class="string">&quot;:checked&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elem) &#123;</span><br><span class="line">      elem.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;shake&#x27;</span>)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; elem.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;shake&#x27;</span>) &#125;, <span class="number">800</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：项目必须引入jQuery <code>&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;</code></p>
</blockquote>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.shake</span> &#123;</span><br><span class="line">   <span class="attribute">animation</span>: shake <span class="number">800ms</span> ease-in-out;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">@keyframes</span> shake &#123;</span><br><span class="line"></span><br><span class="line">   <span class="number">10%</span>,</span><br><span class="line">   <span class="number">90%</span> &#123;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">1px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="number">20%</span>,</span><br><span class="line">   <span class="number">80%</span> &#123;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(+<span class="number">2px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="number">30%</span>,</span><br><span class="line">   <span class="number">70%</span> &#123;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="number">40%</span>,</span><br><span class="line">   <span class="number">60%</span> &#123;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(+<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="number">50%</span> &#123;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>欢迎使用***系统<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logincontent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;login.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;login-box&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;login_form&quot;</span> <span class="attr">id</span>=<span class="string">&quot;login_form&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-item-wrap&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-label&quot;</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-item-wrap&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-label&quot;</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">id</span>=<span class="string">&quot;agree&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>同意<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;agreelink&quot;</span>&gt;</span>《用户协议》<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;submit()&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">submit</span>(<span class="params"></span>) &#123;<span class="comment">//监测同意协议是否点击</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;agree&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>($(<span class="string">&quot;#checkbox&quot;</span>).<span class="title function_">is</span>(<span class="string">&quot;:checked&quot;</span>));</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (!$(<span class="string">&quot;#checkbox&quot;</span>).<span class="title function_">is</span>(<span class="string">&quot;:checked&quot;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (elem) &#123;</span></span><br><span class="line"><span class="language-javascript">        elem.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;shake&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; elem.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;shake&#x27;</span>) &#125;, <span class="number">800</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">5%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.logincontent</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding-top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.image</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">    size: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.pic</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">75%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.login-box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">min-width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">min-height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* border: 1px solid black; */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#login_form</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.login-title</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: cornflowerblue;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.form-item-wrap</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.form-label</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.form-input</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.agree</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.form-submit</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">40%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: <span class="number">24px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding-top</span>: <span class="number">2px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#00aff0</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.agreelink</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.shake</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">animation</span>: shake <span class="number">800ms</span> ease-in-out;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="keyword">@keyframes</span> shake &#123;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="number">10%</span>,</span></span><br><span class="line"><span class="language-css">    <span class="number">90%</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">1px</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="number">20%</span>,</span></span><br><span class="line"><span class="language-css">    <span class="number">80%</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(+<span class="number">2px</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="number">30%</span>,</span></span><br><span class="line"><span class="language-css">    <span class="number">70%</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="number">40%</span>,</span></span><br><span class="line"><span class="language-css">    <span class="number">60%</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(+<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="number">50%</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS分割取字符串方法</title>
    <url>/2021/06/15/js%E5%88%86%E5%89%B2%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1-substr"><a href="#1-substr" class="headerlink" title="1.substr"></a>1.substr</h3><p>substr(start,length)表示从start位置开始，截取length长度的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src=<span class="string">&quot;images/off_1.png&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(src.<span class="title function_">substr</span>(<span class="number">7</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>弹出值:off</p>
<h3 id="2-substring"><a href="#2-substring" class="headerlink" title="2.substring"></a>2.substring</h3><p>substring(start,end)表示从start到end之间的字符串，包括start位置的字符但是不包括end位置的字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src=<span class="string">&quot;images/off_1.png&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(src.<span class="title function_">substring</span>(<span class="number">7</span>,<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p>弹出值:off</p>
<h3 id="3-indexOf"><a href="#3-indexOf" class="headerlink" title="3.indexOf"></a>3.indexOf</h3><p>indexOf() 方法返回某个指定的字符串值在字符串中首次出现的位置（从左向右）。没有匹配的则返回-1，否则返回首次出现位置的字符串的下标值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src=<span class="string">&quot;images/off_1.png&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(src.<span class="title function_">indexOf</span>(<span class="string">&#x27;t&#x27;</span>));</span><br><span class="line"><span class="title function_">alert</span>(src.<span class="title function_">indexOf</span>(<span class="string">&#x27;i&#x27;</span>));</span><br><span class="line"><span class="title function_">alert</span>(src.<span class="title function_">indexOf</span>(<span class="string">&#x27;g&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>弹出值依次为: -1 &nbsp;  0  &nbsp; 3</p>
<h3 id="4-lastIndexOf"><a href="#4-lastIndexOf" class="headerlink" title="4.lastIndexOf"></a>4.lastIndexOf</h3><p>lastIndexOf()方法返回从右向左出现某个字符或字符串的首个字符索引值（与indexOf相反）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src=<span class="string">&quot;images/off_1.png&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(src.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>));</span><br><span class="line"><span class="title function_">alert</span>(src.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;g&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>弹出值依次为：6 &nbsp; 15</p>
<h3 id="5-split"><a href="#5-split" class="headerlink" title="5.split"></a>5.split</h3><p>将一个字符串分割为子字符串，然后将结果作为字符串数组返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SplitDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> s, ss;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="string">&quot;The rain in Spain falls mainly in the plain.&quot;</span>;</span><br><span class="line">  <span class="comment">// 在每个空格字符处进行分解。</span></span><br><span class="line">  ss = s.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>(ss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：[“The”, “rain”, “in”, “Spain”, “falls”, “mainly”, “in”, “the”, “plain.”]</p>
]]></content>
      <categories>
        <category>JS学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑面试题：猴子搬香蕉</title>
    <url>/2021/06/15/%E9%80%BB%E8%BE%91%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%8C%B4%E5%AD%90%E6%90%AC%E9%A6%99%E8%95%89/</url>
    <content><![CDATA[<h2 id="01-故事起源"><a href="#01-故事起源" class="headerlink" title="01 故事起源"></a>01 故事起源</h2><p>一只小猴子边上有100根香蕉，此地距离它家50米，小猴想搬香蕉回家，但有以下几个条件：  </p>
<ul>
<li>每次最多搬运50根香蕉</li>
<li>每走1m就要吃掉一根香蕉</li>
</ul>
<p>请问小猴子最多能把多少根香蕉搬回家？<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210615144312.jpg"></p>
<h2 id="02-初步思考"><a href="#02-初步思考" class="headerlink" title="02 初步思考"></a>02 初步思考</h2><p>小猴子最多只能搬50根香蕉，那就搬起50根香蕉往家走。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615144538.jpg"><br>可以发现，剩余香蕉和行走距离之间是线性关系。最终走到家，剩余香蕉数目为0根。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615144724.jpg"></p>
<p>小猴子搬运香蕉的过程可以看成是运输过程，之所以出现上面的问题，就在于运输效率会线性下降，快到家时，虽然身上只有几根香蕉，但油耗（吃掉香蕉数目）依然不变。<br>因此解决的办法是通过中转来提高运输效率，尽量载满。</p>
<h2 id="03-建立中转站"><a href="#03-建立中转站" class="headerlink" title="03 建立中转站"></a>03 建立中转站</h2><p>总共100根，所以转运最多2趟。而且小猴同学不用返回出发地，所以中转地与出发地之间往返3次。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615145322.jpg"><br>中转是为了下一次能够一次运输完，所以到达中转地之后，香蕉数要小于等于50。<br>设到中转站距离开始位置x米，则100-3x&lt;=50，x=17米。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615145509.jpg"><br>所以第一次搬50到17米处吃掉17根香蕉，再拿17根香蕉返回出发地，此时中转站留下16根香蕉。第二次搬50根到中转站剩下33根，总共49根。然后拿上49根回家，还剩下16根。</p>
<h2 id="04-深入思考"><a href="#04-深入思考" class="headerlink" title="04 深入思考"></a>04 深入思考</h2><p>这里借用一下微分的思想，将中转无限分段，假设每隔1米转运1次，那么每一段之间都是往返3次。如果再把这些区间积起来，其实就和上面的思想一样了。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615150600.jpg"><br>走到16米的地方还有一个特别的点。现在还有52根香蕉，距离家还有34米。此时只拿50根回家，不要多出的2根，也能搬回16根香蕉。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615150707.jpg"></p>
<h2 id="05-总结"><a href="#05-总结" class="headerlink" title="05 总结"></a>05 总结</h2><p>这类问题最直观的第一感觉，就是越到后面阶段，运输效率越低，所以能想到中转。跟现实生活中的快递运输是一样的，快递也会有很多的中转站。中转站的设立是可以无限微分划区间，再用积分来计算，但这样就太复杂了，所以用分段的思想能解决大部分的问题。</p>
<p><strong>文章来源：小K算法</strong></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>逻辑思维</tag>
      </tags>
  </entry>
  <entry>
    <title>本地项目上传至GitHub</title>
    <url>/2021/06/08/%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub/</url>
    <content><![CDATA[<p>当你遭受巨大痛苦时，你要懂得自己忍受，尽量不用你的痛苦去搅扰别人。</p>
<h2 id="0-需求说明"><a href="#0-需求说明" class="headerlink" title="0.需求说明"></a>0.需求说明</h2><p>本地创建项目，github上未存在该项目的repository，现在要将该项目上传至github。</p>
<h2 id="1-操作步骤"><a href="#1-操作步骤" class="headerlink" title="1.操作步骤"></a>1.操作步骤</h2><h4 id="1-1-GitHub中新建仓库"><a href="#1-1-GitHub中新建仓库" class="headerlink" title="1.1 GitHub中新建仓库"></a>1.1 GitHub中新建仓库</h4><p><em>注意：GitHub中新建的仓库名称需要与本地的项目文件夹的名称一致</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210609103848.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210609104142.png"></p>
<h4 id="1-2本地项目文件夹下运行命令"><a href="#1-2本地项目文件夹下运行命令" class="headerlink" title="1.2本地项目文件夹下运行命令"></a>1.2本地项目文件夹下运行命令</h4><p>点击“Git Bash Here”，打开git命令行。</p>
<blockquote>
<p>运行命令:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&#x27;initproject&#x27;</span>(git commit -m <span class="string">&#x27;提交信息说明&#x27;</span>)</span><br><span class="line"></span><br><span class="line">git remote add origin 自己的项目地址</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>此时便已将本地项目上传至github</p>
]]></content>
      <categories>
        <category>GitHub使用</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>table中图片展示</title>
    <url>/2021/06/06/table%E4%B8%AD%E5%9B%BE%E7%89%87%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<p>在人海里相遇的人终究要还给人海。</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210606213709.png" style="zoom:175%;" />

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Table中横向图片展示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Table横向多个图片展示<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>每个表格由 table 标签开始。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>每个表格行由 tr 标签开始。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>每个表格数据由 td 标签开始。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>图片展示<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>阿里<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;table_img&quot;</span> <span class="attr">onmousewheel</span>=<span class="string">&quot;handler()&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-scott-webb-1098520.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-scott-webb-1098520.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-scott-webb-1098520.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-scott-webb-1098520.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-scott-webb-1098520.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>腾讯<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(&#x27;mousewheel信息&#x27;, event);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> detail = event.<span class="property">wheelDelta</span> || event.<span class="property">detail</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> item = event.<span class="property">currentTarget</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> moveForwardStep = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> moveBackStep = -<span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> step = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (detail &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      step = moveForwardStep * <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      step = moveBackStep * <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    item.<span class="property">scrollLeft</span> += step;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-collapse</span>: collapse;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/*对DIV设置margin:0 auto样式，</span></span></span><br><span class="line"><span class="comment"><span class="language-css">    是为了让DIV在浏览器中水平居中。布局居中、水平居中，</span></span></span><br><span class="line"><span class="comment"><span class="language-css">    均加入margin:0 auto即可。*/</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table</span> <span class="selector-tag">td</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#cad9ea</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: <span class="number">#666</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">table</span> <span class="selector-tag">thead</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#CCE8EB</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(odd) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 奇数行 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(even) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 偶数行 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#F5FAFA</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.imgAuto</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 图片样式 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">max-width</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table_img</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">overflow-y</span>: auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">white-space</span>: nowrap;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table_img</span>::-webkit-scrollbar &#123;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/*滚动条整体样式*/</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">3px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/*高宽分别对应横竖滚动条的尺寸*/</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table_img</span>::-webkit-scrollbar-thumb &#123;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/*滚动条里面小方块*/</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">159</span>, <span class="number">160</span>, <span class="number">162</span>, <span class="number">0.8</span>);</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table_img</span>::-webkit-scrollbar-track &#123;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/*滚动条里面轨道*/</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;table&gt;样式模板</title>
    <url>/2021/06/06/table%E6%A0%B7%E5%BC%8F%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>你必须非常努力 ，才能显得毫不费劲</p>
<h3 id="一、样式-1"><a href="#一、样式-1" class="headerlink" title="一、样式 1"></a>一、样式 1</h3><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210606203427.png" style="zoom:175%;" />
##### 1.1源代码：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>table标签样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Table标签样式<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>信息<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>阿里<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>阿里巴巴一般指阿里巴巴集团。阿里巴巴集团控股有限公司（简称：阿里巴巴集团）</span><br><span class="line">            是以曾担任英语教师的马云为首的18人于1999年在浙江省杭州市创立的公司。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>腾讯<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>腾讯于1998年11月成立,是一家以互联网为基础的平台公司,</span><br><span class="line">            通过技术丰富互联网用户的生活,助力企业数字化升级。我们的使命是“用户为本 科技向善”。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>百度是一家持续创新的,以“用科技让复杂世界更简单”为使命的高科技公司。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>字节跳动<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>字节跳动一般指北京字节跳动科技有限公司。北京字节跳动科技有限公司，</span><br><span class="line">            成立于2012年3月，是最早将人工智能应用于移动互联网场景的科技企业之一，</span><br><span class="line">            是中国北京的一家信息科技公司，地址位于北京市海淀区知春路甲48号。</span><br><span class="line">            公司以建设“全球创作与交流平台”为愿景<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* div居中显示 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-collapse</span>: collapse;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/*对DIV设置margin:0 auto样式，</span></span></span><br><span class="line"><span class="comment"><span class="language-css">    是为了让DIV在浏览器中水平居中。布局居中、水平居中，</span></span></span><br><span class="line"><span class="comment"><span class="language-css">    均加入margin:0 auto即可。*/</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table</span> <span class="selector-tag">td</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#cad9ea</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: <span class="number">#666</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">table</span> <span class="selector-tag">thead</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#CCE8EB</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(odd) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 奇数行 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(even) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 偶数行 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#F5FAFA</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.table</span> <span class="selector-tag">td</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="1-2知识点："><a href="#1-2知识点：" class="headerlink" title="1.2知识点："></a>1.2知识点：</h5><p>（1）CSS3 :nth-child() 选择器<br>:nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类型。n 可以是数字、关键词或公式。</p>
<blockquote>
<p>用法 1：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210606205553.png"></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> </span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-css">&#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background</span>:<span class="number">#ccddff</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第三个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第四个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>注释：<span class="tag">&lt;/<span class="name">b</span>&gt;</span>Internet Explorer 不支持 :nth-child() 选择器。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>–存在的问题–<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210606210022.png"></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> </span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)<span class="comment">/*没有起作用，因为页面的第一个子元素是&lt;h3&gt;*/</span></span></span><br><span class="line"><span class="language-css">&#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background</span>:green;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)</span></span><br><span class="line"><span class="language-css">&#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background</span>:red;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>:nth-child()演示<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第三个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第四个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>注释：<span class="tag">&lt;/<span class="name">b</span>&gt;</span>Internet Explorer 不支持 :nth-child() 选择器。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>用法 2：<br>Odd 和 even 是可用于匹配下标是奇数或偶数的子元素的关键词（第一个子元素的下标是 1）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210606210628.png"></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> </span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(odd)</span></span><br><span class="line"><span class="language-css">&#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(even)</span></span><br><span class="line"><span class="language-css">&#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第三个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第四个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>注释：<span class="tag">&lt;/<span class="name">b</span>&gt;</span>Internet Explorer 不支持 :nth-child() 选择器。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>。。。。。。未完待续</p>
]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>How-to-use-Hexo</title>
    <url>/2021/06/02/How-to-use-Hexo/</url>
    <content><![CDATA[<h2 id="如何使用搭建的博客？"><a href="#如何使用搭建的博客？" class="headerlink" title="如何使用搭建的博客？"></a>如何使用搭建的博客？</h2><h3 id="1-新建博客"><a href="#1-新建博客" class="headerlink" title="1 新建博客"></a>1 新建博客</h3><p>项目目录下运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new title</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips:其中title为文章的标题名称</p>
</blockquote>
<h3 id="2-如何进行分类【category-amp-tag】"><a href="#2-如何进行分类【category-amp-tag】" class="headerlink" title="2 如何进行分类【category  &amp; tag】"></a>2 如何进行分类【category  &amp; tag】</h3><h4 id="2-1-创建分类选项"><a href="#2-1-创建分类选项" class="headerlink" title="2.1 创建分类选项"></a>2.1 创建分类选项</h4><ul>
<li>项目目录下执行命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></li>
<li>成功后会提示信息<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210602155850.png"></li>
<li>根据路径信息找到改文件，并打开修改<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2021-06-02 15:14:47</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
<li>保存关闭文件</li>
</ul>
<h4 id="2-2-创建标签选项"><a href="#2-2-创建标签选项" class="headerlink" title="2.2 创建标签选项"></a>2.2 创建标签选项</h4><ul>
<li>项目目录下执行命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li>
<li>成功后会提示信息<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210602160228.png"></li>
<li>根据路径信息找到改文件，并打开修改<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2021-06-02 15:19:33</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
<li>保存关闭文件</li>
</ul>
<h4 id="2-3-为文章添加分类与标签"><a href="#2-3-为文章添加分类与标签" class="headerlink" title="2.3 为文章添加分类与标签"></a>2.3 为文章添加分类与标签</h4><p>在文章内容中进行修改<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210602161206.png"></p>
<blockquote>
<p>重新编译之后运行即可查看页面出现分类和标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210602161127.png"><br><strong>注意：</strong> hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p>
</blockquote>
<p>未完待续……</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex 学习笔记</title>
    <url>/2021/06/01/Vuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-Vuex概述"><a href="#1-Vuex概述" class="headerlink" title="1.Vuex概述"></a>1.Vuex概述</h2><h3 id="1-1-Vue组件之间共享数据"><a href="#1-1-Vue组件之间共享数据" class="headerlink" title="1.1 Vue组件之间共享数据"></a>1.1 Vue组件之间共享数据</h3><ul>
<li>父向子传值：v-bind 属性绑定</li>
<li>子向父传值：v-on  事件绑定</li>
<li>兄弟组件之间共享数据：EventBus<blockquote>
<p>$emit  发送数据的那个组件<br>$on  接收数据的那个组件</p>
</blockquote>
</li>
</ul>
<p>== 以上方式适用于小范围数据共享 == </p>
<p><em>详情请见：【后续补充】</em></p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210608155748.png" style="zoom:120%;" />

<h3 id="1-2-如何使用Vue-UI创建项目？"><a href="#1-2-如何使用Vue-UI创建项目？" class="headerlink" title="1.2 如何使用Vue UI创建项目？"></a>1.2 如何使用Vue UI创建项目？</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/1.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/2.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/3.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/4.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/5.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/6.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/7.png"></p>
<p>创建完成之后，到电脑目录下就可以查看到创建的项目，使用vscode打开即可</p>
<h3 id="1-3-Vuex的使用"><a href="#1-3-Vuex的使用" class="headerlink" title="1.3 Vuex的使用"></a>1.3 Vuex的使用</h3><hr>
<p>Vuex 是实现组件全局状态（数据）管理的一种机制，可以方便实现组件之间的数据共享，适用于大范围的数据共享。</p>
<hr>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/clipboard1.png" style="zoom:120%;" />

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/clipboard3.png"></p>
<h3 id="1-4-Vuex知识点"><a href="#1-4-Vuex知识点" class="headerlink" title="1.4 Vuex知识点"></a>1.4 Vuex知识点</h3><p>Vuex中的核心概念</p>
<ul>
<li>State</li>
<li>Mutation</li>
<li>Action</li>
<li>Getter</li>
</ul>
<h5 id="1-4-1-State"><a href="#1-4-1-State" class="headerlink" title="1.4.1 State"></a>1.4.1 State</h5><p>提供唯一的公共数据源，所有共享的数据都要统一放在Store的State中进行存储</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>组件访问state中数据的第一种方式：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.全局数据名称</span><br></pre></td></tr></table></figure></li>
<li><p>组件访问state中数据的第二种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从Vuex中按需导入mapState函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过刚才导入的mapState函数，将当前组件需要的全局数据映射为当前组件的computed计算属性</span></span><br><span class="line"><span class="comment">//2.将全局数据映射为当前组件的计算属性</span></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">  ...<span class="title function_">mapState</span>([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">  <span class="comment">// ...表示展开运算符，意思是将全局数据映射为当前组件的计算属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Vuex中不允许组件直接修改Store中的数据</p>
</li>
</ul>
<h5 id="1-4-2-Mutation"><a href="#1-4-2-Mutation" class="headerlink" title="1.4.2 Mutation"></a>1.4.2 Mutation</h5><p>用于变更Store中的数据，<b>mutation 必须是同步函数</b><br>①只能通过Mutation变更store数据，不可以直接操作store中的数据<br>②通过这种方式虽然操作起来繁琐一些，但是可以集中监控所有数据的变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>:&#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">state</span>)&#123;</span><br><span class="line">      <span class="comment">//变更状态</span></span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>组件中触发mutation的第一种方式：  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="title function_">handle</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>组件触发mutation的第二种方式：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从vuex中按需导入mapMutations函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 通过刚才导入的mapMutations函数，按需要的mutations函数映射为组件的methods方法</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;add&#x27;</span>])</span><br><span class="line">  <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;add&#x27;)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><b>可以在触发mutations时传递参数</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line"><span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>:&#123;</span><br><span class="line">    <span class="title function_">addN</span>(<span class="params">state,step</span>)&#123;</span><br><span class="line">      <span class="comment">//变更状态      </span></span><br><span class="line">      state.<span class="property">count</span> += step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>,<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">另外一种方法：</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;addN&#x27;</span>])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上述第二种方法，使用时采用如下方法传递参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addN(5)&quot;</span>&gt;</span>+5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h5 id="1-4-3-Action"><a href="#1-4-3-Action" class="headerlink" title="1.4.3 Action"></a>1.4.3 Action</h5><p>用于处理异步任务<br>如果通过异步操作变更数据，必须通过Action,而不能使用Mutation,但是在Actions中还是要通过出发Mutation的方式间接变更数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>:&#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">state</span>)&#123;</span><br><span class="line">      <span class="comment">//变更状态</span></span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="title function_">addAsync</span>(<span class="params">context</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//通过commit去触发mutation函数</span></span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>组件中触发action的第一种方式：  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="title function_">handle</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;addAsync&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>组件中触发action的第二种方式：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从vuex中按需导入mapActions函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 通过刚才导入的mapActions函数，按需要的acyions函数映射为组件的methods方法</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  ...<span class="title function_">mapActions</span>([<span class="string">&#x27;addASync&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>与1.4.2Mutation中相同，也可以携带参数<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210608161404.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210608161437.png"></p>
<h5 id="1-4-4-Getter"><a href="#1-4-4-Getter" class="headerlink" title="1.4.4 Getter"></a>1.4.4 Getter</h5><p>Getter用于对Store中的数据进行加工处理形成新的数据.（<em>Getter不会修改State中的数据，只起到包装的作用</em>）</p>
<p>特点：</p>
<blockquote>
<p>1.Getter可以对Store中已有的数据加工处理之后形成新的数据，类似Vue的计算属性</p>
<p>2.Store中的数据发生改变，Getter的数据也会跟着变化</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Getter</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	<span class="attr">state</span>:&#123;</span><br><span class="line">		<span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">	&#125;,</span><br><span class="line">    <span class="attr">getters</span>:&#123;</span><br><span class="line">        <span class="attr">showNum</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;当前最新的数量是【&#x27;</span>+ state.<span class="property">count</span> +<span class="string">&#x27;】&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用getters的第一种方式：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>.名称</span><br><span class="line"><span class="comment">//例如：this.$store.getters.showNum (this.可以省略)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用getters的第二种方法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125;<span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">	...<span class="title function_">mapGetter</span>([<span class="string">&#x27;showNum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-Vuex小Demo"><a href="#2-Vuex小Demo" class="headerlink" title="2.Vuex小Demo"></a>2.Vuex小Demo</h2><p>Demo效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210618145323.png"></p>
<p>Demo业务流程图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/todolist.png"  /></p>
<p>Demo地址：<br><a href="https://github.com/qw-null/VuexToDoListDemo">VuexToDoListDemo</a></p>
]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样搭建个人博客?【基于hexo 和 github】</title>
    <url>/2021/05/31/How-to-build-Blog/</url>
    <content><![CDATA[<p>最可悲的身份，是那种既不是学霸又不全是学渣的人。 他们听不懂课，作业不会做，只好以抄作业为生； 不逃课，不捣乱纪律； 为考试成绩着急，又无奈于现状； 三分钟热度，又恨自己不争气。 他们以最普通的身份埋没于人群中，却过着最煎熬的日子。</p>
<h2 id="搭建个人博客（基于hexo-github）"><a href="#搭建个人博客（基于hexo-github）" class="headerlink" title="搭建个人博客（基于hexo + github）"></a>搭建个人博客（基于hexo + github）</h2><blockquote>
<p>需要前期配置好git、npm（请自行百度 or B站）</p>
</blockquote>
<h3 id="1-Hexo-使用"><a href="#1-Hexo-使用" class="headerlink" title="1 Hexo 使用"></a>1 Hexo 使用</h3><img src="https://i.loli.net/2021/05/31/OokDG1q3fPCRmQM.png" style="zoom:80%;" />

<h4 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h4 id="初始化（需要到放置该项目的目录下运行）"><a href="#初始化（需要到放置该项目的目录下运行）" class="headerlink" title="初始化（需要到放置该项目的目录下运行）"></a>初始化（<strong>需要到放置该项目的目录下运行</strong>）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init [自己的博客文件夹名称]</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/2.initBlog.png" alt="initBlog" style="zoom:80%;" />

<blockquote>
<p>Tips: 【示例】 hexo init myBlog</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>博客可在本地查看【地址：<a href="http://localhost:4000】">http://localhost:4000】</a><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/3.starthexo.png" style="zoom:80%;" /></p>
<h3 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2 更换主题"></a>2 更换主题</h3><p>主题放置位置：themes文件夹下</p>
<p>以安装Cactus主题为例：<a href="https://github.com/probberechts/hexo-theme-cactus">Cactus主题地址</a></p>
<h4 id="2-1-安装主题"><a href="#2-1-安装主题" class="headerlink" title="2.1 安装主题"></a>2.1 安装主题</h4><p>项目目录下运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/probberechts/hexo-theme-cactus.git themes/cactus</span><br></pre></td></tr></table></figure>

<h4 id="2-2-修改项目配置文件config-yml"><a href="#2-2-修改项目配置文件config-yml" class="headerlink" title="2.2 修改项目配置文件config.yml"></a>2.2 修改项目配置文件config.yml</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531202404.png"></p>
<p>将theme修改为cactus</p>
<h4 id="2-3更换主题风格"><a href="#2-3更换主题风格" class="headerlink" title="2.3更换主题风格"></a>2.3更换主题风格</h4><p>Cactus提供四种主题风格：Dark、White、Light、Classic<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531203328.png"></p>
<p>更换时修改theme-cactus-config.yml<br>将colorscheme改为white或者其他<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531203506.png"></p>
<blockquote>
<p>Tips:删掉theme文件夹下的.git文件，方便后续将代码合并提交到github</p>
</blockquote>
<p>vscode中运行命令，即可在本地查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<h3 id="3-部署到GitHub"><a href="#3-部署到GitHub" class="headerlink" title="3 部署到GitHub"></a>3 部署到GitHub</h3><blockquote>
<p>Tips:此时已拥有github账号且本地已经配置好git</p>
</blockquote>
<h4 id="3-1-创建一个新仓库（命名方式注意）"><a href="#3-1-创建一个新仓库（命名方式注意）" class="headerlink" title="3.1 创建一个新仓库（命名方式注意）"></a>3.1 创建一个新仓库（命名方式注意）</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531204912.png"></p>
<h4 id="3-2-将本地项目添加至线上"><a href="#3-2-将本地项目添加至线上" class="headerlink" title="3.2 将本地项目添加至线上"></a>3.2 将本地项目添加至线上</h4><p>(1)VScode 运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:qw-null/qw-null.github.io.git</span><br></pre></td></tr></table></figure>
<p>（2）修改配置文件config.yml（下拉至最后）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531205837.png"></p>
<blockquote>
<p>Tips:repo是创建的github仓库的地址</p>
</blockquote>
<p>（3） 安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>(4)运行命令将代码推至仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<h4 id="3-3-完成GitHub线上设置"><a href="#3-3-完成GitHub线上设置" class="headerlink" title="3.3 完成GitHub线上设置"></a>3.3 完成GitHub线上设置</h4><p>线上仓库中选择Settings<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531210623.png"></p>
<p>下拉找到GitHub Pages,点击Check it out here!</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531210726.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20210531210829271.png"></p>
<p>博客地址：<a href="https://qw-null.github.io/%EF%BC%8C%E5%B0%86%E5%85%B6%E8%AE%BE%E7%BD%AE%E5%88%B0%E4%BB%93%E5%BA%93%E9%A6%96%E9%A1%B5">https://qw-null.github.io/，将其设置到仓库首页</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531210943.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531211014.png"></p>
<p>此时博客已经部署到线上</p>
<h3 id="4-GitHub自动部署"><a href="#4-GitHub自动部署" class="headerlink" title="4 GitHub自动部署"></a>4 GitHub自动部署</h3><p>项目文件夹下新建.github-&gt;workflows的文件夹,里面新建文件deploy.yml,内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Deploy</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">🛎️</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span> <span class="comment"># If you&#x27;re using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly.</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">persist-credentials:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">and</span> <span class="string">Build</span> <span class="string">🔧</span> <span class="comment"># This example project is built using npm and outputs the result to the &#x27;build&#x27; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          npm run build</span></span><br><span class="line"><span class="string"></span>        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">CI:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">🚀</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@releases/v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">master</span> <span class="comment"># （这里与远程仓库主分支名称一致）.</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span> <span class="comment"># The folder the action should deploy.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-1-新建分支"><a href="#4-1-新建分支" class="headerlink" title="4.1 新建分支"></a>4.1 新建分支</h4><p>示例：创建分支名为dev-</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF%E4%B8%8A%E4%BC%A0.png"></p>
<p>运行代码,将本地创建分支上传至远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin dev-</span><br></pre></td></tr></table></figure>

<p>然后将项目提交到dev-分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;initblog&#x27;</span></span><br><span class="line">git pull </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>此时项目已经提交至远程仓库dev-分支，项目进入到自动部署阶段</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20210531213104475.png"></p>
<blockquote>
<p>Tips: 提交完成后会在dev-分支下出现一个小黄点，这说明项目正在自动部署，变为绿色后，表明部署完成，就可以通过博客地址访问你更新的内容</p>
</blockquote>
<h3 id="5-博客中使用图片"><a href="#5-博客中使用图片" class="headerlink" title="5 博客中使用图片"></a>5 博客中使用图片</h3><p>个人提供解决思路：picGo+Github搭建图床<br>参考教程如下：<a href="https://www.bilibili.com/video/BV1Ui4y1x7Cq?p=2">PicGo+Github图床的正确打开方式</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>写在前面的话</title>
    <url>/2021/05/31/hello-world/</url>
    <content><![CDATA[<p>废话接废话，无穷无尽，说着说着年华老去。</p>
<p>总有一天，他会忘记泥土的感觉，忘记现在纷飞的草叶。</p>
<p>暮风吹过麦浪，远方的山巅盖住落日，田边小道听得见蛙鸣。</p>
]]></content>
      <categories>
        <category>闲言三两句</category>
      </categories>
      <tags>
        <tag>闲言三两句</tag>
      </tags>
  </entry>
</search>
