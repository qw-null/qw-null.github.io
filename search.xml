<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【我眼中的】 - 【3】作用域 &amp; 执行上下文</title>
    <url>/2022/04/18/3-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220419202053.png"></p>
<hr>

<h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h2><p><a href="https://qw-null.github.io/2022/02/25/Javascript%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/#2-3-1-%E4%BD%9C%E7%94%A8%E5%9F%9F">其他参考内容</a></p>
<p>作用域是指程序一个代码坐在的区域，它规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220314203108.png"></p>
<p>JavaScript 采用<span style="background-color:#f1c40f">词法作用域(lexical scoping)</span>，也就是静态作用域。</p>
<h4 id="1-1-静态作用域与动态作用域"><a href="#1-1-静态作用域与动态作用域" class="headerlink" title="1.1 静态作用域与动态作用域"></a>1.1 静态作用域与动态作用域</h4><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p>
<p>动态作用域，函数的作用域是在函数调用的时候才决定的。（在JS中没有的）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果是1。执行流程是执行<code>bar()</code>时会调用内部的<code>foo()</code>，执行 <code>foo()</code>时，先从 <code>foo</code> 函数内部查找是否有局部变量 <code>value</code>，如果没有，<b style="background-color:#F39C12">就根据书写的位置，查找上面一层的代码</b>，也就是 value 等于 1，所以结果会打印 1。</p>
<blockquote>
<p>假设JavaScript采用动态作用域，让我们分析下执行过程：<br>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p>
</blockquote>
<h2 id="2-执行上下文栈"><a href="#2-执行上下文栈" class="headerlink" title="2.执行上下文栈"></a>2.执行上下文栈</h2><p><a href="https://qw-null.github.io/2022/02/25/Javascript%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/#2-2%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88">其他参考内容</a></p>
<p>通常说的JS可执行代码有三类：全局代码、函数代码、eval代码。</p>
<p>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。</p>
<p>接下来问题来了，我们写的函数多了，如何管理创建的那么多执行上下文呢？</p>
<p>所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。</p>
<hr>

<p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p>
<p><code>ECStack = [];</code></p>
<p>试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 <code>globalContext</code> 表示它，并且只有当整个应用程序结束的时候，<code>ECStack</code> 才会被清空，所以程序结束之前， <code>ECStack</code> 最底部永远有个 <code>globalContext</code>：</p>
<p><code>ECStack = [ globalContext ];</code></p>
<p>现在 JavaScript 遇到下面的这段代码了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fun3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure>

<p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1()</span></span><br><span class="line">ECStack.push(&lt;fun1&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1中竟然调用了fun2，还要创建fun2的执行上下文</span></span><br><span class="line">ECStack.push(&lt;fun2&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦，fun2还调用了fun3！</span></span><br><span class="line">ECStack.push(&lt;fun3&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun3执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun2执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span></span><br></pre></td></tr></table></figure>

<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>⭐ 代码段一</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<p>⭐ 代码段二</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure>

<p>两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？<br>答案就是执行上下文栈的变化不一样。</p>
<p>模拟代码段一：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure>

<p>模拟代码段二：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【2】继承</title>
    <url>/2022/04/07/2-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220407230555.png"></p>
<hr>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220418102829.jpg"></p>
<h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h2><p>过程：①定义父类构造函数 ➡ ②给父类的原型添加方法 ➡ ③定义子类型的构造函数 ➡<span style="color:red">④将创建的父类型对象赋值给子类型的原型</span> ➡ <span style="color:red">⑤将子类型的构造属性设置为子类型</span> ➡ ⑥给子类型的原型添加方法 ➡ ⑦创建子类型的对象，可以调用父类型的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.pName = <span class="string">&#x27;人类&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">People.prototype.getPName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.pName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sName = <span class="string">&#x27;学生&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="keyword">new</span> People()</span><br><span class="line">Student.prototype.constructor = Student</span><br><span class="line"></span><br><span class="line">Student.prototype.getSName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.sName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student()</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> People()</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220407151237.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220407151337.png"></p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol>
<li>引用类型的属性被所有实例共享<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.names = [<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;daisy&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">&#x27;yayu&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li>在创建子类型实例时，不能向父类型传参</li>
</ol>
<h2 id="2-借用构造函数继承（假继承）"><a href="#2-借用构造函数继承（假继承）" class="headerlink" title="2.借用构造函数继承（假继承）"></a>2.借用构造函数继承（假继承）</h2><p>过程：①定义父类型构造函数 ➡ ②定义子类型的构造函数 ➡ ③在子类型构造函数中调用父类型构造</p>
<p><b style="color:red">关键点：在子类型构造函数中通过call调用父类型的构造函数</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  People.call(<span class="built_in">this</span>, name, age); <span class="comment">//相当于 this.Person(name,age)</span></span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>, <span class="number">13000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Student &#123; name: &#x27;Tom&#x27;, age: 12, price: 13000 &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>避免了引用类型的属性被所有实例共享<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.names = [<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;daisy&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">&#x27;yayu&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// [&quot;kevin&quot;, &quot;daisy&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li>在创建子类型实例时，可以向父类型传参</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>方法在构造函数中定义，每次创建实例都会创建一遍</p>
<h2 id="3-组合继承（原型链继承-借用构造函数继承）"><a href="#3-组合继承（原型链继承-借用构造函数继承）" class="headerlink" title="3.组合继承（原型链继承 + 借用构造函数继承）"></a>3.组合继承（原型链继承 + 借用构造函数继承）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  People.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> People();</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.setPrice = <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>, <span class="number">3500</span>);</span><br><span class="line">s.setName(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">s.setPrice(<span class="number">1500</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// People &#123; name: &#x27;Jack&#x27;, age: 12, price: 1500 &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>融合继承原型链继承和构造函数继承的优点，是JavaScript中最常用的继承模式。</p>
<h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><p>原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新的对象。你需要把这个对象先传给<code>object()</code>，然后再对返回的对象进行适当的修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>※ 本质上，<code>object()</code>是对传入的对象执行了一次浅复制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="attr">frineds</span>: [<span class="string">&#x27;Daming&#x27;</span>, <span class="string">&#x27;Lingling&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = object(person);</span><br><span class="line"><span class="keyword">var</span> p2 = object(person);</span><br><span class="line"></span><br><span class="line">p1.name = <span class="string">&#x27;Sam&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p2.name); <span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line">p1.frineds.push(<span class="string">&#x27;Amy&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p2.frineds); <span class="comment">// [ &#x27;Daming&#x27;, &#x27;Lingling&#x27;, &#x27;Amy&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>※ 修改<code>p1.name</code>的值，<code>p2.name</code>的值并未发生改变，并不是因为<code>p1</code>和<code>p2</code>有独立的<code>name</code>值，而是因为<code>p1.name= &#39;Sam&#39; </code>是给<code>p1</code>添加了<code>name</code>的属性，并赋值为<code>Sam</code>，并非修改了原型上<code>name</code>的值。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>包含引用类型的属性值会被所有实例共享（与原型链继承相同）。</p>
<h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来做增强对象，最后返回对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = object(original);</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>与借用构造函数继承模式相同，每次创建对象都会创建一遍方法。</p>
<h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6.寄生组合式继承"></a>6.寄生组合式继承</h2><p>组合继承的方式也存在效率的问题，最主要的效率问题就是父类构造函数始终会被调用两次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name); <span class="comment">// 第二次调用Parent()</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); <span class="comment">// 第一次调用Parent()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure>
<p>该如何精益求精，避免重复调用呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>
<p>封装一下这个继承方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(parent.prototype);</span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式的高效率体现它只调用了一次 <code>Parent</code> 构造函数，并且因此避免了在 <code>Parent.prototype</code> 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 <code>instanceof</code> 和 <code>isPrototypeOf</code>。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。  ——《JavaScript高级程序设计》</p>
</blockquote>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【5】闭包</title>
    <url>/2022/04/24/5-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="1-什么是闭包？"><a href="#1-什么是闭包？" class="headerlink" title="1.什么是闭包？"></a>1.什么是闭包？</h2><p>在JavaScript中，函数内部可以读取全局变量，在函数外部却无法读取函数内的局部变量。</p>
<p>闭包指的是<b>有权访问另外一个函数作用域中的变量的函数</b>，也就是能够读取其他函数内部变量的函数。<br>⭐ <b style="color:red;">闭包的本质是函数，有权访问另外一个函数作用域中的变量的函数</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">999</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，函数<code>f2</code>定义在函数<code>f1</code>的作用域内，因此<code>f1</code>内部的局部变量对<code>f2</code>是可见的，但<code>f2</code>内部的局部变量对<code>f1</code>是不可见的。那么只要把<code>f2</code>作为<code>f1</code>的返回值，就可以在<code>f1</code>外部读取它的内部变量了。</p>
<p>⭐ 父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<h3 id="1-1-闭包的作用"><a href="#1-1-闭包的作用" class="headerlink" title="1.1 闭包的作用"></a>1.1 闭包的作用</h3><ul>
<li>使函数的内部变量(函数)在函数执行完后，仍然存活在内存中，延长了局部变量的生命周期</li>
<li>将变量(函数)定义在闭包中使用，避免污染全局变量</li>
<li>定义JS模块</li>
</ul>
<h3 id="1-2-闭包的缺点"><a href="#1-2-闭包的缺点" class="headerlink" title="1.2 闭包的缺点"></a>1.2 闭包的缺点</h3><p>函数执行完后，函数内的变量没有释放，占用内存时间会变长，容易造成内存泄露</p>
<h2 id="2-闭包存在的问题"><a href="#2-闭包存在的问题" class="headerlink" title="2.闭包存在的问题"></a>2.闭包存在的问题</h2><p>使用闭包的时候，①引用的变量可能发生变化 ②this指向的问题</p>
<h3 id="2-1-引用变量的变化"><a href="#2-1-引用变量的变化" class="headerlink" title="2.1 引用变量的变化"></a>2.1 引用变量的变化</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="function">() =&gt;</span> i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = outer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x[i]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为每个闭包函数访问变量i是outer执行环境下的变量i，随着循环的结束，i已经变成10了，所以执行每个闭包函数，结果打印10， 10， …， 10。<br>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = outer();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// [0, 1, 2, 3, 4,5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p>此时访问的num，是上层函数执行环境的num，数组有10个函数对象，每个对象的执行环境下的number都不一样。</p>
<h3 id="2-2-this的指向"><a href="#2-2-this的指向" class="headerlink" title="2.2  this的指向"></a>2.2  this的指向</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;object&quot;</span>，</span><br><span class="line">  getName： <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">object.getName()()    <span class="comment">// underfined</span></span><br></pre></td></tr></table></figure>
<p>因为里面的闭包函数是在window作用域下执行的，也就是说，this指向windows，打印undefined。</p>
<p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">    <span class="attr">getName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.info(<span class="built_in">this</span>.name)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">object.getName();</span><br></pre></td></tr></table></figure>

<p>使用that指向object,指定了匿名函数调用时的this指向对象。</p>
<p>闭包会使得 函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>同时闭包会在 父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【6】this指向问题</title>
    <url>/2022/05/06/6-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220506102501.png"><br>重要的事情说三遍：<b style="color:red">this 永远指向最后调用它的那个对象</b>、<b style="color:red">this 永远指向最后调用它的那个对象</b>、<b style="color:red">this 永远指向最后调用它的那个对象</b>。</p>
<p>例子一：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Cherry&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);          <span class="comment">// windowsName</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;inner:&quot;</span> + <span class="built_in">this</span>);    <span class="comment">// inner: Window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;outer:&quot;</span> + <span class="built_in">this</span>)         <span class="comment">// outer: Window</span></span><br></pre></td></tr></table></figure>
<p>最后调用 <code>a</code> 的地方 <code>a()</code>;，前面没有调用的对象那么就是全局对象 <code>window</code>，这就相当于是 <code>window.a()</code>；注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 <code>undefined</code>，那么就会报错 <code>Uncaught TypeError: Cannot read property &#39;name&#39; of undefined</code>。</p>
<p>例子二：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Cherry&quot;</span>,</span><br><span class="line">    <span class="attr">fn</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);      <span class="comment">// Cherry</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br></pre></td></tr></table></figure>
<p>最终，函数<code>fn</code>是被对象<code>a</code>调用，所以<code>this</code>的指向是对象<code>a</code>。</p>
<p>例子三：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Cherry&quot;</span>,</span><br><span class="line">    <span class="attr">fn</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);      <span class="comment">// Cherry</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.a.fn();</span><br></pre></td></tr></table></figure>
<p>最终，函数<code>fn</code>是被对象<code>a</code>调用，所以<code>this</code>的指向是对象<code>a</code>。</p>
<p>例子四：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="comment">// name: &quot;Cherry&quot;,</span></span><br><span class="line">    <span class="attr">fn</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);      <span class="comment">// undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.a.fn();</span><br></pre></td></tr></table></figure>
<p>最终，<code>this</code>的指向是对象<code>a</code>，但是对象<code>a</code>中没有<code>name</code>属性，所以返回值是<code>undefined</code>。</p>
<p>例子五：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// name: &quot;Cherry&quot;,</span></span><br><span class="line">    <span class="attr">fn</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);      <span class="comment">// windowsName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = a.fn;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>将对象<code>a</code>的<code>fn</code>方法赋值给<code>f</code>，但是此时并没有调用执行<code>fn</code>方法，最终是通过<code>f()</code>进行调用，而<b style="color:red">this 永远指向最后调用它的那个对象</b>，所以<code>this</code>的指向是对象<code>window</code>。</p>
<p>例子六：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Cherry&#x27;</span>;</span><br><span class="line">    innerFunction();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);      <span class="comment">// windowsName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<h2 id="改变this指向的方法"><a href="#改变this指向的方法" class="headerlink" title="改变this指向的方法"></a>改变<code>this</code>指向的方法</h2><ul>
<li>ES6 的箭头函数</li>
<li>函数内部使用 <code>_this = this</code></li>
<li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li>
<li><code>new</code> 实例化一个对象</li>
</ul>
<p>⭐ 箭头函数<br><b>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</b></p>
<blockquote>
<p>箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;Cherry&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func1</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.func1()</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()     <span class="comment">// Cherry</span></span><br></pre></td></tr></table></figure>

<p>⭐ 函数内部使用 <code>_this = this</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;windowsName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;Cherry&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func1</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            _this.func1()</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()       <span class="comment">// Cherry</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，在 <code>func2</code> 中，首先设置 <code>var _this = this;</code>，这里的 <code>this</code> 是调用 <code>func2</code> 的对象 <code>a</code>，为了防止在 <code>func2</code> 中的 <code>setTimeout</code> 被 <code>window</code> 调用而导致的在 <code>setTimeout</code> 中的 <code>this</code> 为 <code>window</code>。我们将 <code>this</code>(指向变量 a) 赋值给一个变量 <code>_this</code>，这样，在 <code>func2</code> 中我们使用 <code>_this</code> 就是指向对象 <code>a</code> 了。</p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【7】图片懒加载</title>
    <url>/2022/05/24/7-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>图片懒加载，顾名思义，就是滑动页面到能看到图片的时候再加载图片。</p>
<p>对于图片懒加载而言，可以分为两部分进行考虑：①判断图片进入到可视窗口 ②控制图片进行加载</p>
<h1 id="0-为什么懒加载？"><a href="#0-为什么懒加载？" class="headerlink" title="0. 为什么懒加载？"></a>0. 为什么懒加载？</h1><p>对于首屏之外的内容，特别是图片和视频，一方面由于资源文件很大，若是全部加载完成，既费时又费力，还容易阻塞渲染引起卡顿；另一方面，就算加载完成用户也不一定浏览到全部内容，如果首屏没有吸引到用户，很可能整个页面都会被关闭。<br>所以，在首次打开网站时，应尽量只加载首屏内容，首屏之外的图片或视频可以等到用户滑动到的时候再加载。</p>
<h1 id="1-实现方式："><a href="#1-实现方式：" class="headerlink" title="1. 实现方式："></a>1. 实现方式：</h1><h2 id="方式一：位置计算-监听滚动事件-DataSet-API"><a href="#方式一：位置计算-监听滚动事件-DataSet-API" class="headerlink" title="方式一：位置计算 + 监听滚动事件 + DataSet API"></a>方式一：位置计算 + 监听滚动事件 + DataSet API</h2><p>👉 判断图片出现在窗口中需要用到<code>clientTop</code>，<code>offsetTop</code>，<code>clientHeight</code> 以及 <code>scrollTop</code> 各种关于图片的高度作比对<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220524151700.png"><br>（一堆东西也记不住，不如，放过自己？）</p>
<p>👉 监听 <code>window.scroll</code> 事件</p>
<p>👉 控制图片加载</p>
<p><code>&lt;img data-src=&quot;shanyue.jpg&quot;&gt;</code></p>
<p>首先设置一个临时 <code>Data</code> 属性 <code>data-src</code>，控制加载时使用 <code>src</code> 代替 <code>data-src</code>，可利用 <code>DataSet API</code> 实现</p>
<p><code>img.src = img.datset.src</code></p>
<h2 id="方式二：getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API"><a href="#方式二：getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API" class="headerlink" title="方式二：getBoundingClientRect API + Scroll with Throttle + DataSet API"></a>方式二：getBoundingClientRect API + Scroll with Throttle + DataSet API</h2><p>👉 <code> getBoundingClientRecy()</code>函数获取元素的相对位置。<br>getBoundingClientRecy().top 、 getBoundingClientRecy().bottom 、 getBoundingClientRecy().left 、 getBoundingClientRecy().right<br>位置如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220524160129.png"></p>
<p>如何判断图片出现在了当前视口？</p>
<p><code> img.getBoundingClientRect().top &lt; document.documentElement.clientHeight</code></p>
<p>👉 优化<code>window.scroll</code>事件<br>加个节流器，提高性能。工作中一般使用 lodash.throttle 就可以了。</p>
<p><code>_.throttle(func, [wait=0], [options=&#123;&#125;])</code></p>
<p>👉 控制图片加载 同方式一</p>
<h2 id="方式三：IntersectionObserver-API-DataSet-API"><a href="#方式三：IntersectionObserver-API-DataSet-API" class="headerlink" title="方式三：IntersectionObserver API + DataSet API"></a>方式三：IntersectionObserver API + DataSet API</h2><p>⚡ 方案二使用的方法是: <code>window.scroll</code> 监听 <code>Element.getBoundingClientRect()</code> 并使用 <code>_.throttle</code> 节流</p>
<p>👉 一系列组合动作太复杂了，于是浏览器出了一个三合一事件:   <code>Intersection Observer API</code>，一个能够监听元素是否到了当前视口的事件，一步到位！</p>
<p>关于<code>Intersection Observer API</code>的简述：<br>每当因页面滚动或者窗口尺寸发生变化，使得目标元素（target）与设备视窗或其他指定元素产生交集时，便会触发<code>Intersection Observer API</code>配置的回调函数，在该回调函数中进行延迟加载的逻辑处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">changes</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// changes: 目标元素集合</span></span><br><span class="line">  changes.forEach(<span class="function">(<span class="params">change</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// intersectionRatio</span></span><br><span class="line">    <span class="keyword">if</span> (change.isIntersecting) &#123;</span><br><span class="line">      <span class="keyword">const</span> img = change.target</span><br><span class="line">      img.src = img.dataset.src</span><br><span class="line">      observer.unobserve(img)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">observer.observe(img)</span><br></pre></td></tr></table></figure>

<h2 id="方式四：LazyLoading属性"><a href="#方式四：LazyLoading属性" class="headerlink" title="方式四：LazyLoading属性"></a>方式四：LazyLoading属性</h2><p>浏览器觉得懒加载这事可以交给自己做，你们开发者加个属性就好了。缺点就是兼容性存在问题。<br><code> &lt;img src=&quot;shanyue.jpg&quot; loading=&quot;lazy&quot;&gt;</code></p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【1】原型与原型链</title>
    <url>/2022/04/06/1.%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220406132939.png"></p>
<hr>

<h2 id="1-一张图"><a href="#1-一张图" class="headerlink" title="1. 一张图"></a>1. 一张图</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg"></p>
<ul>
<li>函数也是对象，对象的<code>__proto__</code>指向构造函数</li>
</ul>
<h2 id="2-什么是原型？"><a href="#2-什么是原型？" class="headerlink" title="2. 什么是原型？"></a>2. 什么是原型？</h2><p>每个JS对象（<code>null</code>除外）在创建的时候，就会与之关联的另一个对象，这个对象就是原型。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220406130950.png"></p>
<h2 id="3-什么是原型链？"><a href="#3-什么是原型链？" class="headerlink" title="3. 什么是原型链？"></a>3. 什么是原型链？</h2><p>由相互关联的原型组成的链状结构就是原型链。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220406131939.png"></p>
<h2 id="4-prototype"><a href="#4-prototype" class="headerlink" title="4. prototype"></a>4. <code>prototype</code></h2><p>每个函数都有一个<code>prototype</code>属性，指向调用该构造函数而创建的实例的原型。</p>
<ul>
<li><code>prototype</code>是函数才会有的属性</li>
</ul>
<h2 id="5-proto"><a href="#5-proto" class="headerlink" title="5. __proto__"></a>5. <code>__proto__</code></h2><p>每个JS对象（处了<code>null</code>）都具有一个属性<code>__proto__</code>，这个属性会指向该对象的原型。</p>
<h2 id="6-constructor"><a href="#6-constructor" class="headerlink" title="6. constructor"></a>6. constructor</h2><p>每个原型都有一个<code>constructor</code>属性指向关联的构造函数。</p>
<h2 id="7-实例与原型"><a href="#7-实例与原型" class="headerlink" title="7. 实例与原型"></a>7. 实例与原型</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220406132548.png"></p>
<h2 id="8-原型的原型"><a href="#8-原型的原型" class="headerlink" title="8. 原型的原型"></a>8. 原型的原型</h2><p>原型也是对象，既然是对象就可以通过最原始的方式创建<code>var obj = new Object()</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220406132827.png"></p>
<h2 id="9-真的是继承吗？"><a href="#9-真的是继承吗？" class="headerlink" title="9.真的是继承吗？"></a>9.真的是继承吗？</h2><blockquote>
<p>继承意味着复制，然而Javascript默认并不会复制对象的属性，相反，Javascript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。    ————《你不知道的Javascript》</p>
</blockquote>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【我眼中的】 - 【4】手写new</title>
    <url>/2022/04/19/4-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-%E6%89%8B%E5%86%99new/</url>
    <content><![CDATA[<h2 id="1-new-操作符"><a href="#1-new-操作符" class="headerlink" title="1. new 操作符"></a>1. <code>new</code> 操作符</h2><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
<p>使用<code>new</code>调用类的构造函数会执行如下操作：</p>
<ol>
<li>在内存中创建一个新的对象（即<code>&#123;&#125;</code>）</li>
<li>为步骤1中创建的对象添加属性<code>__proto__</code>，将该属性连接至构造函数的原型对象</li>
<li>将步骤1创的对象作为<code>this</code>的上下文</li>
<li>如果该函数没有返回对象，则返回<code>this</code></li>
</ol>
<p>对于步骤4，进行如下代码阐述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">⭐ <span class="number">1.</span>构造函数无返回值</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Person(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line">打印值为&#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">⭐ <span class="number">2.</span>构造函数返回值为对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">age</span>:<span class="number">18</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Person(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line">打印值为&#123; <span class="attr">age</span>:<span class="number">18</span> &#125;</span><br><span class="line"></span><br><span class="line">⭐ <span class="number">3.</span>构造函数返回值为非对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Person(<span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"></span><br><span class="line">打印值为&#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p> 所以说<code>new</code>操作符必须要返回一个对象，如果构造函数中没有<code>return</code>那就返回<code>this</code>，如果有<code>return</code>并且<code>return</code>的是一个对象，那么就会返回这个对象，否则都返回<code>this</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220419204952.png"></p>
<blockquote>
<p>来自MDN的解释：<br>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情：<br>1.一个继承自 <code>Foo.prototype</code> 的新对象被创建。<br>2.使用指定的参数调用构造函数 <code>Foo</code>，并将 <code>this</code> 绑定到新创建的对象。<code>new Foo</code> 等同于 <code>new Foo()</code>，也就是没有指定参数列表，<code>Foo</code> 不带任何参数调用的情况。<br>3.由构造函数返回的对象就是 <code>new</code> 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</p>
</blockquote>
<p><b>※ 构造函数为箭头函数</b></p>
<p>普通函数创建时，引擎会按照特定的规则为这个函数创建一个<code>prototype</code>属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 <code>constructor</code> 的属性，指回与之关联的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    constructor: ƒ Foo()</span></span><br><span class="line"><span class="comment">    __proto__: Object</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<p>创建箭头函数时，引擎不会为其创建<code>prototype</code>属性，箭头函数没有<code>constructor</code>供<code>new</code>调用，因此使用new调用箭头函数会报错！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function">()=&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Person()<span class="comment">//TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>也就是说构造函数必须是声明式的，即<code>function xxx()</code>，不可以是表达式的。</p>
<h2 id="2-手写new"><a href="#2-手写new" class="headerlink" title="2.手写new"></a>2.手写<code>new</code></h2><p>依据原理：</p>
<ol>
<li>创建一个对象<code>obj</code></li>
<li>该对象的<code>__proto__</code>指向构造函数Fn的原型<code>prototype</code></li>
<li>执行构造函数<code>Fn</code>的代码，往新创建的对象<code>obj</code>上添加成员属性和方法</li>
<li>返回这个新的对象<code>obj</code></li>
</ol>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">_new</span> (<span class="params">constructor, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数合法类型判断</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title">constructor</span> !== &#x27;<span class="title">function</span>&#x27;) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;constructor must be a function&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个空对象，并继承构造函数的 prototype 属性</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="title">constructor</span>.<span class="title">prototype</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定this</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">obj, args</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有返回值且返回值是对象类型，那么就将它作为返回值，否则就返回之前新建的对象</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result !== <span class="literal">null</span>) || <span class="keyword">typeof</span> result === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><p>作用：创建一个新对象，使用现有的对象来提供新创建的对象的 <code>__proto__</code></p>
<p>因此，可以得出结论</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(func.prototype)</span><br><span class="line"></span><br><span class="line">⭐ 相当于如下语句：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Con</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Con.prototype = func.prototype;</span><br><span class="line">Con.prototype.constructor = func;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Con();</span><br></pre></td></tr></table></figure>

<h3 id="通过new的方式创建对象与通过字面量创建的区别"><a href="#通过new的方式创建对象与通过字面量创建的区别" class="headerlink" title="通过new的方式创建对象与通过字面量创建的区别"></a>通过<code>new</code>的方式创建对象与通过字面量创建的区别</h3><ul>
<li><code>new Object()</code> 方式创建对象本质上是方法调用，涉及到在原型链中查找该方法，当找到该方法后，又会生产方法调用必须的堆栈信息，方法调用结束后，还要释放该堆栈，性能不如字面量的方式</li>
<li>通过对象字面量定义对象时，不会调用<code>Object</code>的构造函数</li>
</ul>
<p>Tips : 使用字面量的方式创建对象 性能上 更好，可读性 更高</p>
]]></content>
      <categories>
        <category>我眼中的系列</category>
      </categories>
      <tags>
        <tag>我眼中的系列</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS实现点击div添加选中样式</title>
    <url>/2022/01/18/CSS%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BBdiv%E6%B7%BB%E5%8A%A0%E9%80%89%E4%B8%AD%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="情景"><a href="#情景" class="headerlink" title="情景:"></a>情景:</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220118144305.png"><br>四个按钮，选中其中一个后，为其添加样式且要保持样式，当选择其他的按钮后，之前选中按钮样式取消，选中按钮样式添加。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用input标签和label标签。</p>
<ul>
<li>input标签表示单选按钮，保证只能有一个按钮可以选中（name相同）。隐藏不显示。</li>
<li>label标签用于显示文字和设置选中背景颜色。</li>
</ul>
<p>实现点击之后才进行切换的效果：<br>将lable指向相应的input标签的id并使用伪类:checked来实现选择切换的效果。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;catebtn&quot;</span> <span class="attr">id</span>=<span class="string">&quot;news&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;news&quot;</span>&gt;</span>公司新闻<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;catebtn&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dongtai&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;dongtai&quot;</span>&gt;</span>行业动态<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;catebtn&quot;</span> <span class="attr">id</span>=<span class="string">&quot;baodao&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;baodao&quot;</span>&gt;</span>媒体报道<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;catebtn&quot;</span> <span class="attr">id</span>=<span class="string">&quot;zhishi&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;zhishi&quot;</span>&gt;</span>行业知识<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">label</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.1rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">label</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#026eb7</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-id">#news</span><span class="selector-pseudo">:checked</span>+<span class="selector-tag">label</span>,</span><br><span class="line"><span class="selector-id">#dongtai</span><span class="selector-pseudo">:checked</span>+<span class="selector-tag">label</span>,</span><br><span class="line"><span class="selector-id">#baodao</span><span class="selector-pseudo">:checked</span>+<span class="selector-tag">label</span>,</span><br><span class="line"><span class="selector-id">#zhishi</span><span class="selector-pseudo">:checked</span>+<span class="selector-tag">label</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#026eb7</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS奇淫技巧</title>
    <url>/2021/09/22/CSS%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>CSS奇淫技巧</p>
<h3 id="1-提示框"><a href="#1-提示框" class="headerlink" title="1.提示框"></a>1.提示框</h3><p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210922164322.gif"><br>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bruce flex-ct-y&quot;</span> <span class="attr">data-title</span>=<span class="string">&quot;使用attr()抓取节点属性&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;hover-tips btn-1&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">data-msg</span>=<span class="string">&quot;Hello World&quot;</span>&gt;</span>提示框<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hover-tips</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="number">#66f</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">	&amp;<span class="selector-class">.btn-1</span> &#123;</span><br><span class="line">		&amp;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">			<span class="attribute">position</span>: absolute;</span><br><span class="line">			<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">			<span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">			<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">			<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">			<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">			<span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">#000</span>, <span class="number">0.5</span>);</span><br><span class="line">			<span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">			<span class="attribute">text-align</span>: center;</span><br><span class="line">			<span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">			<span class="attribute">content</span>: <span class="built_in">attr</span>(data-msg);</span><br><span class="line">			<span class="attribute">transition</span>: all <span class="number">300ms</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		&amp;<span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">			<span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">100%</span> + <span class="number">20px</span>);</span><br><span class="line">			<span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在按钮上触发悬浮状态:hover时，通过attr()获取节点的data-msg并赋值到::after的content上</p>
<h3 id="2-绘制三角形"><a href="#2-绘制三角形" class="headerlink" title="2.绘制三角形"></a>2.绘制三角形</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;triangle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">50px</span> solid red;</span><br><span class="line">  <span class="attribute">border-top</span>:<span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220105102020.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">50px</span> solid red;</span><br><span class="line">  <span class="attribute">border-top</span>:<span class="number">50px</span> solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220105102125.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">50px</span> solid red;</span><br><span class="line">  <span class="attribute">border-top</span>:<span class="number">50px</span> solid green;</span><br><span class="line">  <span class="attribute">border-right</span>:<span class="number">50px</span> solid blue;</span><br><span class="line">  <span class="attribute">border-bottom</span>:<span class="number">50px</span> solid yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220105102312.png"></p>
<h3 id="3-实现点击div添加选中样式"><a href="#3-实现点击div添加选中样式" class="headerlink" title="3.实现点击div添加选中样式"></a>3.实现点击div添加选中样式</h3><p><a href="https://qw-null.github.io/2022/01/18/CSS%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BBdiv%E6%B7%BB%E5%8A%A0%E9%80%89%E4%B8%AD%E6%A0%B7%E5%BC%8F/#%E6%83%85%E6%99%AF">实现点击div添加选中样式</a></p>
]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Echarts快速上手</title>
    <url>/2021/09/14/Echarts%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<h2 id="Echarts使用五部曲"><a href="#Echarts使用五部曲" class="headerlink" title="Echarts使用五部曲"></a>Echarts使用五部曲</h2><ul>
<li>步骤1：下载并引入echarts.js文件</li>
<li>步骤2：准备一个 <mark><b>具备大小</b></mark>的DOM容器</li>
<li>步骤3：初始化echarts实例对象</li>
<li>步骤4：指定配置项和数据（option）</li>
<li>步骤5：将配置项设置给echarts实例对象</li>
</ul>
<h3 id="步骤1：下载并引入echarts-js文件"><a href="#步骤1：下载并引入echarts-js文件" class="headerlink" title="步骤1：下载并引入echarts.js文件"></a>步骤1：下载并引入echarts.js文件</h3><p>安装方式：</p>
<ul>
<li>从npm获取<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install echarts --save</span><br></pre></td></tr></table></figure>
详见<a href="https://echarts.apache.org/handbook/zh/basics/import/">在项目中引入 Apache ECharts</a></li>
<li>从 CDN 获取<br>从 jsDelivr 引用 <a href="https://www.jsdelivr.com/package/npm/echarts">echarts</a></li>
<li>从 GitHub 获取<br><a href="https://github.com/apache/echarts">apache/echarts</a> 项目的 release 页面可以找到各个版本的链接。点击下载页面下方 Assets 中的 Source code，解压后 dist 目录下的 echarts.js 即为包含完整 ECharts 功能的文件</li>
</ul>
<p>引入文件为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914093547.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914093752.png"></p>
<h3 id="步骤2：准备一个-具备大小的DOM容器"><a href="#步骤2：准备一个-具备大小的DOM容器" class="headerlink" title="步骤2：准备一个 具备大小的DOM容器"></a>步骤2：准备一个 <mark><b>具备大小</b></mark>的DOM容器</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914100708.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914100731.png"></p>
<h3 id="步骤3：初始化echarts实例对象"><a href="#步骤3：初始化echarts实例对象" class="headerlink" title="步骤3：初始化echarts实例对象"></a>步骤3：初始化echarts实例对象</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914100559.png"></p>
<h3 id="步骤4：指定配置项和数据（option）"><a href="#步骤4：指定配置项和数据（option）" class="headerlink" title="步骤4：指定配置项和数据（option）"></a>步骤4：指定配置项和数据（option）</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914101109.png"></p>
<h3 id="步骤5：将配置项设置给echarts实例对象"><a href="#步骤5：将配置项设置给echarts实例对象" class="headerlink" title="步骤5：将配置项设置给echarts实例对象"></a>步骤5：将配置项设置给echarts实例对象</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914101150.png"></p>
<h2 id="Echarts的基础配置（option）"><a href="#Echarts的基础配置（option）" class="headerlink" title="Echarts的基础配置（option）"></a>Echarts的基础配置（option）</h2><blockquote>
<p>需要了解的主要配置：series xAxis yAxis grid tooltip title legend color toolbox</p>
</blockquote>
<ul>
<li>series 系列图标配置 决定显示那种类型的图表</li>
<li>xAxis 设置x轴的相关配置（boundaryGap是否让坐标轴和线条之间有缝隙）</li>
<li>yAxis 设置x轴的相关配置</li>
<li>grid 网格配置 可以控制线性图、柱状图等图表的大小（containLabel 显示图标刻度标签[true / false]）</li>
<li>tooltip 提示框组件（触发方式trigger [axis / item] ）</li>
<li>title 标题组件–设置图表的标题</li>
<li>legend 图例组件</li>
<li>color 调色板配置 设置线条颜色</li>
<li>toolbox 工具箱组件 可以另存为图片等功能</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914104751.png"></p>
<h3 id="图表跟随屏幕自动去适应"><a href="#图表跟随屏幕自动去适应" class="headerlink" title="图表跟随屏幕自动去适应"></a>图表跟随屏幕自动去适应</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    myChart.resize()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210914145903.png"></p>
]]></content>
      <categories>
        <category>Echarts</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title>Git教程</title>
    <url>/2021/11/22/Git%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV15J411973T?share_source=copy_web">尚硅谷Git教程全套完整版</a></p>
<h2 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1.版本控制"></a>1.版本控制</h2><p>使用版本控制可以将某个文件回溯到之前的状态，设置将某个项目回退到过去某个时间点的状态。</p>
<h4 id="集中化的版本控制系统-SVN）"><a href="#集中化的版本控制系统-SVN）" class="headerlink" title="集中化的版本控制系统 (SVN）"></a>集中化的版本控制系统 (SVN）</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211122145302.png"><br>优点：代码存放在单一的服务器上，便于项目管理<br>缺点：</p>
<ol>
<li><p>中央服务器的单点故障<br>如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p>
<blockquote>
<p><span style="color:blue;">(并不是说服务器故障了就没有办法写代码了,只是在服务器故障的情况下,编写的代码是没有办法得到保障的.试想 svn 中央服务器挂机一天.你还拼命写了一天代码,其中 12 点之前的代码都是高质量可靠的,而且有很多闪光点.而 12 点之后的代码由于你想尝试一个比较大胆的想法,将代码改的面目全非了.这样下来你 12 点之前做的工作也都白费了 有记录的版本只能是 svn 服务器挂掉时保存的版本!)</span></p>
</blockquote>
</li>
<li><p>中央服务器磁盘发生故障</p>
<blockquote>
<p>要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而客户端偶然提取出来的保存在本地的某些快照数据就成了恢复数据的希望。但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
</blockquote>
</li>
</ol>
<p>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211122151436.png"></p>
<p>SVN每次存的都是版本之间的差异代码，需要硬盘空间相对小一些，但是回滚的速度会很慢<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211220100343.png"></p>
<h4 id="分布式的版本控制系统-（Git）"><a href="#分布式的版本控制系统-（Git）" class="headerlink" title="分布式的版本控制系统 （Git）"></a>分布式的版本控制系统 （Git）</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211122152040.png"><br><em>客户端并不只是提取最新版本的文件快照，而是把代码仓库完整地镜像下来</em></p>
<p>Git每次存储的都是项目的完整快照，需要的硬盘空间会相对大一些（Git团队对代码做了极致的压缩，最终需要的实际空间比SVN多不了多少），Git的回滚速度极快<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211122154932.png"></p>
<p>优点：完全的分布式<br>缺点：学习成本高</p>
<h2 id="2-Git底层概念"><a href="#2-Git底层概念" class="headerlink" title="2.Git底层概念"></a>2.Git底层概念</h2><h4 id="2-1-基础Linux命令"><a href="#2-1-基础Linux命令" class="headerlink" title="2.1 基础Linux命令"></a>2.1 基础Linux命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clear <span class="comment"># 清除屏幕</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;test content&#x27;</span> <span class="comment">#往控制台输出信息 echo &#x27;test content&#x27; &gt; test.txt</span></span><br><span class="line">ll <span class="comment">#将当前目录下的 子文件&amp;子目录平铺在控制台</span></span><br><span class="line">find 目录名 <span class="comment">#将对应目录下的子孙文件&amp;子孙目录平铺在控制台</span></span><br><span class="line">find 目录名 -<span class="built_in">type</span> f <span class="comment"># 将对应目录下的文件平铺在控制台</span></span><br><span class="line">rm 文件名 <span class="comment">#删除文件</span></span><br><span class="line">mv 源文件 重命名文件 <span class="comment">#重命名</span></span><br><span class="line">cat 文件的url <span class="comment">#查看对应文件的内容</span></span><br><span class="line">vim 文件的url（在英文模式下）</span><br><span class="line">  按i进入插入模式 进行文件的编辑</span><br><span class="line">  按esc键 + 按:键 进入命令的执行</span><br><span class="line">    q! <span class="comment">#强制退出（不保存）</span></span><br><span class="line">    wq <span class="comment">#保存退出</span></span><br><span class="line">    <span class="built_in">set</span> nu <span class="comment">#设置行号</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-初始化新仓库与-git目录"><a href="#2-2-初始化新仓库与-git目录" class="headerlink" title="2.2 初始化新仓库与.git目录"></a>2.2 初始化新仓库与.git目录</h4><p>首次使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git版本信息</span></span><br><span class="line">git --version</span><br><span class="line"><span class="comment"># git配置</span></span><br><span class="line">git config --global user.name <span class="string">&quot;我的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;我的邮箱&quot;</span></span><br><span class="line"><span class="comment"># 查看当前配置</span></span><br><span class="line">git config --list</span><br><span class="line"><span class="comment"># 修改时使用相同的命令进行覆盖</span></span><br><span class="line"><span class="comment"># git config --global user.name &quot;我的用户名&quot;</span></span><br><span class="line"><span class="comment"># git config --global user.email &quot;我的邮箱&quot;</span></span><br></pre></td></tr></table></figure>
<p>初始化新仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">1. 初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</span><br><span class="line">2. 要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：git init</span><br></pre></td></tr></table></figure>
<p>.git目录<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211220142540.png"></p>
<h4 id="2-3-Git区域与对象"><a href="#2-3-Git区域与对象" class="headerlink" title="2.3 Git区域与对象"></a>2.3 Git区域与对象</h4><h5 id="2-3-1-区域"><a href="#2-3-1-区域" class="headerlink" title="2.3.1 区域"></a>2.3.1 区域</h5><ol>
<li>工作区（Working Directory）<br>本地代码，日常书写代码目录，肉眼可见区域（沙箱环境：git不会对其进行管理）</li>
<li>暂存区（Stage 或 Index）<br>数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。</li>
<li>版本库（commit History）<br>git commit 后给你生成版本的地方,注意push是提交到远程仓库而不是版本库,请勿混淆</li>
</ol>
<h6 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h6><blockquote>
<p>每个项目都有一个git目录（.git），它是用来保存元数据和对象数据库的地方，每次克隆镜像仓库时，实际上就是拷贝这个目录里的数据。<br>①、在工作目录中修改某些文件<br>   从项目中取出某个版本的所有文件和目录,用以开始后续工作的叫做工作目录,这些文件实际上都是从Git目录中的压缩对象数据库中提取出来的,接下去就可以在工作目录中对这些文件进行编辑<br>②、保存到暂存区域,对暂存区做快照<br>   暂存区域只不过是个简单的文件,一般都放在Git目录中,有时候人们会把这个区域的文件叫做索引文件,不过标准说法还是叫暂存区域<br>③、提交更新<br>   将保存区在暂存区域的文件快照永久转储到本地数据库(Git目录)中</p>
</blockquote>
<p>   可以从文件所处的位置来判断状态</p>
<h5 id="2-3-2对象（Git底层概念）"><a href="#2-3-2对象（Git底层概念）" class="headerlink" title="2.3.2对象（Git底层概念）"></a>2.3.2对象（Git底层概念）</h5><ol>
<li><p>Git对象</p>
<p>key : value 组成的键值对,key是value对应的hash，键值对在git内部都是一个blob类型<br>git对象存储文件内容<br>git对象代表文件的一次次版本</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">》了解即可《</span><br><span class="line">① 直接写入git对象方法与读取(存入<span class="string">&quot;.git/objects&quot;</span>)</span><br><span class="line"><span class="comment">#将打印内容写入对象(git数据库)并且返回其相应哈希值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;写入的对象内容&quot;</span> | git hash-object -w --stdin </span><br><span class="line"></span><br><span class="line"><span class="comment">#读取内容并不能直接cat读取,因为git存入时已经加密,需要如下代码 -p:内容  -t:类型</span></span><br><span class="line">git cat-file -p 存入对象的哈希值(此值可以由上一步得到) </span><br><span class="line"></span><br><span class="line"><span class="comment">#将文件写入git对象,即我们常见的版本控制中出现的</span></span><br><span class="line">git hash-object -w ./test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Git存储的数据  返回其文件夹内的所有哈希文件</span></span><br><span class="line">find .git/objects -<span class="built_in">type</span> f </span><br></pre></td></tr></table></figure></li>
<li><p>树对象<br>树对象代表项目的一次次快照</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">》了解即可《</span><br><span class="line">构建树对象</span><br><span class="line">我们可以通过 update-index , write-tree , read-tree 等命令来构建树对象并且塞到暂存区</span><br><span class="line"></span><br><span class="line">① 利用 update-index 命令 创建暂存区</span><br><span class="line">利用 update-index 命令 为test.txt文件的首个版本创建一个暂存区,并通过write-tree命令生成树对象</span><br><span class="line"></span><br><span class="line"><span class="comment">#1生成一个树对象</span></span><br><span class="line">git update-index --add --cacheinfo 100664(文件状态码:普通文件) 哈希值 对应文件名</span><br><span class="line"><span class="comment">#生成快照(树对象)</span></span><br><span class="line">git write-tree</span><br><span class="line"><span class="comment">#2 将第一个树对象加入第二个树对象,使其成为新的树对象</span></span><br><span class="line">git read-tree -prefix=bak 哈希值(树对象的)  </span><br><span class="line">git write-tree</span><br><span class="line">② 查看暂存区当前样子</span><br><span class="line">git ls-files -s</span><br></pre></td></tr></table></figure></li>
<li><p>提交对象 – 链式<br>我们可以通过调用commit-tree命令创建一个提交对象,为此需要指定一个树对象的SHA-1值,为此需要指定一个树对象的SHA-1值 , 以及该提交的父提交对象(如果有的话,第一次将暂存区做快照就没有父对象)</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220105231626.png"></p>
<h4 id="2-4小结"><a href="#2-4小结" class="headerlink" title="2.4小结"></a>2.4小结</h4><ol>
<li>底层命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git对象：</span><br><span class="line">   git hash-object -w fileUrl //生成一个key（hash值）:value（压缩后的文件内容）键值对存到.git/objects</span><br><span class="line">tree对象</span><br><span class="line">   git update-index --add --cacheinfo 100644 hash test.txt //往暂存区添加一条记录（让git对象 对应上 文件名）存到.git/index</span><br><span class="line">   git write-tree //生成树对象存到.git/objects</span><br><span class="line">commit对象</span><br><span class="line">   echo &#x27;first commit&#x27; | git commit-tree treehash //生成一个提交对象存到.git/objects</span><br><span class="line">对以上对象的查询</span><br><span class="line">   git cat-file -p hash  //拿对应对象的内容</span><br><span class="line">   git cat-file -t hash  //拿对应对象的类型</span><br></pre></td></tr></table></figure></li>
<li>查看暂存区（需要记忆）<br><code>git  ls-files  -s</code></li>
</ol>
<h2 id="3-Git高层命令"><a href="#3-Git高层命令" class="headerlink" title="3.Git高层命令"></a>3.Git高层命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init                     初始化仓库</span><br><span class="line">git add ./                   将修改添加到暂存区</span><br><span class="line">git commit -a                Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</span><br><span class="line">git commit -m  注释          将暂存区提交到版本库</span><br><span class="line">git status                   查看文件的状态</span><br><span class="line">git diff                     查看哪些修改还没有暂存</span><br><span class="line">git diff --staged            查看哪些修改以及被暂存，还没有提交</span><br><span class="line">git log                      查看操作日志</span><br><span class="line">git rm 文件名                删除工作目录中对应的文件，再将修改添加到暂存区</span><br><span class="line">git mv 原文件名  新文件名     将工作目录中文件进行重命名，再将修改添加到暂存区</span><br><span class="line">---</span><br><span class="line">git branch                   显示分支列表</span><br><span class="line">git branch 分支名            创建分支</span><br><span class="line">git checkout 分支名          切换分支</span><br><span class="line">git branch -d 分支名         删除分支（**不能在本分支上删除该分支，需切出去）</span><br><span class="line">git branch -v                查看每一个分支的最后一次提交</span><br><span class="line">git branch -D 分支名         强制删除分支</span><br><span class="line">git branch name commitHash   新建一个分支并且使分支指向对应的提交对象，commitHash通过下面的命令查找</span><br><span class="line">git log --oneline --decorate --graph --all     查看项目的分叉历史</span><br></pre></td></tr></table></figure>
<h5 id="3-1-git操作最基本流程"><a href="#3-1-git操作最基本流程" class="headerlink" title="3.1 git操作最基本流程"></a>3.1 git操作最基本流程</h5><p>创建工作目录 ——&gt;  对工作目录进行修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add ./</span><br><span class="line">   + 对应底层命令 ：</span><br><span class="line">   git hash-object -w 文件名（修改了多少个工作目录中的文件，此命令就要被执行多少次）</span><br><span class="line">   git update-index...</span><br><span class="line">git commit -m <span class="string">&quot;注释内容&quot;</span></span><br><span class="line">   + 对应底层命令 ： </span><br><span class="line">   git write-tree **</span><br><span class="line">   git commit-tree **</span><br></pre></td></tr></table></figure>
<p>检查当前文件的状态<br>命令： <code>git  status</code><br>作用：确定文件当前处于什么状态<br>工作目录下面的所有文件都不外乎这两种状态：<span style="color:red;">已跟踪</span> 或 <span style="color:red;">未跟踪</span><br>已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是<span style="color:red;">已提交</span>，<span style="color:red;">已修改</span>或者<span style="color:red;">已暂存</span></p>
<p>查看操作日志<br>命令：<code>git log</code><br>作用：在提交了若干更新，又或者克隆了某个项目之后，想回顾下提交历史。<br>其他：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 规整查看信息的格式</span><br><span class="line">git log --pretty=oneline</span><br><span class="line">git log --oneline</span><br></pre></td></tr></table></figure>

<h5 id="3-2-git的分支"><a href="#3-2-git的分支" class="headerlink" title="3.2 git的分支"></a>3.2 git的分支</h5><p>创建分支<br>命令：<code>git branch</code><br>作用：为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支：<code>git branch testing</code>。这会在当前所在的提交对象上创建一个指针</p>
<p>Git 的分支本质上是一个提交对象，HEAD是一个指针，默认指向master分支，切换分支时就是让HEAD指向不同的分支</p>
<p>分支切换会改变你工作目录中的文件。在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支</p>
<ul>
<li>git切换分支会改变三个地方：HEAD、暂存区、工作目录</li>
<li>最佳实践：每次切换分支前，当前分支一定要处于已提交状态</li>
<li>切换分支时，如果当前分支上有未暂存的修改 或者 有未提交的暂存（第一次），分支可以切换成功，但是这种操作可能会污染其他分支</li>
</ul>
<h5 id="3-3小结"><a href="#3-3小结" class="headerlink" title="3.3小结"></a>3.3小结</h5><p>已下命令需要记忆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">git --version</span><br><span class="line"></span><br><span class="line"># 初始化配置</span><br><span class="line">git config --global user.name &quot;qw&quot;</span><br><span class="line">git config --global user.email qw@qq.com</span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"># 初始化仓库</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"># C（新增）-- 在工作目录中新增文件</span><br><span class="line">git status</span><br><span class="line">git add ./</span><br><span class="line">git commit -m &quot;msg&quot;</span><br><span class="line"></span><br><span class="line"># U（修改）-- 在工作目录中修改文件</span><br><span class="line">git status</span><br><span class="line">git add ./</span><br><span class="line">git commit -m &quot;msg&quot;</span><br><span class="line"></span><br><span class="line"># D（删除 &amp; 重命名）--在工作目录中删除文件</span><br><span class="line">git rm 要删除的文件</span><br><span class="line">git mv 老文件  新文件</span><br><span class="line">git status</span><br><span class="line">git commit -m &quot;msg&quot;</span><br><span class="line"></span><br><span class="line"># R（查询）</span><br><span class="line">git status // 查看工作目录中的文件状态（已跟踪【已提交，已暂存，已修改】 未跟踪）</span><br><span class="line">fir diff // 查看未暂存的修改</span><br><span class="line">git diff --cache // 查看未提交的暂存</span><br><span class="line">git log --oneline // 查看提交记录</span><br><span class="line"></span><br><span class="line"># 分支</span><br><span class="line">git log --oneline --decorate --graph --all // 查看整个项目的分支图</span><br><span class="line">git branch // 查看分支列表</span><br><span class="line">git branch -v // 查看分支指向的最新的提交</span><br><span class="line">git branch name // 在当前提交对象上创建新的分支</span><br><span class="line">git branch name commithash // 在指定的提交对象上创建新的分支</span><br><span class="line">git checkout name //切换分支</span><br><span class="line">git branch -d name //删除空的分支或删除已经被合并的分支</span><br><span class="line">git branch -D name // 强制删除分支</span><br></pre></td></tr></table></figure>

<h2 id="4-Git存储"><a href="#4-Git存储" class="headerlink" title="4.Git存储"></a>4.Git存储</h2><p>有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是 <code>git stash</code> 命令。</p>
<figure class="highlight plaintext"><figcaption><span>stash ```命令会将未完成的修改保存到一个栈上，而你</span></figcaption><table><tr><td class="code"><pre><span class="line">可以在任何时候重新应用这些改动(```git stash apply```)</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">git stash list    // 查看存储</span><br><span class="line">git stash apply stash@&#123;2&#125;   // 如果不指定一个储藏，Git 认为指定的是最近的储藏</span><br><span class="line">git stash pop     // 来应用储藏然后立即从栈上扔掉它,常使用</span><br><span class="line">git stash drop    // 加上将要移除的储藏的名字来移除它</span><br></pre></td></tr></table></figure>

<h2 id="5-Git后悔药"><a href="#5-Git后悔药" class="headerlink" title="5.Git后悔药"></a>5.Git后悔药</h2><p>三种情景：</p>
<ol>
<li>工作区：如何撤销自己在工作目录中的修改<br><code>git checkout -- filename</code></li>
<li>暂存区：如何撤销自己的暂存<br><code>git reset HEAD filename</code></li>
<li>版本库：如何撤销自己的提交【注释写错】<br><code> git commit --amend  // 重新提交注释信息</code></li>
</ol>
<h5 id="5-1-reset-三部曲-原理"><a href="#5-1-reset-三部曲-原理" class="headerlink" title="5.1 reset 三部曲(原理)"></a>5.1 reset 三部曲(原理)</h5><p>&star; 1.移动 HEAD<br>reset 做的第一件事是移动 HEAD 的指向。<br><code>git reset --soft HEAD~</code></p>
<ul>
<li>只动HEAD（带着分支一起移动）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220110230239.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220110230304.png"></p>
<p>看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 <code>git commit </code>命令。 当你在运行 <code>git commit </code>时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。<br>当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 <code>git commit</code> 来完成 <code>git commit --amend </code>所要做的事情了。</p>
<p>&star;  2.更新暂存区（索引）<br><code>git reset --mixed HEAD~</code></p>
<ul>
<li>动HEAD（带着分支一起移动）</li>
<li>动暂存区</li>
</ul>
<p>&star; 3.更新工作目录<br><code>git reset --hard HEAD~</code></p>
<ul>
<li>动HEAD（带着分支一起移动）</li>
<li>动暂存区</li>
<li>动工作目录<br><span style="color:red;">必须注意，–hard 标记是 reset 命令唯一的危险用法，它也是 Git 会 真正地销毁数据的仅有的几个操作之一。 </span></li>
</ul>
<p>git checkout commithash 与 git reset –hard commithash区别：</p>
<ol>
<li>checkout 只动HEAD、–hard动HEAD而且带着分支一起走</li>
<li>checkout对工作目录是安全的、–hard是强制覆盖工作目录</li>
</ol>
<p>路径reset</p>
<p>前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220110233703.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220110233729.png"></p>
<h2 id="6-数据恢复"><a href="#6-数据恢复" class="headerlink" title="6.数据恢复"></a>6.数据恢复</h2><p>在你使用 Git 的时候，你可能会意外丢失一次提交。 通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。 如果这些事情已经发生，该如何找回你的提交呢？<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220111103150.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220111103238.png"><br>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。<br>当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一<br>次你提交或改变分支，引用日志都会被更新<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220111103454.png"><br>git reflog 并不能显示足够多的信息。为了使显示的信息更加有用，<br>我们可以执行 git log -g，这个命令会以标准日志的格式输出引用日志</p>
<p>&star; 恢复</p>
<p>看起来下面的那个就是你丢失的提交，你可以通过创建一个新的分支指向这个提交来恢复它。 例如，你可以创建一个名为 recover-branch 的分支指向这个提交（ab1afef）</p>
<p><code>git branch recover-branch ab1afef</code></p>
<p>现在有一个名为 recover-branch 的分支是你的 master 分支曾经指向的地方，再一次使得前两次提交可到达了。</p>
<h2 id="7-打tag"><a href="#7-打tag" class="headerlink" title="7.打tag"></a>7.打tag</h2><p>Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git tag // 列出标签</span><br><span class="line">git show tagname // 查看特定标签</span><br><span class="line">git tag v1.0 // 创建标签1</span><br><span class="line">git tag v1.0 commithash // 创建标签2</span><br><span class="line">git tag -d tagname // 删除标签</span><br><span class="line">git checkout tagname // 检出标签（会造成头部分离，需要再创建一个分支避免）</span><br><span class="line">   + git checkout -b branchname</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220111231847.jpg"><br><a href="https://github.com/qw-null/BlogImages/blob/master/git%E5%A4%8D%E4%B9%A0.pdf">文件地址</a></p>
<h2 id="8-团队协作"><a href="#8-团队协作" class="headerlink" title="8.团队协作"></a>8.团队协作</h2><ol>
<li>项目经理初始化远程仓库<br>一定要初始化一个空的仓库，在GitHub上操作</li>
<li>项目经理创建本地仓库<br><code>git remote 别名 仓库地址（可选）</code><br><code>git init</code><br>将源码复制进来（项目内容）<br>修改用户名、邮箱<br><code>git add .</code><br><code>git commit</code></li>
<li>项目经理推送本地仓库到远程仓库<br>清理windows凭据<br><code>git push 别名/项目地址 分支名</code>（输入项目经理的github用户名和密码；推送完之后会附带生成远程跟踪分支）</li>
<li>项目邀请成员 &amp; 成员接受邀请<br>在GitHub上操作</li>
<li>成员克隆远程仓库<br><code>git clone 仓库地址</code>（在本地生成.git文件，默认为远程仓库配了别名 origin）<br>只有在克隆的时候，本地分支master和远程分支 别名/master 是有同步关系的</li>
<li>成员贡献代码<br>修改源码文件<br><code>git add</code><br><code>git commit</code><br><code>git push 别名 分支</code>（输入成员的github用户名和密码；推送完之后会附带生成远程跟踪分支）</li>
<li>项目经理更新修改<br><code>git fetch 别名</code>（将修改同步到远程跟踪分支上）<br><code>git merge 远程跟踪分支</code></li>
</ol>
<h5 id="8-1正常的数据推送和拉取步骤"><a href="#8-1正常的数据推送和拉取步骤" class="headerlink" title="8.1正常的数据推送和拉取步骤"></a>8.1正常的数据推送和拉取步骤</h5><ol>
<li>确保本地分支已经跟踪了远程跟踪分支</li>
<li>拉取数据：<code>git pull</code></li>
<li>上传数据：<code>git push</code></li>
</ol>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协商缓存 VS 强缓存</title>
    <url>/2022/03/12/HTTP%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98VS%E5%BC%BA%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="1.浏览器缓存"></a>1.浏览器缓存</h2><p>在基于HTTP的前后端交互过程中，是使用缓存可以使得性能得到显著提升。<br>具体的缓存策略有两种：<b>强缓存</b>和<b>协商缓存</b>。</p>
<h3 id="1-1-强缓存"><a href="#1-1-强缓存" class="headerlink" title="1.1 强缓存"></a>1.1 强缓存</h3><p>强缓存就是当浏览器判断出本地缓存未过期时，直接读取本地缓存，无须发起HTTP请求，此时状态为 <b style="background:#f1939c">200 from cache</b>。在HTTP1.1版本后通过头部的<code>cache-control</code>字段的<code>max-age</code>属性值规定的过期时长来判断缓存是否过期失效，这比之前使用<code>expires</code>标识的服务器过期时间更加准确而且安全。</p>
<h3 id="1-2-协商缓存"><a href="#1-2-协商缓存" class="headerlink" title="1.2 协商缓存"></a>1.2 协商缓存</h3><p>协商缓存需要浏览器向服务器发起HTTP请求，来判断浏览器本地缓存的文件是否仍未修改，若未修改则从缓存中读取，此时状态码为 <b style="background:#f1939c">304</b>。<br>具体判断过程：判断浏览器头部<code>if-none-match</code>与服务器端的<code>e-tag</code>是否匹配，来判断所访问的数据是否发生更改。<br>这相比HTTP 1.0版本通过<code>last-modified</code>判断上次文件修改时间来说也更加准确。</p>
<h3 id="1-3-浏览器缓存触发逻辑"><a href="#1-3-浏览器缓存触发逻辑" class="headerlink" title="1.3 浏览器缓存触发逻辑"></a>1.3 浏览器缓存触发逻辑</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220312160626.png"></p>
<p>在浏览器缓存中，强缓存优于协商缓存，若强缓存生效则直接使用强缓存，若不生效则在进行协商缓存请求，由服务器来进行判断是否使用缓存，如果都失效则重新向服务器发起请求获取资源。</p>
<h2 id="2-header字段"><a href="#2-header字段" class="headerlink" title="2 header字段"></a>2 header字段</h2><h3 id="2-1-强缓存相关的header字段"><a href="#2-1-强缓存相关的header字段" class="headerlink" title="2.1 强缓存相关的header字段"></a>2.1 强缓存相关的header字段</h3><p>与强缓存相关的字段有两个：<code>expires</code>和<code>cache-control</code>。</p>
<ul>
<li><p><b>expires</b>：这是HTTP 1.0时的规范，值为一个绝对时间的GMT格式的时间字符串，如<code>Mon, 10 Jun 2022 21:31:12 GMT</code>，如果请求时间在<code>expires</code>之前，那么本地缓存始终有效，否则就会发送请求到服务器获取资源。</p>
</li>
<li><p><b>cache-control: max-age = xxx</b>：这是HTTP 1.1时出现的<code>header</code>信息，利用该字段的<code>max-age</code>值来进行判断。它是一个相对值，例如<code>cache-control: max-age=3600</code>，代表着资源有效期是3600秒。</p>
</li>
</ul>
<p><code>cache-control</code>除该字段外。还有几个常用的设置值：</p>
<ol>
<li><code>no-cache</code>：不使用本地缓存，<b>强制使用缓存协商</b>。先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</li>
<li><code>no-store</code>：<b>禁止使用任何缓存策略</b>，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li>
<li><code>public</code>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</li>
<li><code>private</code>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</li>
</ol>
<p>上述的的设置值<code>no-cache</code>和<code>no-store</code>，<code>public</code>和 <code>private</code>是互斥的，只允许使用其中之一。</p>
<p><b style="color:red">注意：如果<code>cache-control</code>与<code>expires</code>同时存在的话，<code>cache-control</code>的优先级高于<code>expires</code></b></p>
<h3 id="2-2-协商缓存相关的header字段"><a href="#2-2-协商缓存相关的header字段" class="headerlink" title="2.2 协商缓存相关的header字段"></a>2.2 协商缓存相关的header字段</h3><p>协商缓存是由服务器来判断缓存资源是否可用，所以需要客户端与服务器双方通过传递某种标识进行判断缓存是否可用。因此与协商缓存相关的header字段有两对：<code>Etag</code>和<code>If-None-Match</code>、<code>Last-Modified</code>和<code>If-Modified-Since</code></p>
<ol>
<li><p><code>Etag</code>和<code>If-None-Match</code><br>这两者的值是通过哈希运算生成的字符串，只要文件修改该字符串就会发生变化，因此可以更有效的监测文件是否修改。<br>浏览器首次请求资源时，在<code>header</code>中会包含一个<code>ETag</code>字段，当再次对该资源进行请求时，会将之前请求头中的<code>ETag</code>字段的值作为此次请求头中<code>If-None-Match</code>字段，提供给服务器进行缓存有效性验证。若验证缓存有效，则返回304状态码。</p>
</li>
<li><p><code>Last-Modified</code>和<code>If-Modified-Since</code><br>浏览器第一次请求一个资源的时候，服务器返回的<code>header</code>中会加上<code>Last-Modify</code>，<code>Last-modify</code>是一个时间标识该资源的最后修改时间，例如<code>Last-Modify: Thu,31 Dec 2037 23:59:59 GMT</code>。<br>当浏览器再次请求该资源时，request的请求头中会包含<code>If-Modify-Since</code>，该值为缓存之前返回的<code>Last-Modify</code>。服务器收到<code>If-Modify-Since</code>后，根据资源的最后修改时间判断是否命中缓存。如果命中缓存，则返回304状态码。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220313205046.png"></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML+CSS学习笔记</title>
    <url>/2021/07/18/HTML-CSS/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1XJ411X7Ud?p=1">【尚硅谷】Web前端零基础入门HTML5+CSS3基础教程丨初学者从入门到精通</a></p>
<p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99">+ 课程配套资料 +</a></p>
<p>网页分成三部分：</p>
<ul>
<li>结构HTML</li>
<li>表现CSS</li>
<li>行为JavaScript</li>
</ul>
<h1 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h1><p>HTML(Hypertext Markup Language)超文本标记语言。</p>
<h2 id="1-标签"><a href="#1-标签" class="headerlink" title="1.标签"></a>1.标签</h2><p>标签一般成对出现，但是存在一些自结束标签（单标签），如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span>、<span class="tag">&lt;<span class="name">img</span>/&gt;</span>、<span class="tag">&lt;<span class="name">input</span>&gt;</span>、<span class="tag">&lt;<span class="name">input</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h2><p>注释不能嵌套</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释内容 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-标签的属性（P7）"><a href="#3-标签的属性（P7）" class="headerlink" title="3.标签的属性（P7）"></a>3.标签的属性（P7）</h2><p>在标签（开始标签或自结束标签）还可以设置属性;<br>属性和标签中的内容应该使用空格隔开</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span> 标签属性 <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- color为font标签的属性 --&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-文档声明-P8"><a href="#4-文档声明-P8" class="headerlink" title="4.文档声明 (P8)"></a>4.文档声明 (P8)</h2><ul>
<li>文档声明用来告诉浏览器当前网页版本</li>
<li>html5的文档声明 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span> / <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-字符编码（P10）"><a href="#5-字符编码（P10）" class="headerlink" title="5.字符编码（P10）"></a>5.字符编码（P10）</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网页字符集通过&lt;meta&gt;设置</span></span><br><span class="line"><span class="comment">&lt;meta&gt;需要放在&lt;head&gt;&lt;/head&gt;中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-实体（转义字符）"><a href="#6-实体（转义字符）" class="headerlink" title="6.实体（转义字符）"></a>6.实体（转义字符）</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">实体语法：</span><br><span class="line">- &amp;实体名字;</span><br><span class="line">(空格：<span class="symbol">&amp;nbsp;</span></span><br><span class="line">大于号：<span class="symbol">&amp;gt;</span></span><br><span class="line">小于号：<span class="symbol">&amp;lt;</span></span><br><span class="line">版权符号：<span class="symbol">&amp;copy;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7-meta标签"><a href="#7-meta标签" class="headerlink" title="7.meta标签"></a>7.meta标签</h2><p>meta主要用于设置网页中的一些元数据，元数据不是给用户看的<br>charset - 指定网页的字符集<br>name - 指定的数据的名称<br>content - 指定的数据的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML5,前端,CSS3&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">keywords表示网站的关键字，可以同时指定多个关键字，关键字之间使用，隔开</span><br><span class="line"></span><br><span class="line">description 用于指定网站的描述</span><br></pre></td></tr></table></figure>

<h2 id="8-语义化标签-块元素、行内元素（P16-P18）"><a href="#8-语义化标签-块元素、行内元素（P16-P18）" class="headerlink" title="8.语义化标签 + 块元素、行内元素（P16-P18）"></a>8.语义化标签 + 块元素、行内元素（P16-P18）</h2><p>块元素：在页面中独占一行的元素（block element），网页中一般通过块元素进行布局</p>
<ul>
<li>p标签表示页面中的一个段落，块元素</li>
<li>h1~h6标签，标题，块元素</li>
<li>hgroup标签用来为标题分组，可以将一组相关的标题同时放入到hgroup</li>
</ul>
<p>行内元素：在页面中不会独占一行的元素（inline element），主要用于包裹文字</p>
<ul>
<li>em标签表示语音语调的加重,行内元素</li>
<li>strong标签表示强调 </li>
</ul>
<p>一般情况下，会在块元素中放置行内元素，而不会在行内元素中放置块元素；<br>块元素中基本什么元素都能放，特殊情况：p元素中不能放置块元素</p>
<h2 id="9-列表list（P19）"><a href="#9-列表list（P19）" class="headerlink" title="9.列表list（P19）"></a>9.列表list（P19）</h2><p>html中列表一共三种：</p>
<ul>
<li>有序列表</li>
<li>无序列表</li>
<li>定义列表<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.有序列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.无序列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3.定义列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构，结构用来规定网页中哪里是标题，哪里是段落<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
定义列表效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211011141506.png"></li>
</ul>
<h2 id="10-超链接（P20）"><a href="#10-超链接（P20）" class="headerlink" title="10.超链接（P20）"></a>10.超链接（P20）</h2><p>超链接：可以从一个页面跳转到其他页面，或者当前页面的其他位置<br>使用a标签定义超链接<br>  属性：<br>    href → 指定跳转的目标路径<br>    target → 用来指定超链接打开的位置<br>   <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220316192446.png"></p>
<p>超链接，行内元素，在a标签中可以嵌套除自身外的任何元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>的作用和<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>相同</span><br></pre></td></tr></table></figure>
<h3 id="相对路径（P21）"><a href="#相对路径（P21）" class="headerlink" title="相对路径（P21）"></a>相对路径（P21）</h3><p>当需要跳转到服务器内部的页面是，一般使用相对路径，相对路径都会使用.或..开头，如果不写./或../则相当于写了./<br>./表示当前文件所在的目录<br>../表示当前文件所在目录的上一级目录</p>
<h2 id="11-图片标签（P23-P24）"><a href="#11-图片标签（P23-P24）" class="headerlink" title="11.图片标签（P23,P24）"></a>11.图片标签（P23,P24）</h2><p>img标签是一个自结束标签<br>属性：</p>
<ul>
<li>src属性指定的是外部图片路径（路径规则和超链接相同）</li>
<li>width 图片宽度</li>
<li>height 图片高度<br>-宽度和高度如果只修改了一个，则另一个会等比例缩放</li>
</ul>
<p>图片格式：</p>
<ul>
<li>jepg(jpg)-支持的颜色比较丰富，不支持透明效果，不支持动图</li>
<li>gif-支持的颜色比较少，支持简单透明，支持动图</li>
<li>png-支持的颜色丰富，支持复杂透明，不支持动图</li>
<li>webp-这种格式是谷歌新推出的专门用来表示网页中的图片的一种格式，具备其他图片格式的所有优点，而且文件特别小/缺点：兼容性差/</li>
<li>base64-将图片使用base64进行编码，这样可以直接通过字符形式引入图片，一般用于需要和网页同时加载的图片才会使用base64</li>
</ul>
<h2 id="12-内联框架（P25）"><a href="#12-内联框架（P25）" class="headerlink" title="12.内联框架（P25）"></a>12.内联框架（P25）</h2><p>iframe标签，用于在当前页面中引入其他页面<br>属性：</p>
<ul>
<li>src指定要引入的网页的路径 </li>
<li>frameborder 指定内联框架的边框</li>
</ul>
<h2 id="13-音视频播放（P26）"><a href="#13-音视频播放（P26）" class="headerlink" title="13.音视频播放（P26）"></a>13.音视频播放（P26）</h2><p>音视频文件引入时，默认情况下不允许用户自己控制播放停止。</p>
<p>audio标签 用来向页面中引入外部音频文件<br>属性：controls 是否允许用户控制播放<br>autoplay 音频文件是否自动播放<br>loop 音频文件是否循环播放</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;***&quot;</span> <span class="attr">contorls</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>video标签 引入视频文件<br>使用方式和audio标签一致</p>
<p>video标签示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;250&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/media/cc0-videos/flower.webm&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/media/cc0-videos/flower.mp4&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    Sorry, your browser doesn&#x27;t support embedded videos.</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当视频的媒体数据加载期间发生错误时执行 JavaScript :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">onerror</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="14-表格（P96-P97）"><a href="#14-表格（P96-P97）" class="headerlink" title="14.表格（P96-P97）"></a>14.表格（P96-P97）</h2><p>网页中通过table标签来创建表格<br>在table中使用tr表示表格中的一行，有几个tr就有几行，在tr中使用td表示一个单元格，有几个td就有几个单元格<br>colspan 横向的合并单元格； rowsoan 纵向合并单元格</p>
<p>可以将一个表格分为三部分：</p>
<ol>
<li>头部 thead</li>
<li>主体 tbody</li>
<li>底部 tfoot</li>
</ol>
<p>th 表示头部单元格</p>
<h4 id="14-1-表格的样式（P98）"><a href="#14-1-表格的样式（P98）" class="headerlink" title="14.1 表格的样式（P98）"></a>14.1 表格的样式（P98）</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1.border-spacing 指定边框之间的距离 */</span></span><br><span class="line">  <span class="comment">/* 此时边框的宽度为2px */</span></span><br><span class="line">  <span class="attribute">border-spacing</span>：<span class="number">0px</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 2.border-collapse: collapse; 设置边框的合并 */</span></span><br><span class="line">   <span class="comment">/* 此时边框的宽度为1px */</span></span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n)&#123;</span><br><span class="line">  <span class="comment">/* 调整表格偶数行的背景颜色 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果表格中没有使用tbody而直接使用tr，那么浏览器会自动创建一个tbody，并且将所有的tr都放到tbody中，因此tr不再是tbody的子元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &gt; <span class="selector-tag">tr</span> &#123;</span><br><span class="line">  <span class="comment">/* 此时效果无法生效 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下元素在td中是垂直居中的，可以通过 vertical-align 来修改</p>
<h2 id="15-表单（P99）"><a href="#15-表单（P99）" class="headerlink" title="15.表单（P99）"></a>15.表单（P99）</h2><p>网页中的表单用于将本地的数据提交给远程的服务器，使用form标签来创建一个表单<br>form的属性：</p>
<ul>
<li>action 表单要提交的服务器的地址<br>表单项：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文本框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;数据提交给服务器必须指定唯一的名称&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;指定显示文字&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 密码框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;**&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 单选按钮 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 像这种选择框，必须要指定一个value属性，value属性最终会作为用户的填写的值传递给服务器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- checked可以将单选按钮设置为默认选中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;**&quot;</span> <span class="attr">value</span>=<span class="string">&quot;**&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;**&quot;</span> <span class="attr">value</span>=<span class="string">&quot;**&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下拉列表 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- selected 属性设置默认选中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">selected</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 重置按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 普通按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
autocomplete=”off” 关闭自动补全<br>readonly 将表单项设置为只读，数据会提交到服务器端<br>disabled 将表单项设置为禁用，数据不会提交到服务器端<br>autofocus 设置表单项自动获取焦点</li>
</ul>
<h1 id="二、CSS（P27-P28）"><a href="#二、CSS（P27-P28）" class="headerlink" title="二、CSS（P27-P28）"></a>二、CSS（P27-P28）</h1><p>CSS 层叠样式表<br>网页实际上是一个多层结构，通过CSS可以分别为网页的每一层来设计样式，而最终我们能看到的只是网页的最上边一层<br>使用方式：</p>
<ul>
<li>内联样式/行内样式：在标签内部通过style属性来设置元素样式</li>
<li><ul>
<li>问题：样式只对一个标签生效、希望影响多个元素必须在每一个元素中都复制一遍，并且样式发生变化时，我们必须要一个一个的修改，不方便维护</li>
</ul>
</li>
<li><ul>
<li>注意：开发时绝对不要使用内联样式</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>内部样式表：将样式编写到head中的style标签里然后通过CSS选择器来选中元素并为其设置各种样式，可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用</li>
<li>内部样式更加方便对样式进行复用</li>
<li><ul>
<li>问题：内部样式表只能对一个网页起作用，内部样式不能跨页面复用</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>外部样式表：将CSS样式编写到外部CSS文件中，然后通过link标签引入外部CSS文件<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;****&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>意味着只要想使用这些样式的网页都可以对其进行引用，使样式可以在不同页面之间进行复用</li>
<li>将样式编写到外部的CSS文件中，可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户的体验</li>
</ul>
<h2 id="1-CSS基本语法（P29）"><a href="#1-CSS基本语法（P29）" class="headerlink" title="1.CSS基本语法（P29）"></a>1.CSS基本语法（P29）</h2><p>CSS注释 - /* 注释内容 */<br>CSS的基本语法：<br>  选择器 声明块</p>
<ul>
<li>选择器：通过选择器可以选中页面中的指定元素（比如p的作用是选中页面中所有的p元素）</li>
<li>声明块：通过声明块来指定要为元素设置的样式。</li>
<li><ul>
<li>声明块由一个一个的声明组成</li>
</ul>
</li>
<li><ul>
<li>声明是一个名值对结构,一个样式名对应一个样式值，名和值之间以:连接，以;结尾</li>
</ul>
</li>
</ul>
<h2 id="2-常用选择器（P30）"><a href="#2-常用选择器（P30）" class="headerlink" title="2.常用选择器（P30）"></a>2.常用选择器（P30）</h2><p>1.元素选择器</p>
<ul>
<li>作用：根据标签名来选中指定的元素</li>
<li>语法：标签名{}</li>
<li>例子：p{}、 h1{} 、div{}</li>
</ul>
<p>2.id选择器</p>
<ul>
<li>作用：根据元素的id属性值选中一个元素</li>
<li>语法：#id属性值{}</li>
<li>例子：#box{}、#red{}</li>
</ul>
<p>3.类选择器<br>class是一个标签属性，它和id类似，不同的是class可以重复使用，通过class属性可以为元素分组,可以同时为一个元素指定多个class属性</p>
<ul>
<li>作用：根据元素class属性值选中一组元素</li>
<li>语法：.class属性值{}</li>
</ul>
<p>4.通配选择器</p>
<ul>
<li>作用：选中页面中的所有元素</li>
<li>语法：*{}</li>
</ul>
<h2 id="3-复合选择器（P31）"><a href="#3-复合选择器（P31）" class="headerlink" title="3.复合选择器（P31）"></a>3.复合选择器（P31）</h2><p>1.交集选择器</p>
<ul>
<li>作用：选中同时符合多个条件的元素</li>
<li>语法：选择器1选择器2选择器3……选择器n{}</li>
<li><ul>
<li>注意点：交集选择器中如果有元素选择器，必须使用元素选择器开头（例如：<strong>div.red{}</strong>不能写成<strong>.reddiv{}</strong>）</li>
</ul>
</li>
</ul>
<p>2.选择器分组（并集选择器）</p>
<ul>
<li>作用：同时选择多个选择器对应的元素</li>
<li>语法：选择器1,选择器2,选择器3,……,选择器n{}（例如：#b1,.p1,h1,span,div.red{}）</li>
</ul>
<h2 id="4-关系选择器（P32）"><a href="#4-关系选择器（P32）" class="headerlink" title="4.关系选择器（P32）"></a>4.关系选择器（P32）</h2><p>父元素–直接包含子元素的元素叫做父元素<br>子元素–直接被父元素包含的元素是子元素<br>祖先元素–直接或间接包含后代元素的元素叫做祖先元素、–一个元素的父元素也是它的祖先元素<br>后代元素–直接或间接被祖先元素包含的元素叫做后代元素<br>兄弟元素–拥有相同父元素的元素是兄弟元素</p>
<p>1.子元素选择器</p>
<ul>
<li>作用：选中指定父元素的指定子元素</li>
<li>语法：父元素 &gt; 子元素{}</li>
</ul>
<p>2.后代元素选择器</p>
<ul>
<li>作用：选中指定元素内的指定后代元素</li>
<li>语法：祖先 &nbsp; 后代{}（例如：div &nbsp; span {}）</li>
</ul>
<p>3.兄弟元素选择器</p>
<ul>
<li>作用：选择下一个兄弟元素</li>
<li>语法：前一个+下一个{}(只有两个元素紧挨着才会生效)<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>紧跟着1<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>非紧挨着2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">div + span&#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!-- 只有 紧跟着1 颜色是红色 --&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>4.选择下面所有的兄弟元素</p>
<ul>
<li>语法：兄 ~ 弟{}</li>
</ul>
<h2 id="5-属性选择器（P33）"><a href="#5-属性选择器（P33）" class="headerlink" title="5.属性选择器（P33）"></a>5.属性选择器（P33）</h2><p>[属性名] 选择含有指定属性的元素<br>[属性名=属性值] 选择含有指定属性和属性值的元素<br>[属性名^=属性值] 选择属性值以指定值开头的元素<br>[属性名$=属性值] 选择属性值以指定值结尾的元素<br>[属性名*=属性值] 选择属性值中含有某值的元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title=abc]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title^=abc]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title$=abc]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title*$*=abc]</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-伪类选择器"><a href="#6-伪类选择器" class="headerlink" title="6.伪类选择器"></a>6.伪类选择器</h2><ol>
<li>伪类（不存在的类，特殊的类） （P34）</li>
</ol>
<ul>
<li>伪类用来描述一个元素的特殊状态，比如：第一个子元素、被点击元素、鼠标移入的元素……</li>
<li>伪类一般情况下都是使用:开头，如 </li>
<li><ul>
<li>:first-child 第一个子元素</li>
</ul>
</li>
<li><ul>
<li>:last-child 最后一个子元素</li>
</ul>
</li>
<li><ul>
<li>:nth-child(n) 选中第n个子元素(特殊值：<strong>1.</strong> n,第n个，n的范围0到正无穷；<strong>2.</strong>2n或even 表示选中偶数位的元素；<strong>3.</strong>2n+1或odd 表示选中奇数位的元素)</li>
</ul>
</li>
</ul>
<h2 id="以上这些伪类都是根据所有元素进行排序"><a href="#以上这些伪类都是根据所有元素进行排序" class="headerlink" title="以上这些伪类都是根据所有元素进行排序"></a>以上这些伪类都是根据所有元素进行排序</h2><ul>
<li><ul>
<li>:first-of-type</li>
</ul>
</li>
<li><ul>
<li>:last-of-type</li>
</ul>
</li>
<li><ul>
<li>:nth-of-type()</li>
</ul>
</li>
</ul>
<h2 id="这几个伪类的功能和上述的类似，不同点是它们在同类型元素中进行排序"><a href="#这几个伪类的功能和上述的类似，不同点是它们在同类型元素中进行排序" class="headerlink" title="这几个伪类的功能和上述的类似，不同点是它们在同类型元素中进行排序"></a>这几个伪类的功能和上述的类似，不同点是它们在同类型元素中进行排序</h2><ul>
<li><ul>
<li>:not() 否定伪类：将符合条件的元素从选择器中去除<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220103175630.png"><br>将所有的p标签背景都换成黄色，除了class为hello的</li>
</ul>
</li>
</ul>
<p>2.a元素的伪类（P35）</p>
<ul>
<li>:link 用于选取未被访问的链接</li>
<li>:visited 用来表示访问过的链接（由于隐私的原因，所以visited这个伪类只能修改链接的颜色）<br>上述两个伪类只对a元素生效</li>
<li>:hover 用来表示鼠标移入的状态</li>
<li>:active 用来表示鼠标点击的状态</li>
</ul>
<h2 id="7-伪元素选择器（P36）"><a href="#7-伪元素选择器（P36）" class="headerlink" title="7.伪元素选择器（P36）"></a>7.伪元素选择器（P36）</h2><p>伪元素，表示页面中一些特殊的并不真实存在的元素（特殊位置），伪元素使用::开头</p>
<ul>
<li>::first-letter 表示第一个字母</li>
<li>::first-line 表示第一行</li>
<li>::selection 表示选中的内容</li>
</ul>
<hr>
<ul>
<li>::before 元素的开始位置</li>
<li>::after 元素的最后位置</li>
</ul>
<p>注意：before 和 after 必须结合content属性来使用</p>
<h4 id="练习项目：餐厅选择器"><a href="#练习项目：餐厅选择器" class="headerlink" title="[练习项目：餐厅选择器]"></a>[练习项目：餐厅选择器]</h4><p><a href="https://github.com/qw-null/CSS-selector-practice/tree/master">餐厅选择器</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211015160542.png"></p>
<h2 id="8-样式的继承（P38）"><a href="#8-样式的继承（P38）" class="headerlink" title="8.样式的继承（P38）"></a>8.样式的继承（P38）</h2><p>样式的继承，我们为一个元素设置的样式同时也会应用到它的后代元素上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  我是一个P元素</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是P元素中的span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是P元素外的span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211016152351.png"></p>
<p>注意：并不是所有的样式都会被继承（比如：背景相关的，布局相关等的这些样式都不会被继承）</p>
<h2 id="9-选择器的权重（P39）"><a href="#9-选择器的权重（P39）" class="headerlink" title="9.选择器的权重（P39）"></a>9.选择器的权重（P39）</h2><p>样式的冲突：</p>
<ul>
<li>当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值，此时就发生了样式的冲突</li>
</ul>
<p>发生样式冲突时，应用哪个样式由选择器的权重（优先级）决定<br>选择器权重：</p>
<ul>
<li>内联样式–1000</li>
<li>id选择器–100</li>
<li>类和伪类选择器–10</li>
<li>元素选择器–1</li>
<li>通配选择器–0</li>
<li>继承的样式–没有优先级</li>
</ul>
<p>比较优先级时，需要将所有的选择器的优先级进行相加，最后优先级越高，则越优先显示（分组选择器是单独计算的）<br>选择器的累加不会超过其最大的数量级（类选择器再高也不会超过id选择器）<br>如果优先级计算相同，此时优先使用靠下的样式<br>可以在某一个样式后面添加!important，此时该样式会获得最高的优先级，甚至超过内联样式【注意：在开发中，一定要慎用！】</p>
<h2 id="10-长度单位"><a href="#10-长度单位" class="headerlink" title="10.长度单位"></a>10.长度单位</h2><h4 id="像素和百分比（P40）"><a href="#像素和百分比（P40）" class="headerlink" title="像素和百分比（P40）"></a>像素和百分比（P40）</h4><ul>
<li>像素：屏幕（显示器）实际上是由一个个的小点构成的，不同屏幕的像素大小是不同的，像素越小的屏幕显示效果越清晰，所以同样的200px在不同的设备下显示效果不同</li>
<li>百分比：也可以将属性值设置为相对于其父元素（<em>这种说法不严谨</em>）属性的百分比</li>
</ul>
<h4 id="em和rem（P41）"><a href="#em和rem（P41）" class="headerlink" title="em和rem（P41）"></a>em和rem（P41）</h4><ul>
<li>em：em是相对于元素的字体大小来计算，1em=1font-size,em会根据字体大小的改变而改变、</li>
<li>rem：rem是相对于根元素的字体大小来计算</li>
</ul>
<h2 id="11-文档流（P44）"><a href="#11-文档流（P44）" class="headerlink" title="11.文档流（P44）"></a>11.文档流（P44）</h2><ul>
<li>网页是一个多层结构，一层摞着一层，通过CSS可以分别为每一层来设置样式，作为用户只能看到最顶层内容，在这些层中，最底下一层称为文档流，文档流是网页的基础</li>
<li>我们所创建的元素默认都是在文档流中进行排列</li>
<li>元素主要是有两个状态</li>
<li><ul>
<li>在文档流中</li>
</ul>
</li>
<li><ul>
<li>不在文档流中（脱离文档流）</li>
</ul>
</li>
</ul>
<h5 id="元素在文档流中的特点："><a href="#元素在文档流中的特点：" class="headerlink" title="元素在文档流中的特点："></a>元素在文档流中的特点：</h5><ul>
<li>块元素</li>
<li><ul>
<li>块元素在文档流中独占一行</li>
</ul>
</li>
<li><ul>
<li>默认宽度是父元素的全部（会把父元素撑满）</li>
</ul>
</li>
<li><ul>
<li>默认高度是被内容撑开（子元素）</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>行内元素</li>
<li><ul>
<li>行内元素不会独占页面的一行，只占自身大小</li>
</ul>
</li>
<li><ul>
<li>行内元素在页面中由左向右水平排列，如果一行之中不能容纳下所有行内元素，则元素会换到第二行继续自左向右排列</li>
</ul>
</li>
<li><ul>
<li>行内元素的默认宽度和高度都是被内容撑开</li>
</ul>
</li>
</ul>
<h2 id="12-盒模型-box-model（P45）"><a href="#12-盒模型-box-model（P45）" class="headerlink" title="12.盒模型 box model（P45）"></a>12.盒模型 box model（P45）</h2><p>CSS将页面中的所有元素都设置为一个矩形的盒子，将元素设置为矩形的盒子后，对页面布局就变成将不同的盒子摆放到不同的位置<br>每一个盒子都由内容区（content）、边框（border）、内边距（padding）、外边距（margin）  组成<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211018114632.png"></p>
<ul>
<li>内容区（content）：元素中所有的子元素和文本内容都在内容区中排列。</li>
<li><ul>
<li>内容区的大小有width和height两个属性来设置</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>边框（border）：边框属于盒子边缘。<em>边框的大小会影响到整个盒子的大小</em>（P46）</li>
<li><ul>
<li>设置边框需要设置三个样式：边框宽度（border-width）、边框颜色（border-color）、边框样式（border-style）</li>
</ul>
</li>
<li> 边框宽度（border-width），默认值一般都是3个像素，可以用来指定四个方向的边框的宽度</li>
<li><ul>
<li><b>四个值：</b>上、右、下、左；<b>三个值：</b>上、左右、下；<b>两个值：</b>上下、左右</li>
</ul>
</li>
<li><ul>
<li>除了border-width还有一组border-xxx-width，其中xxx可以是left、right、top、bottom，用来单独指定某一个边的宽度</li>
</ul>
</li>
<li>border-style指定边框的样式，默认值为none</li>
<li><ul>
<li>值：solid 表示实线；dotted表示点状虚线；dashed表示虚线；double表示双线</li>
</ul>
</li>
<li>border简写属性，通过该属性可以同时设置边框所有的相关样式。例如：<br>border:10px red solid;</li>
</ul>
<hr>
<ul>
<li>内边距（padding）(P47)<br>内容区和边框之间的距离是内边距，一共四个方向的内边距（padding-top、padding-bottom、padding-left、padding-right）</li>
<li><ul>
<li>内边距的设置会影响到盒子的大小，背景颜色会延伸到内边距上</li>
</ul>
</li>
<li><ul>
<li>padding内边距的简写属性，可以同时指定四个方向的内边距，规则和border-width一样 </li>
</ul>
</li>
</ul>
<p>一个盒子的可见框的大小，由内容区、内边距和边框共同决定，所以在计算盒子大小时，需要将这三个区域加到一起计算</p>
<hr>
<ul>
<li>外边距（margin）(P48)<br>外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置，一共四个方向的外边距（margin-top、margin-bottom、margin-left、margin-right）</li>
<li><ul>
<li>元素在页面中是按照自左向右顺序排列，所以默认设置左和上外边距则会移动元素，而设置下和右外边距会移动其他元素</li>
</ul>
</li>
<li><ul>
<li>margin也可以设置为负值，如果是负值则元素会向相反的方向移动</li>
</ul>
</li>
<li><ul>
<li>margin外边距的简写属性，可以同时指定四个方向的外边距，规则和border-width一样</li>
</ul>
</li>
</ul>
<h2 id="13-盒子模型水平方向的布局（P49）"><a href="#13-盒子模型水平方向的布局（P49）" class="headerlink" title="13.盒子模型水平方向的布局（P49）"></a>13.盒子模型水平方向的布局（P49）</h2><p>元素的水平方向的布局：元素在其父元素中水平方向的位置由以下几个属性共同决定：margin-left、border-left、padding-left、width、padding-right、border-right、margin-right</p>
<p>一个元素在其父元素中，水平布局必须满足以下等式：<br>子元素的margin-left+border-left+padding-left+width+padding-right+border-right+margin-right=其父元素内容区的宽度（必须满足）</p>
<ul>
<li>上述等式必须满足，如果相加结果使等式不成立，则称为过度约束，则等式会自动调整</li>
<li>调整情况：如果这七个值中没有auto的情况，则浏览器会自动调整margin-right值以使等式满足</li>
<li>这七个值中有三个值可以设置为auto：width、margin-left、margin-right，如果某个值为auto，则会自动调整为auto的那个值以使得等式成立</li>
<li>设置元素在其父元素中水平居中<br>width:500px; /* 必须指定宽度值 */<br>margin: 0 auto;  </li>
</ul>
<h2 id="14-盒子模型垂直方向的布局（P50）"><a href="#14-盒子模型垂直方向的布局（P50）" class="headerlink" title="14.盒子模型垂直方向的布局（P50）"></a>14.盒子模型垂直方向的布局（P50）</h2><p>子元素是在父元素的内容区中排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出，使用<b>overflow属性</b>来设置父元素如何处理溢出的子元素<br>overflow属性可选值：</p>
<ul>
<li>visible,默认值，子元素会从父元素中溢出，在父元素外部的位置显示</li>
<li>hidden，溢出的内容将会被裁剪不会显示</li>
<li>scroll，生成两个滚动条，通过滚动条来查看完整内容</li>
<li>auto，根据需要生成滚动条</li>
</ul>
<p>overflow-x，overflow-y分别处理水平方向和垂直方向子元素溢出问题，取值和overflow相同。</p>
<h2 id="15-盒子模型外边距的折叠（P51）"><a href="#15-盒子模型外边距的折叠（P51）" class="headerlink" title="15.盒子模型外边距的折叠（P51）"></a>15.盒子模型外边距的折叠（P51）</h2><p>外边距的重叠（折叠）：</p>
<ul>
<li><p>相邻的垂直方向外边距会发生重叠现象</p>
</li>
<li><p>兄弟元素</p>
</li>
<li><ul>
<li>兄弟元素间的相邻垂直外边距会取两者之间的较大值（正值），特殊情况：如果相邻的外边距一正一负，则取两者的和；如果相邻的外边距都是负值，则取两者中绝对值较大的</li>
</ul>
</li>
<li><ul>
<li>兄弟元素之间的外边距的重叠，对于开发是有利的，所以不需要进行处理</li>
</ul>
</li>
<li><p>父子元素</p>
</li>
<li><ul>
<li>父子元素间的相邻外边距，子元素的会传递给父元素（上外边距）</li>
</ul>
</li>
<li><ul>
<li>父子外边距折叠会影响到页面布局，必须进行处理</li>
</ul>
</li>
</ul>
<h2 id="16-行内元素的盒模型（P52）"><a href="#16-行内元素的盒模型（P52）" class="headerlink" title="16.行内元素的盒模型（P52）"></a>16.行内元素的盒模型（P52）</h2><p>行内元素的盒模型：</p>
<ul>
<li>行内元素不支持设置宽度和高度</li>
<li>行内元素可以设置padding，但是垂直方向padding不会影响页面的布局</li>
<li>行内元素可以设置border，垂直方向的border不会影响页面的布局</li>
<li>行内元素可以设置margin，垂直方向的margin不会影响布局</li>
</ul>
<p>display属性，用来设置元素显示类型<br>可选值：</p>
<ul>
<li>inline 将元素设置为行内元素</li>
<li>block 将元素设置为块元素</li>
<li>inline-block 将元素设置为行内块元素（行内块，既可以设置宽度和高度，又不会独占一行）</li>
<li>table 将元素设置为一个表格</li>
<li>none 元素不在页面显示</li>
</ul>
<p>visibility 用来设置元素的显示状态<br>可选值：</p>
<ul>
<li><b>visible</b> 默认值，元素在页面中正常显示;</li>
<li><b>hidden</b>元素在页面中隐藏，不显示，但是依然占据页面的位置</li>
</ul>
<h2 id="17-浏览器的默认样式"><a href="#17-浏览器的默认样式" class="headerlink" title="17.浏览器的默认样式"></a>17.浏览器的默认样式</h2><p>浏览器的默认样式：</p>
<ul>
<li>通常情况下，浏览器都会为元素设置一些默认样式，默认样式的存在会影响到页面的布局，通常情况下编写网页时必须要去除浏览器的默认样式（PC端的页面）</li>
<li>引入css文件清除默认样式</li>
<li><ul>
<li><a href="https://meyerweb.com/eric/tools/css/reset/">CSS Tools: Reset CSS</a></li>
</ul>
</li>
<li><ul>
<li><a href="https://github.com/necolas/normalize.css/">normalize.css</a></li>
</ul>
</li>
</ul>
<h2 id="练习题（P54-P58）"><a href="#练习题（P54-P58）" class="headerlink" title="练习题（P54-P58）"></a>练习题（P54-P58）</h2><p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P54%E5%B8%83%E5%B1%80%E7%BB%83%E4%B9%A0">京东图片列表，京东左侧导航栏，网易新闻列表</a></p>
<h2 id="18-盒子的大小（P58）"><a href="#18-盒子的大小（P58）" class="headerlink" title="18.盒子的大小（P58）"></a>18.盒子的大小（P58）</h2><p>默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定。<br>box-sizing 用来设置盒子尺寸的计算方式（设置width和height的作用）<br>可选值：</p>
<ul>
<li>content-box 默认值，宽度和高度用来设置内容区的大小</li>
<li>border-box 宽度和高度用来设置整个盒子可见框的大小（width和height指的是内容区、内边距和边框的总大小）</li>
</ul>
<h2 id="19-轮廓阴影和圆角（P59）"><a href="#19-轮廓阴影和圆角（P59）" class="headerlink" title="19.轮廓阴影和圆角（P59）"></a>19.轮廓阴影和圆角（P59）</h2><p>outline 用来设置元素的轮廓线，用法和border相同，【outline和border不同点是outline不会影响可见框的大小】</p>
<p>box-shadow用来设置元素的阴影效果，阴影不会影响页面布局<br>box-shadow:水平偏移量 &nbsp; 垂直偏移量&nbsp;模糊半径&nbsp; 颜色;</p>
<ul>
<li>第一个值：水平偏移量，设置阴影的水平位置，正值向右移动，负值向左移动</li>
<li>第二个值：垂直偏移量，设置阴影的垂直位置，正值向下移动，负值向上移动</li>
<li>第三个值：阴影的模糊半径</li>
<li>第四个值：阴影颜色，一般使用rgba保证阴影的透明度</li>
</ul>
<p>border-radius设置圆角，还可以单独设置border-top-left-radius、border-top-right-radius、border-bottom-left-radius、border-bottom-right-radius<br>border-radius可以分别指定四个角的圆角</p>
<ul>
<li>四个值：左上、右上、右下、左下</li>
<li>三个值：左上、右上/左下、右下</li>
<li>两个值：左上/右下、右上/左下</li>
</ul>
<h2 id="20-浮动（P60-P61）"><a href="#20-浮动（P60-P61）" class="headerlink" title="20.浮动（P60-P61）"></a>20.浮动（P60-P61）</h2><p>通过浮动可以使一个元素向其父元素的左侧或者右侧移动，通过float属性来设置元素的浮动。<br>float可选值:</p>
<ul>
<li>none 默认值，元素不浮动</li>
<li>left 元素向左浮动</li>
<li>right 元素向右浮动</li>
</ul>
<p>元素设置浮动以后，会完全从文档流中脱离，不再占用文档流中的位置，因此元素下边的还在文档流中的元素会自动向上移动</p>
<p>浮动的特点：</p>
<ul>
<li>1.浮动元素会完全脱离文档流，不再占据文档流中的位置</li>
<li>2.设置浮动以后元素会向父元素的左侧或右侧移动</li>
<li>3.浮动元素默认不会从父元素中移出</li>
<li>4.浮动元素向左或向右移动时，不会超过它前面的其他浮动元素</li>
<li>5.如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移</li>
<li>6.浮动元素不会超过它上面的浮动的兄弟元素，最多是和其兄弟元素一样高</li>
<li>7.浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，因此可以利用浮动来实现文字环绕图片效果</li>
<li>8.元素设置浮动以后，将会从文档流中脱离，从文档流中脱离后，元素的一些特点也会发生改变</li>
</ul>
<p>简单总结：浮动目前来讲主要作用就是让页面中的元素可以水平排列，通过浮动可以制作一些水平方向的布局</p>
<p><span style="font-size:20px;font-weight:700;">脱离文档流的特点：</span></p>
<ul>
<li>块元素：</li>
<li><ul>
<li>1.块元素不再独占页面一行</li>
</ul>
</li>
<li><ul>
<li>2.脱离文档流之后，默认宽度和高度都是被内容撑开</li>
</ul>
</li>
<li>行内元素：</li>
<li><ul>
<li>行内元素脱离文档流之后会变成块元素，特点和块元素一样</li>
</ul>
</li>
</ul>
<p>脱离文档流之后，不需要再区分块元素和行内元素</p>
<h2 id="浮动练习–导航条（P62）"><a href="#浮动练习–导航条（P62）" class="headerlink" title="浮动练习–导航条（P62）"></a>浮动练习–导航条（P62）</h2><p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P62%E5%AF%BC%E8%88%AA%E6%9D%A1%E7%BB%83%E4%B9%A0">导航条</a><br>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211026103344.png"></p>
<h2 id="21-高度塌陷和BFC（P64）"><a href="#21-高度塌陷和BFC（P64）" class="headerlink" title="21.高度塌陷和BFC（P64）"></a>21.高度塌陷和BFC（P64）</h2><p><b>高度塌陷问题：</b><br>在浮动布局中，父元素高度默认是被子元素撑开，当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离，将会无法撑起父元素的高度，导致父元素的高度丢失。<br>父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱，所以高度塌陷是浮动布局中比较常见的一个问题，必须要进行处理。</p>
<p><b>BFC（Block Formatting Context，块级格式化环境）</b><br>BFC是一个CSS中的一个隐含属性，可以为一个元素开启BFC，开启BFC后，该元素会变成一个独立的布局区域</p>
<p>元素开启BFC后的特点：</p>
<ul>
<li>开启BFC的元素不会被浮动元素所覆盖</li>
<li>开启BFC的元素子元素和父元素外边距不会重叠</li>
<li>开启BFC的元素可以包含浮动的子元素</li>
</ul>
<p>可以通过一些特殊的方式来开启元素的BFC：</p>
<ul>
<li>1.设置元素的浮动<b>【不推荐】</b></li>
<li>2.将元素设置为行内块元素（inline-block）<b>【不推荐】</b></li>
<li>3.将元素的overflow设置为一个非visible的值</li>
<li><ul>
<li>常用方式：为元素设置overflow:hidden开启其BFC，以使其可以包含浮动元素，<b>overflow:hidden要赋值给不想要被影响的元素</b></li>
</ul>
</li>
</ul>
<p> 推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。</p>
<h2 id="22-解决高度塌陷问题"><a href="#22-解决高度塌陷问题" class="headerlink" title="22.解决高度塌陷问题"></a>22.解决高度塌陷问题</h2><h4 id="22-1-clear属性（P66）"><a href="#22-1-clear属性（P66）" class="headerlink" title="22.1 clear属性（P66）"></a>22.1 clear属性（P66）</h4><p>例子引入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#bfa</span>;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box3</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211028105107.png"><br>由于box1的浮动，导致box3位置上移，也就是box3受到了box1浮动的影响，位置发生了改变。<br>如果我们不希望某个元素因为其他元素浮动的影响而改变位置，可以通过clear属性来清除浮动元素对当前元素产生的影响。</p>
<p>clear属性</p>
<ul>
<li>作用：清除浮动元素对当前元素所产生的影响</li>
<li>可选值：</li>
<li><ul>
<li>left 清除左侧浮动元素对当前元素产生的影响</li>
</ul>
</li>
<li><ul>
<li>right 清除右侧浮动元素对当前元素的影响</li>
</ul>
</li>
<li><ul>
<li>both 清除两侧中最大影响的那侧（谁的高度大，就清除谁的）</li>
</ul>
</li>
</ul>
<p>原理：设置清除浮动以后，浏览器会自动为元素添加一个上边距，以使其位置不受其他元素影响</p>
<p>例子：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211028141359.png"></p>
<h4 id="22-2-使用after伪类解决高度塌陷问题（P67）"><a href="#22-2-使用after伪类解决高度塌陷问题（P67）" class="headerlink" title="22.2.使用after伪类解决高度塌陷问题（P67）"></a>22.2.使用after伪类解决高度塌陷问题（P67）</h4><p>使用after伪类解决高度塌陷问题是解决高度塌陷的最终解决方案<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211028142356.png"></p>
<h4 id="补充知识：解决外边距重叠问题（P68）"><a href="#补充知识：解决外边距重叠问题（P68）" class="headerlink" title="补充知识：解决外边距重叠问题（P68）"></a>补充知识：解决外边距重叠问题（P68）</h4><p>问题情景：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211028142844.png"><br>解决方案：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211028143400.png"></p>
<p>clearfix这个样式可以同时解决高度塌陷和外边距重叠的问题，当遇到这些问题时，可以直接使用clearfix进行解决</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>:table;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23-position定位"><a href="#23-position定位" class="headerlink" title="23.position定位"></a>23.position定位</h2><p>定位(position)，是一种更加高级的布局手段，通过定位可以将元素摆放在页面的任意位置，使用position属性来设置定位<br>可选值：</p>
<ul>
<li>static 默认值，元素是静止的没有开启定位</li>
<li>relative 开启元素相对定位</li>
<li>absolute 开启元素绝对定位</li>
<li>fixed 开启元素的固定定位</li>
<li>sticky 开启元素的粘滞定位</li>
</ul>
<h4 id="23-1-相对定位relative（P69）"><a href="#23-1-相对定位relative（P69）" class="headerlink" title="23.1 相对定位relative（P69）"></a>23.1 相对定位relative（P69）</h4><p>position：relative;开启元素的相对定位。<br>特点：</p>
<ul>
<li>1.元素开启相对定位，如果不设置偏移量，元素不会发生任何的变化</li>
<li><ul>
<li>偏移量（offset）：当元素开启了定位之后，可以通过偏移量来设置元素的位置。</li>
</ul>
</li>
<li><ul>
<li>包含的值：</li>
</ul>
</li>
<li><ul>
<li>top———定位元素和定位位置上边的距离、bottom———定位元素和定位位置下边的距离【定位元素垂直方向的位置由top、bottom两个属性控制，通常情况下只会使用其一】</li>
</ul>
</li>
<li><ul>
<li>left———定位元素和定位位置左边的距离、right———定位元素和定位位置右边的距离【定位元素水平方向的位置由left、right两个属性控制，通常情况下只会使用其一】</li>
</ul>
</li>
<li>2.相对定位是参照于元素在文档流中的位置进行定位</li>
<li>3.相对定位会提升元素的层级</li>
<li>4.相对定位不会使元素脱离文档流</li>
<li>5.相对定位不会改变的的元素的性质，块元素还是块元素，行内元素还是行内元素</li>
</ul>
<h4 id="23-2-绝对定位absolute（P70）"><a href="#23-2-绝对定位absolute（P70）" class="headerlink" title="23.2 绝对定位absolute（P70）"></a>23.2 绝对定位absolute（P70）</h4><p>position：absolute;开启元素的绝对定位。<br>特点：</p>
<ul>
<li>1.元素开启绝对定位，如果不设置偏移量，<b><u>元素的位置</u></b>不会发生任何的变化</li>
<li>2.开启绝对定位后，元素会从文档流中脱离</li>
<li>3.绝对定位会改变元素的性质，行内变成块，块的高度被内容撑开</li>
<li>4.绝对定位会使得元素提升一个层级</li>
<li>5.绝对定位是相对于其包含块进行定位的</li>
<li><ul>
<li>包含块（containing block）</li>
</ul>
</li>
<li><ul>
<li>正常情况下包含块就是离当前元素最近的<b>祖先<u>块元素</u></b></li>
</ul>
</li>
<li><ul>
<li>绝对定位的包含块：包含块就是离它最近的开启了定位的祖先元素，如果所有祖先元素都没有开启定位，则根元素就是它的包含块</li>
</ul>
</li>
<li><ul>
<li>html（根元素、初始包含快）</li>
</ul>
</li>
</ul>
<h4 id="23-3-固定定位fixed（P71）"><a href="#23-3-固定定位fixed（P71）" class="headerlink" title="23.3 固定定位fixed（P71）"></a>23.3 固定定位fixed（P71）</h4><p>position:fixed;开启元素的固定定位。固定定位也是一种绝对定位，因此固定定位的大部分特点和绝对定位一样，唯一不同的是固定定位永远参照于浏览器的视口进行定位。<br>固定定位的元素不会随网页的滚动条滚动。</p>
<h4 id="23-4-粘滞定位sticky（P72）"><a href="#23-4-粘滞定位sticky（P72）" class="headerlink" title="23.4 粘滞定位sticky（P72）"></a>23.4 粘滞定位sticky（P72）</h4><p>position:sticky;开启元素的粘滞定位。粘滞定位和相对定位的特点基本一致，不同的是粘滞定位可以在元素到达某个位置时将其固定<br><strong>兼容性很差,了解即可</strong></p>
<h4 id="补充知识：绝对定位（P73）"><a href="#补充知识：绝对定位（P73）" class="headerlink" title="补充知识：绝对定位（P73）"></a>补充知识：绝对定位（P73）</h4><p>当开启绝对定位后：水平方向的布局等式就需要添加left和right两个值。<br>left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 包含块内容区的宽度</p>
<p>开启绝对定位后，水平方向的布局等式就需要添加left和right两个值，此时的规则和之前一样只是多添加了两个值。<br>当发生过度约束，如果9个值中没有auto，则自动调整right的值以使等式成立。<br>可以设置为auto的值：margin、width、left、right</p>
<p>垂直方向布局的等式也必须要满足：top + margin-top/bottom + padding-top/bottom + border-top/bottom + height = 包含块的高度</p>
<h5 id="使得元素水平垂直居中："><a href="#使得元素水平垂直居中：" class="headerlink" title="使得元素水平垂直居中："></a>使得元素水平垂直居中：</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.box2</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101104011.png"><br>关键代码：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101104122.png"></p>
<h2 id="24-元素的层级（P74）"><a href="#24-元素的层级（P74）" class="headerlink" title="24.元素的层级（P74）"></a>24.元素的层级（P74）</h2><p>对于开启了定位的元素，可以通过z-index属性来指定元素的层级，z-index需要一个整数作为参数，值越大元素的层级越高，元素的层级越高越优先显示。<br>如果元素层级一样，则优先显示靠下的元素。<br><strong>祖先元素的层级再高也不会盖住后代元素</strong></p>
<h2 id="京东轮播图布局练习"><a href="#京东轮播图布局练习" class="headerlink" title="京东轮播图布局练习"></a>京东轮播图布局练习</h2><p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P75%E4%BA%AC%E4%B8%9C%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%B8%83%E5%B1%80">京东轮播图布局</a></p>
<h2 id="25-字体相关的样式（P76）"><a href="#25-字体相关的样式（P76）" class="headerlink" title="25.字体相关的样式（P76）"></a>25.字体相关的样式（P76）</h2><p>color：用来设置字体颜色<br>font-size:字体大小</p>
<ul>
<li>和font-size相关的单位：</li>
<li>em 相当于当前元素的一个font-size</li>
<li>rem相当于根元素的一个font-size</li>
</ul>
<p>font-family:字体族（字体的格式），可选值：（字体分类）</p>
<ul>
<li>serif 衬线字体</li>
<li>sans-serif 非衬线字体</li>
<li>monospave 等宽字体</li>
</ul>
<p>指定字体类别，浏览器会自动使用该类别下的字体，font-family可以同时指定多个字体，多个字体间使用,隔开，字体生效时优先使用第一个，第一个无法使用则使用第二个，以此类推</p>
<p>@font-face可以将服务器中的字体直接提供给用户去使用。<br>存在问题：</p>
<ul>
<li>1.加载速度</li>
<li>2.版权</li>
<li>3.字体格式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101144230.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;myfont&#x27;</span>; <span class="comment">/* 指定字体名字 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">/* 服务器端中的地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;myfont&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-1-图标字体iconfont（P77-P78）"><a href="#25-1-图标字体iconfont（P77-P78）" class="headerlink" title="25.1 图标字体iconfont（P77-P78）"></a>25.1 图标字体iconfont（P77-P78）</h4><p>在网页中经常需要使用一些图标，可以通过图片来引入图标，但是图片大小本身比较大，并且非常不灵活。所以在使用图标时，我们还可以将图标直接设置为字体，然后通过font-face的形式来对字体进行引入，这样我们就可以通过使用字体的形式来使用图标。</p>
<p>font awesome使用步骤：</p>
<ul>
<li>1.<a href="https://fontawesome.com/">下载</a></li>
<li>2.解压</li>
<li>3.将css和webfonts移动到项目中<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101150302.png"></li>
<li>4.将all.css引入到网页中<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;(项目中的地址)**/css/all.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101150532.png"></li>
<li>5.使用图标字体</li>
<li><ul>
<li>直接通过类名来使用图标字体<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/your-path-to-fontawesome/css/all.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span> <span class="comment">&lt;!--load all styles --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="comment">&lt;!-- uses solid style --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;far fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="comment">&lt;!-- uses regular style --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fal fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="comment">&lt;!-- uses light style --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--brand icon--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fab fa-github-square&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="comment">&lt;!-- uses brands style --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
通过伪元素来设置图标字体</li>
</ul>
</li>
<li>1.找到要设置图标的 元素通过before或after选中</li>
<li>2.在content中设置字体编码</li>
<li>3.设置字体的样式<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在文件all.css中查找 */</span></span><br><span class="line"><span class="comment">/* fab */</span></span><br><span class="line"><span class="attribute">font-family</span>:<span class="string">&#x27;Font Awesome 5 Brands&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fas */</span></span><br><span class="line"><span class="attribute">font-family</span>:<span class="string">&#x27;Font Awesome 5 Free&#x27;</span>;</span><br><span class="line"><span class="attribute">font-weight</span>: <span class="number">900</span>; </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="25-2-Iconfont阿里图标库（P79）"><a href="#25-2-Iconfont阿里图标库（P79）" class="headerlink" title="25.2 Iconfont阿里图标库（P79）"></a>25.2 Iconfont阿里图标库（P79）</h4><p>使用：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101155211.png"><br>使用到的下载文件：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101155317.png"><br>通过伪类的方法使用：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211101155445.png"></p>
<h4 id="25-3-字体的简写属性（P81）"><a href="#25-3-字体的简写属性（P81）" class="headerlink" title="25.3 字体的简写属性（P81）"></a>25.3 字体的简写属性（P81）</h4><p>font可以设置字体相关的所有属性，语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font</span>: 字体大小/行高  字体族</span><br><span class="line">行高可以省略不写，如果不写会使用默认值</span><br></pre></td></tr></table></figure>
<p>font-weight 字重，字体加粗<br>可选值：</p>
<ul>
<li>normal 默认值，不加粗</li>
<li>blod 加粗</li>
<li>100-900 九个级别（没什么用）</li>
</ul>
<p>font-style 字体风格<br>可选值：</p>
<ul>
<li>normal 正常的</li>
<li>italic 斜体</li>
</ul>
<h2 id="26-行高（P80）"><a href="#26-行高（P80）" class="headerlink" title="26.行高（P80）"></a>26.行高（P80）</h2><p>行高（line height）: </p>
<ul>
<li>指的是文字占有的实际高度</li>
<li>可以通过line-height来设置行高，可以直接指定一个大小（px,em）,也可以直接为行高设置一个整数【行高为整数的话，将会是字体指定的倍数】</li>
<li>行高还经常用来设置文字的行间距【行间距 = 行高 - 字体大小】</li>
</ul>
<p>字体框：就是字体存在的盒子，设置font-size实际上就是在设置字体框的高度</p>
<p>行高会在字体框的上下平均分配，可以将line-height和height的值设为一致，使得单行文字在一个元素中垂直居中。</p>
<h2 id="27-文本的水平和垂直对齐（P82）"><a href="#27-文本的水平和垂直对齐（P82）" class="headerlink" title="27.文本的水平和垂直对齐（P82）"></a>27.文本的水平和垂直对齐（P82）</h2><p>text-align 文本的水平对齐<br>可选值：</p>
<ul>
<li>left 左对齐 </li>
<li>center 居中对齐 </li>
<li>right 右对齐 </li>
<li>justify 两端对齐</li>
</ul>
<p>vertical-align 设置元素垂直对齐的方式<br>可选值：</p>
<ul>
<li>baseline 默认值，基线对齐</li>
<li>top 顶部对齐</li>
<li>bottom 底部对齐</li>
<li>middle 居中对齐</li>
</ul>
<p>补充知识点：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>:<span class="number">1px</span> red solid;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211104093836.png"><br>解决方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>:bottom;</span><br><span class="line">  <span class="comment">/* vertical-align:top;vertical-align:middle;也可以实现同样的效果 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="28-其他文本样式（P83）"><a href="#28-其他文本样式（P83）" class="headerlink" title="28.其他文本样式（P83）"></a>28.其他文本样式（P83）</h2><p>text-decoration 设置文本修饰<br>可选值：</p>
<ul>
<li>none 默认值，什么都没有</li>
<li>underline 下划线</li>
<li>line-through 删除线</li>
<li>overline 上划线</li>
</ul>
<p>white-space 设置网页如何处理空白<br>可选值：</p>
<ul>
<li>normal 默认值，正常</li>
<li>nowrap 不换行</li>
<li>pre 保留空白（源代码中文本格式不做处理，保留）</li>
</ul>
<p>超出文本框的文字设置省略号</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet consectetuir adipisicim</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.box2</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">white-space</span>:nowrap;</span></span><br><span class="line"><span class="css">    <span class="attribute">overflow</span>:hidden;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-overflow</span>:ellipsis;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211104100706.png"></p>
<h2 id="练习题（P84-P86）"><a href="#练习题（P84-P86）" class="headerlink" title="练习题（P84-P86）"></a>练习题（P84-P86）</h2><p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P84%E4%BA%AC%E4%B8%9C%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%9D%A1">京东顶部导航条</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211105154415.png"></p>
<h2 id="29-背景（P88）"><a href="#29-背景（P88）" class="headerlink" title="29.背景（P88）"></a>29.背景（P88）</h2><p>&hearts; background-color 设置背景颜色<br>&hearts; background-image 设置背景图片</p>
<ul>
<li>可以同时设置背景颜色和背景图片，这样背景颜色将会成为图片的背景色</li>
<li>如果背景的图片小于元素，则背景图片会自动在元素中平铺，将元素铺满</li>
<li>如果背景的图片大于元素，背景图片将无法完全显示，只显示元素大小</li>
<li>如果背景的图片和元素一样大，则会直接正常显示</li>
</ul>
<p>&hearts; background-repeat 用来设置背景的重复方式<br>可选值：<br>repeat 默认值，背景会沿着x轴 y轴双方向重复<br>repeat-x 沿着x轴方向重复<br>repeat-y 沿着y轴方向重复<br>no-repeat 背景图片不重复 </p>
<p>&hearts; background-position 用来设置背景图片的位置<br>设置方式：通过top,left,right,bottom,center几个表示方位的词来设置背景图片的位置<br>使用方位词时必须同时指定两个值，如果只写一个值，则第二个值默认是center<br>通过偏移量来指定背景图片的位置，顺序是水平偏移量+垂直偏移量</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-position</span>:top center;</span><br><span class="line"><span class="attribute">background-position</span>:-<span class="number">10px</span> <span class="number">10px</span>;</span><br></pre></td></tr></table></figure>

<p>&hearts; background-clip设置背景的范围，可选值：<br>border-box 默认值，背景会出现在边框的下边<br>padding-box 背景不会出现在边框，只出现在内容区和内边距<br>content-box 背景只会出现在内容区</p>
<p>&hearts;background-origin 背景图片的偏移量计算的原点<br>可选值：<br>padding-box 默认值，background-position从内边距处开始计算<br>content-box 背景图片的偏移量从内容区处计算<br>border-box 背景图片的偏移量从边框处开始计算</p>
<p>&hearts;background-size 设置背景图片的大小<br>可选值：</p>
<ul>
<li>第一个值表示宽度，第二个值表示高度，如果只写一个值，则第二个值默认是auto【background:100% 100%;】</li>
<li>cover 图片的比例不变，将元素铺满</li>
<li>contain 图片比例不变，将图片在元素中完整显示</li>
</ul>
<p>&hearts;background 背景相关的简写属性，所有背景相关的样式都可以通过该样式来设置，并且该样式没有顺序要求，也没有哪个属性必须写的<br>&star; 注意：baxkground-size 必须写在background-position的后边，并且使用/隔开；background-origin，background-clip两个样式，background-origin要在background-clip的前边</p>
<h2 id="背景练习题（P92）"><a href="#背景练习题（P92）" class="headerlink" title="背景练习题（P92）"></a>背景练习题（P92）</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211110102651.png"><br>&spades;  存在问题：<br>图片属于网页中的外部资源，外部资源都需要浏览器单独发送请求加载，浏览器加载外部资源时是按需加载，用则加载，不用则不加载。<br>上边的练习，link会首先加载，而hover和active会在指定状态时才会加载</p>
<h2 id="30-雪碧图（P92）"><a href="#30-雪碧图（P92）" class="headerlink" title="30.雪碧图（P92）"></a>30.雪碧图（P92）</h2><p>解决图片显示问题：<br>可以将多个小图片同意保存到一个大图片中，然后通过调整background-position来显示图片，这样图片会同时加载到网页中，就可以有效避免出现闪烁问题，这个技术在网页中应用十分广泛，被称为CSS-Sprite，这种图称为雪碧图。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211110113539.png"></p>
<p>&hearts; 雪碧图的使用步骤：</p>
<ol>
<li>先确定要使用的图标</li>
<li>测量图标的大小</li>
<li>根据测量的结果创建一个元素</li>
<li>将雪碧图设置为元素的背景图片</li>
<li>设置一个偏移量以显示正确图片</li>
</ol>
<p>雪碧图的特点：<br>一次性将多个图片加载进页面，降低请求的次数，加快访问速度，提升用户体验</p>
<h2 id="31-线性渐变（P93）"><a href="#31-线性渐变（P93）" class="headerlink" title="31.线性渐变（P93）"></a>31.线性渐变（P93）</h2><h4 id="31-1-linear-gradient"><a href="#31-1-linear-gradient" class="headerlink" title="31.1 linear-gradient()"></a>31.1 linear-gradient()</h4><p>通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果<br>！！渐变是图片，需要通过 <b>background-image</b> 来设置<br>线性渐变：颜色沿着一条直线发生变化 </p>
<ul>
<li>linear-gradient(red,yellow) 红色在开头，黄色在结尾，中间是过渡区域</li>
<li>线性渐变的开头，我们可以指定一个渐变的方向</li>
<li>linear-gradient(to top , red , yellow)</li>
<li><ul>
<li>to left / to right / to bottom / to top</li>
</ul>
</li>
<li>linear-gradient(45deg , red , yellow)</li>
<li><ul>
<li>deg表示度数</li>
</ul>
</li>
<li><ul>
<li>turn 表示圈</li>
</ul>
</li>
</ul>
<p>渐变可以同时指定多个颜色，多个颜色默认情况下平均分布，<br>也可以手动指定渐变的分布情况，例如：<b>linear-gradient(red 100px , yellow 50px)</b></p>
<h4 id="31-2-repeating-linear-gradient"><a href="#31-2-repeating-linear-gradient" class="headerlink" title="31.2 repeating-linear-gradient()"></a>31.2 repeating-linear-gradient()</h4><p>repeating-linear-gradient() 可以平铺的线性渐变</p>
<p>background-image:repeating-linear-gradient(red 50px , yellow 100px)<br>效果：（元素高度200px）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211110142040.png"></p>
<h4 id="31-2-径向渐变（P94）"><a href="#31-2-径向渐变（P94）" class="headerlink" title="31.2 径向渐变（P94）"></a>31.2 径向渐变（P94）</h4><p>radial-gradient() 径向渐变(放射性的效果)</p>
<ul>
<li>默认情况下，径向渐变的形状是根据元素的形状来计算的</li>
<li><ul>
<li>正方形 —&gt; 圆形</li>
</ul>
</li>
<li><ul>
<li>长方形 —&gt; 椭圆形</li>
</ul>
</li>
<li>也可以手动指定径向渐变的大小</li>
<li><ul>
<li>circle - 圆形 / ellipse - 椭圆形</li>
</ul>
</li>
<li>也可以指定渐变的位置</li>
</ul>
<p>radial-gradient(大小 at 位置 , 颜色 位置 , 颜色 位置 , ……)</p>
<ul>
<li>大小：</li>
<li><ul>
<li>circle 圆形</li>
</ul>
</li>
<li><ul>
<li>ellipse 椭圆形</li>
</ul>
</li>
<li><ul>
<li>closest-side 近边</li>
</ul>
</li>
<li><ul>
<li>closest-corner 近角</li>
</ul>
</li>
<li><ul>
<li>farthest-side 远边</li>
</ul>
</li>
<li><ul>
<li>farthest-corner 远角</li>
</ul>
</li>
<li>位置：top / right / left / center / bottom</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(circle , red , yellow)</span><br><span class="line"></span><br><span class="line">background-image: <span class="built_in">radial-gradient</span>(<span class="number">100px</span> <span class="number">50px</span> at top left , red , yellow)  </span><br><span class="line">//<span class="number">100px</span> <span class="number">50px</span>指定大小；at top left指定位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="练习项目：小米商城"><a href="#练习项目：小米商城" class="headerlink" title="练习项目：小米商城"></a>练习项目：小米商城</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211224104600.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211224104907.png"><br><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P101%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E-%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0">项目地址</a></p>
<hr>
<h2 id="32-动画效果"><a href="#32-动画效果" class="headerlink" title="32.动画效果"></a>32.动画效果</h2><h4 id="32-1-过渡效果（P115）"><a href="#32-1-过渡效果（P115）" class="headerlink" title="32.1 过渡效果（P115）"></a>32.1 过渡效果（P115）</h4><p>过渡（transition）：</p>
<ul>
<li><p>通过过渡可以指定一个属性发生变化时的切换方式</p>
</li>
<li><p>通过过渡可以创建一些非常好的效果，提升用户体验</p>
</li>
<li><p>transition-property<br>指定要执行过渡的属性,多个属性之间使用,隔开；<br>如果所有属性都需要过渡，则使用all关键字；<br>大部分属性都支持过渡效果，注意过渡时必须是从一个有效值向另一个有效值进行过渡；</p>
</li>
<li><p>transition-duration<br>指定过渡效果持续的时间<br>时间单位：s和ms，1s = 1000ms</p>
</li>
<li><p>transition-timing-function<br>过渡的时序函数<br>可选值：<br> ease 默认值，慢速开始，先加速，再减速<br> linear 匀速运动<br> ease-in 加速运动<br> ease-out 减速运动<br> ease-in-out 先加速，后减速<br> cubic-bezier() 来指定时序函数 <a href="https://cubic-bezier.com/">cubic-bezier网址</a><br> steps() 分步执行过渡效果，可以设置第二个数值【end-在时间结束时执行过渡（默认值）；start-在时间开始时执行过渡,示例：steps(2,end)】</p>
</li>
<li><p>transition-delay<br>过渡效果的延迟，等待一段时间后再执行过渡</p>
</li>
</ul>
<p>使用transition可以同时设置过渡相关的所有属性的，只有一个要求，如果要写延迟，则两个时间中第一个是持续时间，第二个是延迟时间</p>
<h4 id="32-2-过渡练习：米兔（P116）"><a href="#32-2-过渡练习：米兔（P116）" class="headerlink" title="32.2 过渡练习：米兔（P116）"></a>32.2 过渡练习：米兔（P116）</h4><p>动画：动画和过渡类似，都是可以实现一些动态的效果，不同的是过渡需要在某个属性发生变化时才会触发，动画可以自动触发动态效果</p>
<ul>
<li><p>设置动画效果，必须设置一个关键帧，关键帧设置了动画执行每一个步骤</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 关键帧 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> test &#123;</span><br><span class="line">  <span class="comment">/* from表示动画的开始位置,也可以使用0% */</span></span><br><span class="line">  <span class="selector-tag">from</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* to表示动画的结束位置,也可以使用100% */</span></span><br><span class="line">  <span class="selector-tag">to</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">700px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>animation-name:指定当前元素生效的关键帧的名字</p>
</li>
<li><p>animation-duration:指定动画的执行时间</p>
</li>
<li><p>animation-delay:指定动画的延迟时间</p>
</li>
<li><p>animation-iteration-count:指定动画执行的次数<br>可选值：数字（次数）、infinite 无限次</p>
</li>
<li><p>animation-direction:指定动画的运行方向<br>可选值：<br>normal - 默认值，从from向to运行<br>reverse - 从to向from运行<br>alternate - 从from到to，再从to到from，再从from到to …… 运行<br>alternate-reverse - 从to到from，再从from到to，再从to到from…… 运行</p>
</li>
<li><p>animation-play-state:设置动画的执行状态<br>可选值：<br>running 默认值，动画执行<br>paused 动画暂停</p>
</li>
<li><p>animation-fill-mode:设置动画的填充模式<br>可选值：<br>none 默认值，动画执行完毕元素回到原来位置<br>forwards 动画执行完毕，元素会停止在动画结束位置<br>backwards 动画延时等待时，元素就会处于开始位置<br>both 结合了forwards和backwards</p>
</li>
</ul>
<h2 id="33-变形（P120-P121）"><a href="#33-变形（P120-P121）" class="headerlink" title="33.变形（P120-P121）"></a>33.变形（P120-P121）</h2><p>变形就是通过css来改变元素的形状或者位置，变形不会影响到页面的布局。<br>transform： 用来设置元素的变形效果<br>平移：<br>translateX() - 沿着X轴方向平移<br>translateY() - 沿着Y轴方向平移<br>translateZ() - 沿着Z轴方向平移<br>平移元素时，百分比是相对于自身计算的</p>
<h4 id="★元素居中显示★"><a href="#★元素居中显示★" class="headerlink" title="★元素居中显示★"></a>★元素居中显示★</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1.已知元素大小情况： */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.不知元素大小情况 */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://qw-null.github.io/2021/09/13/%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/">实现水平垂直居中[不知自身宽高情况]</a></p>
<p>变形不会影响到页面的布局,不会导致元素脱离文档流，因此可以用于实现选中元素的浮动效果。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211224172635.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211224172708.png"></p>
<p>translateZ():Z轴平移，调整元素在z轴的位置，正常情况就是调整元素和人眼之间的距离，距离越大，元素离人越近<br>z轴平移属于立体效果（近大远小），默认情况下网页是不支持透视，如果需要看见效果，必须要设置网页的视距</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="comment">/* 设置当前网页的视距为800px,人眼距离网页的距离 */</span></span><br><span class="line">  <span class="attribute">perspective</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* 此时translateZ效果才会生效 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">800px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-旋转（P122）"><a href="#34-旋转（P122）" class="headerlink" title="34.旋转（P122）"></a>34.旋转（P122）</h2><p>通过旋转可以使元素沿着x、y或z旋转指定的角度<br>rotateX()<br>rotateY()<br>rotateZ()</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">45deg</span>);</span><br><span class="line">  <span class="comment">/* 45deg-&gt;45° ；1turn-&gt;旋转一圈 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>backface-visibility：是否显示元素的背面<br>可选值：visible - 默认值，可以看到背面；hidden - 无法看到背面</p>
<p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P123%E9%92%9F%E8%A1%A8">旋转练习 - 钟表</a><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211225172211.png"></p>
<p><a href="https://github.com/qw-null/Web-HTML5-CSS3-/tree/master/P124%E5%A4%8D%E4%BB%87%E8%80%85%E8%81%94%E7%9B%9F">旋转练习 - 立方体</a><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211225171609.png"></p>
<h2 id="35-缩放（P125）"><a href="#35-缩放（P125）" class="headerlink" title="35.缩放（P125）"></a>35.缩放（P125）</h2><p>对元素进行缩放,当数值&gt;1表示对元素进行放大，当数值&lt;1表示对元素进行缩小。<br>scaleX() - 对元素的水平方向进行放大或者缩小<br>scaleY() - 对元素的垂直方向进行放大或者缩小<br>scale() - 对元素进行放大或缩小 </p>
<p>transform-origin 设置元素变形的远点<br>可选值：<br>center - 默认值，元素中间<br>0，0 - 元素最左上角</p>
<h2 id="36-less-P126"><a href="#36-less-P126" class="headerlink" title="36.less (P126)"></a>36.less (P126)</h2><p>less是一门css的预处理语言，通过less可以编写更少的代码实现更强大的样式<br>在less中添加了许多新特性，像对变量的支持、对mixin的支持……，less的语法大体上和css语法一致，但是less中增添了许多对css的拓展，所以浏览器无法直接执行less代码，要执行就必须将less转换为css</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">1</span>.注释</span><br><span class="line"><span class="comment">// less中的单行注释，注释中的内容不会被解析到css中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  css中的注释，内容会被解析到css文件中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">2</span>.变量</span><br><span class="line">变量中可以存储一个任意值，并且在需要时可任意的修改变量的值</span><br><span class="line">变量的语法： @变量名</span><br><span class="line">使用变量时，如果是直接使用则以 @变量名 的形式使用即可</span><br><span class="line">作为类名，或者一部分值使用时必须以 @&#123;变量名&#125; 的形式使用</span><br><span class="line"><span class="variable">@length:</span><span class="number">100px</span></span><br><span class="line"><span class="variable">@c</span>:box3;</span><br><span class="line"><span class="selector-class">.@&#123;c&#125;</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">@length</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&quot;@&#123;c&#125;/1.jpg&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">变量重名时，会优先使用比较近的变量</span><br><span class="line">可在声明变量前就使用变量</span><br><span class="line"><span class="selector-tag">---</span></span><br><span class="line"><span class="selector-tag">&amp;</span> 表示外层的父元素</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.entend</span>() 对当前选择器扩展指定选择器的样式（选择器分组）</span><br><span class="line">示例：<span class="selector-class">.p2</span><span class="selector-class">.extend</span>(.p1)&#123;</span><br><span class="line">        <span class="attribute">color</span>:red;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mixin</span> 混合</span><br><span class="line"><span class="selector-class">.p3</span>&#123;</span><br><span class="line">  <span class="comment">// 直接对指定的样式进行引用，这里就相当于将p1的样式在这里进行了复制</span></span><br><span class="line">  <span class="selector-class">.p1</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用类选择器时可以在选择器后边添加一个括号，这时实际上就创建了一个<span class="selector-tag">mixins</span></span><br><span class="line"><span class="selector-class">.p4</span>()&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">混合函数 在混合函数中可以直接设置变量,使用时按照顺序传递参数</span><br><span class="line"><span class="selector-class">.test</span>(<span class="variable">@w</span>)&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">@w</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="selector-class">.test</span>(<span class="number">100px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在<span class="selector-tag">less</span>中所有数值都可以直接进行运算</span><br><span class="line"><span class="selector-tag">width</span>: <span class="selector-tag">100px</span> + <span class="selector-tag">200px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span>用于将其他<span class="selector-tag">less</span>文件引入当前<span class="selector-tag">less</span>文件中</span><br><span class="line">@<span class="selector-tag">import</span> &quot;<span class="selector-tag">color</span><span class="selector-class">.less</span>&quot;</span><br></pre></td></tr></table></figure>
<p>★less中的除法计算要放在括号中，不然会失效</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: (<span class="number">100</span> / <span class="number">4</span> rem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="37-弹性盒（P131）"><a href="#37-弹性盒（P131）" class="headerlink" title="37.弹性盒（P131）"></a>37.弹性盒（P131）</h2><p>flex(弹性盒、伸缩盒)：是css中的又一种布局手段，它主要用来代替浮动来完成页面。<br>flex可以使元素具有弹性，让元素可以跟随页面得到大小的改变而改变</p>
<ul>
<li>弹性容器<br>要使用弹性盒，必须先将一个元素设置为弹性容器，通过display来设置弹性容器<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>:flex; //设置为块级弹性容器</span><br><span class="line"><span class="attribute">display</span>:inline-flex; //设置为行内的弹性容器</span><br></pre></td></tr></table></figure></li>
<li>弹性元素<br>弹性容器的子元素是弹元素（弹性项），一个元素可以同时是弹性容器和弹性元素</li>
</ul>
<p>主轴：弹性元素的排列方向称为主轴<br>侧轴：与主轴垂直方向的称为侧轴</p>
<p><i style="color:green;font-size:18px;">☻</i> 弹性容器的样式：</p>
<ol>
<li><p>flex-direction 指定容器中弹性元素的排列方式（主轴方向）<br>可选值：<br> row 默认值，弹性元素在容器中水平排列（自左向右）<br> row-reverse 弹性元素在容器中反向水平排列（自右向左）<br> column 弹性元素纵向排列（自上向下）<br> column-reverse 弹性元素反向纵向排列（自下向上）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117114131.png"></p>
</li>
<li><p>flex-grow 指定弹性元素的伸展系数<br>当父元素有多余空间时，子元素如何伸展</p>
</li>
<li><p>flex-shrink 指定弹性元素的收缩系数<br>当父元素中的空间不足以容纳所有子元素时，如何对子元素进行收缩</p>
</li>
<li><p>flex-wrap 设置弹性元素是否在弹性容器中自动换行<br>可选值：<br>nowrap 默认值，元素不会自动换行<br>wrap 元素沿着辅轴方向自动换行<br>wrap-reverse 元素沿着辅轴反方向换行</p>
</li>
</ol>
<p>★flex-flow 是 flex-wrap和flex-direction的简写属性,例如：flex-flow: row wrap;</p>
<ol start="5">
<li><p>justify-content 如何分配主轴上的空白空间（主轴上的元素如何排列）<br>可选值：<br>flex-start 元素沿着主轴的起边排列<br>flex-end 元素沿着主轴的终边排列<br>center 元素居中排列<br>space-around 空白分布到元素的两个<br>space-between 空白均匀分布到元素间<br>space-evenly 空白分布到元素的单侧<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117135730.png"></p>
</li>
<li><p>align-items 定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式（元素间关系）<br>可选值：<br>stretch 默认值，将元素的长度设置为相同的值<br>flex-start 元素不会拉伸，沿着辅轴起边对齐<br>flex-end 元素不会拉伸，沿着辅轴终边对齐<br>center 居中对齐<br>baseline 基线对齐</p>
</li>
</ol>
<p>  ** align-self 用来覆盖当前弹性元素上的align-items<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117135907.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117140115.png"></p>
<p><i style="color:green;font-size:18px;">☻</i> 弹性元素的样式：</p>
<ol>
<li>弹性元素的缩减系数：<br>缩减系数的计算方式比较复杂，缩减多少是根据缩减系数和元素大小来计算（flex-grow和flex-shrink）。</li>
<li>元素基础长度<br>flex-basis 指定的是元素在主轴上的基础长度。如果主轴是横向的，则该值指定的就是元素的宽度，如果主轴是纵向的，则该值指定的就是元素的高度。<br>默认值是auto，表示参考元素自身的高度或宽度。如果传递了一个具体的数值，则以该值为准。</li>
</ol>
<p>★flex可以设置弹性元素所有的三个样式。<br>格式：flex: 增长 缩减 基础；（例如：flex: 1 1 auto;）</p>
<ol start="3">
<li>order 决定弹性元素的排列顺序（依据order指定的数值）。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220117140405.png"></li>
</ol>
<h2 id="38-像素（P136-P138）"><a href="#38-像素（P136-P138）" class="headerlink" title="38.像素（P136 - P138）"></a>38.像素（P136 - P138）</h2><p>像素：屏幕是由一个一个发光的小点构成，这一个个的小点就是像素。前端开发中像素要分为两种情况讨论：css像素 和 物理像素。</p>
<ul>
<li>物理像素：上述所说的小点就是物理像素。</li>
<li>css像素：编写网页时所用的像素是css像素。浏览器在显示网页时，需要将css像素转换为物理像素，然后再呈现。</li>
</ul>
<p>一个css像素最终由几个物理像素显示，由浏览器决定。默认情况下，在PC端 一个css像素 = 一个物理像素</p>
<p>视口（viewport）:屏幕中用来显示网页的区域。<br>可以通过查看视口的大小来观察css像素和物理像素的比值</p>
<p>在不同的屏幕，单位像素的大小是不同的，像素越小屏幕会越清晰</p>
<p>可以通过meta标签来设置视口大小</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置视口大小 device-width表示设备的宽度（完美视口） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将网页的视口设置为完美视口</span></span><br><span class="line"><span class="comment">结论：书写移动端的页面，就把上边这段代码加上 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>完美视口：<br>每一款移动设备设计时，都会有一个最佳的像素比，一般只需要将像素比设置为该值即可得到一个最佳效果。将像素比设置为最佳像素比的视口大小成为完美视口。</p>
<p>vw表示的是视口的宽度（viewport width）<br>100vw = 一个视口的宽度<br>1vw = 1%视口宽度</p>
<p>☻ 网页中字体大小最小是12px，不能设置一个比12px还小的字体，如果设置一个小于12px的字体，则字体自动设置为12px。</p>
<h2 id="39-媒体查询（P143）"><a href="#39-媒体查询（P143）" class="headerlink" title="39.媒体查询（P143）"></a>39.媒体查询（P143）</h2><p>响应式布局：网页可以根据不同设备或窗口大小呈现出不同的效果，使用响应式布局可以使一个网页适用于所有设备<br>响应式布局的关键是媒体查询。<br>媒体查询：通过媒体查询可以为不同的设备或设备不同的状态来分别设置样式。<br>语法：@media 查询规则{}</p>
<p>媒体类型：<br>all - 所有设备<br>print - 打印设备<br>screen - 带屏幕的设备<br>speech - 屏幕阅读器<br>可以使用逗号连接多个媒体类型，这样它们之间就是一个或的关系；<br>可以在媒体类型前添加一个only，表示只有。only的使用主要是为了兼容一些老版本的浏览器。</p>
<p>媒体特性：<br>width - 视口的宽度<br>height - 视口的高度<br>min-width - 视口的最小宽度（视口大于指定宽度时生效）<br>max-width - 视口的最大宽度（视口小于指定宽度时生效）</p>
<p>样式切换的分界点，我们称其为断点，也就是网页的样式在这个点会发生变化。 </p>
<p>小于768px - 超小屏幕 [max-width = 768px]<br>大于768px - 小屏幕 [min-width = 768px]<br>大于992px - 中型屏幕 [min-width = 992px]<br>大于1200px - 大屏幕 [min-width = 1200px]</p>
<p>响应式设计原则：<br>  1.移动端优先<br>  2.渐进增强（由移动端逐渐向网页过渡）</p>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样搭建个人博客?【基于hexo 和 github】</title>
    <url>/2021/05/31/How-to-build-Blog/</url>
    <content><![CDATA[<p>最可悲的身份，是那种既不是学霸又不全是学渣的人。 他们听不懂课，作业不会做，只好以抄作业为生； 不逃课，不捣乱纪律； 为考试成绩着急，又无奈于现状； 三分钟热度，又恨自己不争气。 他们以最普通的身份埋没于人群中，却过着最煎熬的日子。</p>
<h2 id="搭建个人博客（基于hexo-github）"><a href="#搭建个人博客（基于hexo-github）" class="headerlink" title="搭建个人博客（基于hexo + github）"></a>搭建个人博客（基于hexo + github）</h2><blockquote>
<p>需要前期配置好git、npm（请自行百度 or B站）</p>
</blockquote>
<h3 id="1-Hexo-使用"><a href="#1-Hexo-使用" class="headerlink" title="1 Hexo 使用"></a>1 Hexo 使用</h3><img src="https://i.loli.net/2021/05/31/OokDG1q3fPCRmQM.png" style="zoom:80%;" />

<h4 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h4 id="初始化（需要到放置该项目的目录下运行）"><a href="#初始化（需要到放置该项目的目录下运行）" class="headerlink" title="初始化（需要到放置该项目的目录下运行）"></a>初始化（<strong>需要到放置该项目的目录下运行</strong>）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init [自己的博客文件夹名称]</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/2.initBlog.png" alt="initBlog" style="zoom:80%;" />

<blockquote>
<p>Tips: 【示例】 hexo init myBlog</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>博客可在本地查看【地址：<a href="http://localhost:4000】">http://localhost:4000】</a><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/3.starthexo.png" style="zoom:80%;" /></p>
<h3 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2 更换主题"></a>2 更换主题</h3><p>主题放置位置：themes文件夹下</p>
<p>以安装Cactus主题为例：<a href="https://github.com/probberechts/hexo-theme-cactus">Cactus主题地址</a></p>
<h4 id="2-1-安装主题"><a href="#2-1-安装主题" class="headerlink" title="2.1 安装主题"></a>2.1 安装主题</h4><p>项目目录下运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/probberechts/hexo-theme-cactus.git themes/cactus</span><br></pre></td></tr></table></figure>

<h4 id="2-2-修改项目配置文件config-yml"><a href="#2-2-修改项目配置文件config-yml" class="headerlink" title="2.2 修改项目配置文件config.yml"></a>2.2 修改项目配置文件config.yml</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531202404.png"></p>
<p>将theme修改为cactus</p>
<h4 id="2-3更换主题风格"><a href="#2-3更换主题风格" class="headerlink" title="2.3更换主题风格"></a>2.3更换主题风格</h4><p>Cactus提供四种主题风格：Dark、White、Light、Classic<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531203328.png"></p>
<p>更换时修改theme-cactus-config.yml<br>将colorscheme改为white或者其他<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531203506.png"></p>
<blockquote>
<p>Tips:删掉theme文件夹下的.git文件，方便后续将代码合并提交到github</p>
</blockquote>
<p>vscode中运行命令，即可在本地查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<h3 id="3-部署到GitHub"><a href="#3-部署到GitHub" class="headerlink" title="3 部署到GitHub"></a>3 部署到GitHub</h3><blockquote>
<p>Tips:此时已拥有github账号且本地已经配置好git</p>
</blockquote>
<h4 id="3-1-创建一个新仓库（命名方式注意）"><a href="#3-1-创建一个新仓库（命名方式注意）" class="headerlink" title="3.1 创建一个新仓库（命名方式注意）"></a>3.1 创建一个新仓库（命名方式注意）</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531204912.png"></p>
<h4 id="3-2-将本地项目添加至线上"><a href="#3-2-将本地项目添加至线上" class="headerlink" title="3.2 将本地项目添加至线上"></a>3.2 将本地项目添加至线上</h4><p>(1)VScode 运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:qw-null/qw-null.github.io.git</span><br></pre></td></tr></table></figure>
<p>（2）修改配置文件config.yml（下拉至最后）<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531205837.png"></p>
<blockquote>
<p>Tips:repo是创建的github仓库的地址</p>
</blockquote>
<p>（3） 安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>(4)运行命令将代码推至仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<h4 id="3-3-完成GitHub线上设置"><a href="#3-3-完成GitHub线上设置" class="headerlink" title="3.3 完成GitHub线上设置"></a>3.3 完成GitHub线上设置</h4><p>线上仓库中选择Settings<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531210623.png"></p>
<p>下拉找到GitHub Pages,点击Check it out here!</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531210726.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20210531210829271.png"></p>
<p>博客地址：<a href="https://qw-null.github.io/%EF%BC%8C%E5%B0%86%E5%85%B6%E8%AE%BE%E7%BD%AE%E5%88%B0%E4%BB%93%E5%BA%93%E9%A6%96%E9%A1%B5">https://qw-null.github.io/，将其设置到仓库首页</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531210943.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210531211014.png"></p>
<p>此时博客已经部署到线上</p>
<h3 id="4-GitHub自动部署"><a href="#4-GitHub自动部署" class="headerlink" title="4 GitHub自动部署"></a>4 GitHub自动部署</h3><p>项目文件夹下新建.github-&gt;workflows的文件夹,里面新建文件deploy.yml,内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Deploy</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">🛎️</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span> <span class="comment"># If you&#x27;re using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly.</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">persist-credentials:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">and</span> <span class="string">Build</span> <span class="string">🔧</span> <span class="comment"># This example project is built using npm and outputs the result to the &#x27;build&#x27; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          npm run build</span></span><br><span class="line"><span class="string"></span>        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">CI:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">🚀</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@releases/v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">master</span> <span class="comment"># （这里与远程仓库主分支名称一致）.</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span> <span class="comment"># The folder the action should deploy.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-1-新建分支"><a href="#4-1-新建分支" class="headerlink" title="4.1 新建分支"></a>4.1 新建分支</h4><p>示例：创建分支名为dev-</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF%E4%B8%8A%E4%BC%A0.png"></p>
<p>运行代码,将本地创建分支上传至远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin dev-</span><br></pre></td></tr></table></figure>

<p>然后将项目提交到dev-分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;initblog&#x27;</span></span><br><span class="line">git pull </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>此时项目已经提交至远程仓库dev-分支，项目进入到自动部署阶段</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/image-20210531213104475.png"></p>
<blockquote>
<p>Tips: 提交完成后会在dev-分支下出现一个小黄点，这说明项目正在自动部署，变为绿色后，表明部署完成，就可以通过博客地址访问你更新的内容</p>
</blockquote>
<h3 id="5-博客中使用图片"><a href="#5-博客中使用图片" class="headerlink" title="5 博客中使用图片"></a>5 博客中使用图片</h3><p>个人提供解决思路：picGo+Github搭建图床<br>参考教程如下：<a href="https://www.bilibili.com/video/BV1Ui4y1x7Cq?p=2">PicGo+Github图床的正确打开方式</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>How-to-use-Hexo</title>
    <url>/2021/06/02/How-to-use-Hexo/</url>
    <content><![CDATA[<h2 id="如何使用搭建的博客？"><a href="#如何使用搭建的博客？" class="headerlink" title="如何使用搭建的博客？"></a>如何使用搭建的博客？</h2><h3 id="1-新建博客"><a href="#1-新建博客" class="headerlink" title="1 新建博客"></a>1 新建博客</h3><p>项目目录下运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new title</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips:其中title为文章的标题名称</p>
</blockquote>
<h3 id="2-如何进行分类【category-amp-tag】"><a href="#2-如何进行分类【category-amp-tag】" class="headerlink" title="2 如何进行分类【category  &amp; tag】"></a>2 如何进行分类【category  &amp; tag】</h3><h4 id="2-1-创建分类选项"><a href="#2-1-创建分类选项" class="headerlink" title="2.1 创建分类选项"></a>2.1 创建分类选项</h4><ul>
<li>项目目录下执行命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></li>
<li>成功后会提示信息<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210602155850.png"></li>
<li>根据路径信息找到改文件，并打开修改<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2021-06-02 15:14:47</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
<li>保存关闭文件</li>
</ul>
<h4 id="2-2-创建标签选项"><a href="#2-2-创建标签选项" class="headerlink" title="2.2 创建标签选项"></a>2.2 创建标签选项</h4><ul>
<li>项目目录下执行命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li>
<li>成功后会提示信息<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210602160228.png"></li>
<li>根据路径信息找到改文件，并打开修改<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2021-06-02 15:19:33</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
<li>保存关闭文件</li>
</ul>
<h4 id="2-3-为文章添加分类与标签"><a href="#2-3-为文章添加分类与标签" class="headerlink" title="2.3 为文章添加分类与标签"></a>2.3 为文章添加分类与标签</h4><p>在文章内容中进行修改<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210602161206.png"></p>
<blockquote>
<p>重新编译之后运行即可查看页面出现分类和标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210602161127.png"><br><strong>注意：</strong> hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p>
</blockquote>
<p>未完待续……</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中with的用法</title>
    <url>/2022/03/23/JavaScript%E4%B8%ADwith%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>⚠ 警告：由于with语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用with语句。</p>
</blockquote>
<p>但是这个东东，不是用来做项目的，而是用来做面试题的。</p>
<h2 id="1-with简介"><a href="#1-with简介" class="headerlink" title="1. with简介"></a>1. with简介</h2><p>with语句的用途是将代码作用域设置为特定的对象，语法是：<code>with(expression) statement</code><br>使用with语句的主要场景是针对一个对象反复操作，此时将代码的作用域设置为该对象能提供便利。<br>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="string">&#x27;13&#x27;</span>,</span><br><span class="line">  <span class="attr">school</span>:<span class="string">&#x27;ucas&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果修改<code>person</code>的每一项属性值，一般做法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">person.age = <span class="number">15</span>;</span><br><span class="line">person.school = <span class="string">&#x27;SDAU&#x27;</span>;</span><br><span class="line"><span class="comment">// 上述代码中重复写了3次person</span></span><br></pre></td></tr></table></figure>
<p>使用<code>with</code>的写法，会更加简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">person</span>)</span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">  age = <span class="number">15</span>;</span><br><span class="line">  school = <span class="string">&#x27;SDAU&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-with弊端"><a href="#2-with弊端" class="headerlink" title="2.with弊端"></a>2.with弊端</h2><ul>
<li>数据泄露</li>
<li>性能下降</li>
</ul>
<h3 id="2-1-数据泄露"><a href="#2-1-数据泄露" class="headerlink" title="2.1 数据泄露"></a>2.1 数据泄露</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(a); //ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line">fn(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">fn(obj2);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 2，a被泄漏到全局作用域上</span></span><br></pre></td></tr></table></figure>
<p>上述代码中创建了<code>obj1</code> 、<code>obj2</code>两个对象，其中<code>obj1</code>中有属性<code>a</code>，<code>obj2</code>没有属性<code>a</code>。<code>fn(obj) </code>函数接受一个 <code>obj</code> 的形参，该参数是一个对象引用，并对该对象执行了 <code>with(obj) &#123;...&#125;</code>。将<code>obj1</code>传递进去，<code>a = 2</code>赋值操作找到<code>obj.a</code>并将2赋值给它。当<code>obj2</code>传递进去时，但是并没有属性<code>a</code>，因此不会创建这个属性，所以<code>obj2.a</code>的值为<code>undefined</code>。<br>⭐ 为什么对<code>obj2</code>的操作会导致数据泄露？<br>当传递<code>obj2</code>给<code>with</code>时，<code>with</code>所声明的作用域是<code>obj2</code>，从这个作用域开始对<code>a</code>进行LHS查询：<code>obj2</code>的作用域➡<code>fn()</code>的作用域➡全局作用域，以上中都没有找到<code>a</code>，在<b>非严格模式下</b>，会在全局作用域中创建一个全局变量<code>a</code>。在<b>严格模式下</b>，会抛出<code>ReferenceError</code> 异常。</p>
<h3 id="2-2-性能下降"><a href="#2-2-性能下降" class="headerlink" title="2.2 性能下降"></a>2.2 性能下降</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">&quot;func&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> v = obj.a[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">&quot;func&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcWith</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">&quot;funcWith&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> v = a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">&quot;funcWith&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcWith();</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220323113947.png"></p>
<p>原因是什么？<br>JavaScript 引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。</p>
<p>但如果引擎在代码中发现了 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。</p>
<p>最悲观的情况是如果出现了 with ，所有的优化都可能是无意义的。因此引擎会采取最简单的做法就是完全不做任何优化。如果代码大量使用 with 或者 eval()，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢的事实。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>13个JavaScript数组技巧</title>
    <url>/2021/09/22/JavaScript%E6%95%B0%E7%BB%84%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>数组是JS最常见的概念之一，它为我们提供了处理存储数据的许多可能性。在刷题过程中常会用的一些技巧，对数组中的元素进行操作。</p>
<h3 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1.数组去重"></a>1.数组去重</h3><p>两种方法：</p>
<ul>
<li>使用.from()方法</li>
<li>使用拓展运算符…<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  fruits = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;watermelon&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line"><span class="keyword">let</span> uniqueFruits = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(fruits))</span><br><span class="line"><span class="comment">// returns [“banana”, “apple”, “orange”, “watermelon”, “grape”]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="keyword">let</span> uniqueFruits2 = [...new <span class="built_in">Set</span>(fruits)]</span><br><span class="line"><span class="comment">// returns [“banana”, “apple”, “orange”, “watermelon”, “grape”]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-替换数组中特定的值"><a href="#2-替换数组中特定的值" class="headerlink" title="2.替换数组中特定的值"></a>2.替换数组中特定的值</h3><p>使用.splice(start , value to remove , value to add),其中三个参数分别指明从哪里开始、要更改多少个值、更改时使用的替换值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  fruits = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;watermelon&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line">fruits.splice(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&quot;potato&quot;</span>,<span class="string">&quot;tomato&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fruits) </span><br><span class="line"><span class="comment">//returns  [&quot;potato&quot;, &quot;tomato&quot;, &quot;orange&quot;, &quot;watermelon&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;grape&quot;, &quot;apple&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="3-不使用-map-映射数组"><a href="#3-不使用-map-映射数组" class="headerlink" title="3.不使用.map()映射数组"></a>3.不使用.map()映射数组</h3><p>也许每个人都知道数组的.map()方法，但是可以使用另一种方案来获得相似的效果，并且代码非常简洁。这里我们可用.from()方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> friends = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Mark&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Maria&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Monica&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Martha&#x27;</span>, <span class="attr">age</span>: <span class="number">19</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> friendsNames = <span class="built_in">Array</span>.from(friends, <span class="function">(<span class="params">&#123;name&#125;</span>) =&gt;</span> name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friendsNames) </span><br><span class="line"><span class="comment">//returns [&quot;John&quot;, &quot;Peter&quot;, &quot;Mark&quot;, &quot;Maria&quot;, &quot;Monica&quot;, &quot;Martha&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="补充知识：使用-map-映射数组"><a href="#补充知识：使用-map-映射数组" class="headerlink" title="补充知识：使用.map()映射数组"></a>补充知识：使用.map()映射数组</h4><p>一般写法：</p>
<ul>
<li>创建Map</li>
<li>将需要查询的数据，按照 “key - value” 的形式存储到map对象中，其中key为关键字，value为查询的信息</li>
<li>查询时根据key查找对应的value<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// return [2,4,6]</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210922095015.png"></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉花括号的写法（只有一个return的时候，&#123;&#125;可以省略）</span></span><br><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个小例子：判断成绩是否及格</span></span><br><span class="line"><span class="keyword">let</span> scroe = [<span class="number">12</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>, <span class="number">33</span>, <span class="number">100</span>, <span class="number">59</span>]</span><br><span class="line"><span class="keyword">let</span> result = scroe.map(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;= <span class="number">60</span> ? <span class="string">&#x27;及格&#x27;</span> : <span class="string">&#x27;不及格&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210922095712.png"></p>
<h3 id="4-清空数组"><a href="#4-清空数组" class="headerlink" title="4.清空数组"></a>4.清空数组</h3><p>清空数组仅需要将数组的长度设为0即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;watermelon&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;apple&quot;</span>];</span><br><span class="line"></span><br><span class="line">fruits.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fruits); <span class="comment">// returns []</span></span><br></pre></td></tr></table></figure>

<h3 id="5-数组转对象"><a href="#5-数组转对象" class="headerlink" title="5.数组转对象"></a>5.数组转对象</h3><p>数组转换为对象的最快方法是使用扩展运算符…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;watermelon&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fruitsObj = &#123;...fruits&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruitsObj) </span><br><span class="line"><span class="comment">// returns &#123;0: “banana”, 1: “apple”, 2: “orange”, 3: “watermelon”&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-用数据填充数组"><a href="#6-用数据填充数组" class="headerlink" title="6.用数据填充数组"></a>6.用数据填充数组</h3><p>在刷题时，一般会初始化一个具有相同值的数组。使用.fill()可以快速实现这一需求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="string">&#x27;1&#x27;</span>) <span class="comment">// 数组长度为10，填充内容为‘1’</span></span><br><span class="line"><span class="built_in">console</span>.log(newArray) </span><br><span class="line"><span class="comment">// returns [“1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”, “1”]</span></span><br></pre></td></tr></table></figure>

<h3 id="7-合并数组"><a href="#7-合并数组" class="headerlink" title="7.合并数组"></a>7.合并数组</h3><p>两种方法：</p>
<ul>
<li>.concat()方法</li>
<li>扩展运算符…<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;orange&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> meat = [<span class="string">&quot;beaf&quot;</span>,<span class="string">&quot;fish&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> vegetables = [<span class="string">&quot;potato&quot;</span>,<span class="string">&quot;cucumber&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fruits.concat(meat).concat(vegetables))</span><br><span class="line"><span class="comment">// return [&quot;apple&quot;, &quot;orange&quot;, &quot;beaf&quot;, &quot;fish&quot;, &quot;potato&quot;, &quot;cucumber&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> food = [...fruits,...meat,...vegetables]</span><br><span class="line"><span class="built_in">console</span>.log(food)</span><br><span class="line"><span class="comment">// return [&quot;apple&quot;, &quot;orange&quot;, &quot;beaf&quot;, &quot;fish&quot;, &quot;potato&quot;, &quot;cucumber&quot;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-求数组交集"><a href="#8-求数组交集" class="headerlink" title="8.求数组交集"></a>8.求数组交集</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numOne = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> numTwo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> duplicatedValues = [...new <span class="built_in">Set</span>(numOne)].filter(<span class="function"><span class="params">item</span>=&gt;</span> numTwo.includes(item))</span><br><span class="line"><span class="built_in">console</span>.log(duplicatedValues); <span class="comment">// returns [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="9-从数组中删除虚值"><a href="#9-从数组中删除虚值" class="headerlink" title="9.从数组中删除虚值"></a>9.从数组中删除虚值</h3><p>在Javascript中，虚值有false, 0, „”, null, NaN, undefined。现在，我们可以找到如何从数组中删除此类值。为此，我们将使用.filter（）方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixedArr = [<span class="number">0</span>, “blue”, “”, <span class="literal">NaN</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, “white”, <span class="literal">false</span>];</span><br><span class="line"><span class="keyword">var</span> trueArr = mixedArr.filter(<span class="built_in">Boolean</span>);</span><br><span class="line"><span class="built_in">console</span>.log(trueArr); <span class="comment">// returns [“blue”, 9, true, “white”]</span></span><br></pre></td></tr></table></figure>

<h3 id="10-从数组中获取随机值"><a href="#10-从数组中获取随机值" class="headerlink" title="10.从数组中获取随机值"></a>10.从数组中获取随机值</h3><p>可以根据数组长度获取随机索引号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&quot;blue&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;navy&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> randomColor = colors[(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (colors.length)))]</span><br></pre></td></tr></table></figure>

<h3 id="11-反转数组"><a href="#11-反转数组" class="headerlink" title="11. 反转数组"></a>11. 反转数组</h3><p>使用.reverse()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&quot;blue&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;navy&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> reversedColors = colors.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(reversedColors); </span><br><span class="line"><span class="comment">// returns [&#x27;purple&#x27;, &#x27;pink&#x27;, &#x27;navy&#x27;, &#x27;green&#x27;, &#x27;white&#x27;, &#x27;blue&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="12-lastIndexOf（）方法"><a href="#12-lastIndexOf（）方法" class="headerlink" title="12.lastIndexOf（）方法"></a>12.lastIndexOf（）方法</h3><p>lastIndexOf（）方法:查找给定元素的最后一次出现的索引。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> lastIndex = nums.lastIndexOf(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lastIndex); <span class="comment">// returns 9</span></span><br></pre></td></tr></table></figure>

<h3 id="13-求数组中的所有值的和"><a href="#13-求数组中的所有值的和" class="headerlink" title="13.求数组中的所有值的和"></a>13.求数组中的所有值的和</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> sum = nums.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// returns 14</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Grid网格布局笔记</title>
    <url>/2021/07/13/Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1-什么是Grid布局？"><a href="#1-1-什么是Grid布局？" class="headerlink" title="1.1 什么是Grid布局？"></a>1.1 什么是Grid布局？</h3><ul>
<li>Flex布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。</li>
<li>Grid布局将页面容器划分为“行”和“列”，产生单元格，然后指定“项目”所在的单元格，可以看作二维布局。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713140049.png"><h3 id="1-2-布局方式—常用的3种"><a href="#1-2-布局方式—常用的3种" class="headerlink" title="1.2 布局方式—常用的3种"></a>1.2 布局方式—常用的3种</h3><h4 id="1-2-1-传统布局方式"><a href="#1-2-1-传统布局方式" class="headerlink" title="1.2.1 传统布局方式"></a>1.2.1 传统布局方式</h4>利用position属性 + display属性 + float属性布局, 兼容性最好, 但是效率低, 麻烦!<h4 id="1-2-1-flex布局"><a href="#1-2-1-flex布局" class="headerlink" title="1.2.1 flex布局"></a>1.2.1 flex布局</h4>有自己的一套属性, 效率高, 学习成本低, 兼容性强!<h4 id="1-2-1-grid布局"><a href="#1-2-1-grid布局" class="headerlink" title="1.2.1 grid布局"></a>1.2.1 grid布局</h4>网格布局(grid)是最强大的布局方案, 但是知识点比较多, 学习成本相对较高, 目前兼容性不如flex布局!</li>
</ul>
<h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h2><ul>
<li><p>采用网格布局的区域，称为”容器”（container）。</p>
</li>
<li><p>容器内部采用网格定位的子元素，称为”项目”（item）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，最外层的&lt;div&gt;元素就是容器，内层的三个&lt;div&gt;元素就是项目。</p>
<blockquote>
<p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的&lt;p&gt;元素就不是项目。Grid 布局只对项目生效。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713141153.png"></p>
</li>
<li><p>网格线：划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713141238.png"></p>
<p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p>
<h3 id="2-1-容器属性"><a href="#2-1-容器属性" class="headerlink" title="2.1 容器属性"></a>2.1 容器属性</h3><h4 id="2-1-1-display属性"><a href="#2-1-1-display属性" class="headerlink" title="2.1.1 display属性"></a>2.1.1 display属性</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定一个容器采用网格布局。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-5&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-6&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-7&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-8&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-9&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-size</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#container</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="css">      grid-template-<span class="attribute">columns</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      grid-template-rows: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-size</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e4e9</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-1</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#ef342a</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-2</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#f68f26</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-3</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#4ba946</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-4</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#0376c2</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-5</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#c077af</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-6</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#f8d29d</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-7</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#b5a87f</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-8</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#d0e4a9</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.item-9</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#4dc7ec</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713144424.png"></p>
<p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713144912.png"></p>
<blockquote>
<p>注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p>
</blockquote>
<h4 id="2-1-2-grid-template-columns-属性和grid-template-rows-属性"><a href="#2-1-2-grid-template-columns-属性和grid-template-rows-属性" class="headerlink" title="2.1.2 grid-template-columns 属性和grid-template-rows 属性"></a>2.1.2 grid-template-columns 属性和grid-template-rows 属性</h4><ul>
<li>grid-template-columns属性定义每一列的列宽</li>
<li>grid-template-rows属性定义每一行的行高<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">300px</span> <span class="number">100px</span> <span class="number">200px</span>;</span><br><span class="line">    grid-template-rows: <span class="number">100px</span> <span class="number">150px</span> <span class="number">120px</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
指定一个三行三列的网格，列宽为300px,100px,200px和行高是100px,150px,120px<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713151714.png"><br>除了使用绝对单位，也可以使用百分比。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">  grid-template-rows: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-辅助函数repeat"><a href="#1-辅助函数repeat" class="headerlink" title="(1) 辅助函数repeat()"></a>(1) 辅助函数repeat()</h6>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br><span class="line">  grid-template-rows: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。repeat()重复某种模式也是可以的。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">20px</span> <span class="number">80px</span>);</span><br></pre></td></tr></table></figure>
上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713152142.png"></li>
</ul>
<h6 id="2-auto-fill-关键字"><a href="#2-auto-fill-关键字" class="headerlink" title="(2) auto-fill 关键字"></a>(2) auto-fill 关键字</h6><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713153005.png"></p>
<h6 id="3-fr-关键字"><a href="#3-fr-关键字" class="headerlink" title="(3) fr 关键字"></a>(3) fr 关键字</h6><p>为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示两个相同宽度的列。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713153417.png"><br>fr可以与绝对长度的单位结合使用，这时会非常方便。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713153548.png"></p>
<h6 id="4-minmax"><a href="#4-minmax" class="headerlink" title="(4) minmax()"></a>(4) minmax()</h6><p>minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure>
<p>上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。</p>
<h6 id="5-auto关键字"><a href="#5-auto关键字" class="headerlink" title="(5) auto关键字"></a>(5) auto关键字</h6><p>auto关键字表示由浏览器自己决定长度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。</p>
<h6 id="（6）网格线的名称"><a href="#（6）网格线的名称" class="headerlink" title="（6）网格线的名称"></a>（6）网格线的名称</h6><p>grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">  grid-template-rows: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。<br>网格布局允许同一根线有多个名字，比如[fifth-line row-5]。</p>
<h6 id="（7）布局实例"><a href="#（7）布局实例" class="headerlink" title="（7）布局实例"></a>（7）布局实例</h6><p>grid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码将左边栏设为70%，右边栏设为30%。</p>
<p>传统的十二网格布局，写起来也很容易。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">12</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-grid-row-gap-属性，grid-column-gap-属性，grid-gap-属性"><a href="#2-1-3-grid-row-gap-属性，grid-column-gap-属性，grid-gap-属性" class="headerlink" title="2.1.3 grid-row-gap 属性，grid-column-gap 属性，grid-gap 属性"></a>2.1.3 grid-row-gap 属性，grid-column-gap 属性，grid-gap 属性</h4><ul>
<li>grid-row-gap属性设置行与行的间隔（行间距）</li>
<li>grid-column-gap属性设置列与列的间隔（列间距）</li>
<li>grid-gap 属性是grid-row-gap和grid-column-gap的合并简写形式<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  grid-row-gap: <span class="number">20px</span>;</span><br><span class="line">  grid-<span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713155129.png"></li>
</ul>
<p>grid-gap 属性是grid-row-gap和grid-column-gap的合并简写形式，语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p>
</blockquote>
<h4 id="2-1-4-grid-template-areas-属性"><a href="#2-1-4-grid-template-areas-属性" class="headerlink" title="2.1.4 grid-template-areas 属性"></a>2.1.4 grid-template-areas 属性</h4><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-areas: <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">                       <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">                       <span class="string">&#x27;g h i&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713161356.png"><br>多个单元格合并成一个区域的写法如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&#x27;a a a&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;b b b&#x27;</span></span><br><span class="line">                     <span class="string">&#x27;c c c&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码将9个单元格分成a、b、c三个区域。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713161535.png"><br>布局实例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&quot;header header header&quot;</span></span><br><span class="line">                     <span class="string">&quot;main main sidebar&quot;</span></span><br><span class="line">                     <span class="string">&quot;footer footer footer&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。</p>
<p>如果某些区域不需要利用，则使用”点”（.）表示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: </span><br><span class="line">            <span class="string">&quot;a a .&quot;</span></span><br><span class="line">            <span class="string">&quot;a a .&quot;</span></span><br><span class="line">            <span class="string">&quot;. b c&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713162146.png"></p>
<h4 id="2-1-5-grid-auto-flow-属性"><a href="#2-1-5-grid-auto-flow-属性" class="headerlink" title="2.1.5 grid-auto-flow 属性"></a>2.1.5 grid-auto-flow 属性</h4><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713162818.png"><br>这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: column;</span><br></pre></td></tr></table></figure>
<p>上面代码设置了column以后，放置顺序就变成了下图。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713162945.png"></p>
<p>下面的例子让1号项目和2号项目各占据两个单元格，然后在默认的grid-auto-flow: row 情况下，会产生下面这样的布局。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713170446.png"><br>上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。</p>
<p>现在修改设置，设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: row dense;</span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713170539.png"></p>
<p>如果将设置改为column dense，表示”先列后行”，并且尽量填满空格。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: column dense;</span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713171202.png"><br>上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。</p>
<h4 id="2-1-6-justify-items-属性，align-items-属性，place-items-属性"><a href="#2-1-6-justify-items-属性，align-items-属性，place-items-属性" class="headerlink" title="2.1.6 justify-items 属性，align-items 属性，place-items 属性"></a>2.1.6 justify-items 属性，align-items 属性，place-items 属性</h4><p>justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  justify-items: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-items</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个属性的写法完全相同，都可以取下面这些值。</p>
<blockquote>
<ul>
<li>start：对齐单元格的起始边缘。(左对齐 / 上对齐)</li>
<li>end：对齐单元格的结束边缘。（右对齐 / 下对齐）</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  justify-items: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，单元格的内容左对齐，效果如下图。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713174744.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，单元格的内容头部对齐，效果如下图。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713174838.png"></p>
<p>place-items属性是align-items属性和justify-items属性的合并简写形式。语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-items: &lt;align-items&gt; &lt;justify-items&gt;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-7-justify-content-属性，align-content-属性，place-content-属性"><a href="#2-1-7-justify-content-属性，align-content-属性，place-content-属性" class="headerlink" title="2.1.7 justify-content 属性，align-content 属性，place-content 属性"></a>2.1.7 justify-content 属性，align-content 属性，place-content 属性</h4><p>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  <span class="attribute">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713205759.png"></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713205830.png"></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713210130.png"></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713210219.png"></p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713210344.png"></p>
<p>place-content属性是align-content属性和justify-content属性的合并简写形式,语法形式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: space-around space-evenly;</span><br></pre></td></tr></table></figure>
<p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p>
<h4 id="2-1-8-grid-auto-columns-属性，grid-auto-rows-属性"><a href="#2-1-8-grid-auto-columns-属性，grid-auto-rows-属性" class="headerlink" title="2.1.8 grid-auto-columns 属性，grid-auto-rows 属性"></a>2.1.8 grid-auto-columns 属性，grid-auto-rows 属性</h4><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。<br>grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-5&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-6&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-7&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-8&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-9&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#container</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="css">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  grid-<span class="attribute">auto</span>-rows: <span class="number">50px</span>; </span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e4e9</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.item-1</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: <span class="number">#ef342a</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.item-2</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: <span class="number">#f68f26</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.item-3</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: <span class="number">#4ba946</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.item-4</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: <span class="number">#0376c2</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.item-5</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: <span class="number">#c077af</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.item-6</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: <span class="number">#f8d29d</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.item-7</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: <span class="number">#b5a87f</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.item-8</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: <span class="number">#d0e4a9</span>;</span></span><br><span class="line"><span class="css">  grid-row-start: <span class="number">4</span>;</span></span><br><span class="line"><span class="css">  grid-column-start: <span class="number">2</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.item-9</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: <span class="number">#4dc7ec</span>;</span></span><br><span class="line"><span class="css">  grid-row-start: <span class="number">5</span>;</span></span><br><span class="line"><span class="css">  grid-column-start: <span class="number">3</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210713225142.png"></p>
<h4 id="2-1-8grid-template-属性，grid-属性"><a href="#2-1-8grid-template-属性，grid-属性" class="headerlink" title="2.1.8grid-template 属性，grid 属性"></a>2.1.8grid-template 属性，grid 属性</h4><ul>
<li><p>grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。</p>
</li>
<li><p>grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p>
</li>
</ul>
<p>从易读易写的角度考虑，还是建议不要合并属性。</p>
<h3 id="2-2-项目属性"><a href="#2-2-项目属性" class="headerlink" title="2.2 项目属性"></a>2.2 项目属性</h3><h4 id="2-1-1-grid-column-start-属性，grid-column-end-属性，grid-row-start-属性，grid-row-end-属性"><a href="#2-1-1-grid-column-start-属性，grid-column-end-属性，grid-row-start-属性，grid-row-end-属性" class="headerlink" title="2.1.1 grid-column-start 属性，grid-column-end 属性，grid-row-start 属性，grid-row-end 属性"></a>2.1.1 grid-column-start 属性，grid-column-end 属性，grid-row-start 属性，grid-row-end 属性</h4><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p>
<blockquote>
<ul>
<li>grid-column-start属性：左边框所在的垂直网格线</li>
<li>grid-column-end属性：右边框所在的垂直网格线</li>
<li>grid-row-start属性：上边框所在的水平网格线</li>
<li>grid-row-end属性：下边框所在的水平网格线</li>
</ul>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-start: <span class="number">2</span>;</span><br><span class="line">  grid-column-end: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210714094703.png"><br>上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-start: <span class="number">1</span>;</span><br><span class="line">  grid-column-end: <span class="number">3</span>;</span><br><span class="line">  grid-row-start: <span class="number">2</span>;</span><br><span class="line">  grid-row-end: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210714095102.png"></p>
<p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-start: header-start;</span><br><span class="line">  grid-column-end: header-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-start: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，1号项目的左边框距离右边框跨越2个网格。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210714095416.png"><br>这与下面的代码效果完全一样。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-column-end: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。</p>
</blockquote>
<h4 id="2-1-2-grid-column-属性，grid-row-属性"><a href="#2-1-2-grid-column-属性，grid-row-属性" class="headerlink" title="2.1.2  grid-column 属性，grid-row 属性"></a>2.1.2  grid-column 属性，grid-row 属性</h4><p>grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。语法格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  grid-column: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">  grid-row: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">  grid-column: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  grid-row: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">  grid-column: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">  grid-row: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目item-1占据的区域，包括第一行 + 第二行、第一列 + 第二列。<br>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210714095857.png"></p>
<h4 id="2-1-3-grid-area-属性"><a href="#2-1-3-grid-area-属性" class="headerlink" title="2.1.3 grid-area 属性"></a>2.1.3 grid-area 属性</h4><p>grid-area属性指定项目放在哪一个区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  grid-area: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，1号项目位于e区域，效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210714100643.png"><br>grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-4-justify-self-属性，align-self-属性，place-self-属性"><a href="#2-1-4-justify-self-属性，align-self-属性，place-self-属性" class="headerlink" title="2.1.4 justify-self 属性，align-self 属性，place-self 属性"></a>2.1.4 justify-self 属性，align-self 属性，place-self 属性</h4><p>justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。</p>
<p>align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>place-self属性是align-self属性和justify-self属性的合并简写形式。语法格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: &lt;align-self&gt; &lt;justify-self&gt;;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: center center;</span><br></pre></td></tr></table></figure>
<p>如果省略第二个值，place-self属性会认为这两个值相等。</p>
<p><strong>参考文章：</strong></p>
<p>1.<a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程-阮一峰</a></p>
<p>2.<a href="https://www.jianshu.com/p/3762f214cd6f">(超详细)强大的grid布局-雨溪滩</a></p>
]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>页面布局</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript练习题【牛客网】（持续使用中）</title>
    <url>/2021/10/09/JavaScript%E7%BB%83%E4%B9%A0%E9%A2%98%E3%80%90%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%91/</url>
    <content><![CDATA[<h4 id="1-JavaScript定义var-a-”30”-var-b-8-则执行-a-b-会得到（）"><a href="#1-JavaScript定义var-a-”30”-var-b-8-则执行-a-b-会得到（）" class="headerlink" title="1.JavaScript定义var a=”30”,var b=8,则执行 a%b 会得到（）"></a>1.JavaScript定义var a=”30”,var b=8,则执行 a%b 会得到（）</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211009092934.png"></p>
<p>【解析】<br>B<br>运算中‘+’号，数字隐式转换成字符串。其余的运算符号是字符串隐式转换成数字。</p>
<h4 id="2-下面这段JS程序的执行结果是："><a href="#2-下面这段JS程序的执行结果是：" class="headerlink" title="2.下面这段JS程序的执行结果是："></a>2.下面这段JS程序的执行结果是：</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211009093457.png"><br>A. [1,2,3,4]<br>B. [1,2,3]<br>C. [4]<br>D. [2,3,4]</p>
<p>【解析】<br>B<br>JS中slice()方法是选取数组的的一部分，并返回一个新数组。</p>
<h4 id="3-执行以下程序段后，x的值是（-）。"><a href="#3-执行以下程序段后，x的值是（-）。" class="headerlink" title="3.执行以下程序段后，x的值是（ ）。"></a>3.执行以下程序段后，x的值是（ ）。</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211009093823.png"><br>A. 1<br>B. 2<br>C. 3<br>D. 4</p>
<p>【解析】<br>C<br>switch中没有break</p>
<h4 id="4-以下代码执行后，-num-的值是？"><a href="#4-以下代码执行后，-num-的值是？" class="headerlink" title="4.以下代码执行后， num 的值是？"></a>4.以下代码执行后， num 的值是？</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211009094034.png"><br>A. -1<br>B. 3<br>C. 1<br>D. 2</p>
<p>【解析】<br>A</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.匿名函数，需要通过变量引用指向函数的运行结果。</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;      <span class="comment">//赋值式函数</span></span><br><span class="line"><span class="keyword">return</span> x-y;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.有名函数，可以单独定义。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>)</span>&#123;         <span class="comment">//声明式函数</span></span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际调用</span></span><br><span class="line"><span class="keyword">var</span> num=foo(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//调用赋值式函数  return x-y  为  -1</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211009094556.png"><br>知识点：<a href="https://www.cnblogs.com/lvonve/p/9871226.html">js变量提升与函数提升的详细过程</a></p>
]]></content>
      <categories>
        <category>JS学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript数组的reduce方法</title>
    <url>/2022/03/03/Javascript%E6%95%B0%E7%BB%84%E7%9A%84reduce%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Javascript数组的<code>reduce</code>方法对数组中的每个元素执行一个由您提供的<code>reducer</code>函数(升序执行)，将其结果汇总为单个返回值。</p>
<p>基本语法：<code>arr.reduce(callback,[initialValue])</code></p>
<p>参数说明：<br>callback 执行数组中每个值的函数，包含四个参数：</p>
<ul>
<li><code>previousValue</code>：第一项的值或者上一次叠加的结果值，或者是提供的初始值<code>initialValue</code></li>
<li><code>currentValue</code>：数组中当前被处理的元素</li>
<li><code>index</code>：当前元素在数组中的索引</li>
<li><code>array</code>：数组本身</li>
</ul>
<p>initialValue（可选）：作为第一次调用<code>callback</code>的第一个参数，可以控制返回值的格式</p>
<blockquote>
<p>reduce() 方法可以使用一下这个表达式总结一下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>


<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>次执行：pre=<span class="subst">$&#123;pre&#125;</span>,cur=<span class="subst">$&#123;cur&#125;</span>,index=<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220303165351.png"></p>
<p>代码分析：</p>
<ul>
<li>数组中的元素依次执行了回调函数。</li>
<li>因为给 initialValue 赋了初始值 10，所以第一次执行时， pre 的值默认从 10 开始。</li>
<li>每次执行时，pre 的值都是 cur 元素前的所有元素之和。</li>
<li>最后返回数组所有元素累加的和。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>次执行：pre=<span class="subst">$&#123;pre&#125;</span>,cur=<span class="subst">$&#123;cur&#125;</span>,index=<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220303165658.png"></p>
<p>可以看到代码只执行了3次，并且是从数组的第二个元素开始执行的，数组的第一位元素默认作为<code>pre</code>的值。</p>
<h2 id="实际用法"><a href="#实际用法" class="headerlink" title="实际用法"></a>实际用法</h2><h4 id="1-计算数组中每个元素出现的次数"><a href="#1-计算数组中每个元素出现的次数" class="headerlink" title="1.计算数组中每个元素出现的次数"></a>1.计算数组中每个元素出现的次数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>];</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pre, cur);</span><br><span class="line">  <span class="keyword">if</span> (cur <span class="keyword">in</span> pre) &#123;</span><br><span class="line">    pre[cur]++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pre[cur] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220303170846.png"></p>
<h4 id="2-数组去重"><a href="#2-数组去重" class="headerlink" title="2.数组去重"></a>2.数组去重</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>];</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pre, cur);</span><br><span class="line">  <span class="keyword">if</span> (!pre.includes(cur)) &#123;</span><br><span class="line">    pre.push(cur);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220303171115.png"></p>
<h4 id="3-对象属性求和"><a href="#3-对象属性求和" class="headerlink" title="3.对象属性求和"></a>3.对象属性求和</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">17</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Lily&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">19</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">person.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    a = a + b.age;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 54</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的Map详解</title>
    <url>/2022/02/19/JavaScript%E7%9A%84Map%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>在ES6之前，JS实现“键/值”式存储可以使用<code>Object</code>来高效地完成，也就是使用对象属性作为键，再使用属性来引用值。</p>
<p>ES6中出现Map，<code>Map</code>是一种新的集合类型。<code>Map</code>对象保存键-值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<h2 id="Map和Object的区别"><a href="#Map和Object的区别" class="headerlink" title="Map和Object的区别"></a>Map和Object的区别</h2><ul>
<li><code>Map</code>的键值是有序的（FIFO原则，First Input First Output），而添加到对象中的键则不是</li>
<li><code>Map</code>的键值对个数可以通过<code>size</code>属性获取，而<code>Object</code>的键值对个数只能手动计算</li>
<li><code>Object</code> 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li>
</ul>
<h2 id="Map对象的方法"><a href="#Map对象的方法" class="headerlink" title="Map对象的方法"></a>Map对象的方法</h2><ul>
<li><code>set(key, val)</code> ：向Map中添加新元素</li>
<li><code>get(key)</code>: 通过键值查找特定的数值并返回</li>
<li><code>has(key)</code>: 判断Map对象中是否有key所对应的值，有返回true,否则返回false</li>
<li><code>delete(key)</code>: 通过键值从Map中移除对应的数据</li>
<li><code>clear()</code>: 将这个Map中的所有元素删除</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;a&#x27;</span>,<span class="number">111</span>],[<span class="string">&#x27;b&#x27;</span>,<span class="number">222</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(m1); <span class="comment">// &#123;&#x27;a&#x27; =&gt; 111, &#x27;b&#x27; =&gt; 222&#125;</span></span><br><span class="line"></span><br><span class="line">m1.get(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">// 111</span></span><br><span class="line">m1.has(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">m1.set(<span class="string">&#x27;c&#x27;</span>,<span class="number">333</span>) <span class="comment">// &#123;&#x27;a&#x27; =&gt; 111, &#x27;b&#x27; =&gt; 222, &#x27;c&#x27; =&gt; 333&#125;</span></span><br><span class="line">m1.delete(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(m1); <span class="comment">// &#123;&#x27;a&#x27; =&gt; 111, &#x27;c&#x27; =&gt; 333&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Map的遍历方法"><a href="#Map的遍历方法" class="headerlink" title="Map的遍历方法"></a>Map的遍历方法</h2><ul>
<li><code>keys()</code>：返回键名的遍历器</li>
<li><code>values()</code>：返回键值的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>], [<span class="string">&#x27;b&#x27;</span>,  <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">// &quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> map)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;a&quot;, 1]</span></span><br><span class="line"><span class="comment">// [&quot;b&quot;, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;a&quot; 1</span></span><br><span class="line"><span class="comment">// &quot;b&quot; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of...遍历map等同于使用map.entries()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;a&quot; 1</span></span><br><span class="line"><span class="comment">// &quot;b&quot; 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用Map解题：<a href="https://qw-null.github.io/2022/02/19/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E4%B8%AA%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90Leetcode%E3%80%91/">数组中第K个独一无二的字符串【Leetcode】</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>N进制数【Leetcode】</title>
    <url>/2022/03/07/N%E8%BF%9B%E5%88%B6%E6%95%B0%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>给定一个数字，求该数字的N进制表示方法（N&lt;10）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getN_aryNum = <span class="function"><span class="keyword">function</span>(<span class="params">n,num</span>)</span>&#123;<span class="comment">//n表示进制，num表示原数</span></span><br><span class="line">  <span class="keyword">if</span>(num === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span>;<span class="comment">//原数是正数还是负数的标志</span></span><br><span class="line">  <span class="keyword">if</span>(num&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    num = -num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    res.push(num%n);</span><br><span class="line">    num = <span class="built_in">Math</span>.floor(num/n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag) res.push(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> res.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/base-7/">原题链接：504. 七进制数</a><br>给定一个整数 <code>num</code>，将其转化为 <b>7 进制</b>，并以字符串形式输出。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307145705.png"></p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> getN_aryNum = <span class="function"><span class="keyword">function</span>(<span class="params">n,num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(num === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span>;<span class="comment">//原数是正数还是负数的标志</span></span><br><span class="line">  <span class="keyword">if</span>(num&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    num = -num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    res.push(num%n);</span><br><span class="line">    num = <span class="built_in">Math</span>.floor(num/n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag) res.push(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> res.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> convertToBase7 = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getN_aryNum(<span class="number">7</span>,num)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript高级教程</title>
    <url>/2022/02/25/Javascript%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV14s411E7qf?share_source=copy_web">尚硅谷JavaScript高级教程(javascript实战进阶)</a></p>
<h2 id="1-基础总结深入"><a href="#1-基础总结深入" class="headerlink" title="1.基础总结深入"></a>1.基础总结深入</h2><h3 id="1-1数据类型"><a href="#1-1数据类型" class="headerlink" title="1.1数据类型"></a>1.1数据类型</h3><p>两大类：1.基本（值）类型  2.对象（引用）类型</p>
<ol>
<li><p>基本（值）类型<br>String：任意字符串<br>Number：任意数字<br>Symbol：代表创建后独一无二且不可变的数据类型【它的出现我认为是为了解决可能出现的全局变量冲突的问题】<br>Boolean：true / false<br>Undefined：undefined<br>Null：null</p>
</li>
<li><p>对象（引用）类型<br>Object：任意对象<br>Function：一种特别的对象（特别在可以执行）<br>Array：一种特别的对象（特别在属性为数值下标，内部数据是有序的）</p>
</li>
<li><p>判断数据类型</p>
</li>
</ol>
<ul>
<li>typeof  ： 可以判断：undefined / 数值 / 字符串 / 布尔值</li>
<li>typeof  ： 不可以判断：<b style="background:yellow;">null与object、object与array</b></li>
<li>instanceof ：判断对象的具体类型</li>
<li>===  ： 可以判断：undefined / null （因为这两者只有一个数值）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.基本数据类型</span></span><br><span class="line"><span class="comment">// typeof 返回数据类型的字符串表达</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Undefined</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="keyword">typeof</span> a, <span class="keyword">typeof</span> a === <span class="string">&#x27;undefined&#x27;</span>, a === <span class="literal">undefined</span>); <span class="comment">// undefined  &#x27;undefined&#x27;  true  true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String</span></span><br><span class="line">a = <span class="string">&#x27;angle&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean</span></span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a === <span class="string">&#x27;boolean&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Null</span></span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="literal">null</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.对象数据类型</span></span><br><span class="line"><span class="keyword">var</span> b1 = &#123;</span><br><span class="line">  <span class="attr">b2</span>: [<span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="built_in">console</span>.log],</span><br><span class="line">  <span class="attr">b3</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b3&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.b2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>, b1.b2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// true true</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.b3 <span class="keyword">instanceof</span> <span class="built_in">Function</span>, b1.b3 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// true true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1.b3 === <span class="string">&#x27;function&#x27;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>为什么<code>b1.b3 instanceof Object</code> 是 <code>true</code>，这是因为函数是一种特殊的对象。</p>
<p>对于上述定义中的<code>b2</code>的第三个元素<code>console.log</code>进行类型判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1.b2[<span class="number">2</span>] === <span class="string">&#x27;function&#x27;</span>);<span class="comment">//true</span></span><br><span class="line">b1.b2[<span class="number">2</span>](<span class="number">4</span>);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="1-undefined与null的区别是什么？"><a href="#1-undefined与null的区别是什么？" class="headerlink" title="1.undefined与null的区别是什么？"></a>1.undefined与null的区别是什么？</h4><ul>
<li>undefined 代表定义未赋值</li>
<li>null表示定义了变量并且赋值为null</li>
</ul>
<h4 id="2-什么时候给变量赋值为null"><a href="#2-什么时候给变量赋值为null" class="headerlink" title="2.什么时候给变量赋值为null?"></a>2.什么时候给变量赋值为null?</h4><ul>
<li>初始赋值为null，表明将要赋值为对象。</li>
<li>结束前，让对象成为垃圾对象（被垃圾回收器回收）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 起始</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">null</span>; <span class="comment">// 初始赋值为null，表明将要赋值为对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定对象就要赋值</span></span><br><span class="line">b = [<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后</span></span><br><span class="line">b = <span class="literal">null</span>; <span class="comment">// 释放对象：让b指向的对象成为垃圾对象（被垃圾回收器回收）</span></span><br></pre></td></tr></table></figure>
<h4 id="3-严格区别变量类型与数据类型？"><a href="#3-严格区别变量类型与数据类型？" class="headerlink" title="3.严格区别变量类型与数据类型？"></a>3.严格区别变量类型与数据类型？</h4><p>数据的类型：*基本类型  *对象类型<br>变量类型（变量内存值的类型）：<br>*基本类型：保存基本类型的数据<br>*引用类型：保存地址值</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228110010.png"></p>
<p>对于上图中的变量<code>a</code>和<code>b</code>，因为其存储的是基本类型，所以数据直接保存在栈内存中，而对于变量<code>c</code>而言，其代表对象，因此在栈内存中只存储该对象在堆内存中的地址。</p>
<h3 id="1-2-数据，变量与内存"><a href="#1-2-数据，变量与内存" class="headerlink" title="1.2 数据，变量与内存"></a>1.2 数据，变量与内存</h3><h4 id="1-2-1-什么是数据？"><a href="#1-2-1-什么是数据？" class="headerlink" title="1.2.1 什么是数据？"></a>1.2.1 什么是数据？</h4><p>● 存储在内存中的代表特定信息的东西，本质上是0101……<br>● 数据的特点：可传递、可运算<br>● 一切皆数据<br>● 内存中所有操作的目标：数据【*算术运算 、 *逻辑运算、 <em>赋值运算 、</em>运行函数】</p>
<h4 id="1-2-2-什么是内存？"><a href="#1-2-2-什么是内存？" class="headerlink" title="1.2.2 什么是内存？"></a>1.2.2 什么是内存？</h4><p>● 内存条通电之后产生的可存储数据的空间（临时的）；<br>● 内存的产生和死亡：内存条（电路板） → 通电  → 产生内存空间  → 存储数据  → 处理数据  →  断电  →  内存空间和数据都消失；<br>● 一块小内存可以保存的2种数据：内部存储的数据 + 地址值<br>● 内存的分类：<br>  栈：全局变量和局部变量（空间较小）<br>  堆：对象（空间较大）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br></pre></td></tr></table></figure>
<p>上述代码在打印时，首先读取的是<code>obj</code>，此时读取的是<code>obj</code>的内容值，只不过内容值当中存储的是<code>obj</code>的地址值。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228114525.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228114817.png"></p>
<h4 id="1-2-3-什么是变量？"><a href="#1-2-3-什么是变量？" class="headerlink" title="1.2.3 什么是变量？"></a>1.2.3 什么是变量？</h4><p>可变化的量，由变量名和变量值组成；<br>每个变量都对应一小块内存，变量名用来查找对应的内存，变量值就是内存中保存的数据</p>
<h4 id="1-2-4-内存、数据、变量三者之间的关系？"><a href="#1-2-4-内存、数据、变量三者之间的关系？" class="headerlink" title="1.2.4 内存、数据、变量三者之间的关系？"></a>1.2.4 内存、数据、变量三者之间的关系？</h4><p>● 内存：用来存储数据的的空间<br>● 变量：是内存的标识</p>
<h4 id="1-2-5-相关问题："><a href="#1-2-5-相关问题：" class="headerlink" title="1.2.5 相关问题："></a>1.2.5 相关问题：</h4><h5 id="⭐-var-a-xxx，a内存中到底保存的是什么？"><a href="#⭐-var-a-xxx，a内存中到底保存的是什么？" class="headerlink" title="⭐ var a = xxx，a内存中到底保存的是什么？"></a>⭐ var a = xxx，a内存中到底保存的是什么？</h5><ul>
<li>xxx是基本数据，保存的是这个数据</li>
<li>xxx是对象，保存的是对象的地址值</li>
<li>xxx是一个变量，保存的是xxx的内容值（可能是基本数据，也可能是地址值）</li>
</ul>
<h5 id="⭐-关于引用变量赋值问题？"><a href="#⭐-关于引用变量赋值问题？" class="headerlink" title="⭐ 关于引用变量赋值问题？"></a>⭐ 关于引用变量赋值问题？</h5><p>● n个引用变量指向同一个对象，通过一个变量修改对象内部的数据，其他所有变量看到的是修改之后的数据。</p>
<p>● 2个引用对象指向同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br></pre></td></tr></table></figure>
<p>上述代码中，实现了将<code>obj1</code>的内容保存的<code>obj2</code>【<code>obj1</code>中保存的是地址值】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name) <span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// Bob</span></span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">age</span>:<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = &#123;<span class="attr">name</span>:<span class="string">&#x27;Bob&#x27;</span>,<span class="attr">age</span>:<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b.age,a.name,a.age); <span class="comment">// 12 Bob 13</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj = &#123;<span class="attr">age</span>:<span class="number">15</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fn2(a);</span><br><span class="line"><span class="built_in">console</span>.log(a.age); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>上述第二部分代码图示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220302084101.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228154520.png"></p>
<p>代码执行完毕之后，<code>age:15</code>会在哪里？<br>变量<code>obj</code>是函数的局部变量，在函数执行完毕之后，局部变量会被释放，一旦局部变量<code>obj</code>被释放，那么其指向的<code>age:15</code>就会被当作垃圾对象回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">&#x27;Lily&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn3(a);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Lily</span></span><br></pre></td></tr></table></figure>
<p>实际上只要是没有切断变量与堆内存中存储内容之间的执行，修改其中一个，其他都会跟着变。</p>
<h5 id="⭐-在JS调用函数时传递变量参数，是值传递还是引用传递？"><a href="#⭐-在JS调用函数时传递变量参数，是值传递还是引用传递？" class="headerlink" title="⭐ 在JS调用函数时传递变量参数，是值传递还是引用传递？"></a>⭐ 在JS调用函数时传递变量参数，是值传递还是引用传递？</h5><p>答案：</p>
<ul>
<li>理解1：都是值传递，值分为两种：基本值和地址值。</li>
<li>理解2：可能是值传递，也可能是引用传递（地址值）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(a);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220302091425.png"></p>
<h5 id="⭐-JS引擎如何管理内存？"><a href="#⭐-JS引擎如何管理内存？" class="headerlink" title="⭐ JS引擎如何管理内存？"></a>⭐ JS引擎如何管理内存？</h5><p>1.内存生命周期</p>
<ul>
<li>分配小内存空间，得到它的使用权</li>
<li>存储数据，可以反复进行操作</li>
<li>释放小内存空间</li>
</ul>
<p>2.释放内存</p>
<ul>
<li>局部变量：函数执行完自动释放</li>
<li>对象：成为垃圾对象，由垃圾回收器回收</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码中共使用几个内存空间？<br>3个内存空间。一个是栈内存a，存储数据3；一个是栈内存obj，存储数据{}（堆内存）的地址；另一个是堆内存中存储的{}。</p>
<hr>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码中共使用几个内存空间？<br>2个内存空间。一个是栈内存a，存储数据3；一个是栈内存obj，存储值为null。堆内存中存储的{}被回收。</p>
<hr>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p>上述代码中的b在函数<code>fn()</code>执行完毕之后会自动释放，而b指向的对象是在后面的某个时刻由垃圾回收器回收。</p>
<h3 id="1-3-对象"><a href="#1-3-对象" class="headerlink" title="1.3 对象"></a>1.3 对象</h3><h4 id="1-3-1-什么是对象？"><a href="#1-3-1-什么是对象？" class="headerlink" title="1.3.1 什么是对象？"></a>1.3.1 什么是对象？</h4><p>多个数据的封装体 或者 是用来保存多个数据的容器；<br>一个对象代表现实中的一个事物</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-为什么用对象？"><a href="#1-3-2-为什么用对象？" class="headerlink" title="1.3.2 为什么用对象？"></a>1.3.2 为什么用对象？</h4><p>统一管理多个数据</p>
<h4 id="1-3-3-对象的组成"><a href="#1-3-3-对象的组成" class="headerlink" title="1.3.3 对象的组成"></a>1.3.3 对象的组成</h4><p>属性 + 方法<br>♥ 属性：属性名（字符串）和属性值（任意类型）组成<br>♥ 方法：是一种特别的属性（属性值是函数）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">13</span>,</span><br><span class="line">  <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">setAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name, person.setName)</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220302110213.png"></p>
<h4 id="1-3-4-如何访问对象内部数据？"><a href="#1-3-4-如何访问对象内部数据？" class="headerlink" title="1.3.4 如何访问对象内部数据？"></a>1.3.4 如何访问对象内部数据？</h4><p>※ 第一种方式：<code>.属性名</code>，编码简单，有时不能用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.setName(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line">p.name;</span><br></pre></td></tr></table></figure>
<p>※ 第二种方式：<code>[&#39;属性名&#39;]</code>，编码麻烦，能通用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person[<span class="string">&#x27;setAge&#x27;</span>](<span class="number">23</span>);</span><br><span class="line">p[<span class="string">&#x27;age&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h5 id="⭐-什么情况下必须使用-39-属性名-39-的方式？"><a href="#⭐-什么情况下必须使用-39-属性名-39-的方式？" class="headerlink" title="⭐ 什么情况下必须使用[&#39;属性名&#39;]的方式？"></a>⭐ 什么情况下必须使用<code>[&#39;属性名&#39;]</code>的方式？</h5><p>1.属性名包含特殊字符：- 、空格<br>2.属性名不确定（属性名是个变量）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;&#125;</span><br><span class="line"><span class="number">1.</span>给p对象添加一个属性：content-type : text/json</span><br><span class="line">p.content-type = <span class="string">&#x27;text/json&#x27;</span>  <span class="comment">// 不能用</span></span><br><span class="line">p[<span class="string">&#x27;content-type&#x27;</span>] = <span class="string">&#x27;text/json&#x27;</span> <span class="comment">//可以使用</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>属性名不确定（属性名是个变量）</span><br><span class="line"><span class="keyword">var</span> propName = <span class="string">&#x27;myAge&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">18</span>;</span><br><span class="line">p.propName = value; <span class="comment">//不能用</span></span><br><span class="line">p[propName] = value; <span class="comment">//可以使用</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-函数"><a href="#1-4-函数" class="headerlink" title="1.4 函数"></a>1.4 函数</h3><h4 id="1-4-1-什么是函数？"><a href="#1-4-1-什么是函数？" class="headerlink" title="1.4.1 什么是函数？"></a>1.4.1 什么是函数？</h4><p>实现特定功能的n条语句的封装体<br>只有函数是可以执行的，其他类型的数据不能执行</p>
<h4 id="1-4-2-为什么要用函数？"><a href="#1-4-2-为什么要用函数？" class="headerlink" title="1.4.2 为什么要用函数？"></a>1.4.2 为什么要用函数？</h4><p>提高代码复用、便于阅读交流</p>
<h4 id="1-4-3-如何定义函数？"><a href="#1-4-3-如何定义函数？" class="headerlink" title="1.4.3 如何定义函数？"></a>1.4.3 如何定义函数？</h4><p>函数声明<br>表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>函数声明</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn1()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>表达式</span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn2()&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-4-如何调用（执行）函数？"><a href="#1-4-4-如何调用（执行）函数？" class="headerlink" title="1.4.4 如何调用（执行）函数？"></a>1.4.4 如何调用（执行）函数？</h4><p>直接调用：<code>test()</code><br>通过对象调用：<code>obj.test()</code><br>new调用：<code>new test()</code><br>临时让test成为obj的方法进行调用：<code>test.call(obj) </code>、<code> test.apply(obj)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.xx = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* obj.test(); <span class="comment">// 不能直接调用，因为obj中根本没有这个函数</span></span><br><span class="line"></span><br><span class="line">test.call(obj) <span class="comment">//可以让一个函数成为指定任意对象的方法进行调用</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.xx) <span class="comment">// Hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-4-4-回调函数"><a href="#1-4-4-回调函数" class="headerlink" title="1.4.4 回调函数"></a>1.4.4 回调函数</h4><h5 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a>什么是回调函数？</h5><p>3个特点：<br>1）自己定义的<br>2）没有调用<br>3）最终执行了（在某个时刻 或者 某个条件下）</p>
<h5 id="常见的回调函数"><a href="#常见的回调函数" class="headerlink" title="常见的回调函数"></a>常见的回调函数</h5><ul>
<li>dom事件的回调函数 ➡ this指的是发生事件的dom元素</li>
<li>定时器回调函数 ➡ this指的是window</li>
<li>ajax请求回调函数</li>
<li>生命周期回调函数</li>
</ul>
<h4 id="1-4-5-IIFE"><a href="#1-4-5-IIFE" class="headerlink" title="1.4.5 IIFE"></a>1.4.5 IIFE</h4><p>Immediately-Invoked Function Expression，立即调用函数表达式<br>匿名函数自调用 = IIFE<br>IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名函数自调用</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p><b> ♥ 作用：</b></p>
<ul>
<li>隐藏实现</li>
<li>不会污染外部（全局）命名空间</li>
<li>用它来编写js模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//向外暴露一个全局函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">test</span>: test</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">$().test() <span class="comment">// 1.$是一个函数 2.$执行后返回的是一个对象</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-6-函数中的this"><a href="#1-4-6-函数中的this" class="headerlink" title="1.4.6 函数中的this"></a>1.4.6 函数中的this</h4><h5 id="this-是什么？"><a href="#this-是什么？" class="headerlink" title="this 是什么？"></a>this 是什么？</h5><ul>
<li>任何函数本质上都是通过某个对象来调用的</li>
<li>所有函数内部都有一个变量this</li>
<li>它的值是调用函数的当前对象</li>
</ul>
<h5 id="如何确定this的值？"><a href="#如何确定this的值？" class="headerlink" title="如何确定this的值？"></a>如何确定this的值？</h5><ul>
<li><code>test()</code> ：window</li>
<li><code>p.test()</code> ：p</li>
<li><code>new test()</code> ：新创建的对象</li>
<li><code>p.call(obj)</code>：obj</li>
</ul>
<blockquote>
<ol>
<li>函数调用时，指向window </li>
<li>以方法调用时，指向调用该方法的对象 </li>
<li>使用new创建一个对象时，指向新创建的对象 </li>
<li>call,apply ,bind可以改变this指向，this指向指定的那个对象</li>
<li>在全局作用域中this代表window</li>
</ol>
</blockquote>
<h2 id="2-函数高级"><a href="#2-函数高级" class="headerlink" title="2.函数高级"></a>2.函数高级</h2><h3 id="2-1原型与原型链"><a href="#2-1原型与原型链" class="headerlink" title="2.1原型与原型链"></a>2.1原型与原型链</h3><h4 id="2-1-1-原型（prototype）"><a href="#2-1-1-原型（prototype）" class="headerlink" title="2.1.1 原型（prototype）"></a>2.1.1 原型（prototype）</h4><p><b>1.函数的<code>prototype</code>属性</b></p>
<ul>
<li>每个函数都有一个<code>prototype</code>属性，它默认指向一个<code>Object</code>空对象（即称为：原型对象）<blockquote>
<p>何为Object空对象？ 没有我们自己定义的属性</p>
</blockquote>
</li>
<li>原型对象中有一个属性<code>constructor </code>，它指向函数对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype.constructor === <span class="built_in">Date</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(fun.prototype.constructor === fun); <span class="comment">//true（fun为自定义函数）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220303112643.png"><br>⭐ 构造函数和它的原型对象是一个相互引用的关系。<br>解释相互引用：当前存在两个对象<code>A</code>和<code>B</code>，<code>A</code>当中有一个属性可以找到<code>B</code>，<code>B</code>当中有一个属性可以找到<code>A</code>。</p>
<p><b>2.给原型对象添加属性（这里的属性一般都是方法）</b><br>给原型对象添加属性（一般是方法）➡ 实例对象可以访问</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给原型对象添加属性（一般是方法）➡ 实例对象可以访问</span></span><br><span class="line">Fun.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;test方法&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> Fun();</span><br><span class="line">fun.test();<span class="comment">// test方法</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-显式原型与隐式原型"><a href="#2-1-2-显式原型与隐式原型" class="headerlink" title="2.1.2 显式原型与隐式原型"></a>2.1.2 显式原型与隐式原型</h4><ol>
<li>每个函数<code>function</code>都有一个<code>prototype</code>，即显式原型（属性）</li>
<li>每个实例对象都有一个<code>__proto__</code>，可称为隐式原型（属性）</li>
<li>对象的隐式原型的值为其对应构造函数的显式原型的值</li>
<li>总结：</li>
</ol>
<ul>
<li>函数的<code>prototype</code>属性：在定义函数时自动添加的，默认为一个空Object对象</li>
<li>对象的<code>__proto__</code>属性：在创建对象时自动添加的，默认值为构造函数的<code>prototype</code>属性值</li>
<li>程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 内部语句：this.prototype = &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 每个函数function都有一个prototype，即显式原型（属性），默认指向一个空Object对象</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.每个实例对象都有一个__proto__，可称为隐式原型（属性）</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn(); <span class="comment">// 内部语句：this.__proto__ = Fn.prototype;</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.__proto__);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.对象的隐式原型的值为其对应构造函数的显式原型的值</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype === fn.__proto__) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给原型添加方法</span></span><br><span class="line">Fn.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过实例对象调用原型的方法</span></span><br><span class="line">fn.test()</span><br></pre></td></tr></table></figure>
<p>上述代码内存结构图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220304121321.png"></p>
<h4 id="2-1-3-原型链"><a href="#2-1-3-原型链" class="headerlink" title="2.1.3 原型链"></a>2.1.3 原型链</h4><p>访问一个对象的属性时：</p>
<ul>
<li>先在自身属性中查找，如果找到则返回</li>
<li>如果未找到，再沿着<code>__proto__</code>这条链向上查找，找到返回</li>
<li>如果最终没有找到，返回<code>undefined</code></li>
</ul>
<p>原型链的别名是隐式原型链。<br>原型链的作用：查找对象的属性（方法），只是用来查找，如果是一些赋值操作等，则不会查找原型链。</p>
<p><b style="background:#f8df70">原型链的本质是隐式原型链。</b><br>原型链的尽头是<code>Object的原型对象</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.test1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test1()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype);</span><br><span class="line">Fn.prototype.test2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;test2()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn()</span><br><span class="line"></span><br><span class="line">fn.test1(); <span class="comment">// test1()</span></span><br><span class="line">fn.test2(); <span class="comment">// test2()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn.toString()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.test3); <span class="comment">// undefined</span></span><br><span class="line">fn.test3(); <span class="comment">//  &quot;TypeError: fn.test3 is not a function</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220305205820.png"><br>原型链的尽头是<code>Object的原型对象</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220305214943.png"><br>创建两个实例对象，实例对象有隐式原型属性<code>__proto__</code>，这个隐式原型属性指向的是Object的原型对象，（隐式原型属性<code>__proto__</code>的值是将<code>prototype</code>的值赋给它得到的）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220306140152.png"></p>
<ul>
<li><p>所有函数的<code>__proto__</code>都是一样的，都是通过<code>new Function()</code>产生的</p>
</li>
<li><p>任何函数都是通过<code>new Function()</code>产生的.因此，所有函数对象的隐式原型都指向<code>Function.prototype</code></p>
</li>
<li><p>实例对象的隐式原型属性等于构造函数的显示原型属性</p>
</li>
</ul>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li><p>函数的显式原型指向的对象：默认是空Object实例对象【但是Object不满足】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.test1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test1()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307084657.png"><br>( 😀 因此，上图中存在绿色部分)</p>
</li>
<li><p>所有函数都是Function的实例，包括Function它自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>Object 的原型对象是原型链的尽头</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="原型链的属性问题"><a href="#原型链的属性问题" class="headerlink" title="原型链的属性问题"></a>原型链的属性问题</h4><ul>
<li>读取对象属性值时：会自动到原型链中查找</li>
<li>设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加属性并设置其值</li>
<li>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</li>
</ul>
<p>※ <i style = "background:#a7ed3d">原型链是用来查找属性的，当为一个对象添加属性时，不会看原型链</i></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.a = <span class="string">&#x27;AAA&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(fn1.a); <span class="comment">// AAA</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> Fn();</span><br><span class="line">fn2.a = <span class="string">&#x27;BBB&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fn1.a, fn2.a); <span class="comment">// AAA BBB</span></span><br></pre></td></tr></table></figure>
<p>此时<code>fn1</code>的内容为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307101504.png"><br>⭐ 查找<code>fn1</code>的<code>a</code>属性值时，发现<code>fn1</code>本身没有属性<code>a</code>，所以会自动到原型链中查找属性<code>a</code>。</p>
<p>此时<code>fn2</code>的内容为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307101627.png"><br>⭐ 查找<code>fn2</code>的<code>a</code>属性值时，发现<code>fn2</code>本身有属性<code>a</code>，所以直接输出该属性值，不再去查找原型链，但是原型链中实际上仍存在属性<code>a</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line">p1.setName(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br></pre></td></tr></table></figure>
<p>⭐ 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Lily&#x27;</span>, <span class="number">13</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__ === p2.__proto__) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>⭐ 实例对象的隐式原型等于构造函数的显式原型</p>
<h4 id="2-1-4-instanceof"><a href="#2-1-4-instanceof" class="headerlink" title="2.1.4 instanceof"></a>2.1.4 instanceof</h4><p>instanceof 作用：<code>a instanceof b</code> → 判断<code>a</code>是否是<code>b</code>的实例【其中，a是实例对象，b是构造函数】</p>
<ul>
<li>instanceof 是如何判断的？<br>表达式：<code>A instanceof B</code><br>如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307113311.png"></p>
<hr>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> Foo); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E6%97%A0%E6%A0%87%E9%A2%98.png"></p>
<h4 id="2-1-5-面试题"><a href="#2-1-5-面试题" class="headerlink" title="2.1.5 面试题"></a>2.1.5 面试题</h4><p><b>题目1</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">A.prototype.n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">A.prototype = &#123; <span class="comment">//这步操作直接改变了原型对象</span></span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> A()</span><br><span class="line"><span class="built_in">console</span>.log(b.n, b.m, c.n, c.m);<span class="comment">// 1 undefined  2 3</span></span><br></pre></td></tr></table></figure>

<p>上述代码在内存中的示意图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220308130123.png"><br>（<em>最开始是是红色指示线，后来变为蓝色指示线</em>）</p>
<p>两种表达方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">表达方式<span class="number">1</span>：</span><br><span class="line">B.prototype.n = <span class="number">1</span>;</span><br><span class="line">表达方式<span class="number">2</span>：</span><br><span class="line">B.prototype = &#123; </span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中表达方式1会影响原有的实例对象，因为表达方式1是在原有的实例对象上添加到。<br>表达方式2不会影响原有的实例对象，因为表达方式2直接改变了实例对象原型。</p>
<p>对于代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">A.prototype = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的理解：现在堆内存中创建对象<code>&#123;n:2,m:3&#125;</code>，然后改变<code>A.prototype</code>的指向。（<em>蓝色指示线部分</em>）</p>
<p><b>题目2</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> F();</span><br><span class="line">fn.a(); <span class="comment">// a()</span></span><br><span class="line">fn.b(); <span class="comment">// TypeError: fn.b is not a function</span></span><br><span class="line">F.a(); <span class="comment">// a()</span></span><br><span class="line">F.b(); <span class="comment">// b()</span></span><br></pre></td></tr></table></figure>

<h4 id="原型链一张图"><a href="#原型链一张图" class="headerlink" title="原型链一张图"></a>原型链一张图</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg"></p>
<p><b>实记口诀：</b></p>
<ol>
<li>函数都是<code>Function</code>构造出来的</li>
<li>一切函数都是对象，只要是函数对象，就会有原型<code>prototype</code>和隐式原型<code>__proto__</code>两个属性</li>
<li>普通对象身上只有<code>__proto__</code>，没有<code>prototype</code></li>
<li>实例化对象的<code>__proto__</code>都指向构造函数的<code>prototype</code></li>
<li>所有函数的<code>prototype</code>都指向自身的<code>prototype</code></li>
<li>所有的<code>prototype</code>的<code>__proto__</code>都指向<code>Object.prototype</code>（Object除外）</li>
<li>所有函数对象的<code>__proto__</code>都指向<code>Function.prototype</code>（包括Function自身）</li>
<li>所有对象身上都有<code>constructor</code>指向函数自身</li>
</ol>
<h3 id="2-2执行上下文与执行上下文栈"><a href="#2-2执行上下文与执行上下文栈" class="headerlink" title="2.2执行上下文与执行上下文栈"></a>2.2执行上下文与执行上下文栈</h3><h4 id="2-2-1-变量提升与函数提升"><a href="#2-2-1-变量提升与函数提升" class="headerlink" title="2.2.1 变量提升与函数提升"></a>2.2.1 变量提升与函数提升</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题：程序最终输出什么？</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上述代码的实际执行过程是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//undefined   </span></span><br><span class="line">fn2(); <span class="comment">// fn2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn2&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在执行<code>console.log</code>时，变量<code>b</code>和函数<code>fn2</code>均未提前声明，但是仍然可以执行。原因是变量<code>b</code>进行了变量提升，函数<code>fn2</code>进行了函数提升。</p>
<ol>
<li>变量（声明）提升<br>通过<code>var</code>定义（声明）的变量，在定义语句之前就可以访问到，值为<code>undefined</code></li>
<li>函数（声明）提升<br>通过<code>function</code>声明的函数，在之前就可以直接调用，值为函数定义。<br>函数提升必须使用声明的方式。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn2&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309091249.png"></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn3); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn3&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码遵循的是变量提升。</p>
<h4 id="2-2-2-执行上下文"><a href="#2-2-2-执行上下文" class="headerlink" title="2.2.2 执行上下文"></a>2.2.2 执行上下文</h4><p><b>1.代码分类</b><br>全局代码 和 函数（局部）代码</p>
<p><b>2.全局执行上下文</b><br>在执行全局代码前将<code>window</code>确定为全局执行上下文。</p>
<p>对全局数据进行预处理:</p>
<ul>
<li><code>var</code>定义的全局变量 → <code>undefined</code>，添加为<code>window</code>的属性</li>
<li><code>function</code>声明的全局函数 → 赋值（<code>fun</code>）,添加为<code>window</code>的方法</li>
<li><code>this</code> → 赋值（<code>var</code>）</li>
</ul>
<p>–上述过程是在全局代码执行之前就会进行的操作</p>
<ul>
<li>执行全局代码</li>
</ul>
<p><b>3.函数执行上下文</b><br>在调用函数时，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈中）</p>
<p>对局部数据进行预处理：</p>
<ul>
<li>形参变量 → 赋值（实参） → 添加为执行上下文的属性</li>
<li><code>arguments</code> → 赋值（实参列表），添加为执行上下文的属性</li>
<li><code>var</code>定义的局部变量 → undefined，添加为执行上下文的属性</li>
<li><code>function</code>声明的函数 → 赋值（fun），添加为执行上下文的方法</li>
<li><code>this</code> → 赋值（调用函数的对象）</li>
</ul>
<p>开始执行函数体代码</p>
<h4 id="2-2-3-执行上下文栈"><a href="#2-2-3-执行上下文栈" class="headerlink" title="2.2.3 执行上下文栈"></a>2.2.3 执行上下文栈</h4><ol>
<li>在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象</li>
<li>在全局执行上下文（window）确定后，将其添加到栈中（压栈）</li>
<li>在函数执行上下文创建后，将其添加到栈中（压栈）</li>
<li>在当前函数执行完成后，将栈顶的对象移除（出栈）</li>
<li>当所有的代码执行完后，栈中只剩下window</li>
</ol>
<p><span style="background-color:#f9c116"> 处于活动状态的执行上下文环境只有一个。</span><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309154025.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.进入全局执行上下文</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  fn(x + b);<span class="comment">// 3. 进入foo执行上下文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a + c + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(<span class="number">10</span>);<span class="comment">// 2.进入bar函数执行上下文</span></span><br></pre></td></tr></table></figure>
<p>上述代码结果为30。</p>
<p>执行上下文栈结构图如下所示：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309153021.png"></p>
<p>栈的底部始终是<code>window</code>，因为第一个产生的是<code>window</code>，要放入栈中进行管理。<br>执行上下文个数遵循 <code>n + 1</code>的原则，其中<code>n</code>指的是调用函数的次数，<code>1</code>指的是<code>window</code>。</p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p><b>⭐ 1.依次输出什么？整个过程中产生了几个执行上下文？</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;global begin:&#x27;</span> + i);</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo begin:&#x27;</span> + i);</span><br><span class="line">  foo(i + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo end:&#x27;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;global end:&#x27;</span> + i);</span><br></pre></td></tr></table></figure>
<p>依次输出的结果：</p>
<blockquote>
<p>global begin:undefidned<br>foo begin:1<br>foo begin:2<br>foo begin:3<br>foo end:3<br>foo end:2<br>foo end:1<br>global end:1</p>
</blockquote>
<p>整个过程中产生了5个执行上下文。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309163434.png"></p>
<p><b>⭐ 2.函数提升与变量提升顺序</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上述代码先执行函数提升，再执行变量提升，但是变量未进行赋值操作，所以是function。<br>具体参考：<a href="https://qw-null.github.io/2022/03/09/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/">变量提升和函数提升的优先级问题</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(b <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>); <span class="comment">// TypeError: c is not a function</span></span><br></pre></td></tr></table></figure>
<p>上述代码相当于：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220311102431.png"></p>
<h3 id="2-3作用域与作用域链"><a href="#2-3作用域与作用域链" class="headerlink" title="2.3作用域与作用域链"></a>2.3作用域与作用域链</h3><h4 id="2-3-1-作用域"><a href="#2-3-1-作用域" class="headerlink" title="2.3.1 作用域"></a>2.3.1 作用域</h4><ol>
<li>理解<br>作用域就像是一块“地盘”，一个代码所在的区域。它是静态的（相对于 执行上下文对象 而言，因为执行上下文对象只有代码执行时才会产生），在编写代码时就确定了。</li>
<li>分类<br>全局作用域、函数作用域、块级作用域（ES6出现）</li>
<li>作用<br>隔离变量，不同作用域下同名变量不会有冲突</li>
<li>作用域个数<br>作用域个数遵循<code>n + 1</code>的原则（与执行上下文相同），其中<code>n</code>指的是定义的函数的个数，<code>1</code>指的是全局作用域。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220314203108.png"><br>结果为：<br>fn() 100 20 300 10<br>bar() 1000 20 300 400 100<br>bar() 1000 20 300 400 200</p>
<h4 id="2-3-2-作用域与执行上下文"><a href="#2-3-2-作用域与执行上下文" class="headerlink" title="2.3.2 作用域与执行上下文"></a>2.3.2 作用域与执行上下文</h4><ol>
<li>区别：<br>⭐全局作用域之外，每个函数都会创建自己的作用域。作用域在函数定义时就已经确定了，而不是在函数调用时。全局执行上下文环境是在全局作用域确定之后，JS代码马上执行之前创建；函数执行上下文环境是在调用函数时，函数代码执行之前创建。<br>⭐作用域是静态的，只要函数定义好了就一直存在，且不会再变化。执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放。</li>
<li>联系<br>执行上下文（对象）是从属于所作用域。全局上下文环境 → 全局作用域；函数上下文环境 → 对应的函数作用域。</li>
</ol>
<h4 id="2-3-3-作用域链"><a href="#2-3-3-作用域链" class="headerlink" title="2.3.3 作用域链"></a>2.3.3 作用域链</h4><ol>
<li>理解<br>多个上下级关系的作用域形成的链，它的方向是从下向上（从内到外）；查找变量时就是沿着作用域链来查找的</li>
<li>查找一个变量的查找规则<br>① 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入②；<br>② 在上一级作用域的执行上下文中查找对应的属性，如果有直接返回，否则进入③；<br>③ 在执行②的相同操作，直到全局作用域，如果还找不到就排除找不到的异常。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">  &#125;</span><br><span class="line">  fn2()</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220314230130.png"></p>
<h4 id="2-3-4-面试题"><a href="#2-3-4-面试题" class="headerlink" title="2.3.4 面试题"></a>2.3.4 面试题</h4><p>⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line">show(fn); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315140359.png"><br>执行函数<code>fn()</code>时，会先在<code>fn</code>的作用域中查找<code>x</code>，没有找到后会跳到其外部的作用域中继续寻找，<code>fn</code>的作用域和<code>show</code>的作用域是同级的不会相互查找。<br>⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">fn2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fn2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn2();</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315142215.png"><br>报错的原因是<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315142435.png"><br>在函数作用域中查找不到<code>fn2</code>，会到全局作用域中继续查找，在全局作用域中不存在<code>fn2</code>。<br>※ 如果想要调用<code>fn2</code>，应该修改代码为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">fn2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.fn2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn2(); <span class="comment">// 结果为打印fn2</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4闭包"><a href="#2-4闭包" class="headerlink" title="2.4闭包"></a>2.4闭包</h3><ol>
<li><p>如何产生闭包？<br>当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包。</p>
</li>
<li><p>闭包是什么？<br>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<blockquote>
<p>使用chrome调试查看：<br>※ 理解一：闭包是嵌套的内部函数（该函数中引用了外部函数的变量）<br>※ 理解二：包含被引用变量（函数）的对象<br><b>注意：</b>闭包存在于嵌套的内部函数中</p>
</blockquote>
</li>
<li><p>产生闭包的条件？</p>
</li>
</ol>
<ul>
<li>函数嵌套</li>
<li>内部函数引用了外部函数的数据（变量 \ 函数）</li>
<li>执行了外部函数</li>
</ul>
<h4 id="2-4-1-常见的闭包"><a href="#2-4-1-常见的闭包" class="headerlink" title="2.4.1 常见的闭包"></a>2.4.1 常见的闭包</h4><ol>
<li>将函数作为另一个函数的返回值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn1();</span><br><span class="line"><span class="built_in">console</span>.log(f);</span><br></pre></td></tr></table></figure>
结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315154451.png"><br>上述过程中<b>创建了1个闭包</b>。通过代码<code>fn1()</code>产生。<br>再执行下列代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f(); <span class="comment">// 3</span></span><br><span class="line">f(); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li>
<li>将函数作为实参传递给另一个函数调用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDelay</span> (<span class="params">msg, time</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg)</span><br><span class="line">  &#125;, time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showDelay(<span class="string">&#x27;延迟输出&#x27;</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
上述代码在执行过程中产生了闭包。因为<br>嵌套的内部函数引用了外部函数的变量<code>msg</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315160727.png"><br>若将代码修改如下，就不会产生闭包<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDelay</span> (<span class="params">msg, time</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;无闭包产生&#x27;</span>)；</span><br><span class="line">  &#125;, time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showDelay(<span class="string">&#x27;延迟输出&#x27;</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-4-2-闭包的作用"><a href="#2-4-2-闭包的作用" class="headerlink" title="2.4.2 闭包的作用"></a>2.4.2 闭包的作用</h4><ol>
<li><p>使得函数内部的变量在函数执行完后，仍存活在内存中（延长了局部变量的生命周期）</p>
</li>
<li><p>让函数外部可以操作（读写）到函数内部的数据（变量/函数）</p>
</li>
</ol>
<p>问题：<br><b>※ 1. 函数执行完后，函数内部声明的局部变量是否还在？</b><br>一般是不存在，存在于闭包中的变量才可能存在</p>
<p><b>※ 2. 在函数外部能直接访问函数内部的局部变量吗？</b><br>不能，但是通过闭包可以让外部操作它</p>
<h4 id="2-4-3-闭包的生命周期"><a href="#2-4-3-闭包的生命周期" class="headerlink" title="2.4.3 闭包的生命周期"></a>2.4.3 闭包的生命周期</h4><ol>
<li>产生：在嵌套内部函数定义执行完时就产生了（不是在调用时）</li>
<li>死亡：在嵌套的内部函数成为垃圾对象时 </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此时闭包就已经产生了（函数提升，内部函数对象已经创建了）</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = fn1();</span><br><span class="line">f(); <span class="comment">// 3</span></span><br><span class="line">f(); <span class="comment">// 4</span></span><br><span class="line">f = <span class="literal">null</span>;<span class="comment">// 闭包死亡（包含必报的函数对象成为垃圾对象）</span></span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-闭包的应用：定义JS模块"><a href="#2-4-3-闭包的应用：定义JS模块" class="headerlink" title="2.4.3 闭包的应用：定义JS模块"></a>2.4.3 闭包的应用：定义JS模块</h4><p>JS模块是具有特定功能的JS文件，将所有的数据和功能都封装在一个函数内部（私有的），只向外暴露一个包含n个方法的对象或者函数，模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能。</p>
<p><b>※ 方式一</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myModule</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&quot;My module&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 操作数据的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doSomething()&#x27;</span>, msg.toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doOtherthing()&#x27;</span>, msg.toLowerCase());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露对象（给外部使用的方法）</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>※ 方式二</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&quot;My module&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 操作数据的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doSomething()&#x27;</span>, msg.toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doOtherthing()&#x27;</span>, msg.toLowerCase());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露对象（给外部使用的方法）</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h4 id="2-4-4-闭包的缺点及解决"><a href="#2-4-4-闭包的缺点及解决" class="headerlink" title="2.4.4 闭包的缺点及解决"></a>2.4.4 闭包的缺点及解决</h4><ol>
<li>缺点：<br>■ 函数执行完后，函数内的局部变量没有释放，占用内存时间会变长<br>■ 容易造成内存泄漏 【内存泄漏：内存占用却不使用】</li>
<li>解决：<br>■ 能不用闭包就不用<br>■ 及时释放</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>[<span class="number">100000</span>];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = fn1();</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">f = <span class="literal">null</span>;<span class="comment">// 让内部函数成为垃圾对象 --&gt; 回收闭包</span></span><br></pre></td></tr></table></figure>
<p>补充知识点：<a href="https://qw-null.github.io/2022/03/20/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">内存溢出与内存泄漏</a></p>
<h4 id="2-4-5-面试题"><a href="#2-4-5-面试题" class="headerlink" title="2.4.5 面试题"></a>2.4.5 面试题</h4><p><b>⭐ 题目 1</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;This Window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());</span><br></pre></td></tr></table></figure>
<p>输出的结果为<code>This Window</code>，原因是函数调用时，<code>this</code>指向<code>window</code>，因此<code>this.name</code>指的是全局变量<code>name</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;This Window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());</span><br></pre></td></tr></table></figure>
<p>输出的结果为<code>My Object</code>，原因是<code>this</code>是在对象<code>object</code>的方法<code>getNameFunc</code>中进行调用的，以方法调用时，<code>this</code>指向调用该方法的对象，因此<code>that.name</code>相当于<code>object.name</code>。</p>
<p><b>⭐ 题目 2</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">n, o</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">fun</span>: <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fun(m, n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>); <span class="comment">// undefidned</span></span><br><span class="line">a.fun(<span class="number">1</span>); a.fun(<span class="number">2</span>); a.fun(<span class="number">3</span>);<span class="comment">// ? ? ?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>);<span class="comment">// undefined ? ? ?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);<span class="comment">// undefined ?</span></span><br><span class="line">c.fun(<span class="number">2</span>); c.fun(<span class="number">3</span>);<span class="comment">// ? ?</span></span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefidned 0 0 0</span><br><span class="line">undefidned 0 1 2</span><br><span class="line">undefidned 0 1 1</span><br></pre></td></tr></table></figure>




<h2 id="3-面向对象高级"><a href="#3-面向对象高级" class="headerlink" title="3.面向对象高级"></a>3.面向对象高级</h2><h3 id="3-1-对象创建模式"><a href="#3-1-对象创建模式" class="headerlink" title="3.1 对象创建模式"></a>3.1 对象创建模式</h3><p>⭐ 方式一：Object构造函数模式</p>
<ul>
<li>套路：先创建空<code>Object</code>对象，再动态添加属性/方法</li>
<li>使用场景：起始时不确定对象内部数据</li>
<li>问题：语句太多</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个人：name:&quot;Tom&quot;,age:12</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">p.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">p.age = <span class="number">12</span>;</span><br><span class="line">p.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">p.setName(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure>
<p>结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220321112724.png"></p>
<p>⭐ 方式二：对象字面量模式</p>
<ul>
<li>套路：使用{}创建对象，同时指定属性/方法</li>
<li>使用场景：起始时对象内部数据是确定的</li>
<li>问题：如果创建多个对象，有重复代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个人：name:&quot;Tom&quot;,age:12</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">p.setName(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.name, p.age); <span class="comment">// Jack 12</span></span><br></pre></td></tr></table></figure>

<p>⭐ 方式三：工厂模式</p>
<ul>
<li>套路：通过工厂函数动态创建对象并返回</li>
<li>适用场景：需要创建多个对象</li>
<li>问题：对象没有一个具体的类型，都是object类型</li>
</ul>
<p>※ 何为工厂函数？  —— 返回一个对象的函数成为工厂函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">age</span>: age,</span><br><span class="line">    <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建2个人</span></span><br><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">&#x27;Jack&#x27;</span>,<span class="number">14</span>);</span><br></pre></td></tr></table></figure>

<p>⭐ 方式四：自定义构造函数模式</p>
<ul>
<li>套路：自定义构造函数，通过new创建对象</li>
<li>适用场景：需要创建多个类型确定的对象</li>
<li>问题：每个对象都有相同的数据，浪费内存</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">p1.setName(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但是此种方式创建的对象，每个对象中都包含<code>setName</code>方法，占用内存。</p>
<p>⭐ 方式五：构造函数+原型的组合模式</p>
<ul>
<li>套路：自定义构造函数，属性在函数中初始化，方法添加到原型上</li>
<li>适用场景：需要创建多个类型确定的对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在构造函数中，只初始化一般属性</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">13</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1, p2)</span><br></pre></td></tr></table></figure>
结果为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220321135956.png"></li>
</ul>
<h3 id="3-2-原型链继承"><a href="#3-2-原型链继承" class="headerlink" title="3.2 原型链继承"></a>3.2 原型链继承</h3><h4 id="3-2-1-方式一：-原型链继承"><a href="#3-2-1-方式一：-原型链继承" class="headerlink" title="3.2.1 方式一： 原型链继承"></a>3.2.1 方式一： 原型链继承</h4><p>过程如下：</p>
<ol>
<li>定义父类型构造函数</li>
<li>给父类型的原型添加方法</li>
<li>定义子类型的构造函数</li>
<li>创建父类型的对象赋值给子类型的原型</li>
<li>将子类型原型的构造属性设置为子类型</li>
<li>给子类型原型添加方法</li>
<li>创建子类型的对象：可以调用父类型的方法</li>
</ol>
<p><b>⭐ 关键点：子类型的原型为父类型的一个实例对象</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定义父类型构造函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Supper</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.supProp = <span class="string">&#x27;Supper Property&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> 给父类型的原型添加方法</span><br><span class="line">Supper.prototype.showSupperProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.supProp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 定义子类型的构造函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subProp = <span class="string">&#x27;Sub Property&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型的原型为父类型的一个实例对象</span></span><br><span class="line"><span class="number">4.</span> 创建父类型的对象赋值给子类型的原型</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Supper();</span><br><span class="line"><span class="number">5.</span> 将子类型原型的构造属性设置为子类型</span><br><span class="line">Sub.prototype.constructor = Sub</span><br><span class="line"><span class="number">6.</span> 给子类型原型添加方法</span><br><span class="line">Sub.prototype.showSubProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.subProp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 创建子类型的对象：可以调用父类型的方法</span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line">sub.showSupperProp();</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220321171328.png"></p>
<h4 id="3-2-2-方式二：-借用构造函数继承（假的）"><a href="#3-2-2-方式二：-借用构造函数继承（假的）" class="headerlink" title="3.2.2 方式二： 借用构造函数继承（假的）"></a>3.2.2 方式二： 借用构造函数继承（假的）</h4><p>过程如下：</p>
<ol>
<li>定义父类型构造函数</li>
<li>定义子类型构造函数</li>
<li>在子类型构造函数中调用父类型构造</li>
</ol>
<p><b>⭐ 关键点：在子类型构造函数中通过<code>call()</code>调用父类型构造函数</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定义父类型构造函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 定义子类型构造函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  <span class="number">3.</span> 在子类型构造函数中调用父类型构造</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age); <span class="comment">//相当于 this.Person(name,age)</span></span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>, <span class="number">13000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<p>结果为：<code>Student &#123; name: &#39;Tom&#39;, age: 12, price: 13000 &#125;</code></p>
<h4 id="3-2-3-方式三：-组合继承（原型链-借用构造函数）"><a href="#3-2-3-方式三：-组合继承（原型链-借用构造函数）" class="headerlink" title="3.2.3 方式三： 组合继承（原型链 + 借用构造函数）"></a>3.2.3 方式三： 组合继承（原型链 + 借用构造函数）</h4><p>过程如下： </p>
<ol>
<li>利用原型链实现对父类型对象的方法继承</li>
<li>利用<code>call()</code>借用父类型构造函数初始化相同属性</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age); <span class="comment">// 为了得到属性</span></span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person(); <span class="comment">// 为了能看到父类型的方法</span></span><br><span class="line">Student.prototype.constructor = Student; <span class="comment">// 修正constructor属性</span></span><br><span class="line">Student.prototype.setPrice = <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>, <span class="number">13000</span>);</span><br><span class="line">s.setName(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">s.setPrice(<span class="number">15000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<p>结果为<code>Student &#123; name: &#39;Jack&#39;, age: 12, price: 15000 &#125;</code></p>
<h4 id="3-2-4-补充：new一个对象背后做了什么？"><a href="#3-2-4-补充：new一个对象背后做了什么？" class="headerlink" title="3.2.4 补充：new一个对象背后做了什么？"></a>3.2.4 补充：new一个对象背后做了什么？</h4><ul>
<li>创建一个空对象</li>
<li>给对象设置<code>__proto__</code>，值为构造函数对象的<code>prototype</code>属性值</li>
<li>执行构造函数体（给对象添加属性 / 方法）</li>
</ul>
<h2 id="4-线程机制与事件机制"><a href="#4-线程机制与事件机制" class="headerlink" title="4.线程机制与事件机制"></a>4.线程机制与事件机制</h2><h3 id="4-1-进程与线程"><a href="#4-1-进程与线程" class="headerlink" title="4.1 进程与线程"></a>4.1 进程与线程</h3><p><b>进程（process）：</b>程序的一次执行，它占有一片独有的内存空间。可以通过window任务管理器查看进程。<br><b>线程（thread）：</b>线程是进程内一个独立执行的单元，是程序执行的一个完整流程，是CPU的最小的调度单元。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220322145958.png"><br>如果一个程序有2个进程，每个进程包含1个线程，则该程序是单线程程序。</p>
<p>⭐ 相关知识：</p>
<ol>
<li>应用程序必须运行在某个进程的某个线程上</li>
<li>一个进程至少有一个运行的线程：主线程（线程启动后自动创建）</li>
<li>一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的</li>
<li>一个进程内的数据可以供其中的多个线程直接共享</li>
<li>多个进程之间的数据是不能直接共享的</li>
<li>线程池（thread pool）：保存多个线程对象的容器，实现线程对象的反复利用</li>
</ol>
<p>⭐ 相关问题：</p>
<ol>
<li>何为多进程与多线程？<br>多进程运行：一个应用程序可以启动多个实例运行<br>多线程：在一个进程内，同时有多个线程运行</li>
<li>比较单线程与多线程？<br>多线程：【优点】能有效提升CPU的利用率 【缺点】创建多线程开销，线程间切换开销，死锁与状态同步问题<br>单线程：【优点】顺序变成简单易懂 【缺点】效率低</li>
<li>JS是单线程还是多线程？<br>JS是单线程运行的。但使用H5中的Web Workers可以多线程运行。</li>
<li>浏览器运行是单线程还是多线程？<br>浏览器运行是多线程。</li>
<li>浏览器运行是单进程还是多进程？<br>有单进程也有多进程。其中，单进程：firefox、老版IE，多进程：chrome、Edge。<h3 id="4-2-浏览器内核"><a href="#4-2-浏览器内核" class="headerlink" title="4.2 浏览器内核"></a>4.2 浏览器内核</h3></li>
</ol>
<table>
<thead>
<tr>
<th>浏览器名称</th>
<th>内核</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome、Safari</td>
<td>webkit</td>
</tr>
<tr>
<td>firefox</td>
<td>Gecko</td>
</tr>
<tr>
<td>IE</td>
<td>Trident</td>
</tr>
<tr>
<td>360，搜狗等国内浏览器</td>
<td>Trident + webkit</td>
</tr>
</tbody></table>
<p>浏览器内核由很多模块组成，其中包括：</p>
<ul>
<li>js引擎模块：负责js程序的编译与运行</li>
<li>html，css文档解析模块：负责页面文本解析</li>
<li>DOM/CSS模块：负责dom/css在内存中的相关处理</li>
<li>布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）</li>
</ul>
<p><b>【上述部分运行在主线程】</b></p>
<ul>
<li>……</li>
<li>定时器模块：负责定时器的管理</li>
<li>DOM事件响应模块：负责事件管理</li>
<li>网络请求模块：负责ajax请求</li>
</ul>
<p><b>【上述部分运行在分线程】</b></p>
<h3 id="4-3-定时器引发的思考"><a href="#4-3-定时器引发的思考" class="headerlink" title="4.3 定时器引发的思考"></a>4.3 定时器引发的思考</h3><p>相关问题：</p>
<ol>
<li>定时器真的是定时执行的吗？<br>定时器并不能保证真正定时执行，一般会延迟一丁点（可以接受），也可能延迟很长时间（不能接收）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;启动定时器前……&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;定时器执行了&#x27;</span>, <span class="built_in">Date</span>.now() - start);</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
多次执行结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324103330.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324103357.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324103437.png"></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;启动定时器前……&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;定时器执行了&#x27;</span>, <span class="built_in">Date</span>.now() - start);</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多次执行结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324110425.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324110514.png"></p>
<ol start="2">
<li><p>定时器回调函数是在哪个线程执行的？<br>在主线程执行（JS是单线程的）</p>
</li>
<li><p>定时器是如何实现的？<br>事件循环模型（详情见后续内容）</p>
</li>
</ol>
<h3 id="4-4-JS是单线程执行的"><a href="#4-4-JS是单线程执行的" class="headerlink" title="4.4 JS是单线程执行的"></a>4.4 JS是单线程执行的</h3><ol>
<li>如何证明JS执行是单线程的？<br>setTimeout()的回调函数是在主线程执行的<br>定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 2000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 1000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn函数执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
执行结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324113636.png"></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 2000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 1000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn函数执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;alert之前&#x27;</span>);</span><br><span class="line">alert(<span class="string">&#x27;---------&#x27;</span>); <span class="comment">// 暂停当前主线程的执行，同时暂停计时，点击确定之后，恢复程序的执行和计时</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;alert之后&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324114233.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324114309.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324114353.png"></p>
<ol start="2">
<li><p>为什么JS要用单线程模式，而不用多线程模式？<br>Javascript的单线程与它的用途有关，作为浏览器脚本语言，Javascript的主要用途是与用户互动以及操作DOM，这决定了它只能是单线程的，负责会带来很复杂的同步问题。</p>
</li>
<li><p>代码分类</p>
</li>
</ol>
<ul>
<li>初始化代码</li>
<li>回调代码</li>
</ul>
<ol start="4">
<li>JS引擎执行代码的基本流程<br>先执行初始化代码【包含一些特别的代码：设置定时器、绑定监听、发送ajax请求】，后面的某一个时刻才会执行回调代码</li>
</ol>
<blockquote>
<p>其中，设置定时器指的是setTimeout(),不包括内部的回调函数，其内部的回调函数需要在初始化代码执行完毕之后再执行</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 2000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 1000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 0&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn函数执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;alert之前&#x27;</span>);</span><br><span class="line">alert(<span class="string">&#x27;---------&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;alert之后&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>最终结果执行顺序：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324143955.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324144022.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324144050.png"></p>
<h3 id="4-5-事件循环（轮询）模型"><a href="#4-5-事件循环（轮询）模型" class="headerlink" title="4.5 事件循环（轮询）模型"></a>4.5 事件循环（轮询）模型</h3><h4 id="4-5-1-模型原型图"><a href="#4-5-1-模型原型图" class="headerlink" title="4.5.1 模型原型图"></a>4.5.1 模型原型图</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/2356897452565.png"><br>对于JS代码可以分为两类：</p>
<ol>
<li>初始化执行代码（同步代码）：包含绑定dom事件监听，设置定时器，发送ajax请求的代码</li>
<li>回调执行代码（异步代码）：处理回调逻辑</li>
</ol>
<p><b>JS引擎执行代码的基本流程：</b>初始化代码 ➡ 回调代码</p>
<p><b>模型的两个重要组成部分：</b>事件管理模块、回调队列</p>
<p><b>🍎 模型的运转流程：</b>执行初始化代码，将事件回调函数交给对应模块管理 ➡ 当事件发生时，管理模块会将回调函数及其数据添加到回调队列中 ➡ 只有当初始化代码执行完成后（可能需要一段时间），才会遍历读取回调队列中的回调函数执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;执行fn1()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;点击了btn&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;执行了定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;执行fn2()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn2();</span><br></pre></td></tr></table></figure>
<p>上述代码的执行结果不唯一，首先确定的结果是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">执行fn1()</span><br><span class="line">执行fn2()</span><br></pre></td></tr></table></figure>
<p>剩余的<code>执行了定时器</code>和<code>点击了btn</code>，需要看点击btn的时机，如果点击btn在前，则执行顺序为<code>点击了btn</code>、<code>执行了定时器</code>，否则为<code>执行了定时器</code>、<code>点击了btn</code>。但是无论怎样<code>执行fn1()</code>和<code>执行fn2()</code>的顺序是不会改变的，因为这个为初始化执行代码。</p>
<h4 id="4-5-2-相关概念"><a href="#4-5-2-相关概念" class="headerlink" title="4.5.2 相关概念"></a>4.5.2 相关概念</h4><ul>
<li>执行栈（execution stack）：所有代码都是在此空间中执行的</li>
<li>浏览器内核（browser core）:js引擎模块（在主线程）、其他模块（在主/分线程处理）</li>
<li>任务队列（task queue）、消息队列（message queue）、事件队列（event queue）：同一个callback queue</li>
<li>事件轮询（event loop）：从任务队列中循环取出回调函数放入执行栈中处理（一个接一个）</li>
</ul>
<h3 id="4-6-H5-Web-Workers（多线程）"><a href="#4-6-H5-Web-Workers（多线程）" class="headerlink" title="4.6 H5 Web Workers（多线程）"></a>4.6 H5 Web Workers（多线程）</h3><p>H5提供了JS分线程的实现，取名为：<code>Web Workers</code>，我们可以将一些大计算量的代码交由web Worker 运行而不冻结用户界面。但是子线程完全受主线程控制，且不操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>相关API：</p>
<ul>
<li><code>Worker</code>：构造函数，加载分线程执行的JS文件</li>
<li><code>Worker.prototype.onmessage</code>：用于接收另一个线程的回调函数</li>
<li><code>Worker.prototype.postMessage</code>：向另一个线程发送消息</li>
</ul>
<p>不足之处：</p>
<ol>
<li><code>Worker</code>内代码不能操作DOM（更新UI）</li>
<li>不能跨域加载JS</li>
<li>不是每个浏览器都支持这个新特性</li>
<li>速度慢</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;number&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> number = input.value;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建一个Worker对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;work.js&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定接收消息的监听</span></span></span><br><span class="line"><span class="javascript">    worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;主线程接收分线程返回的数据&#x27;</span> + event.data);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 向分线程发送消息</span></span></span><br><span class="line"><span class="javascript">    worker.postMessage(number);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;主线程向分线程发送数据&#x27;</span> + number);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// work.js文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt;= <span class="number">2</span> ? <span class="number">1</span> : fn(n - <span class="number">1</span>) + fn(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;分线程接收主线程发送的数据&#x27;</span> + event.data);</span><br><span class="line">  <span class="keyword">var</span> result = fn(event.data);</span><br><span class="line">  postMessage(result);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;分线程向主线程发送数据&#x27;</span> + result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142438.png"><br>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142359.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142107.png"></p>
<p>主线程中的<code>this</code>是<code>window</code>，而work线程中的<code>this</code>是一个专门为 <code>Worker</code> 定制的全局对象。</p>
<h2 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h2><h4 id="JS分号问题"><a href="#JS分号问题" class="headerlink" title="JS分号问题"></a>JS分号问题</h4><ul>
<li>JS一条语句的后面可以不加分号</li>
<li>是否加分号是编码风格问题，没有应该不应该，只有开发者喜欢与否</li>
<li>下面两种情况不加分号会报错<br>※ 小括号开头的前一条语句 （匿名函数自调用）<br>※ 中方括号开头的前一条语句<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>小括号开头的前一条语句 （匿名函数自调用）</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line">错误理解：</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>中方括号开头的前一条语句</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">;[<span class="number">3</span>,<span class="number">4</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">错误理解：</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>[<span class="number">3</span>,<span class="number">4</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
⭐解决方法：在行首加分号</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex 学习笔记</title>
    <url>/2021/06/01/Vuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-Vuex概述"><a href="#1-Vuex概述" class="headerlink" title="1.Vuex概述"></a>1.Vuex概述</h2><h3 id="1-1-Vue组件之间共享数据"><a href="#1-1-Vue组件之间共享数据" class="headerlink" title="1.1 Vue组件之间共享数据"></a>1.1 Vue组件之间共享数据</h3><ul>
<li>父向子传值：v-bind 属性绑定</li>
<li>子向父传值：v-on  事件绑定</li>
<li>兄弟组件之间共享数据：EventBus<blockquote>
<p>$emit  发送数据的那个组件<br>$on  接收数据的那个组件</p>
</blockquote>
</li>
</ul>
<p>== 以上方式适用于小范围数据共享 == </p>
<p><em>详情请见：【后续补充】</em></p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210608155748.png" style="zoom:120%;" />

<h3 id="1-2-如何使用Vue-UI创建项目？"><a href="#1-2-如何使用Vue-UI创建项目？" class="headerlink" title="1.2 如何使用Vue UI创建项目？"></a>1.2 如何使用Vue UI创建项目？</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/1.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/2.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/3.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/4.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/5.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/6.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/7.png"></p>
<p>创建完成之后，到电脑目录下就可以查看到创建的项目，使用vscode打开即可</p>
<h3 id="1-3-Vuex的使用"><a href="#1-3-Vuex的使用" class="headerlink" title="1.3 Vuex的使用"></a>1.3 Vuex的使用</h3><hr>
<p>Vuex 是实现组件全局状态（数据）管理的一种机制，可以方便实现组件之间的数据共享，适用于大范围的数据共享。</p>
<hr>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/clipboard1.png" style="zoom:120%;" />

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/clipboard3.png"></p>
<h3 id="1-4-Vuex知识点"><a href="#1-4-Vuex知识点" class="headerlink" title="1.4 Vuex知识点"></a>1.4 Vuex知识点</h3><p>Vuex中的核心概念</p>
<ul>
<li>State</li>
<li>Mutation</li>
<li>Action</li>
<li>Getter</li>
</ul>
<h5 id="1-4-1-State"><a href="#1-4-1-State" class="headerlink" title="1.4.1 State"></a>1.4.1 State</h5><p>提供唯一的公共数据源，所有共享的数据都要统一放在Store的State中进行存储</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>组件访问state中数据的第一种方式：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.state.全局数据名称</span><br></pre></td></tr></table></figure></li>
<li><p>组件访问state中数据的第二种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从Vuex中按需导入mapState函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过刚才导入的mapState函数，将当前组件需要的全局数据映射为当前组件的computed计算属性</span></span><br><span class="line"><span class="comment">//2.将全局数据映射为当前组件的计算属性</span></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">  ...mapState([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">  <span class="comment">// ...表示展开运算符，意思是将全局数据映射为当前组件的计算属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Vuex中不允许组件直接修改Store中的数据</p>
</li>
</ul>
<h5 id="1-4-2-Mutation"><a href="#1-4-2-Mutation" class="headerlink" title="1.4.2 Mutation"></a>1.4.2 Mutation</h5><p>用于变更Store中的数据，<b>mutation 必须是同步函数</b><br>①只能通过Mutation变更store数据，不可以直接操作store中的数据<br>②通过这种方式虽然操作起来繁琐一些，但是可以集中监控所有数据的变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>组件中触发mutation的第一种方式：  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  <span class="function"><span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>组件触发mutation的第二种方式：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从vuex中按需导入mapMutations函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 通过刚才导入的mapMutations函数，按需要的mutations函数映射为组件的methods方法</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  ...mapMutations([<span class="string">&#x27;add&#x27;</span>])</span><br><span class="line">  <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;add&#x27;)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><b>可以在触发mutations时传递参数</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"><span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">addN</span>(<span class="params">state,step</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//变更状态      </span></span><br><span class="line">      state.count += step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;add&#x27;</span>,<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">另外一种方法：</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    ...mapMutations([<span class="string">&#x27;addN&#x27;</span>])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上述第二种方法，使用时采用如下方法传递参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addN(5)&quot;</span>&gt;</span>+5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h5 id="1-4-3-Action"><a href="#1-4-3-Action" class="headerlink" title="1.4.3 Action"></a>1.4.3 Action</h5><p>用于处理异步任务<br>如果通过异步操作变更数据，必须通过Action,而不能使用Mutation,但是在Actions中还是要通过出发Mutation的方式间接变更数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">addAsync</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//通过commit去触发mutation函数</span></span><br><span class="line">        context.commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>组件中触发action的第一种方式：  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  <span class="function"><span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addAsync&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>组件中触发action的第二种方式：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从vuex中按需导入mapActions函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 通过刚才导入的mapActions函数，按需要的acyions函数映射为组件的methods方法</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  ...mapActions([<span class="string">&#x27;addASync&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>与1.4.2Mutation中相同，也可以携带参数<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210608161404.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210608161437.png"></p>
<h5 id="1-4-4-Getter"><a href="#1-4-4-Getter" class="headerlink" title="1.4.4 Getter"></a>1.4.4 Getter</h5><p>Getter用于对Store中的数据进行加工处理形成新的数据.（<em>Getter不会修改State中的数据，只起到包装的作用</em>）</p>
<p>特点：</p>
<blockquote>
<p>1.Getter可以对Store中已有的数据加工处理之后形成新的数据，类似Vue的计算属性</p>
<p>2.Store中的数据发生改变，Getter的数据也会跟着变化</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Getter</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">	<span class="attr">state</span>:&#123;</span><br><span class="line">		<span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">	&#125;,</span><br><span class="line">    <span class="attr">getters</span>:&#123;</span><br><span class="line">        <span class="attr">showNum</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;当前最新的数量是【&#x27;</span>+ state.count +<span class="string">&#x27;】&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用getters的第一种方式：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.getters.名称</span><br><span class="line"><span class="comment">//例如：this.$store.getters.showNum (this.可以省略)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用getters的第二种方法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125;<span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">	...mapGetter([<span class="string">&#x27;showNum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-Vuex小Demo"><a href="#2-Vuex小Demo" class="headerlink" title="2.Vuex小Demo"></a>2.Vuex小Demo</h2><p>Demo效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210618145323.png"></p>
<p>Demo业务流程图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/todolist.png"  /></p>
<p>Demo地址：<br><a href="https://github.com/qw-null/VuexToDoListDemo">VuexToDoListDemo</a></p>
]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue双向数据绑定</title>
    <url>/2022/04/11/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>视频链接：<a href="https://www.bilibili.com/video/BV1Dr4y1c7xS?share_source=copy_web">【黑马程序员】vue双向数据绑定原理</a></p>
<h2 id="0-前置知识点-数组的reduce-方法"><a href="#0-前置知识点-数组的reduce-方法" class="headerlink" title="0.前置知识点 - 数组的reduce()方法"></a>0.前置知识点 - 数组的<code>reduce()</code>方法</h2><blockquote>
<p>应用场景：下次操作的初始值，依赖于上次操作的返回值</p>
</blockquote>
<ol>
<li>数值的累加操作<br>数组的<code>reduce</code>方法会循环当前数组，侧重于进行“滚雪球”的操作<br><code>Array.reduce(函数, 初始值)</code><br><code>Array.reduce((上次计算的结果，当前循环的Item项) =&gt; &#123; &#125;, 初始值)</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">total, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total += item;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 0是箭头函数的第一个参数的初始值</span></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">//40</span></span><br></pre></td></tr></table></figure></li>
<li>链式获取对象的属性的值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">      <span class="attr">location</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> attrs = [<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;address&#x27;</span>, <span class="string">&#x27;location&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> res = attrs.reduce(<span class="function">(<span class="params">newObj, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> newObj[key]</span><br><span class="line">&#125;, obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 北京</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">      <span class="attr">location</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> attrStr = <span class="string">&#x27;info.address.location&#x27;</span></span><br><span class="line"><span class="keyword">const</span> res = attrStr.split(<span class="string">&#x27;.&#x27;</span>).reduce(<span class="function">(<span class="params">newObj, key</span>) =&gt;</span> newObj[key], obj)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 北京</span></span><br></pre></td></tr></table></figure>
<h2 id="1-发布订阅模式"><a href="#1-发布订阅模式" class="headerlink" title="1. 发布订阅模式"></a>1. 发布订阅模式</h2><ul>
<li><code>Dep</code>类：负责进行<b>依赖收集</b><br>首先，有个数组，专门存放所有的订阅信息；其次，还要提供一个向数组中追加订阅信息的方法；然后，还要提供一个循环，循环触发数组中的每一个订阅信息</li>
<li><code>Watcher</code>类：负责<b>订阅一些事件</b></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收集依赖/收集订阅</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// subs数组用来存放所有订阅者信息</span></span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向subs数组中添加订阅者的信息</span></span><br><span class="line">  addSub (watcher) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(watcher)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布订阅的方法</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function">(<span class="params">watcher</span>) =&gt;</span> watcher.update())</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅者的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发回调的方法</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="built_in">this</span>.cb()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> w1 = <span class="keyword">new</span> Watcher(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是第一个订阅者&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> w2 = <span class="keyword">new</span> Watcher(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是第二个订阅者&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">dep.addSub(w1)</span><br><span class="line">dep.addSub(w2)</span><br><span class="line"></span><br><span class="line">dep.notify()</span><br></pre></td></tr></table></figure>
<h4 id="Vue中发布订阅模式如何运作？"><a href="#Vue中发布订阅模式如何运作？" class="headerlink" title="Vue中发布订阅模式如何运作？"></a>Vue中发布订阅模式如何运作？</h4><ul>
<li>只要我们为Vue中data数据重新赋值，这个复制动作会被Vue监听到</li>
<li>然后Vue要把数据的变化，通知到每一个订阅者</li>
<li>接下来，订阅者（DOM元素）要根据最新的数据，更新自己的内容 </li>
</ul>
<h2 id="2-使用Object-defineProperty-进行数据劫持"><a href="#2-使用Object-defineProperty-进行数据劫持" class="headerlink" title="2. 使用Object.defineProperty()进行数据劫持"></a>2. 使用<code>Object.defineProperty()</code>进行数据劫持</h2><p>Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
<blockquote>
<p>备注：应当直接在 Object 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。</p>
</blockquote>
<p>语法：<code>Object.defineProperty(obj, prop, descriptor)</code><br>参数：</p>
<ul>
<li><code>obj</code>：要定义属性的对象</li>
<li><code>prop</code>：要定义或修改的属性的名称或 <code>Symbol</code> </li>
<li><code>descriptor</code>：要定义或修改的属性描述符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,<span class="comment">// 当前属性允许被循环</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 当前属性允许被配置</span></span><br><span class="line">  get () &#123; <span class="comment">// getter</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;获取了obj.name&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set (newVal) &#123; <span class="comment">// setter</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;赋值了&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// 获取了obj.name   Tom</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&#x27;Sam&#x27;</span>; <span class="comment">//赋值了</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack5学习笔记</title>
    <url>/2022/04/20/Webpack5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>视频地址：<a href="https://www.bilibili.com/video/BV1e7411j7T5?share_source=copy_web">尚硅谷新版Webpack5实战教程(从入门到精通)</a></p>
<h1 id="1-Webpack简介"><a href="#1-Webpack简介" class="headerlink" title="1.Webpack简介"></a>1.Webpack简介</h1><p>Webpack是一种前端资源构建工具，一个静态资源打包器（module bundler）<br>在webpack看来，前端所有资源文件（js/jso/css/img/less/…）都会作为模块处理。<br>它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle）</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220420115745.png"></p>
<h1 id="2-Webpack五个核心概念"><a href="#2-Webpack五个核心概念" class="headerlink" title="2.Webpack五个核心概念"></a>2.Webpack五个核心概念</h1><h2 id="2-1-Entry"><a href="#2-1-Entry" class="headerlink" title="2.1 Entry"></a>2.1 Entry</h2><p>入口（Entry）指示Webpack以哪个文件为入起点开始打包，分构建内部依赖图。</p>
<h2 id="2-2-Output"><a href="#2-2-Output" class="headerlink" title="2.2 Output"></a>2.2 Output</h2><p>输出（Output）指示Webpack打包后的资源bundles输出到哪里去，以及如何命名。</p>
<h2 id="2-3-Loader"><a href="#2-3-Loader" class="headerlink" title="2.3 Loader"></a>2.3 Loader</h2><p>Loader让Webpack能够去处理那些非Javascript文件（webpack自身只能理解Javascript）</p>
<h2 id="2-4-Plugins"><a href="#2-4-Plugins" class="headerlink" title="2.4 Plugins"></a>2.4 Plugins</h2><p>插件（Plugins）可以用于执行范围更广的任务。插件的范围包括 从打包优化和压缩，一直到重新定义环境中的变量等。</p>
<h2 id="2-5-Mode"><a href="#2-5-Mode" class="headerlink" title="2.5 Mode"></a>2.5 Mode</h2><p>模式（Mode）指示webpack使用相应模式的配置。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220420142019.png"></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Z字形变换【Leetcode】</title>
    <url>/2022/03/01/Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<p>传送门：<a href="https://leetcode-cn.com/problems/zigzag-conversion/">6. Z 字形变换</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301143027.png"></p>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：<code>string convert(string s, int numRows);</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301143141.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>我愿称之为 ‘ 最强flag ’ </p>
</blockquote>
<p>要对字符串<code>s</code>进行Z字形存储，所按照顺序如下所示：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301145304.png"></p>
<p>通过图示可以发现：遍历字符串<code>s</code>时，每个字符在Z字形中对应的行索引先从小到大，再从大到小……如此往复，直到遍历结束。</p>
<p>so,问题的难点就在于，如何控制遍历过程的 <b>行索引</b> 呢？<br>其实通过一个<code>flag</code>变量就可以完美解决这个问题。</p>
<p><b>算法流程：</b></p>
<p>初始化变量：<code>res数组--存放对应索引的字符串</code>、<code>flag--改变行索引，初始值为-1</code>、<code>i--对应的行索引</code></p>
<ol>
<li><code>res[i] += c</code>：把每个字符<code>c</code>填入对应行</li>
<li><code>i += flag</code>：更新当前字符<code>c</code>对应的行索引</li>
<li><code>flag = -flag</code>：到达Z字形的转折点时，改变方向</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> convert = <span class="function"><span class="keyword">function</span>(<span class="params">s, numRows</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(numRows).fill(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;<span class="comment">//最终结果</span></span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,flag=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> s)&#123;</span><br><span class="line">        res[i] += c;</span><br><span class="line">        <span class="keyword">if</span>(i===<span class="number">0</span>||i===numRows-<span class="number">1</span>) flag = -flag;</span><br><span class="line">        i += flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(res)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> res)&#123;</span><br><span class="line">        <span class="comment">// console.log(i)</span></span><br><span class="line">        result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise学习</title>
    <url>/2022/01/18/Promise%D1%A7%CF%B0/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1GA411x7z1?share_source=copy_web">尚硅谷Web前端Promise教程从入门到精通（2021抢先版）</a></p>
<h2 id="1-Promise介绍与基本使用"><a href="#1-Promise介绍与基本使用" class="headerlink" title="1.Promise介绍与基本使用"></a>1.Promise介绍与基本使用</h2><h3 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1.1 理解"></a>1.1 理解</h3><p>1.抽象表达</p>
<ul>
<li>Promise是一门新的技术（ES6规范）</li>
<li><span style="background-color:yellow;">Promise是JS中进行异步编程的新解决方案</span><br>备注：旧方案是单纯使用回调函数</li>
</ul>
<p>2.具体表达</p>
<ul>
<li>从语法上来说：Promise是一个构造函数</li>
<li>从功能上来说：Promise对象用来封装一个异步操作并且可以获取其成功/失败的结果值</li>
</ul>
<p>异步编程：(使用回调函数方式)</p>
<ul>
<li>fs文件操作<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(&#x27;fs&#x27;).readFile(&#x27;./index.html&#x27;,(err,data)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>数据库操作</li>
<li>AJAX<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.get(&#x27;/server&#x27;,(data)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>定时器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;&#125;,2000);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-2-为什么要用Promise？"><a href="#1-2-为什么要用Promise？" class="headerlink" title="1.2 为什么要用Promise？"></a>1.2 为什么要用Promise？</h3><h4 id="1-2-1指定回调函数方式更加灵活"><a href="#1-2-1指定回调函数方式更加灵活" class="headerlink" title="1.2.1指定回调函数方式更加灵活"></a>1.2.1指定回调函数方式更加灵活</h4><ol>
<li>旧的：必须在启动异步任务前指定</li>
<li>promise:启动异步任务=&gt;返回promise对象=&gt;给promise对象绑定回调函数（甚至可以在异步任务结束后指定/多个）</li>
</ol>
<h4 id="1-2-2支持链式调用，可以解决回调地狱问题"><a href="#1-2-2支持链式调用，可以解决回调地狱问题" class="headerlink" title="1.2.2支持链式调用，可以解决回调地狱问题"></a>1.2.2支持链式调用，可以解决回调地狱问题</h4><p><b>1.什么是回调地狱?</b><br>回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210703102534.png" alt="回调地狱常见情形"></p>
<p><b>2.回调地狱的缺点？</b><br>不便于阅读<br>不便于异常处理</p>
<p><b>3.解决方案？</b><br>promise链式调用</p>
<h5 id="Case-1-Promise初体验"><a href="#Case-1-Promise初体验" class="headerlink" title="Case 1:Promise初体验"></a>Case 1:Promise初体验</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Promise初体验<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>Promise初体验<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击抽奖<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//生成随机数</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">rand</span>(<span class="params">m, n</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * (n - m + <span class="number">1</span>)) + m - <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 点击按钮，2s后显示是否中奖（30%概率中奖）</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 若中奖弹出  恭喜恭喜，奖品为10RMB劳斯莱斯优惠券</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 若未中奖弹出 再接再厉</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//获取元素对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="comment">//绑定单击事件</span></span></span><br><span class="line"><span class="javascript">  btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//1. 常规写法</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   //30%  1-100</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   //获取从1-100的一个随机数</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   let n = rand(1, 100);</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   //判断</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   if (n &lt;= 30) &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//     alert(&#x27;恭喜恭喜，奖品为10RMB劳斯莱斯优惠券&#x27;)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   &#125; else &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//     alert(&#x27;再接再厉&#x27;)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;, 1000);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//2.promise 形式实现</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// resolve 解决 函数类型的数据</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// reject 拒绝 函数类型的数据</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//30%  1-100</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//获取从1-100的一个随机数</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> n = rand(<span class="number">1</span>, <span class="number">100</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//判断</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (n &lt;= <span class="number">30</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">//成功</span></span></span><br><span class="line"><span class="javascript">          resolve(n); <span class="comment">//将promise对象的状态设置为【成功】</span></span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">//失败</span></span></span><br><span class="line"><span class="javascript">          reject(n); <span class="comment">//将promise对象的状态设置为【失败】</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//调用 then 方法</span></span></span><br><span class="line"><span class="javascript">    p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//成功时的回调函数</span></span></span><br><span class="line"><span class="javascript">      alert(<span class="string">&#x27;恭喜恭喜，奖品为10RMB劳斯莱斯优惠券,你的中奖号码为&#x27;</span> + value)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//失败时的回调函数</span></span></span><br><span class="line"><span class="javascript">      alert(<span class="string">&#x27;再接再厉，你的号码为&#x27;</span> + reason)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Case-2-Promise实践练习-fs模块"><a href="#Case-2-Promise实践练习-fs模块" class="headerlink" title="Case 2:Promise实践练习-fs模块"></a>Case 2:Promise实践练习-fs模块</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//引入模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.回调函数形式</span></span><br><span class="line"><span class="comment">// fs.readFile(&#x27;./content.txt&#x27;, (err, data) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   //如果出错，则抛出错误</span></span><br><span class="line"><span class="comment">//   if (err) throw err;</span></span><br><span class="line"><span class="comment">//   // 如果正确，则输出文件内容</span></span><br><span class="line"><span class="comment">//   console.log(data.toString());</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Promise形式</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(<span class="string">&#x27;content.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//如果出错</span></span><br><span class="line">    <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">    <span class="comment">//如果成功</span></span><br><span class="line">    resolve(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用then方法</span></span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Case-3-Promise实践练习-AJAX请求"><a href="#Case-3-Promise实践练习-AJAX请求" class="headerlink" title="Case 3:Promise实践练习-AJAX请求"></a>Case 3:Promise实践练习-AJAX请求</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Promise 封装 AJAX<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>Promise 封装 AJAX操作<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击发送AJAX<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//接口地址：https://api.apiopen.top/getJoke</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//获取元素对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;btn信息&#x27;</span>, btn);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//创建Promise</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//1.创建对象</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">      <span class="comment">//2.初始化</span></span></span><br><span class="line"><span class="javascript">      xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="comment">//3.发送</span></span></span><br><span class="line"><span class="javascript">      xhr.send();</span></span><br><span class="line"><span class="javascript">      <span class="comment">//4.处理响应结果</span></span></span><br><span class="line"><span class="javascript">      xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">//判断响应状态码2xx</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//控制台输出响应体</span></span></span><br><span class="line"><span class="javascript">            resolve(xhr.response);</span></span><br><span class="line"><span class="javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//控制台输出响应状态码</span></span></span><br><span class="line"><span class="javascript">            reject(xhr.status);</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//调用then方法</span></span></span><br><span class="line"><span class="javascript">    p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(value);</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.warn(reason);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Case-4-Promise封装练习-fs模块"><a href="#Case-4-Promise封装练习-fs模块" class="headerlink" title="Case 4:Promise封装练习-fs模块"></a>Case 4:Promise封装练习-fs模块</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个函数 mineReadFile 读取文件内容</span></span><br><span class="line"><span class="comment">// 参数：path 文件路径</span></span><br><span class="line"><span class="comment">// 返回：promise 对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mineReadFile</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).readFile(path, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//判断</span></span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      <span class="comment">//成功</span></span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mineReadFile(<span class="string">&#x27;content.txt&#x27;</span>).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//输出内容</span></span><br><span class="line">  <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Case-5-util-promisify方法"><a href="#Case-5-util-promisify方法" class="headerlink" title="Case 5:util.promisify方法"></a>Case 5:util.promisify方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util.promisify 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入util模块</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="comment">//引入fs模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//返回一个新的函数</span></span><br><span class="line"><span class="keyword">let</span> mineReadFile = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">mineReadFile(<span class="string">&#x27;content.txt&#x27;</span>).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="1-3-Promise的状态"><a href="#1-3-Promise的状态" class="headerlink" title="1.3 Promise的状态"></a>1.3 Promise的状态</h3><p>  实例对象中的一个属性 [PromiseState]</p>
<ul>
<li>pending 未决定的</li>
<li>resolved / fullfiled 成功</li>
<li>rejected 失败</li>
</ul>
<h5 id="1-3-1-Promise的状态的改变"><a href="#1-3-1-Promise的状态的改变" class="headerlink" title="1.3.1 Promise的状态的改变"></a>1.3.1 Promise的状态的改变</h5><ol>
<li>pending 变为 resolved</li>
<li>pending 变为 rejected<br>说明：只有这两种状态改变的方式，且一个promise对象只能改变一次<br>   无论变为成功还是失败，都会有一个结果数据<br>   成功的结果数据一般称为value，失败的结果数据一般称为reason</li>
</ol>
<h3 id="1-4-Promise的值"><a href="#1-4-Promise的值" class="headerlink" title="1.4 Promise的值"></a>1.4 Promise的值</h3><p>实例对象中的另一个属性 [RromiseResult]<br>保存着异步任务 [成功/失败] 的结果</p>
<ul>
<li>resolve函数</li>
<li>reject函数</li>
</ul>
<h3 id="1-5-Promise的基本流程"><a href="#1-5-Promise的基本流程" class="headerlink" title="1.5 Promise的基本流程"></a>1.5 Promise的基本流程</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210709104619.png"></p>
<h2 id="2-Promise-API"><a href="#2-Promise-API" class="headerlink" title="2.Promise API"></a>2.Promise API</h2><h4 id="2-1-Promise-构造函数-Promise-excutor"><a href="#2-1-Promise-构造函数-Promise-excutor" class="headerlink" title="2.1-Promise 构造函数: Promise (excutor) {}"></a>2.1-Promise 构造函数: Promise (excutor) {}</h4><blockquote>
<p>(1) executor 函数: 执行器 (resolve, reject) =&gt; {}<br>(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {}<br>(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {}<br>说明: executor 会在 Promise 内部立即同步调用，异步操作在执行器中执行，换话说Promise支持同步也支持异步操作</p>
</blockquote>
<h4 id="2-2-Promise-prototype-then-方法-onResolved-onRejected-gt"><a href="#2-2-Promise-prototype-then-方法-onResolved-onRejected-gt" class="headerlink" title="2.2-Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}"></a>2.2-Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}</h4><blockquote>
<p>(1) onResolved 函数: 成功的回调函数 (value) =&gt; {}<br>(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {}<br>说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</p>
</blockquote>
<h4 id="2-3-Promise-prototype-catch-方法-onRejected-gt"><a href="#2-3-Promise-prototype-catch-方法-onRejected-gt" class="headerlink" title="2.3-Promise.prototype.catch 方法: (onRejected) =&gt; {}"></a>2.3-Promise.prototype.catch 方法: (onRejected) =&gt; {}</h4><blockquote>
<p>(1) onRejected 函数: 失败的回调函数 (reason) =&gt; {}<br>说明: then()的语法糖, 相当于: then(undefined, onRejected)</p>
</blockquote>
<h4 id="2-4-Promise-resolve-方法-value-gt"><a href="#2-4-Promise-resolve-方法-value-gt" class="headerlink" title="2.4-Promise.resolve 方法: (value) =&gt; {}"></a>2.4-Promise.resolve 方法: (value) =&gt; {}</h4><blockquote>
<p>（1）value: 成功的数据或 promise 对象<br>说明：返回一个成功/失败的promise对象，直接改变promise状态</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">521</span>);</span><br><span class="line"><span class="comment">// * 如果传入的参数为非Promise类型对象，则返回的结果为成功Promise对象</span></span><br><span class="line"><span class="comment">// * 如果传入的参数为Promise对象，则参数的结果决定了resolve的结果</span></span><br><span class="line"><span class="comment">// 即：传入的promise对象的状态决定了p2的状态（成功 or 失败）</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve(&#x27;ok&#x27;);</span></span><br><span class="line">  reject(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;))</span><br><span class="line"><span class="comment">// console.log(p2);</span></span><br><span class="line">p2.catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="2-5-Promise-reject-方法-reason-gt"><a href="#2-5-Promise-reject-方法-reason-gt" class="headerlink" title="2.5-Promise.reject 方法: (reason) =&gt; {}"></a>2.5-Promise.reject 方法: (reason) =&gt; {}</h4><blockquote>
<p>（1）reason: 失败的原因<br>说明：返回一个失败的promise对象(不论传入什么，返回结果的状态都是失败，即使传入的为成功的promise对象，状态也是失败)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.reject(<span class="number">521</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;iloveyou&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p1结果&#x27;</span>, p1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p2结果&#x27;</span>, p2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p3结果&#x27;</span>, p3);</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210709151507.png"></p>
<h4 id="2-6-Promise-all-方法-promises-gt"><a href="#2-6-Promise-all-方法-promises-gt" class="headerlink" title="2.6-Promise.all 方法: (promises) =&gt; {}"></a>2.6-Promise.all 方法: (promises) =&gt; {}</h4><blockquote>
<p>promises:包含n个promise的数组<br>说明：返回一个新的promise，只有所有的promise都成功才成功，只要有一个失败，就直接失败</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有的promise都成功</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Yeah&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210709153134.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise中有一个失败</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210709153226.png"></p>
<h4 id="2-7-Promise-race-方法-promises-gt"><a href="#2-7-Promise-race-方法-promises-gt" class="headerlink" title="2.7 Promise.race 方法: (promises) =&gt; {}"></a>2.7 Promise.race 方法: (promises) =&gt; {}</h4><blockquote>
<p>promises:包含n个promise的数组<br>说明：返回一个新的promise,第一个完成的promise结果状态就是最终的结果状态</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Yeah&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119150233.png"><br>状态为p1的状态，结果为p1的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Yeah&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119150538.png"><br>因为p1中有定时器，因此p2是第一个执行的，所以状态和结果都与p2的一致。</p>
<h2 id="3-Promise关键问题"><a href="#3-Promise关键问题" class="headerlink" title="3.Promise关键问题"></a>3.Promise关键问题</h2><h4 id="3-1-如何修改对象的状态"><a href="#3-1-如何修改对象的状态" class="headerlink" title="3.1 如何修改对象的状态"></a>3.1 如何修改对象的状态</h4><p>三种方式：resolve函数、reject函数、throw抛出错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.resolve 函数</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>); <span class="comment">//状态：pending =&gt; filfilled (resolved)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.rejected 函数</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;error&#x27;</span>); <span class="comment">//状态：pending =&gt; rejected</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.抛出错误</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;出问题了&#x27;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-2-能否执行多个回调"><a href="#3-2-能否执行多个回调" class="headerlink" title="3.2 能否执行多个回调"></a>3.2 能否执行多个回调</h4><p>Q: 一个promise指定多个成功/失败回调函数，都会调用吗？<br>A：当promise改变为对应状态时都会调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定回调 - 1</span></span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定回调 - 2</span></span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  alert(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-改变状态与指定回调的顺序问题"><a href="#3-3-改变状态与指定回调的顺序问题" class="headerlink" title="3.3 改变状态与指定回调的顺序问题"></a>3.3 改变状态与指定回调的顺序问题</h4><p>改变promise状态和指定回调函数谁先谁后？</p>
<ol>
<li>都有可能，正常情况下是先指定回调再改变状态，但也可以先改变状态再指定回调</li>
<li>如何先改变状态再指定回调？<br>① 在执行器中直接调用resolve() / reject()<br>② 延迟更长时间才调用then()</li>
<li>什么时候才能得到数据？<br>① 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据<br>② 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先改变状态，再执行回调</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先执行回调，再改变状态</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-4-then方法返回结果由什么决定"><a href="#3-4-then方法返回结果由什么决定" class="headerlink" title="3.4 then方法返回结果由什么决定"></a>3.4 then方法返回结果由什么决定</h4><p>promise.then()返回的新的promise的结果状态由什么决定？</p>
<ol>
<li>简单表达：由then()指定的回调函数执行的结果决定</li>
<li>详细表达：<br>① 如果抛出异常，新promise变为rejected，reason为抛出的异常<br>② 如果返回的是非promise的任意值，新promise变为resolved，value为返回值<br>③ 如果返回的是另一个新promise，此promise的结果就会成为新promise的结果</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119163613.png"></p>
<h4 id="3-5-串联多个任务"><a href="#3-5-串联多个任务" class="headerlink" title="3.5 串联多个任务"></a>3.5 串联多个任务</h4><p>promise如何串联多个操作任务？</p>
<ol>
<li>promise的then()返回一个新的promise，可以看成then()的链式调用</li>
<li>通过then的链式调用串联多个同步/异步任务</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;value1:&#x27;</span>,value1)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;value2:&#x27;</span>,value2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119170913.png"><br>说明：<br>value1是new Promise的返回值success，value2是value1（promise）的返回值，因其未定义，所以为undefined</p>
<h4 id="3-6-异常穿透"><a href="#3-6-异常穿透" class="headerlink" title="3.6 异常穿透"></a>3.6 异常穿透</h4><ol>
<li>当使用promise的then链式调用时，可以在最后指定失败的回调</li>
<li>前面任何操作出现了异常，都会传到最后失败的回调中处理</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;value1:&#x27;, value1)</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;Error&#x27;</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;value2:&#x27;</span>, value2)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-7-中断promise链"><a href="#3-7-中断promise链" class="headerlink" title="3.7 中断promise链"></a>3.7 中断promise链</h4><ol>
<li>当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数</li>
<li>唯一方法：在回调函数中返回一个pending状态的promise对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;value1:&#x27;</span>, value1)</span><br><span class="line">  <span class="comment">// 有且只有一种方法：返回一个pending状态的promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;value2:&#x27;</span>, value2)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-Promise自定义封装-手写Promise"><a href="#4-Promise自定义封装-手写Promise" class="headerlink" title="4.Promise自定义封装(手写Promise)"></a>4.Promise自定义封装(手写Promise)</h2><h4 id="4-1-初始结构搭建"><a href="#4-1-初始结构搭建" class="headerlink" title="4.1 初始结构搭建"></a>4.1 初始结构搭建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加then方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-resolve与reject的结构搭建"><a href="#4-2-resolve与reject的结构搭建" class="headerlink" title="4.2 resolve与reject的结构搭建"></a>4.2 resolve与reject的结构搭建</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">  executor(resolve, reject);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加then方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-resolve与reject的代码实现"><a href="#4-3-resolve与reject的代码实现" class="headerlink" title="4.3 resolve与reject的代码实现"></a>4.3 resolve与reject的代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//保存实例对象的 this 的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.修改对象的状态(promiseState)</span></span><br><span class="line">    self.PromiseState = <span class="string">&#x27;fulfilled&#x27;</span>; <span class="comment">// resolved</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值(promiseResult)</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.修改对象的状态(promiseState)</span></span><br><span class="line">    self.PromiseState = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="comment">// 2.设置对象结果值(promiseResult)</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">  executor(resolve, reject);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加then方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-throw抛出异常改变状态"><a href="#4-4-throw抛出异常改变状态" class="headerlink" title="4.4 throw抛出异常改变状态"></a>4.4 throw抛出异常改变状态</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-5-Promise对象状态只能修改一次"><a href="#4-5-Promise对象状态只能修改一次" class="headerlink" title="4.5 Promise对象状态只能修改一次"></a>4.5 Promise对象状态只能修改一次</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-6-then方法执行回调"><a href="#4-6-then方法执行回调" class="headerlink" title="4.6 then方法执行回调"></a>4.6 then方法执行回调</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">    onResolved(<span class="built_in">this</span>.promiseResult);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">    onRejected(<span class="built_in">this</span>.promiseResult);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-7-异步任务回调的执行"><a href="#4-7-异步任务回调的执行" class="headerlink" title="4.7 异步任务回调的执行"></a>4.7 异步任务回调的执行</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.callback = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    <span class="keyword">if</span> (self.callback.onResolved) &#123;</span><br><span class="line">      self.callback.onResolved(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    <span class="keyword">if</span> (self.callback.onRejected) &#123;</span><br><span class="line">      self.callback.onRejected(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">    onResolved(<span class="built_in">this</span>.promiseResult);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">    onRejected(<span class="built_in">this</span>.promiseResult);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存回调函数</span></span><br><span class="line">    <span class="built_in">this</span>.callback = &#123;</span><br><span class="line">      <span class="attr">onResolved</span>: onResolved,</span><br><span class="line">      <span class="attr">onRejected</span>: onRejected</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-指定多个回调的实现"><a href="#4-8-指定多个回调的实现" class="headerlink" title="4.8 指定多个回调的实现"></a>4.8 指定多个回调的实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onResolved(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onRejected(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">    onResolved(<span class="built_in">this</span>.promiseResult);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">    onRejected(<span class="built_in">this</span>.promiseResult);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存回调函数</span></span><br><span class="line">    <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">      <span class="attr">onResolved</span>: onResolved,</span><br><span class="line">      <span class="attr">onRejected</span>: onRejected</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-9-同步任务下then方法返回结果的实现"><a href="#4-9-同步任务下then方法返回结果的实现" class="headerlink" title="4.9 同步任务下then方法返回结果的实现"></a>4.9 同步任务下then方法返回结果的实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onResolved(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onRejected(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = onResolved(<span class="built_in">this</span>.promiseResult);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      onRejected(<span class="built_in">this</span>.promiseResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行成功回调函数</span></span><br><span class="line">            <span class="keyword">let</span> result = onResolved(self.promiseResult);</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">              result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(v);</span><br><span class="line">              &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">                reject(r);</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> result = onRejected(self.promiseResult)</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">              result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(v);</span><br><span class="line">              &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">                reject(r);</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-10-异步任务下then方法返回结果的实现"><a href="#4-10-异步任务下then方法返回结果的实现" class="headerlink" title="4.10 异步任务下then方法返回结果的实现"></a>4.10 异步任务下then方法返回结果的实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onResolved(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onRejected(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = type(self.promiseResult);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      callback(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      callback(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-11-then方法的完善与优化"><a href="#4-11-then方法的完善与优化" class="headerlink" title="4.11 then方法的完善与优化"></a>4.11 then方法的完善与优化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onResolved(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onRejected(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = type(self.promiseResult);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      callback(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      callback(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-11-catch方法、异常穿透、值传递"><a href="#4-11-catch方法、异常穿透、值传递" class="headerlink" title="4.11 catch方法、异常穿透、值传递"></a>4.11 catch方法、异常穿透、值传递</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onResolved(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onRejected(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = type(self.promiseResult);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      callback(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      callback(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-12-Promise-resolve-的封装"><a href="#4-12-Promise-resolve-的封装" class="headerlink" title="4.12 Promise.resolve()的封装"></a>4.12 Promise.resolve()的封装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onResolved(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onRejected(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = type(self.promiseResult);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      callback(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      callback(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 resolve  方法</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      value.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//状态设置为成功</span></span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-13-Promise-reject-的封装"><a href="#4-13-Promise-reject-的封装" class="headerlink" title="4.13 Promise.reject()的封装"></a>4.13 Promise.reject()的封装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onResolved(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onRejected(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = type(self.promiseResult);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      callback(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      callback(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 resolve  方法</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      value.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//状态设置为成功</span></span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 reject 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-14-Promise-all-的封装"><a href="#4-14-Promise-all-的封装" class="headerlink" title="4.14 Promise.all()的封装"></a>4.14 Promise.all()的封装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onResolved(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onRejected(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = type(self.promiseResult);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      callback(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      callback(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 resolve  方法</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      value.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//状态设置为成功</span></span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 reject 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 all 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回结果为promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 声明变量-&gt; 保证所有的promise都成功才可以执行resolve()</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 存放成功结果</span></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">// 遍历 promises</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 得知对象的状态是成功</span></span><br><span class="line">        <span class="comment">// 每个promise对象都成功</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 将当前promise对象成功的结果存入到数组中</span></span><br><span class="line">        arr[i] = v;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (count === promises.length) &#123;</span><br><span class="line">          <span class="comment">// 修改状态</span></span><br><span class="line">          resolve(arr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        reject(r);</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-14-Promise-race-的封装"><a href="#4-14-Promise-race-的封装" class="headerlink" title="4.14 Promise.race()的封装"></a>4.14 Promise.race()的封装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onResolved(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.onRejected(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = type(self.promiseResult);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      callback(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      callback(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 resolve  方法</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      value.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//状态设置为成功</span></span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 reject 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 all 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回结果为promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 声明变量-&gt; 保证所有的promise都成功才可以执行resolve()</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 存放成功结果</span></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">// 遍历 promises</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 得知对象的状态是成功</span></span><br><span class="line">        <span class="comment">// 每个promise对象都成功</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 将当前promise对象成功的结果存入到数组中</span></span><br><span class="line">        arr[i] = v;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (count === promises.length) &#123;</span><br><span class="line">          <span class="comment">// 修改状态</span></span><br><span class="line">          resolve(arr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        reject(r);</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 race 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改返回对象的状态为【成功】</span></span><br><span class="line">        resolve(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改返回对象的状态为【失败】</span></span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-15-then方法回调的异步执行"><a href="#4-15-then方法回调的异步执行" class="headerlink" title="4.15 then方法回调的异步执行"></a>4.15 then方法回调的异步执行</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220125163632.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        item.onResolved(data);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">    <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">    self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">    self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        item.onRejected(data);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 封装函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = type(self.promiseResult);</span><br><span class="line">        <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">// 结果是promise对象</span></span><br><span class="line">          result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        callback(onResolved);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        callback(onRejected);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 catch 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 resolve  方法</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      value.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//状态设置为成功</span></span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 reject 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 all 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回结果为promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 声明变量-&gt; 保证所有的promise都成功才可以执行resolve()</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 存放成功结果</span></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">// 遍历 promises</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 得知对象的状态是成功</span></span><br><span class="line">        <span class="comment">// 每个promise对象都成功</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 将当前promise对象成功的结果存入到数组中</span></span><br><span class="line">        arr[i] = v;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (count === promises.length) &#123;</span><br><span class="line">          <span class="comment">// 修改状态</span></span><br><span class="line">          resolve(arr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        reject(r);</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 race 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改返回对象的状态为【成功】</span></span><br><span class="line">        resolve(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 修改返回对象的状态为【失败】</span></span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-16-封装Promise类"><a href="#4-16-封装Promise类" class="headerlink" title="4.16 封装Promise类"></a>4.16 封装Promise类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加属性</span></span><br><span class="line">    <span class="built_in">this</span>.promiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.promiseResult = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明属性 --&gt; 用于then方法中保存回调函数</span></span><br><span class="line">    <span class="built_in">this</span>.callbacks = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存实例对象的this的值</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//resolve函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 判断</span></span><br><span class="line">      <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">      self.promiseState = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">      <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">      self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          item.onResolved(data);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 判断</span></span><br><span class="line">      <span class="keyword">if</span> (self.promiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 1. 修改对象状态（promiseState）</span></span><br><span class="line">      self.promiseState = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">      <span class="comment">// 2.设置对象结果值（promiseResult）</span></span><br><span class="line">      self.promiseResult = data;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用成功的回调函数 -- 异步任务</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          item.onRejected(data);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 同步调用【执行器函数】</span></span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//then方法</span></span><br><span class="line">  then (onResolved, onRejected) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 判断回调参数 -- catch方法使用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 封装函数</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 获取回调函数的执行结果</span></span><br><span class="line">          <span class="keyword">let</span> result = type(self.promiseResult);</span><br><span class="line">          <span class="comment">// 判断result是否是promise对象</span></span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            <span class="comment">// 结果是promise对象</span></span><br><span class="line">            result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">              resolve(v);</span><br><span class="line">            &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">              reject(r);</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 结果对象的状态为成功</span></span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用回调函数,通过PromiseState决定调用谁</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 异步执行时，需要处理pending状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.promiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 保存回调函数</span></span><br><span class="line">        <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">          <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            callback(onResolved);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            callback(onRejected);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//catch方法</span></span><br><span class="line">  <span class="keyword">catch</span> (onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加resolve方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve (value) &#123;</span><br><span class="line">    <span class="comment">// 返回Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        value.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(v);</span><br><span class="line">        &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//状态设置为成功</span></span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加 reject 方法</span></span><br><span class="line">  <span class="keyword">static</span> reject (reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加 all 方法</span></span><br><span class="line">  <span class="keyword">static</span> all (promises) &#123;</span><br><span class="line">    <span class="comment">// 返回结果为promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 声明变量-&gt; 保证所有的promise都成功才可以执行resolve()</span></span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 存放成功结果</span></span><br><span class="line">      <span class="keyword">let</span> arr = [];</span><br><span class="line">      <span class="comment">// 遍历 promises</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        promises[i].then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 得知对象的状态是成功</span></span><br><span class="line">          <span class="comment">// 每个promise对象都成功</span></span><br><span class="line">          count++;</span><br><span class="line">          <span class="comment">// 将当前promise对象成功的结果存入到数组中</span></span><br><span class="line">          arr[i] = v;</span><br><span class="line">          <span class="comment">// 判断</span></span><br><span class="line">          <span class="keyword">if</span> (count === promises.length) &#123;</span><br><span class="line">            <span class="comment">// 修改状态</span></span><br><span class="line">            resolve(arr);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          reject(r);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加 race 方法</span></span><br><span class="line">  <span class="keyword">static</span> race (promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        promises[i].then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 修改返回对象的状态为【成功】</span></span><br><span class="line">          resolve(v);</span><br><span class="line">        &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 修改返回对象的状态为【失败】</span></span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-async-与-await"><a href="#5-async-与-await" class="headerlink" title="5.async 与 await"></a>5.async 与 await</h2><h4 id="5-1-async函数"><a href="#5-1-async函数" class="headerlink" title="5.1 async函数"></a>5.1 async函数</h4><ol>
<li>函数的返回值为promise对象</li>
<li>promise对象的结果由async函数执行的返回值决定</li>
</ol>
<p>async函数返回值的规则与then方法的规则是一致的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 1.如果返回值是一个非Promise类型的数据</span></span><br><span class="line">      <span class="comment">// promiseState为fulfilled，promiseResult为返回的值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">521</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.如果返回的是一个Promise对象</span></span><br><span class="line">      <span class="comment">// promiseState为返回promise对象的状态，promiseResult为返回的promise对象的值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">      reject(<span class="string">&#x27;ERR&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.抛出异常</span></span><br><span class="line">      <span class="comment">// promiseState为reject，promiseResult为抛出异常的值</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;error&#x27;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-await表达式"><a href="#5-2-await表达式" class="headerlink" title="5.2 await表达式"></a>5.2 await表达式</h4><ol>
<li>await右侧的表达式一般为promise对象，但也可以是其他的值</li>
<li>如果表达式是promise对象，await返回的是promise成功的值</li>
<li>如果表达式是其他值，直接将此值作为await的返回值</li>
</ol>
<p><b>注意</b></p>
<ul>
<li>await必须写在async函数中，但async函数中可以没有await</li>
<li>如果await的promise失败了，就会抛出异常，需要通过try…catch捕获处理</li>
</ul>
<p><code>await 10;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220126094102.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220126095436.png"></p>
<h4 id="5-3-async和await结合"><a href="#5-3-async和await结合" class="headerlink" title="5.3  async和await结合"></a>5.3  async和await结合</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> mineReadFile = util.promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数的方式</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;1.txt&#x27;</span>, <span class="function">(<span class="params">err, data1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  fs.readFile(<span class="string">&#x27;2.txt&#x27;</span>, <span class="function">(<span class="params">err, data2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;3.txt&#x27;</span>, <span class="function">(<span class="params">err, data3</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">      <span class="built_in">console</span>.log(data1 + data2 + data3);</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// async 与 await</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    <span class="keyword">let</span> data1 = <span class="keyword">await</span> mineReadFile(<span class="string">&#x27;1.txt&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> data2 = <span class="keyword">await</span> mineReadFile(<span class="string">&#x27;2.txt&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> data3 = <span class="keyword">await</span> mineReadFile(<span class="string">&#x27;3.txt&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data1 + data2 + data3);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>async 与 await方式非常简洁，且捕获异常也十分简单。</p>
<h4 id="5-4-async-与-await结合发送AJAX"><a href="#5-4-async-与-await结合发送AJAX" class="headerlink" title="5.4 async 与 await结合发送AJAX"></a>5.4 async 与 await结合发送AJAX</h4><p>情景：点击获取段子按钮，发送ajax请求，获取数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>async与await结合发送AJAX<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>获取段子<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">sendAJAX</span>(<span class="params">url</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//1.创建对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">        <span class="comment">//2.初始化</span></span></span><br><span class="line"><span class="javascript">        xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//3.发送</span></span></span><br><span class="line"><span class="javascript">        xhr.send();</span></span><br><span class="line"><span class="javascript">        <span class="comment">//4.处理响应结果</span></span></span><br><span class="line"><span class="javascript">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//判断响应状态码2xx</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">//控制台输出响应体</span></span></span><br><span class="line"><span class="javascript">              resolve(xhr.response);</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">//控制台输出响应状态码</span></span></span><br><span class="line"><span class="javascript">              reject(xhr.status);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 获取段子信息</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> duanzi = <span class="keyword">await</span> sendAJAX(<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(duanzi);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>axios入门与源码分析（尚硅谷2021最新版）</title>
    <url>/2021/07/02/axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B72021%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1wr4y1K7tq?from=search&seid=5757211588371183468">尚硅谷2021最新版axios入门与源码解析</a></p>
<h2 id="第1章：axios的理解和使用"><a href="#第1章：axios的理解和使用" class="headerlink" title="第1章：axios的理解和使用"></a>第1章：axios的理解和使用</h2><h2 id="第2章：axios源码分析"><a href="#第2章：axios源码分析" class="headerlink" title="第2章：axios源码分析"></a>第2章：axios源码分析</h2>]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>a</title>
    <url>/2022/06/01/a/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Vue项目实战：尚品汇</title>
    <url>/2022/02/13/Vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9A%E5%B0%9A%E5%93%81%E6%B1%87/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Vf4y1T7bw?share_source=copy_web">尚硅谷VUE项目实战-尚品汇(大型\重磅)</a></p>
<h2 id="0-项目简介"><a href="#0-项目简介" class="headerlink" title="0 项目简介"></a>0 项目简介</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213145705.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213145730.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213150118.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213150219.png"></p>
<h2 id="1-项目初始化"><a href="#1-项目初始化" class="headerlink" title="1 项目初始化"></a>1 项目初始化</h2><p><b>★vue-cli脚手架初始化项目</b></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213151031.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220213152327.png"><br>– 选择vue2版本</p>
<p><b>★认识项目的组成</b></p>
<ul>
<li> <code>node_modules</code>文件夹：项目依赖</li>
<li> <code>public</code>文件夹：一般放置一些静态资源（图片），需要注意，放在public文件夹中的静态资源，webpack进行打包时，会原封不动的打包到dist文件夹中。</li>
<li><code>src</code>文件夹（程序员源代码文件夹）：</li>
</ul>
<ul>
<li><ul>
<li><code>assets</code>文件夹：一般也是放置静态资源（一般放置多个组件共用的静态资源），需要注意，放置在assets文件夹里面的静态资源，在webpack打包的时候，webpack会把静态资源当作一个模块，打包到JS文件里面。</li>
</ul>
</li>
<li><ul>
<li><code>components</code>文件夹：一般放置的是非路由组件（全局组件）</li>
</ul>
</li>
<li><ul>
<li><code>App.vue</code>文件：唯一的根组件。Vue的组件都是<code>.vue</code>文件</li>
</ul>
</li>
<li><ul>
<li><code>main.js</code>文件：程序入口文件，也是整个程序中最先执行的文件</li>
</ul>
</li>
</ul>
<ul>
<li><code>babel.config.js</code>文件：配置文件（babel相关）</li>
<li><code>package.json</code>文件：认为是项目的‘身份证’，记录项目叫什么，项目当中有哪些依赖、项目怎么运行。</li>
<li><code>package-lock.json</code>文件：缓存性文件</li>
<li><code>README.md</code>文件：说明性文件</li>
</ul>
<p><b>★项目的其他配置</b></p>
<p><b>1.项目运行起来时，让浏览器自动打开</b></p>
<p>修改 package.json 文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve --open&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;vue-cli-service lint&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><b>2.eslint校验功能关闭</b></p>
<p>方法：在根目录下创建<code>vue.config.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 关闭eslint</span></span><br><span class="line">  <span class="attr">lintOnSave</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>3.配置别名（例如将src配置别名为@）</b></p>
<p>方法：在根目录下创建<code>jsconfig.json</code>文件<br>@代表的是src文件夹，当文件过多时可以方便查找</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;src/*&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span>: [</span><br><span class="line">    <span class="comment">// 下列文件夹中不可使用</span></span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dist&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>★项目路由的分析</b></p>
<p>vue-router</p>
<p>前端所谓的路由：k-v键值对。<br>key：URL（地址栏中的路径）<br>value：相应的路由组件</p>
<p>注意：项目上中下结构</p>
<ul>
<li>路由组件：<br>Home首页路由组件、Search路由组件、login登录路由</li>
<li>非路由组件：<br>Header<br>Footer 在【首页、搜索页】，但在 【登录 | 注册】 页面是没有</li>
</ul>
<h2 id="2-完成非路由组件Header与Footer的业务"><a href="#2-完成非路由组件Header与Footer的业务" class="headerlink" title="2 完成非路由组件Header与Footer的业务"></a>2 完成非路由组件Header与Footer的业务</h2><p>在项目中，不再以 HTML+CSS 为主，主要搞业务逻辑。</p>
<p>开发项目时：</p>
<ol>
<li>书写静态页面（HTML + CSS）</li>
<li>拆分组件</li>
<li>获取服务器的数据动态展示</li>
<li>完成相应的动态业务逻辑</li>
</ol>
<p>注意：</p>
<ol>
<li>创建组件的时候，需要保证 组件结构 + 组件样式 + 图片资源 正确</li>
<li>项目采用less样式，但浏览器不识别less样式，需要通过less、less-loader进行处理less，把less样式变为css样式，浏览器才能识别。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 安装less和less-loader【注意：less-loader不能安装最新版，否则报错】</span><br><span class="line"></span><br><span class="line">npm install --save less less-loader@5</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>如果想让组件识别less样式，需要在style标签的身上加上 <code>lang=&quot;less&quot;</code></li>
</ol>
<h4 id="2-1-使用组件的步骤（非路由组件）"><a href="#2-1-使用组件的步骤（非路由组件）" class="headerlink" title="2.1 使用组件的步骤（非路由组件）"></a>2.1 使用组件的步骤（非路由组件）</h4><ul>
<li>创建或者定义</li>
<li>引入</li>
<li>注册</li>
<li>使用</li>
</ul>
<h4 id="2-2-路由组件的搭建"><a href="#2-2-路由组件的搭建" class="headerlink" title="2.2 路由组件的搭建"></a>2.2 路由组件的搭建</h4><p>vue-router<br>安装命令：<code>npm install --save vue-router@3</code></p>
<p>上面对项目的分析可知，路由组件应该有四个：Home、Search、Login、Register</p>
<ul>
<li><code>components</code>文件夹：经常放置非路由组件（共用全局组件）</li>
<li><code>pages | views</code>文件夹：经常放置路由组件</li>
</ul>
<h5 id="2-2-1-配置路由"><a href="#2-2-1-配置路由" class="headerlink" title="2.2.1 配置路由"></a>2.2.1 配置路由</h5><p>项目当中配置路由一般放置在<code>router</code>文件夹中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router下的index.js文件</span></span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用插件</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"><span class="comment">//引入路由组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;@/pages/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Search <span class="keyword">from</span> <span class="string">&#x27;@/pages/Search&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;@/pages/Login&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Register <span class="keyword">from</span> <span class="string">&#x27;@/pages/Register&#x27;</span></span><br><span class="line"><span class="comment">//配置路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 配置路由</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: Home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/register&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: Register</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/search&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: Search</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-小结"><a href="#2-2-2-小结" class="headerlink" title="2.2.2 小结"></a>2.2.2 小结</h5><p><b>路由组件与非路由组件的区别？</b></p>
<ol>
<li>路由组件一般放置在 <code>pages | views</code>文件夹，非路由组件一般放置<code>components</code>文件夹中</li>
<li>路由组件一般需要在<code>router</code>文件夹中进行注册（使用的即为组件的名字），非路由组件在使用的时候，一般都是以标签的形式使用</li>
<li>注册完路由，不管路由组件还是非路由组件身上都有<code>$route</code>和<code>$router</code>属性</li>
</ol>
<ul>
<li><p><code>$route</code> :一般获取路由信息【路径、query、params等】</p>
</li>
<li><p><code>$router</code> :一般进行编程式导航，进行路由跳转【push | replace】</p>
</li>
</ul>
<h5 id="2-2-3-路由跳转"><a href="#2-2-3-路由跳转" class="headerlink" title="2.2.3 路由跳转"></a>2.2.3 路由跳转</h5><p>路由跳转有两种形式：</p>
<ul>
<li>声明式导航<code>router-link</code></li>
<li>编程式导航<code>$router.push | $router.replace</code></li>
</ul>
<p>声明式导航能做的，编程式导航都能做。编程式导航除了可以进行路由跳转，还可以做一些其他的业务逻辑。</p>
<h4 id="2-3-Footer组件的显示与隐藏"><a href="#2-3-Footer组件的显示与隐藏" class="headerlink" title="2.3 Footer组件的显示与隐藏"></a>2.3 Footer组件的显示与隐藏</h4><p>Footer组件：在Home、Search显示Footer组件；在登录、注册时隐藏</p>
<p>显示或者隐藏组件：<code>v-if | v-show</code><br>两者使用<code>v-show</code>更好一些，原因：<code>v-if</code>控制显示与否是通过操作DOM实现的，<code>v-if</code>会频繁的操作DOM，损耗性能。<code>v-show</code>仅仅通过样式显示元素（<code>display:block</code>）或者隐藏元素（<code>display:none</code>）。</p>
<ul>
<li>我们可以依据路由身上的<code>$route</code>获取当前路由的信息，通过路由路径（<code>this.$route.path</code>）判断Footer显示与隐藏。</li>
<li>配置路由的时候，可以给路由添加路由元信息【meta】，路由需要配置对象，它的key不能乱写，需要依据开发文档。</li>
</ul>
<h4 id="2-4-路由传参"><a href="#2-4-路由传参" class="headerlink" title="2.4 路由传参"></a>2.4 路由传参</h4><p><b>路由跳转有几种方式？</b></p>
<p>路由跳转有两种形式：</p>
<ul>
<li>声明式导航<code>router-link</code>（务必要有 to 属性）</li>
<li>编程式导航<code>$router.push | $router.replace</code>（可以书写一些自己的业务）</li>
</ul>
<p><b>路由传参，参数有几种写法？</b></p>
<ul>
<li><code>params</code>参数：属于路径当中的一部分，需要注意，在配置路由时，需要占位</li>
<li><code>query</code>参数：不属于路径当中的一部分，类似于ajax中的queryString <code>/home?k=v&amp;k=v</code>会直接拼接到地址后面,不需要占</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由传递参数：</span></span><br><span class="line">  <span class="comment">// 第一种：字符串形式</span></span><br><span class="line">  <span class="built_in">this</span>.$router.push(<span class="string">&quot;/search/&quot;</span> + <span class="built_in">this</span>.keyword + <span class="string">&quot;?k=&quot;</span> + <span class="built_in">this</span>.keyword.toUpperCase());</span><br><span class="line">  <span class="comment">// 第二种：模板字符串</span></span><br><span class="line">  <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/search/ $&#123;this.keyword&#125; ?k= $&#123;this.keyword.toUpperCase())&#x27;</span>)</span><br><span class="line">  <span class="comment">// 第三种：对象【推荐】</span></span><br><span class="line">  <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123; <span class="attr">keyword</span>: <span class="built_in">this</span>.keyword &#125;,</span><br><span class="line">    <span class="attr">query</span>: &#123; <span class="attr">k</span>: <span class="built_in">this</span>.keyword.toUpperCase() &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>路由配置时占位符写法：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220215104243.png"></p>
<h5 id="路由传参的相关面试题"><a href="#路由传参的相关面试题" class="headerlink" title="路由传参的相关面试题"></a>路由传参的相关面试题</h5><p><b>题目1：</b>路由传递参数（对象写法）path是否可以结合params参数一起使用？</p>
<p>答案：路由跳转传参的时候，对象的写法可以是name、path的形式，但是需要注意的是，path这种写法不能与params参数一起使用。params参数只能和name形式结合使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三种：对象【推荐】</span></span><br><span class="line">  <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123; <span class="attr">keyword</span>: <span class="built_in">this</span>.keyword &#125;,</span><br><span class="line">    <span class="attr">query</span>: &#123; <span class="attr">k</span>: <span class="built_in">this</span>.keyword.toUpperCase() &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><b>题目2：</b>如何指定params参数可传可不传？</p>
<p>如果路由要求传递params参数，但是你就不传递params参数，会发现跳转后的URL存在问题。<br><code>已传递params参数：http://localhost:8080/#/search/aaa?k=AAA</code><br><code>未传递params参数：http://localhost:8080/#/?k=AAA</code>可以发现丢失<code>search</code></p>
<p>答案：如何指定params参数可传可不传，在配置路由的时候，在占位符的后面添加一个问号【代表params参数可传递或者不传递】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/search/:keyword?&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: Search,</span><br><span class="line">  <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><b>题目3：</b>params参数可以传递也可以不传递，但是如果传递的是空串，如何解决？</p>
<p>传递空串的params参数会导致路径出现问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; <span class="attr">keyword</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">query</span>: &#123; <span class="attr">k</span>: <span class="built_in">this</span>.keyword.toUpperCase() &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>传递后的路径：<br><code>http://localhost:8080/#/?k=AAA</code></p>
<p>答案：使用undefined解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; <span class="attr">keyword</span>: <span class="string">&#x27;&#x27;</span> || <span class="literal">undefined</span> &#125;,</span><br><span class="line">  <span class="attr">query</span>: &#123; <span class="attr">k</span>: <span class="built_in">this</span>.keyword.toUpperCase() &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><b>题目4：</b>路由组件能不能传递props数据？</p>
<ul>
<li><p>第一种：布尔值写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/search/:keyword?&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: Search,</span><br><span class="line">  <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">  <span class="comment">// 第一种：布尔值写法</span></span><br><span class="line">  <span class="attr">props</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在search页面通过props接收：<br><code>props:[&#39;keyword&#39;]</code></p>
</li>
<li><p>第二种：对象写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;/search/:keyword?&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: Search,</span><br><span class="line">  <span class="attr">meta</span>: &#123; <span class="attr">show</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">  <span class="comment">// 第二种：对象写法</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在search页面通过props接收：<br><code>props:[&#39;a&#39;,&#39;b&#39;]</code></p>
<ul>
<li>第三种：函数写法：可以params参数，query参数，通过props传递给路由组件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: <span class="function">(<span class="params">$route</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">keyword</span>: $route.params.keyword,</span><br><span class="line">    <span class="attr">k</span>: $route.query.k</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="★★进一步的思考"><a href="#★★进一步的思考" class="headerlink" title="★★进一步的思考"></a>★★进一步的思考</h5><p><b>编程式导航跳转到当前路由（参数不变），多次执行会抛出NavigationDuplicated的警告错误？</b></p>
<p>路由跳转有两种形式：编程式导航和声明式导航，上述问题不会出现在声明式导航中的，因为vue-router底层已经处理好了。</p>
<p>编程式导航进行路由跳转的时候出现这种错误的原因是当前的<code>vue-router</code>的版本是<code>3.5.3</code>，它引入了<code>promise</code>，因此可以通过给<code>push</code>方法传递相应的成功、失败的回调函数，捕获当前错误进行解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; <span class="attr">ketword</span>:<span class="built_in">this</span>.keyword &#125;,</span><br><span class="line">  <span class="attr">query</span>: &#123; <span class="attr">k</span>:<span class="built_in">this</span>.keyword.toUpperCase()&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function">()=&gt;</span>&#123;&#125;,</span><br><span class="line"><span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>但是上述这种解决方法治标不治本，在别的组件中<code>push | replace</code>，编程式导航还是要类似的错误。因此需要更加通用的解决方法。解决之前需要明确几点信息：</p>
<ul>
<li><p><code>this</code>：指的是当前组件实例（search）</p>
</li>
<li><p><code>this.$router</code>属性：当前的这个属性，属性值VueRouter类的一个实例，当在入口文件注册路由的时候，给组件实例添加<code>$router | $route</code>属性</p>
</li>
<li><p><code>push</code>:VueRouter类的一个实例</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">VueRouter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象的方法</span></span><br><span class="line">VueRouter.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//函数的上下文为VueRouter类的一个实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     ----------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> $router = <span class="keyword">new</span> VueRouter();</span><br><span class="line"></span><br><span class="line">$router.push(xxx);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终解决方法：重写push、replace方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js文件</span></span><br><span class="line"><span class="comment">// 先把VueRouter原型对象的push、replace方法保存一份</span></span><br><span class="line"><span class="keyword">let</span> originPush = VueRouter.prototype.push;</span><br><span class="line"><span class="keyword">let</span> originReplace = VueRouter.prototype.replace;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call|apply区别</span></span><br><span class="line">  <span class="comment">// 相同点：都可以调用函数一次，都可以篡改函数的上下文一次</span></span><br><span class="line">  <span class="comment">// 不同点：call与apply传递参数：call传递参数用逗号隔开，apply方法执行需要传递数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写push | replace方法</span></span><br><span class="line"><span class="comment">// 第一个参数：告诉原来的push方法，你往哪里跳转（传递哪些参数）</span></span><br><span class="line"><span class="comment">// 第二个参数：成功的回调，第三个参数：失败的回调</span></span><br><span class="line">VueRouter.prototype.push = <span class="function"><span class="keyword">function</span> (<span class="params">location, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (resolve &amp;&amp; reject) &#123;</span><br><span class="line">    originPush.call(<span class="built_in">this</span>, location, rosolve, reject)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    originPush.call(<span class="built_in">this</span>.location, <span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123; &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VueRouter.prototype.replace = <span class="function"><span class="keyword">function</span> (<span class="params">location, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (resolve &amp;&amp; reject) &#123;</span><br><span class="line">    originReplace.call(<span class="built_in">this</span>, location, resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    originReplace.call(<span class="built_in">this</span>.location, <span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Home组件"><a href="#3-Home组件" class="headerlink" title="3 Home组件"></a>3 Home组件</h2><h4 id="3-1-组件拆分步骤"><a href="#3-1-组件拆分步骤" class="headerlink" title="3.1 组件拆分步骤"></a>3.1 组件拆分步骤</h4><ol>
<li>先将静态页面完成</li>
<li>拆分出静态组件</li>
<li>获取服务器的数据进行展示</li>
<li>完成动态业务</li>
</ol>
<h4 id="3-2-全局组件的使用方法"><a href="#3-2-全局组件的使用方法" class="headerlink" title="3.2 全局组件的使用方法"></a>3.2 全局组件的使用方法</h4><p>首先明确全局组件的引入，注册需要在程序入口<code>main.js</code>中实现</p>
<p>例如，引如一个名为TypeNav的全局组件，<code>mian.js</code>中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> TypeNav <span class="keyword">from</span> <span class="string">&#x27;@/pages/Home/TypeNav&#x27;</span></span><br><span class="line"><span class="comment">// 第一个参数：全局组件的名字   第二个参数：哪一个组件</span></span><br><span class="line">Vue.component(TypeNav.name, TypeNav)</span><br></pre></td></tr></table></figure>

<h2 id="4-axios"><a href="#4-axios" class="headerlink" title="4 axios"></a>4 axios</h2><h4 id="4-1-为什么需要二次封装axios"><a href="#4-1-为什么需要二次封装axios" class="headerlink" title="4.1 为什么需要二次封装axios?"></a>4.1 为什么需要二次封装axios?</h4><p>请求拦截器、响应拦截器：</p>
<ul>
<li>请求拦截器可以在发送请求之前处理一些业务</li>
<li>响应拦截器，当服务器数据返回以后，可以处理一些事情</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 安装axios</span><br><span class="line">npm install --save axios</span><br></pre></td></tr></table></figure>

<h4 id="4-2-项目中api文件夹【axios】"><a href="#4-2-项目中api文件夹【axios】" class="headerlink" title="4.2 项目中api文件夹【axios】"></a>4.2 项目中api文件夹【axios】</h4><p>在接口中，路径都带有<code>/api</code>，因此可将<code>/api</code>设置为baseURL<br>api下的request.js文件的基本结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于axios进行二次封装</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.利用axios对象的方法create去创建一个axios实例</span></span><br><span class="line"><span class="keyword">const</span> requests = axios.create(&#123;</span><br><span class="line">  <span class="comment">// 配置对象</span></span><br><span class="line">  <span class="comment">// 基础路径，发送请求的路径都会出现api</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;/api&#x27;</span>,</span><br><span class="line">  <span class="comment">// 代表请求超时时间为5s</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求拦截器：在发送请求之前，请求拦截器可以检测到，可以在请求发送出去之前做一些事情</span></span><br><span class="line">requests.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//config：配置对象，对象里面有一个属性很重要-&gt;headers请求头</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">requests.interceptors.response.use(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 成功的回调函数：服务器相应数据回来以后，相应拦截器可以检测到，可以做一些事情</span></span><br><span class="line">  <span class="keyword">return</span> res.data;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 响应失败的回调函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> requests;</span><br></pre></td></tr></table></figure>

<p>其中的一些配置内容可以参考<a href="http://www.axios-js.com/zh-cn/docs/">axios文档</a></p>
<h4 id="4-3-接口的统一管理"><a href="#4-3-接口的统一管理" class="headerlink" title="4.3 接口的统一管理"></a>4.3 接口的统一管理</h4><ul>
<li>项目很小：完全可以在组件的生命周期函数中发送</li>
<li>项目很大：需要在<code>api</code>文件夹下的<code>index.js</code>中统一管理</li>
</ul>
<h5 id="4-3-1-跨域问题"><a href="#4-3-1-跨域问题" class="headerlink" title="4.3.1 跨域问题"></a>4.3.1 跨域问题</h5><p>什么是跨域？协议、域名、端口号不同的请求，称之为跨域。</p>
<p>例如：<br><a href="http://localhost:8080/#/home">http://localhost:8080/#/home</a>  – 前端项目本地服务<br><a href="http://39.98.123.211/">http://39.98.123.211</a> – 后台服务器</p>
<p>解决跨域的方法：<code>JSONP</code> <code>CROS</code> <code>代理</code></p>
<ul>
<li>代理方法<br>在<code>webpack.config.js</code>文件 或者 <code>vue.config.js</code>文件中设置代理<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,<span class="comment">//目标服务器</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;, <span class="comment">// 路径重写</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-nprogress"><a href="#5-nprogress" class="headerlink" title="5 nprogress"></a>5 nprogress</h2><p>这是一个类似youtube、Medium等网站上的小进度条插件。纳米级的进度条，涓涓细流动画告诉你的用户，一些事情正在发生！<br>安装命令：<code>npm install --save nprogress</code></p>
<p><b>项目当中如何使用？</b></p>
<p>可以在项目接口的请求拦截器【进度条开始】和响应拦截器【进度条结束】中使用。</p>
<p>注意：在使用时要引入 <code>nprogress.css</code> 文件，否则无法显示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入进度条</span></span><br><span class="line"><span class="keyword">import</span> nprogress <span class="keyword">from</span> <span class="string">&#x27;nprogress&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入进度条样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;nprogress/nprogress.css&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start方法：进度条开始 done方法：进度条结束</span></span><br><span class="line">nprogress.start();</span><br><span class="line">nprogress.done();</span><br></pre></td></tr></table></figure>
<p>❤ 如果想要修改进度条的颜色，可在<code>node_modules</code>中找到<code>nprogress</code>下的<code>nprogress.css</code>，修改其中的样式即可</p>
<h2 id="6-vuex状态管理库"><a href="#6-vuex状态管理库" class="headerlink" title="6 vuex状态管理库"></a>6 vuex状态管理库</h2><p>vuex是官方提供的一个状态管理库，可以集中式管理项目中组件共用的数据。<br>切记，并不是所有的项目都需要vuex，如果项目很小，完全不需要vuex，如果项目很大，组件很多，数据很多，数据维护很费劲，则使用vuex。</p>
<p>安装命令：<code>npm install --save vuex</code></p>
<h4 id="6-1-vuex核心概念"><a href="#6-1-vuex核心概念" class="headerlink" title="6.1 vuex核心概念"></a>6.1 vuex核心概念</h4><p>state<br>mutations<br>actidons<br>getters<br>modules</p>
<p>详情见 <a href="https://qw-null.github.io/2021/06/01/Vuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">vuex学习笔记</a></p>
<h4 id="6-2-vuex实现模块式开发"><a href="#6-2-vuex实现模块式开发" class="headerlink" title="6.2 vuex实现模块式开发"></a>6.2 vuex实现模块式开发</h4><p>如果项目过大，组件过多，接口也很多，数据很多，可以让vuex实现模块式开发。</p>
]]></content>
      <categories>
        <category>Vue实战项目</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>ElementUI树形结构样式修改</title>
    <url>/2021/08/31/elementUI%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h3 id="0-最终效果图"><a href="#0-最终效果图" class="headerlink" title="0.最终效果图"></a>0.最终效果图</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210831152413.png"></p>
<blockquote>
<p>PS:基于<a href="https://element.eleme.cn/#/zh-CN/component/tree">ElementUI中的树形控件进行实现</a></p>
</blockquote>
<p>原效果图：<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210831153551.png"></p>
<h3 id="1-实现步骤"><a href="#1-实现步骤" class="headerlink" title="1.实现步骤"></a>1.实现步骤</h3><p>分为4各步骤：</p>
<ul>
<li>更换父子节点以及根节点的图标</li>
<li>调整父子节点的缩进</li>
<li>绘制结点间的关系线</li>
<li>更换最前方的小三角形图标</li>
</ul>
<h4 id="1-1-更换父子节点以及根节点的图标"><a href="#1-1-更换父子节点以及根节点的图标" class="headerlink" title="1.1 更换父子节点以及根节点的图标"></a>1.1 更换父子节点以及根节点的图标</h4><p>实现思路：通过data.class的值来确定父子节点和根节点【树形结构的数据中要包含class字段】，分别为其加上不同的图标，图标使用<svg-icon>展示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-tree</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:data</span>=<span class="string">&quot;data&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:props</span>=<span class="string">&quot;defaultProps&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-expand-all</span></span></span><br><span class="line"><span class="tag">    <span class="attr">indent</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;tree-line&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">highlight-current</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:expand-on-click-node</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">node-click</span>=<span class="string">&quot;handleNodeClick&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123; node, data &#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;custom-tree-node&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父级icon --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 0&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;danghui&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:#ff0000;font-size:10px;&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--非父节点非根节点icon--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;dangOrg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:#ff0000;font-size:10px;&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 子集icon --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;dangMember&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:10px;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; node.label &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-tree</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-调整父子节点的缩进"><a href="#1-2-调整父子节点的缩进" class="headerlink" title="1.2 调整父子节点的缩进"></a>1.2 调整父子节点的缩进</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.el-tree-node</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>; <span class="comment">/* 缩进量 */</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-class">.el-tree-node__children</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>; <span class="comment">/* 缩进量 */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-绘制结点间的关系线"><a href="#1-3-绘制结点间的关系线" class="headerlink" title="1.3 绘制结点间的关系线"></a>1.3 绘制结点间的关系线</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 竖线 */</span></span><br><span class="line"><span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    //<span class="attribute">left</span>: -<span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="number">#D1CECE</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 当前层最后一个节点的竖线高度固定 */</span></span><br><span class="line"><span class="selector-class">.el-tree-node</span><span class="selector-pseudo">:last-child</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">38px</span>; // 可以自己调节到合适数值</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 横线 */</span></span><br><span class="line"><span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="comment">/* left: -3px; */</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#D1CECE</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 去掉最顶层的虚线，放最下面样式才不会被上面的覆盖了 */</span></span><br><span class="line">&amp; &gt; <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">border-top</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">&amp; &gt; <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-更换最前方的小三角形图标"><a href="#1-4-更换最前方的小三角形图标" class="headerlink" title="1.4 更换最前方的小三角形图标"></a>1.4 更换最前方的小三角形图标</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 展开关闭的icon修改 */</span></span><br><span class="line">  <span class="selector-class">.el-tree-node__expand-icon</span><span class="selector-class">.expanded</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.el-icon-caret-right</span>:before &#123;</span><br><span class="line">    content: <span class="string">&quot;\e783&quot;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:element-icons <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.el-tree-node__expand-icon</span><span class="selector-class">.expanded</span><span class="selector-class">.el-icon-caret-right</span>:before &#123;</span><br><span class="line">    content: <span class="string">&quot;\e781&quot;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:element-icons <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Q:content属性的值如何取到？<br>A:打开<a href="https://element.eleme.cn/#/zh-CN/component/icon">ElementUI图标库</a>,F12选中需要的图标，在样式中即可获取到。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210831160209.png"></p>
<h3 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2.完整代码"></a>2.完整代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-tree</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:data</span>=<span class="string">&quot;data&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:props</span>=<span class="string">&quot;defaultProps&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">default-expand-all</span></span></span><br><span class="line"><span class="tag">    <span class="attr">indent</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;tree-line&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">highlight-current</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:expand-on-click-node</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">node-click</span>=<span class="string">&quot;handleNodeClick&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123; node, data &#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;custom-tree-node&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父级icon --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 0&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;danghui&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:#ff0000;font-size:10px;&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--非父节点非子节点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;dangOrg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:#ff0000;font-size:10px;&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 子集icon --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;data.class === 2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-right: 5px&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">icon-class</span>=<span class="string">&quot;dangMember&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:10px;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; node.label &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-tree</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: [&#123;</span><br><span class="line">    <span class="comment">// class:0 一级节点  class:1非父节点，非子节点     class:2子节点</span></span><br><span class="line">    <span class="attr">label</span>: <span class="string">&#x27;一级 1&#x27;</span>,</span><br><span class="line">    <span class="attr">class</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">label</span>: <span class="string">&#x27;二级 1-1&#x27;</span>,</span><br><span class="line">        <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">label</span>: <span class="string">&#x27;三级 1-1-1&#x27;</span>,</span><br><span class="line">        <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;一级 2&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;二级 2-1&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">                    <span class="attr">label</span>: <span class="string">&#x27;三级 2-1-1&#x27;</span>,</span><br><span class="line">                    <span class="attr">class</span>: <span class="number">2</span></span><br><span class="line">                &#125;]</span><br><span class="line">                &#125;, </span><br><span class="line">                &#123;</span><br><span class="line">                <span class="attr">label</span>: <span class="string">&#x27;二级 2-2&#x27;</span>,</span><br><span class="line">                <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">children</span>: [&#123;</span><br><span class="line">                    <span class="attr">label</span>: <span class="string">&#x27;三级 2-2-1&#x27;</span>,</span><br><span class="line">                    <span class="attr">class</span>: <span class="number">2</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="string">&#x27;一级 3&#x27;</span>,</span><br><span class="line">    <span class="attr">class</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;二级 3-1&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;三级 3-1-1&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">2</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;二级 3-2&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;三级 3-2-1&#x27;</span>,</span><br><span class="line">            <span class="attr">class</span>: <span class="number">2</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="attr">defaultProps</span>: &#123;</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;children&#x27;</span>,</span><br><span class="line">        <span class="attr">label</span>: <span class="string">&#x27;label&#x27;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.tree-line</span>&#123;</span><br><span class="line">  <span class="selector-class">.el-tree-node</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>; // 缩进量</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.el-tree-node__children</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>; // 缩进量</span><br><span class="line">  &#125;</span><br><span class="line">  // 竖线</span><br><span class="line">  <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    //<span class="attribute">left</span>: -<span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="number">#D1CECE</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  // 当前层最后一个节点的竖线高度固定</span><br><span class="line">  <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">:last-child</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">38px</span>; // 可以自己调节到合适数值</span><br><span class="line">  &#125;</span><br><span class="line">  // 横线</span><br><span class="line">  <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    //<span class="attribute">left</span>: -<span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#D1CECE</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  // 去掉最顶层的虚线，放最下面样式才不会被上面的覆盖了</span><br><span class="line">  &amp; &gt; <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">border-top</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp; &gt; <span class="selector-class">.el-tree-node</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">  // 展开关闭的<span class="attribute">icon</span>修改</span><br><span class="line">  <span class="selector-class">.el-tree-node__expand-icon</span><span class="selector-class">.expanded</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.el-icon-caret-right</span>:before &#123;</span><br><span class="line">    content: <span class="string">&quot;\e783&quot;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:element-icons <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.el-tree-node__expand-icon</span><span class="selector-class">.expanded</span><span class="selector-class">.el-icon-caret-right</span>:before &#123;</span><br><span class="line">    content: <span class="string">&quot;\e781&quot;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:element-icons <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>get、post和put的区别</title>
    <url>/2022/04/21/get%E3%80%81post%E5%92%8Cput%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="1-get请求和post请求的区别"><a href="#1-get请求和post请求的区别" class="headerlink" title="1.get请求和post请求的区别"></a>1.get请求和post请求的区别</h2><ol>
<li>get用来获取数据，post用来提交数据</li>
<li>get参数有长度限制（受限于url长度，具体数值取决于浏览器和服务器的限制，最长2048字节），而post无限制</li>
<li>get请求的数据会附加在url之后，以”?”分割url和传输数据，多个参数通过”&amp;”连接，而post请求会把请求的数据放在http请求体中</li>
<li>get是明文传输，post是放在请求体中，但开发者可以通过抓包工具看到，也相当于是明文的</li>
<li>get请求会保存在浏览器历史记录中，还可能保存在web服务器的日志中</li>
<li>get能够被缓存，post不能被缓存</li>
</ol>
<h2 id="2-post和put的区别"><a href="#2-post和put的区别" class="headerlink" title="2.post和put的区别"></a>2.post和put的区别</h2><ol>
<li>put操作需要明确知道操作的对象，如果对象不存在会创建对象，如果对象存在，则会全部替换目标对象；post请求并不知道要操作的对象，post创建对象时，由http服务器为新创建的对象生成一个唯一的url，post修改对象时，一般只修改目标对象的部分内容。</li>
<li>put操作是幂等的，post操作是非幂等的。</li>
</ol>
<blockquote>
<p>Tips: 何时使用？<br>当知道要创建或覆盖的内容的URL时，应该使用PUT方法。<br>当只知道要创建内容的对象的类别或子部分的URL，请使用POST方法。</p>
</blockquote>
<h4 id="何为幂等？"><a href="#何为幂等？" class="headerlink" title="何为幂等？"></a>何为幂等？</h4><p>幂等（idempotent）指操作不管执行多少次，结果都不会改变。<br>例如，你到银行中存钱，在存的过程中机器出现故障，执行多次存钱数据写入操作，但是最终你还是账户还是仅仅多出你存入的金额，存钱的操作就是幂等的。类似于<code>x=1</code>的操作，不管你执行多少次，结果都是<code>x=1</code>.</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>写在前面的话</title>
    <url>/2021/05/31/hello-world/</url>
    <content><![CDATA[<p>废话接废话，无穷无尽，说着说着年华老去。</p>
<p>总有一天，他会忘记泥土的感觉，忘记现在纷飞的草叶。</p>
<p>暮风吹过麦浪，远方的山巅盖住落日，田边小道听得见蛙鸣。</p>
<p>人生遇到的每一个人，出场顺序真的很重要。很多人，如果换一个时间认识，就会有不一样的结局。有些人执着到，擦干眼泪继续爱你，有些人冷静到，权衡轻重地放弃你。生不逢时，爱人逢人，所到之处，皆是命数。</p>
]]></content>
      <categories>
        <category>闲言三两句</category>
      </categories>
      <tags>
        <tag>闲言三两句</tag>
      </tags>
  </entry>
  <entry>
    <title>table中图片展示</title>
    <url>/2021/06/06/table%E4%B8%AD%E5%9B%BE%E7%89%87%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<p>在人海里相遇的人终究要还给人海。</p>
<img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210606213709.png" style="zoom:175%;" />

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Table中横向图片展示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Table横向多个图片展示<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>每个表格由 table 标签开始。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>每个表格行由 tr 标签开始。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>每个表格数据由 td 标签开始。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>图片展示<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>阿里<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;table_img&quot;</span> <span class="attr">onmousewheel</span>=<span class="string">&quot;handler()&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-scott-webb-1098520.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-scott-webb-1098520.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-scott-webb-1098520.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-scott-webb-1098520.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-scott-webb-1098520.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/qw-null/BlogImages/pexels-pixabay-2150.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgAuto&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>腾讯<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(&#x27;mousewheel信息&#x27;, event);</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> detail = event.wheelDelta || event.detail;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> item = event.currentTarget;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> moveForwardStep = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> moveBackStep = -<span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> step = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (detail &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">      step = moveForwardStep * <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">      step = moveBackStep * <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    item.scrollLeft += step;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-collapse</span>: collapse;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">    <span class="comment">/*对DIV设置margin:0 auto样式，</span></span></span><br><span class="line"><span class="comment"><span class="css">    是为了让DIV在浏览器中水平居中。布局居中、水平居中，</span></span></span><br><span class="line"><span class="comment"><span class="css">    均加入margin:0 auto即可。*/</span></span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table</span> <span class="selector-tag">td</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.table</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#cad9ea</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#666</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">table</span> <span class="selector-tag">thead</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#CCE8EB</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(odd) &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 奇数行 */</span></span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(even) &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 偶数行 */</span></span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#F5FAFA</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.imgAuto</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 图片样式 */</span></span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">max-width</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table_img</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">overflow-y</span>: auto;</span></span><br><span class="line"><span class="css">    <span class="attribute">white-space</span>: nowrap;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table_img</span>::-webkit-scrollbar &#123;</span></span><br><span class="line"><span class="css">    /*滚动条整体样式*/</span></span><br><span class="line"><span class="css">    width: <span class="number">3px</span>;</span></span><br><span class="line"><span class="css">    <span class="comment">/*高宽分别对应横竖滚动条的尺寸*/</span></span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table_img</span>::-webkit-scrollbar-thumb &#123;</span></span><br><span class="line"><span class="css">    /*滚动条里面小方块*/</span></span><br><span class="line"><span class="css">    border-radius: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">159</span>, <span class="number">160</span>, <span class="number">162</span>, <span class="number">0.8</span>);</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table_img</span>::-webkit-scrollbar-track &#123;</span></span><br><span class="line"><span class="css">    /*滚动条里面轨道*/</span></span><br><span class="line"><span class="css">    border-radius: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>js分割取字符串方法</title>
    <url>/2021/06/15/js%E5%88%86%E5%89%B2%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1-substr"><a href="#1-substr" class="headerlink" title="1.substr"></a>1.substr</h3><p>substr(start,length)表示从start位置开始，截取length长度的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src=<span class="string">&quot;images/off_1.png&quot;</span>;</span><br><span class="line">alert(src.substr(<span class="number">7</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>弹出值:off</p>
<h3 id="2-substring"><a href="#2-substring" class="headerlink" title="2.substring"></a>2.substring</h3><p>substring(start,end)表示从start到end之间的字符串，包括start位置的字符但是不包括end位置的字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src=<span class="string">&quot;images/off_1.png&quot;</span>;</span><br><span class="line">alert(src.substring(<span class="number">7</span>,<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p>弹出值:off</p>
<h3 id="3-indexOf"><a href="#3-indexOf" class="headerlink" title="3.indexOf"></a>3.indexOf</h3><p>indexOf() 方法返回某个指定的字符串值在字符串中首次出现的位置（从左向右）。没有匹配的则返回-1，否则返回首次出现位置的字符串的下标值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src=<span class="string">&quot;images/off_1.png&quot;</span>;</span><br><span class="line">alert(src.indexOf(<span class="string">&#x27;t&#x27;</span>));</span><br><span class="line">alert(src.indexOf(<span class="string">&#x27;i&#x27;</span>));</span><br><span class="line">alert(src.indexOf(<span class="string">&#x27;g&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>弹出值依次为: -1 &nbsp;  0  &nbsp; 3</p>
<h3 id="4-lastIndexOf"><a href="#4-lastIndexOf" class="headerlink" title="4.lastIndexOf"></a>4.lastIndexOf</h3><p>lastIndexOf()方法返回从右向左出现某个字符或字符串的首个字符索引值（与indexOf相反）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src=<span class="string">&quot;images/off_1.png&quot;</span>;</span><br><span class="line">alert(src.lastIndexOf(<span class="string">&#x27;/&#x27;</span>));</span><br><span class="line">alert(src.lastIndexOf(<span class="string">&#x27;g&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>弹出值依次为：6 &nbsp; 15</p>
<h3 id="5-split"><a href="#5-split" class="headerlink" title="5.split"></a>5.split</h3><p>将一个字符串分割为子字符串，然后将结果作为字符串数组返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SplitDemo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s, ss;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="string">&quot;The rain in Spain falls mainly in the plain.&quot;</span>;</span><br><span class="line">  <span class="comment">// 在每个空格字符处进行分解。</span></span><br><span class="line">  ss = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>(ss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：[“The”, “rain”, “in”, “Spain”, “falls”, “mainly”, “in”, “the”, “plain.”]</p>
]]></content>
      <categories>
        <category>JS学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ62 二叉搜索树的第k个结点 [ 剑指offer ]</title>
    <url>/2021/08/25/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210825142603.png"></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li>法一：<br>将二叉搜索树的中序遍历的结果存入数组中，取数组的第k个结果。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">KthNode</span>(<span class="params">pRoot, k</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pRoot || k&lt;<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> gotoArr(pRoot)[k-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gotoArr</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历结果存入数组</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    gotoArr(root.left);</span><br><span class="line">    res.push(root);</span><br><span class="line">    gotoArr(root.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>存在问题：需要将所有结点遍历完，时间复杂度高</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 》》改进版《《</span></span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">let</span> key; <span class="comment">// flag：确定是否取到结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">KthNode</span>(<span class="params">pRoot, k</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pRoot || k&lt;<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    key = k;</span><br><span class="line">    <span class="keyword">return</span> gotoArr(pRoot)[k-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gotoArr</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历结果存入数组</span></span><br><span class="line">    <span class="keyword">if</span>(res.length === key) <span class="keyword">return</span>; <span class="comment">//取到结果，停止</span></span><br><span class="line">    <span class="keyword">if</span>(root.left) gotoArr(root.left);</span><br><span class="line">    res.push(root);</span><br><span class="line">    <span class="keyword">if</span>(root.right) gotoArr(root.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>法二：<br>中序遍历二叉搜索树，搜索至第k个结点时，停止。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">KthNode</span>(<span class="params">root, k</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || k&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 为了追踪k值，将中序遍历函数定义在里面</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left) res = traverse(root.left);</span><br><span class="line">        <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">            <span class="comment">// 左子树未查找到结果</span></span><br><span class="line">            <span class="keyword">if</span>(k===<span class="number">1</span>) res=root;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right) res = traverse(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> traverse(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="补充知识点："><a href="#补充知识点：" class="headerlink" title="补充知识点："></a>补充知识点：</h3><h5 id="二叉搜索树："><a href="#二叉搜索树：" class="headerlink" title="二叉搜索树："></a>二叉搜索树：</h5><p>a. 定义:</p>
<p>二分搜索树（Binary Search Tree），也称为二叉查找树 、二叉搜索树 、有序二叉树或排序二叉树。满足以下几个条件：</p>
<ul>
<li>若它的左子树不为空，左子树上所有节点的值都小于它的根节点。</li>
<li>若它的右子树不为空，右子树上所有的节点的值都大于它的根节点。<br>它的左、右子树也都是二分搜索树。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210825150004.png"></li>
</ul>
<p>b. 二分搜索树有着高效的插入、删除、查询操作。</p>
<p>平均时间的时间复杂度为 O(log n)，最差情况为 O(n)。二分搜索树与堆不同，不一定是完全二叉树，底层不容易直接用数组表示故采用链表来实现二分搜索树。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210825150259.png"></p>
<p>c. 二分查找法过程<br>二分查找法的思想在 1946 年提出，查找问题是计算机中非常重要的基础问题，对于有序数列，才能使用二分查找法。如果我们要查找一元素，先看数组中间的值V和所需查找数据的大小关系，分三种情况：</p>
<ul>
<li>1、等于所要查找的数据，直接找到</li>
<li>2、若小于 V，在小于 V 部分分组继续查询</li>
<li>2、若大于 V，在大于 V 部分分组继续查询</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210825150526.png"><br>代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [start,end] = [<span class="number">0</span>,nums.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> middle,midItem;<span class="comment">// 中间元素索引以及内容</span></span><br><span class="line">    <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">        middle = <span class="built_in">Math</span>.floor((start+end)/<span class="number">2</span>);</span><br><span class="line">        midItem = nums[middle];</span><br><span class="line">        <span class="keyword">if</span>(midItem === target)&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(midItem &gt; target)&#123;</span><br><span class="line">            end = middle-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            start = middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ60 把二叉树打印成多行[剑指offer]</title>
    <url>/2021/09/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210901094843.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210901094918.png"><br>[中等、队列]</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>解题思路：</p>
<ul>
<li>树的层次遍历+使用两个变量（a.记录当前行的节点数目 b.记录下一行的节点数目）</li>
<li>每一行的节点都要放到一个数组内部</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Print</span>(<span class="params">pRoot</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = []; <span class="comment">//最终结果</span></span><br><span class="line">    <span class="keyword">let</span> queue = [];<span class="comment">// 层次遍历queue</span></span><br><span class="line">    <span class="keyword">let</span> temprow = [];<span class="comment">// 存放每一层的结点</span></span><br><span class="line">    <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> res;</span><br><span class="line">    queue.push(pRoot);</span><br><span class="line">    <span class="keyword">let</span> nextLevel = <span class="number">0</span>;<span class="comment">//下一层结点数</span></span><br><span class="line">    <span class="keyword">let</span> nowLevel = <span class="number">1</span>;<span class="comment">// 本层结点数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">         <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">        temprow.push(node.val);</span><br><span class="line">        nowLevel--;</span><br><span class="line">        <span class="keyword">if</span>(node.left) &#123;</span><br><span class="line">            nextLevel++;</span><br><span class="line">            queue.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right) &#123;</span><br><span class="line">            nextLevel++;</span><br><span class="line">            queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nowLevel === <span class="number">0</span>)&#123;</span><br><span class="line">            res.push(temprow);</span><br><span class="line">            temprow = [];</span><br><span class="line">            nowLevel = nextLevel;</span><br><span class="line">            nextLevel = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ38 二叉树的深度[剑指offer]</title>
    <url>/2021/08/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210821135542.png"><br>[简单、递归]</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>树的深度 = max(左子树深度，右子树深度)+1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeDepth</span>(<span class="params">pRoot</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot===<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = TreeDepth(pRoot.left);</span><br><span class="line">    <span class="keyword">let</span> right = TreeDepth(pRoot.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (left&gt;right?left:right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还有层次遍历的方法，待补充……</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ18 二叉树的镜像[剑指offer]</title>
    <url>/2021/08/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210820140027.png"><br>[简单、递归]</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>交换二叉树的左右子树</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mirror</span>(<span class="params"> pRoot </span>) </span>&#123;</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot === <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> pRoot;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [pRoot.left,pRoot.right] = [pRoot.right,pRoot.left]</span><br><span class="line">    &#125;</span><br><span class="line">    Mirror(pRoot.left);</span><br><span class="line">    Mirror(pRoot.right);</span><br><span class="line">    <span class="keyword">return</span> pRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>二叉树的答题模板</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">TreeNode root</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的中心思想：</p>
<ul>
<li>考虑出口 （ if 部分）</li>
<li>处理当前节点</li>
<li>递归处理下个节点</li>
</ul>
<p>二叉树问题的递归出口，一般包括：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.节点为空（到达叶子节点）</span></span><br><span class="line">pRoot === <span class="literal">null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>内存溢出与内存泄漏</title>
    <url>/2022/03/20/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h1 id="1-内存溢出"><a href="#1-内存溢出" class="headerlink" title="1.内存溢出"></a>1.内存溢出</h1><ul>
<li>一种程序运行出现的错误</li>
<li>当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出错误</li>
</ul>
<p>例如，下面这一段程序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  obj[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当运行时，浏览器会报错：内存不足<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220320101217.png"></p>
<p><b>说明：内存是有限的资源，不能无限制地进行分配！</b></p>
<h1 id="2-内存泄漏"><a href="#2-内存泄漏" class="headerlink" title="2.内存泄漏"></a>2.内存泄漏</h1><ul>
<li>占用内存没有被及时释放</li>
<li>内存泄漏积累多了就容易导致内存溢出</li>
<li>常见的内存泄漏：<br>※ 意外的全局变量<br>※ 没有及时清理的计时器或者回调函数<br>※ 闭包</li>
</ul>
<p><b>⭐ 意外的全局变量</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p>上述代码中，变量<code>a</code>实际上是全局变量，以这种方式定义时，变量不会随着<code>fn</code>函数的执行完成而释放。</p>
<p><b>⭐ 没有及时清理的计时器或者回调函数</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动循环定时器后不清理</span></span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;-----------------&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>由于没关闭定时器而导致内存溢出，除非浏览器关闭、刷新，不然的话会一直执行下去。因此需要及时清理定时器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clearInterval</span>(intervalId);</span><br></pre></td></tr></table></figure>

<p><b>⭐ 闭包</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(++a)</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">return</span> fn2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = fn1()</span><br><span class="line">  fn()</span><br></pre></td></tr></table></figure>
<p>执行完函数之后<code>a</code>没有被释放掉，是因为<code>fn</code>保存了<code>fn1</code>函数。<br>因此需要将<code>fn</code>置为空，让垃圾回收器回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Set、Map、WeakSet、WeakMap的二三事</title>
    <url>/2022/04/25/%E5%85%B3%E4%BA%8ESet%E3%80%81Map%E3%80%81WeakSet%E3%80%81WeakMap%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h2><p>特征：</p>
<ol>
<li>成员不能重复</li>
<li>只有键值，没有键名，有点类似于数组</li>
<li>可以遍历</li>
</ol>
<p><code>console.log(Set.prototype)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220425144545.png"></p>
<p>对于<code>Set</code>应该明确的几点：</p>
<p><b>⭐ 不重复</b><br>在js中判断元素相等的方法有两种：<code>===</code>和 <code>Object.is</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span> , <span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span> , -<span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>我们不妨来看一下，<code>Set</code>遵循哪种原则呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">1</span>);</span><br><span class="line">set.add(<span class="literal">NaN</span>);</span><br><span class="line">set.add(<span class="literal">NaN</span>);</span><br><span class="line">set.add(<span class="number">0</span>);</span><br><span class="line">set.add(-<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220425145751.png"></p>
<p>可以看到，在<code>Set</code>中，认为<code>NaN</code>是相等的，认为<code>+0</code>和<code>-0</code>也是相等的，所以才会说<code>Set</code>中成员是<b style="color:red;">不重复的。</b></p>
<p><b>⭐ 数组 ⇌ Set</b></p>
<p>数组转换为<code>Set</code>：<code>new Set([1,2,3])</code></p>
<p><code>Set</code>转换为数组：<code>[...set]</code></p>
<h2 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2.WeakSet"></a>2.WeakSet</h2><p>特征：</p>
<ol>
<li>成员都是对象（<code>Object</code>或者继承自<code>Object</code>的类型），尝试其他值会抛出<code>TypeError</code></li>
<li>WeakSet是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存DOM节点，不容易造成内存泄漏</li>
<li>不能遍历</li>
</ol>
<p><code>console.log(WeakSet.prototype)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220425151232.png"></p>
<p>对于<code>WeakSet</code>需要明确几点：</p>
<p><b>⭐ 何为 强引用 &amp; 弱引用？</b></p>
<p>对于一个全局变量<code>var key = &#123;&#125;</code>，JS垃圾回收器不能自动将其回收，若想要释放内存，则需让 <code>key = null</code>。</p>
<p>※ 强引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = &#123; <span class="attr">name</span>: <span class="string">&quot;Kitty&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> pets = [cat];</span><br><span class="line"></span><br><span class="line">cat = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pets); <span class="comment">// [&#123; name: &quot;Kitty&quot; &#125;]</span></span><br></pre></td></tr></table></figure>
<p>通过将变量 <code>cat</code> 创建为对象，并把这个对象放入一个数组 <code>pets</code> 中，然后通过将它的值设置为 <code>null</code> 来删除其对原始对象的引用。</p>
<p>尽管我们再也无法访问 <code>cat</code> 变量，但由于在 <code>pets</code> 数组和这个对象之间存在<b>强引用关系</b>，因此这个对象其实仍保留在内存中，并且可以通过 <code>pets[0]</code> 访问到它。 换句话说，<b>强引用可以防止垃圾回收从内存中删除对象。</b></p>
<p>※ 弱引用</p>
<p>弱引用是对对象的引用，如果它还是对内存中对象的唯一引用，就能顺利地进行垃圾回收。相反，一般强引用都会防止垃圾回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pets = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> cat = &#123; <span class="attr">name</span>: <span class="string">&quot;Kitty&quot;</span> &#125;;</span><br><span class="line">pets.set(cat, <span class="string">&quot;Kitty&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pets); <span class="comment">// WeakMap &#123;&#123;…&#125; =&gt; &#x27;Kitty&#x27;&#125;</span></span><br><span class="line">cat = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待垃圾回收后</span></span><br><span class="line"><span class="built_in">console</span>.log(pets); <span class="comment">// WeakMap&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过利用 <code>WeakMap</code> 及其附带的弱引用，我们可以看到两种类型的引用之间的差异。虽然对原始 <code>cat</code> 对象的强引用仍然存在，但 <code>cat</code> 对象仍然存在于 <code>WeakMap</code> 中，我们可以毫无问题地访问它。</p>
<p>但是，当我们通过将 <code>cat</code>变量重新赋值 <code>null</code> 来覆盖对原始 <code>cat</code> 对象的引用时，由于内存中对原始对象的唯一引用是来自我们创建的 <code>WeakMap</code> 的弱引用，所以它不会阻止垃圾回收的发生。这意味着当 <code>JavaScript</code> 引擎再次运行垃圾回收过程时，<code>cat</code> 对象将从内存和我们分配给它的 <code>WeakMap</code> 中删除。</p>
<p><b>因此这里的关键区就别在于</b>，强引用可以防止对象进行垃圾回收，而弱引用则不会。</p>
<p>默认情况下，<b style="color:red;">JavaScript 对其所有引用使用强引用，使用弱引用的唯一方法是使用 WeakMap 或 WeakSet。</b></p>
<h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h2><p>特征：</p>
<ol>
<li>本质上是键值对</li>
<li>可以遍历</li>
</ol>
<p>Q：<code>Object</code>与<code>Map</code>的区别？</p>
<ul>
<li>键的类型：<code>Object</code>的key值必须是<code>String</code>、<code>Number</code>或者<code>Symbol</code>，<code>Map</code>的键可以是JavaScript支持的所有类型。</li>
<li>元素顺序：<code>Map</code> 元素的顺序遵循插入的顺序，而 <code>Object</code> 的则没有这一特性。</li>
<li>继承：<code>Map</code> 继承自 <code>Object</code> 对象。</li>
</ul>
<h2 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4.WeakMap"></a>4.WeakMap</h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数this的绑定规则</title>
    <url>/2022/02/08/%E5%87%BD%E6%95%B0this%E7%9A%84%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1.默认绑定"></a>1.默认绑定</h2><p>当函数调用类型为独立函数调用时，函数的this为默认绑定，指向全局变量；在严格模式下，this将绑定到undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>foo()</code>为独立函数调用，foo()中的this指向全局变量（严格模式下则指向undefined）</p>
<h2 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2.隐式绑定"></a>2.隐式绑定</h2><p>当函数的调用位置有上下文对象时，或者说函数在被调用时<span style="color:red;"><b>被某个对象拥有或者包含时</b></span>，隐式绑定规则就会把函数调用中的this绑定到这个上下文对象。</p>
<p>如下，foo在调用时this便隐式绑定到obj上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">  foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>知识点：隐式绑定丢失的情况（待补充！！）</p>
<h2 id="3-显示绑定"><a href="#3-显示绑定" class="headerlink" title="3.显示绑定"></a>3.显示绑定</h2><p>使用call、apply和bind显示的绑定函数调用时的this的指向</p>
<h2 id="4-new"><a href="#4-new" class="headerlink" title="4.new"></a>4.new</h2><p>当使用new调用函数时，会发生this的指向绑定，但此处发生的绑定与函数本身无关</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>元素抖动</title>
    <url>/2021/06/17/%E5%85%83%E7%B4%A0%E6%8A%96%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="0-需求说明"><a href="#0-需求说明" class="headerlink" title="0.需求说明"></a>0.需求说明</h2><p>表单中同意用户协议未选择时，让该部分抖动，可以给用户友好的提示。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/123.gif"></p>
<h2 id="1-实现方法"><a href="#1-实现方法" class="headerlink" title="1.实现方法"></a>1.实现方法</h2><h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">id</span>=<span class="string">&quot;agree&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span>同意<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;agreelink&quot;</span>&gt;</span>《用户协议》<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;submit()&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;<span class="comment">//监测同意协议是否点击</span></span><br><span class="line">  <span class="keyword">let</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">&quot;agree&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log($(<span class="string">&quot;#checkbox&quot;</span>).is(<span class="string">&quot;:checked&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!$(<span class="string">&quot;#checkbox&quot;</span>).is(<span class="string">&quot;:checked&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elem) &#123;</span><br><span class="line">      elem.classList.add(<span class="string">&#x27;shake&#x27;</span>)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; elem.classList.remove(<span class="string">&#x27;shake&#x27;</span>) &#125;, <span class="number">800</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：项目必须引入jQuery <code>&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;</code></p>
</blockquote>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.shake</span> &#123;</span><br><span class="line">   <span class="attribute">animation</span>: shake <span class="number">800ms</span> ease-in-out;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">@keyframes</span> shake &#123;</span><br><span class="line"></span><br><span class="line">   <span class="number">10%</span>,</span><br><span class="line">   <span class="number">90%</span> &#123;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">1px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="number">20%</span>,</span><br><span class="line">   <span class="number">80%</span> &#123;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(+<span class="number">2px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="number">30%</span>,</span><br><span class="line">   <span class="number">70%</span> &#123;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="number">40%</span>,</span><br><span class="line">   <span class="number">60%</span> &#123;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(+<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="number">50%</span> &#123;</span><br><span class="line">     <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>欢迎使用***系统<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logincontent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;login.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;login-box&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;login_form&quot;</span> <span class="attr">id</span>=<span class="string">&quot;login_form&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-item-wrap&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-label&quot;</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-item-wrap&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-label&quot;</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">id</span>=<span class="string">&quot;agree&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>同意<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;agreelink&quot;</span>&gt;</span>《用户协议》<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;submit()&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;<span class="comment">//监测同意协议是否点击</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">&quot;agree&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($(<span class="string">&quot;#checkbox&quot;</span>).is(<span class="string">&quot;:checked&quot;</span>));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!$(<span class="string">&quot;#checkbox&quot;</span>).is(<span class="string">&quot;:checked&quot;</span>)) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (elem) &#123;</span></span><br><span class="line"><span class="javascript">        elem.classList.add(<span class="string">&#x27;shake&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; elem.classList.remove(<span class="string">&#x27;shake&#x27;</span>) &#125;, <span class="number">800</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: <span class="number">5%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.logincontent</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding-top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.image</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">    size: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">    <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.pic</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">75%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.login-box</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">min-width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">min-height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="comment">/* border: 1px solid black; */</span></span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#login_form</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.login-title</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: cornflowerblue;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.form-item-wrap</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.form-label</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.form-input</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.agree</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.form-submit</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">40%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: <span class="number">24px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding-top</span>: <span class="number">2px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#00aff0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.agreelink</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.shake</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">animation</span>: shake <span class="number">800ms</span> ease-in-out;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="keyword">@keyframes</span> shake &#123;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="number">10%</span>,</span></span><br><span class="line"><span class="css">    <span class="number">90%</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">1px</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="number">20%</span>,</span></span><br><span class="line"><span class="css">    <span class="number">80%</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(+<span class="number">2px</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="number">30%</span>,</span></span><br><span class="line"><span class="css">    <span class="number">70%</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="number">40%</span>,</span></span><br><span class="line"><span class="css">    <span class="number">60%</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(+<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="number">50%</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">4px</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】删除有序数组中的重复项</title>
    <url>/2021/11/18/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>说明：</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>数组中的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。<br><b>双指针法：</b>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211118113717.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211118113752.png"><br>说明：当 nums[fast] === nums[slow] 时，代码中无需进行处理，只需要考虑 nums[fast] != nums[slow] 的情况。<br>当 nums[fast] != nums[slow] 时，slow前进 –&gt; nums[slow] 需要使用 nums[fast] 覆盖 –&gt; fast前进</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化快、慢指针</span></span><br><span class="line">    <span class="keyword">let</span> [fast, slow] = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (fast = <span class="number">0</span>; fast &lt; nums.length; ++fast)&#123;</span><br><span class="line">        <span class="comment">// 处理nums[fast] != nums[slow]的情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line">    <span class="comment">// slow表示的是数组元素下标，长度需要将其+1</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;table&gt;样式模板</title>
    <url>/2021/06/06/table%E6%A0%B7%E5%BC%8F%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>你必须非常努力 ，才能显得毫不费劲</p>
<h3 id="一、样式-1"><a href="#一、样式-1" class="headerlink" title="一、样式 1"></a>一、样式 1</h3><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210606203427.png" style="zoom:175%;" />
##### 1.1源代码：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>table标签样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Table标签样式<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>信息<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>阿里<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>阿里巴巴一般指阿里巴巴集团。阿里巴巴集团控股有限公司（简称：阿里巴巴集团）</span><br><span class="line">            是以曾担任英语教师的马云为首的18人于1999年在浙江省杭州市创立的公司。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>腾讯<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>腾讯于1998年11月成立,是一家以互联网为基础的平台公司,</span><br><span class="line">            通过技术丰富互联网用户的生活,助力企业数字化升级。我们的使命是“用户为本 科技向善”。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>百度是一家持续创新的,以“用科技让复杂世界更简单”为使命的高科技公司。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>字节跳动<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>字节跳动一般指北京字节跳动科技有限公司。北京字节跳动科技有限公司，</span><br><span class="line">            成立于2012年3月，是最早将人工智能应用于移动互联网场景的科技企业之一，</span><br><span class="line">            是中国北京的一家信息科技公司，地址位于北京市海淀区知春路甲48号。</span><br><span class="line">            公司以建设“全球创作与交流平台”为愿景<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/* div居中显示 */</span></span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-collapse</span>: collapse;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">    <span class="comment">/*对DIV设置margin:0 auto样式，</span></span></span><br><span class="line"><span class="comment"><span class="css">    是为了让DIV在浏览器中水平居中。布局居中、水平居中，</span></span></span><br><span class="line"><span class="comment"><span class="css">    均加入margin:0 auto即可。*/</span></span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table</span> <span class="selector-tag">td</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.table</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#cad9ea</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#666</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">table</span> <span class="selector-tag">thead</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#CCE8EB</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(odd) &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 奇数行 */</span></span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(even) &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 偶数行 */</span></span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#F5FAFA</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.table</span> <span class="selector-tag">td</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="1-2知识点："><a href="#1-2知识点：" class="headerlink" title="1.2知识点："></a>1.2知识点：</h5><p>（1）CSS3 :nth-child() 选择器<br>:nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类型。n 可以是数字、关键词或公式。</p>
<blockquote>
<p>用法 1：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210606205553.png"></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"> </span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>:<span class="number">#ccddff</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第三个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第四个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>注释：<span class="tag">&lt;/<span class="name">b</span>&gt;</span>Internet Explorer 不支持 :nth-child() 选择器。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>–存在的问题–<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210606210022.png"></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"> </span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)<span class="comment">/*没有起作用，因为页面的第一个子元素是&lt;h3&gt;*/</span></span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>:green;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)</span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>:red;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>:nth-child()演示<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第三个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第四个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>注释：<span class="tag">&lt;/<span class="name">b</span>&gt;</span>Internet Explorer 不支持 :nth-child() 选择器。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>用法 2：<br>Odd 和 even 是可用于匹配下标是奇数或偶数的子元素的关键词（第一个子元素的下标是 1）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210606210628.png"></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"> </span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(odd)</span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(even)</span></span><br><span class="line"><span class="css">&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第三个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第四个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>注释：<span class="tag">&lt;/<span class="name">b</span>&gt;</span>Internet Explorer 不支持 :nth-child() 选择器。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>。。。。。。未完待续</p>
]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>原生JavaScript实现call、apply和bind</title>
    <url>/2022/02/01/%E5%8E%9F%E7%94%9FJavaScript%E5%AE%9E%E7%8E%B0call%E3%80%81apply%E5%92%8Cbind/</url>
    <content><![CDATA[<h2 id="1-call方法"><a href="#1-call方法" class="headerlink" title="1. call方法"></a>1. call方法</h2><h4 id="1-1-call方法详解："><a href="#1-1-call方法详解：" class="headerlink" title="1.1 call方法详解："></a>1.1 call方法详解：</h4><ul>
<li>call()可以用来代替另一个对象，来调用它的方法</li>
<li>call()本质是<b style="background:#ffffcc">改变this的指向</b></li>
<li>call()真正强大的在于能够扩充目标函数的作用域</li>
<li>所谓的call的多重继承就是把自己的this指向多个目标函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call方法</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="string">&#x27;你好&#x27;</span>,</span><br><span class="line">  <span class="attr">s</span>: <span class="string">&#x27;2022年&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.n + <span class="built_in">this</span>.s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.fn.call(p) <span class="comment">// 你好2022年</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call方法带参数</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.n + <span class="built_in">this</span>.s + x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.fn.call(p, <span class="string">&#x27;加油向未来&#x27;</span>)<span class="comment">// 你好2022年加油向未来</span></span><br></pre></td></tr></table></figure>
<p>call的多重继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123; <span class="comment">//----&gt;父类</span></span><br><span class="line">  <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;<span class="comment">//----&gt;子类</span></span><br><span class="line">  fn1.call(<span class="built_in">this</span>);</span><br><span class="line">  fn3.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span> (<span class="params"></span>) </span>&#123; <span class="comment">//----&gt;父类</span></span><br><span class="line">  <span class="built_in">this</span>.fn3xx = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call简单实现多重继承&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _f = <span class="keyword">new</span> fn2();</span><br><span class="line">_f.say(<span class="string">&#x27;你好，未来&#x27;</span>); <span class="comment">//你好，未来</span></span><br><span class="line">_f.fn3xx(); <span class="comment">//call简单实现多重继承</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-模拟实现call"><a href="#1-2-模拟实现call" class="headerlink" title="1.2 模拟实现call"></a>1.2 模拟实现call</h4><p><a href="https://qw-null.github.io/2022/02/08/%E5%87%BD%E6%95%B0this%E7%9A%84%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99/#1-%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A">函数this的绑定规则</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220208224245.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220208224357.png"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端接口传值方式(body参数和query参数)</title>
    <url>/2021/10/13/%E5%89%8D%E7%AB%AF%E6%8E%A5%E5%8F%A3%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>前端通过接口向后端服务器请求数据，最常用到是Get请求和Post请求</p>
<ul>
<li>get请求只能传query参数，query参数都是拼在请求地址上的<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getMemberInfo</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;orgmanage/org/findMember/&#x27;</span> + id,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="comment">/* 获取用户信息 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/user/info&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123; token &#125;	<span class="comment">// params就是query参数</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>post可以传body和query两种形式的参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/user/login&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data,	<span class="comment">// data就是body参数</span></span><br><span class="line">    <span class="comment">//请求头部设置</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
  </entry>
  <entry>
    <title>变量提升和函数提升的优先级问题</title>
    <url>/2022/03/09/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>⭐ 首先在最开始介绍一下，JS中存在提升的原因？<br>JS引擎在读取代码时，进行两步操作：</p>
<ul>
<li>第一步：对整个JS代码进行读取解析</li>
<li>第二步：代码执行</li>
</ul>
<p>提升只会发生在第一步中，所以在代码执行之前，浏览器的解析器遇到变量名和函数声明时，会将其提升至当前作用域的最前面。</p>
<p><b style="background:yellow;">注意：</b></p>
<ol>
<li>上述提及的变量提升，只针对<code>var</code>声明的变量，使用<code>let</code>或<code>const</code>声明的变量不存在提升。</li>
<li>JS引擎严格规定句首用 <code>function</code> 的才能算作函数声明，其余的杂牌声明只能算作函数表达式.</li>
</ol>
<h2 id="变量提升-amp-函数提升"><a href="#变量提升-amp-函数提升" class="headerlink" title="变量提升 &amp; 函数提升"></a>变量提升 &amp; 函数提升</h2><ul>
<li>变量提升<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//&#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure>
上述代码相当于：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 只定义不声明就默认是undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line">a=<span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//hi</span></span><br></pre></td></tr></table></figure></li>
<li>函数提升<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">//f a()&#123;console.log(&#x27;hi&#x27;);&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);    <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述代码相当于：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b;<span class="comment">//undefined;</span></span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">//f a()&#123;console.log(&#x27;hi&#x27;);&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);    <span class="comment">//undefined</span></span><br><span class="line">b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二者的优先级"><a href="#二者的优先级" class="headerlink" title="二者的优先级"></a>二者的优先级</h2><ul>
<li>函数提升会优先于变量提升，而且不会被同名的变量覆盖。</li>
<li>但是，如果这个同名变量被赋值了，那函数变量就会被覆盖。</li>
<li>当二者同时存在时，会先指向函数声明。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">//f a() &#123;...&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a());    <span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">//1</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a());    <span class="comment">//报错，现在的函数a已经被赋值过后的变量a给覆盖了，无法再调用a()</span></span><br></pre></td></tr></table></figure>
上述代码相当于：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">//f a() &#123;...&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a());    <span class="comment">//2</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">//1</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a());    <span class="comment">//报错，现在的函数a已经被赋值过后的变量a给覆盖了，无法再调用a()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>牛客网上的一道题目：<br>以下代码执行之后，控制台的输出是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure>
<p>答案是:Number。<br>原因是函数提升优先级高于变量提升，先执行函数提升，再执行变量提升。执行完函数提升之后，又执行了变量提升并进行赋值操作。此时函数变量被覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure>
<p>答案是：function。<br>此时先执行了函数提升，又执行了变量提升，但是变量没有进行赋值，因此指向函数。【当二者同时存在时，会先指向函数声明】</p>
<h2 id="为什么会有提升？"><a href="#为什么会有提升？" class="headerlink" title="为什么会有提升？"></a>为什么会有提升？</h2><p>Dmitry Soshnikov早些年在twitter上提出关于变量提升的问题，同时Brendan Eich给出了一些解答：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310195643.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310195820.png"><br>答案的大致意思是由于第一代JS虚拟机中的抽象纰漏导致的，编译器将变量放入栈槽内并编入索引。然后在（当前作用域）入口处将变量名绑定到栈槽内的变量上。（注：这里提到的抽象是计算机术语，是对内部发生的更加复杂的事情的一种简化。）<br>随后，Dmitry Soshnikov又提到了函数提升，他提到了函数的相互递归。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310200629.png"><br>Brendan Eich又对其进行了解答。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310200809.png"><br>大致意思是函数提升就是为了解决函数相互递归问题，大体上可以解决像ML语言这样自下而上的顺序问题。</p>
<hr>
对于函数递归的一些阐述：

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证偶数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOdd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEven(<span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证奇数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEven(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于中间语句<code>console.log(isEven(2));</code>而言，它在执行的时候，<code>isOdd</code>函数还没有被声明，如果没有函数提升，那就必然会报错，这段程序就会陷入一种死循环的状态。</p>
<p>因此，在JS设计之初，就人为加入了函数提升。在代码执行时，将函数提升至当前作用域的顶部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证偶数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOdd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证奇数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEven(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isEven(<span class="number">2</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<hr>
最后，Brendan Eich还对变量提升和函数提升做了总结：

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310201531.png"><br>大概是说，变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。</p>
<h2 id="后续的补充"><a href="#后续的补充" class="headerlink" title="后续的补充"></a>后续的补充</h2><p>在stackoverflow中用户提出一道相关问题<a href="https://stackoverflow.com/questions/7506844/javascript-function-scoping-and-hoisting">Javascript function scoping and hoisting</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310201904.png"><br>大意就是他阅读了Ben Cherry写的一篇关于JS范围和提升的文章，对其中给出的一个案例存在疑惑，为什么代码执行结果是浏览器输出1？</p>
<p>然后下面有人对其问题进行了解答。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310202424.png"><br>函数提升意味着函数被移动到作用域的开头。（红框中的代码的执行过程实际上是绿框中代码的顺序）</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220310202714.png"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端路由模式：hash模式与history模式</title>
    <url>/2022/03/27/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%EF%BC%9Ahash%E6%A8%A1%E5%BC%8F%E4%B8%8Ehistory%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>前端会通过使用不同的URL向用户展示不同的页面，使得当我们想要访问一个页面时只要知道其URL地址，再浏览器地址栏中输入便会看到这个页面。但是在平时也会存在输入确定的URL地址却无法访问到页面的情况（出现404页面）。这实际上与前端的路由模式息息相关。</p>
<h2 id="🎸-0-为什么使用路由？"><a href="#🎸-0-为什么使用路由？" class="headerlink" title="🎸 0.为什么使用路由？"></a>🎸 0.为什么使用路由？</h2><p>Ajax异步请求可以实现页面的无缝刷新，导致浏览器地址栏的URL不会发生任何变化，破坏了用户的浏览体验。同时本次浏览的页面内容使用URL访问无法重新复现。<br>使用路由就可以很好的解决这个问题。单页面应用利用JS动态切换网页内容，避免页面重载；路由则提供浏览器地址的变化。二者结合以后，页面内容发生变化时浏览器地址也发生变化。</p>
<blockquote>
<p>SPA（Single Page Application），即<b>单页面应用</b>。所谓单页 Web 应用，就是只有一张 Web 页面的应用。单页应用程序 (SPA) 是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序。 浏览器一开始会加载必需的 HTML 、 CSS 和 JavaScript ，所有的操作都在这张页面上完成，都由 JavaScript 来控制。</p>
</blockquote>
<h2 id="🎸1-URL地址介绍"><a href="#🎸1-URL地址介绍" class="headerlink" title="🎸1.URL地址介绍"></a>🎸1.URL地址介绍</h2><p>URL属性介绍：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">location.protocal</td>
<td align="left">协议</td>
</tr>
<tr>
<td align="left">location.hostname</td>
<td align="left">主机名</td>
</tr>
<tr>
<td align="left">location.host</td>
<td align="left">主机</td>
</tr>
<tr>
<td align="left">location.port</td>
<td align="left">端口号</td>
</tr>
<tr>
<td align="left">location.patchname</td>
<td align="left">访问页面</td>
</tr>
<tr>
<td align="left">location.search</td>
<td align="left">搜索内容</td>
</tr>
<tr>
<td align="left">location.hash</td>
<td align="left">哈希值</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">以网址 <span class="string">&quot;http://127.0.0.1:8080/01-hash.html?a=1&amp;b=2#/aaa/bbb&quot;</span> 为例</span><br><span class="line">location.protocal ➡ <span class="string">&#x27;http:&#x27;</span></span><br><span class="line">location.hostname ➡ <span class="string">&#x27;127.0.0.1:&#x27;</span></span><br><span class="line">location.host ➡ <span class="string">&#x27;127.0.0.1:8080:&#x27;</span></span><br><span class="line">location.port ➡ <span class="string">&#x27;8080:&#x27;</span></span><br><span class="line">location.patchname ➡ <span class="string">&#x27;01-hash.html:&#x27;</span></span><br><span class="line">location.search ➡ <span class="string">&#x27;?a=1&amp;b=2&#x27;</span></span><br><span class="line">location.hash ➡ <span class="string">&#x27;#/aaa/bbb&#x27;</span></span><br></pre></td></tr></table></figure>


<h2 id="🎸-2-前端路由简介"><a href="#🎸-2-前端路由简介" class="headerlink" title="🎸 2.前端路由简介"></a>🎸 2.前端路由简介</h2><p>前端路由只有两种模式：<code>hash</code>模式和<code>history</code>模式。</p>
<h3 id="😺2-1-hash模式"><a href="#😺2-1-hash模式" class="headerlink" title="😺2.1 hash模式"></a>😺2.1 <code>hash</code>模式</h3><p>hash模式是一种把前端路由的路径使用<b> # </b>拼接在真实URL后面的模式。当<b> # </b>后的路由路径发生改变时，浏览器不会发起新的请求，而是触发<code>onhashchange</code>事件。</p>
<h4 id="2-1-1-特点"><a href="#2-1-1-特点" class="headerlink" title="2.1.1 特点"></a>2.1.1 特点</h4><ul>
<li><code>hash</code>变化会触发网页跳转，即浏览器的前进和后退。</li>
<li><code>hash</code>可以改变<code>URL</code>，但是不会触发页面重新加载（hash的变化是记录在<code>window.history</code>中），即不会刷新页面。因此所有的跳转都是在客户端进行操作，不算是一次 <code>http</code> 请求，所以这种模式不利于 <code>SEO</code> 优化。</li>
<li><code>hash</code>通过<code>window.onhashchange</code>的方式监听<code>hash</code>的改变，由此实现无刷新跳转。</li>
<li><b><code>hash</code>永远不会提交到服务器，只能在前端自生自灭</b>。</li>
</ul>
<h3 id="🐯2-2-history模式"><a href="#🐯2-2-history模式" class="headerlink" title="🐯2.2 history模式"></a>🐯2.2 <code>history</code>模式</h3><p>history模式是利用<code>history API</code>实现URL地址改变，网页内容随之改变。<code>history API</code>是由<code> H5</code>提供的新特性，允许开发者直接改变前端路由，即更新浏览器URL地址而<b>不重新发起请求</b>。</p>
<h4 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h4><ul>
<li><code>window.history</code>属性指向<code>History</code>对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。</li>
<li><code>History</code>对象保存了当前窗口访问过的所有页面网址。</li>
<li>由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。</li>
<li>浏览器工具栏的“前进”和“后退”按钮，其实就是对 <code>History</code> 对象进行操作。</li>
</ul>
<h4 id="2-2-2-特点-amp-存在问题"><a href="#2-2-2-特点-amp-存在问题" class="headerlink" title="2.2.2 特点 &amp; 存在问题"></a>2.2.2 特点 &amp; 存在问题</h4><p>对于 <code>history</code> 来说，主要有以下特点：</p>
<ul>
<li>新的 <code>url</code> 可以是与当前 <code>url</code> 同源的任意 <code>url</code> ，也可以是与当前 <code>url</code> 一样的地址，但是这样会导致的一个问题是，会把重复的这一次操作记录到栈当中。</li>
<li>通过 <code>history.state</code> ，添加任意类型的数据到记录中。</li>
<li>可以额外设置 <code>title</code> 属性，以便后续使用。</li>
<li>通过 <code>pushState</code> 、 <code>replaceState</code> 来实现无刷新跳转的功能。</li>
</ul>
<p>对于 <code>history</code> 来说，确实解决了不少 <code>hash</code> 存在的问题，但是也带来了新的问题。具体如下：</p>
<ul>
<li>使用 <code>history</code> 模式时，在对当前的页面进行刷新时，此时浏览器会重新发起请求。如果 <code>nginx</code> 没有匹配得到当前的 url ，就会出现 404 的页面。</li>
<li>在使用 <code>history</code> 模式时，需要<b>通过服务端来允许地址可访问</b>，如果没有设置，就很容易导致出现 404 的局面。</li>
</ul>
<h4 id="2-2-3-属性"><a href="#2-2-3-属性" class="headerlink" title="2.2.3 属性"></a>2.2.3 属性</h4><p>History对象主要有两个属性：<code>length</code>和<code>state</code>。</p>
<ul>
<li><code>History.length</code>：当前窗口访问过的网址数量（包括当前网页）</li>
<li><code>History.state</code>：History 堆栈最上层的状态值，通常是 <code>undefined</code>，即未设置。</li>
</ul>
<h4 id="2-2-4-方法"><a href="#2-2-4-方法" class="headerlink" title="2.2.4 方法"></a>2.2.4 方法</h4><p>5个方法：<code>History.back()</code>、<code>History.forward()</code>、<code>History.go()</code>、<code>History.pushState()</code>、<code>History.replaceState()</code></p>
<ul>
<li><code>History.back()</code>：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。</li>
<li><code>History.forward()</code>：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。</li>
<li><code>History.go()</code>：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。<code>history.go(-1)</code>相当于<code>history.back()</code>、<code>history.go(1)</code>相当于<code>history.forward()</code>、<code>history.go(0)</code>表示刷新当前页面。</li>
<li><code>History.pushState()</code>：该方法用于在历史记录中添加一条记录。执行该方法时不会触发刷新，只是会导致<code>History</code>对象发生变化，地址栏会有变化。<br>语法：<code>history.pushState(object, title, url)</code><br>该方法接受三个参数，依次为：</li>
<li><ul>
<li><code>object</code>：是一个对象，通过 pushState 方法可以将该对象内容传递到新页面中。如果不需要这个对象，此处可以填 null。</li>
</ul>
</li>
<li><ul>
<li><code>title</code>：指标题，几乎没有浏览器支持该参数，传一个空字符串比较安全。</li>
</ul>
</li>
<li><ul>
<li><code>url</code>：新的网址，必须与当前页面处在同一个域。不指定的话则为当前的路径，如果设置了一个跨域网址，则会报错。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line">history.pushState(data, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;2.html&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(history.state) <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p><b>注意：</b>如果 <code>pushState</code> 的 <code>URL</code> 参数设置了一个新的锚点值（即 <code>hash</code>），并不会触发 <code>hashchange</code> 事件。反过来，如果 <code>URL</code> 的锚点值变了，则会在 <code>History</code> 对象创建一条浏览记录。<br>如果 pushState() 方法设置了一个跨域网址，则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 当前网址为 http://example.com</span></span><br><span class="line">history.pushState(<span class="literal">null</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;https://baidu.com/hello&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>pushState</code> 想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。</p>
<ul>
<li><code>History.replaceState()</code>：该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">当前网页网址是 example.com/example.html。</span><br><span class="line"></span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;?page=1&#x27;</span>)</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=1</span></span><br><span class="line"></span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;?page=2&#x27;</span>);</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=2</span></span><br><span class="line"></span><br><span class="line">history.replaceState(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;?page=3&#x27;</span>);</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=3</span></span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=1</span></span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html</span></span><br><span class="line"></span><br><span class="line">history.go(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【leetcode】650.只有两个键的键盘</title>
    <url>/2021/09/19/%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<h2 id="650-只有两个键的键盘"><a href="#650-只有两个键的键盘" class="headerlink" title="650. 只有两个键的键盘"></a>650. 只有两个键的键盘</h2><p>最初记事本上只有一个字符 ‘A’ 。你每次可以对这个记事本进行两种操作：</p>
<ul>
<li>Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。</li>
<li>Paste（粘贴）：粘贴 上一次 复制的字符。</li>
</ul>
<p>给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 ‘A’ 。返回能够打印出 n 个 ‘A’ 的最少操作次数。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210919163546.png"></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210919173359.jpg"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSteps = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// n=1的情况</span></span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">// 质数情况</span></span><br><span class="line">        res[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">2</span>;j&lt;=<span class="built_in">Math</span>.sqrt(i);++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j === <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//合数情况</span></span><br><span class="line">                res[i] = res[j]+res[i/j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>判断一个数是否为素数：<br>判断该数在 2-√n 中是否有因数即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">Math</span>.sqrt(n);++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i===<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 不是素数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 是素数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>力扣Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>实现水平垂直居中[不知自身宽高情况]</title>
    <url>/2021/09/13/%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<p>translate()函数是css3的新特性。<b>在不知道自身宽高的情况下，可以利用它来进行水平垂直居中。</b></p>
<p>当使用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>; </span><br></pre></td></tr></table></figure>
<p>是以左上角为原点，故不处于中心位置。translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。</p>
<blockquote>
<p>与负margin-left和margin-top实现居中不同的是，margin-left必须知道自身的宽高，而translate可以在不知道宽高的情况下进行居中，tranlate（）函数中的百分比是相对于自身宽高的百分比，所以能进行居中。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">    -moz-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>【leetcode】找到需要补充粉笔的学生编号</title>
    <url>/2021/09/10/%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%85%E7%B2%89%E7%AC%94%E7%9A%84%E5%AD%A6%E7%94%9F%E7%BC%96%E5%8F%B7/</url>
    <content><![CDATA[<p>描述：一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。</p>
<p>给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。</p>
<p>请你返回需要 补充 粉笔的学生 编号 。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210910170244.png"></p>
<p>提示：</p>
<ul>
<li>chalk.length == n</li>
<li>1 &lt;= n &lt;= 105</li>
<li>1 &lt;= chalk[i] &lt;= 105</li>
<li>1 &lt;= k &lt;= 109</li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>思路：<br>1.学生需要粉笔总数 % 粉笔总数<br>2.将得到的结果依次减去学生需要粉笔总数（0 - n-1）,当结果&lt;0，此时i即为需要补充粉笔的同学编号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chalkReplacer = <span class="function"><span class="keyword">function</span>(<span class="params">chalk, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;<span class="comment">//存储chalk元素之和</span></span><br><span class="line">    <span class="keyword">let</span> tempk;<span class="comment">//保存k%sum</span></span><br><span class="line">    chalk.forEach(<span class="function">(<span class="params">i</span>)=&gt;</span>&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;)</span><br><span class="line">    tempk = k%sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;chalk.length;++i)&#123;</span><br><span class="line">        tempk -= chalk[i];</span><br><span class="line">        <span class="keyword">if</span>(tempk&lt;<span class="number">0</span>) <span class="keyword">return</span> i; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ39 平衡二叉树 [剑指offer]</title>
    <url>/2021/08/22/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210822195233.png"></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>（一）<br>计算左子树和右子树高度，判断二者高度差是否不大于1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsBalanced_Solution</span>(<span class="params">pRoot</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> l = getTreeDeep(pRoot.left);</span><br><span class="line">    <span class="keyword">let</span> r = getTreeDeep(pRoot.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(l-r)&lt;=<span class="number">1</span> &amp;&amp; IsBalanced_Solution(pRoot.left) &amp;&amp; IsBalanced_Solution(pRoot.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTreeDeep</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = getTreeDeep(root.left);</span><br><span class="line">    <span class="keyword">let</span> right = getTreeDeep(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (left&gt;right?left:right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>存在问题：节点重复遍历，影响效率</li>
</ul>
<p>（二）<br>改进策略：在求树的高度的同时判断是否平衡，如果不平衡返回-1，否则返回树的高度。<br>当左子树返回-1时，不需要再对右子树进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsBalanced_Solution</span>(<span class="params">pRoot</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getTreeDeep(pRoot)!==-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTreeDeep</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = getTreeDeep(root.left);</span><br><span class="line">    <span class="keyword">if</span>(left === -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> right = getTreeDeep(root.right);</span><br><span class="line">    <span class="keyword">if</span>(right === -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left-right)&gt;<span class="number">1</span> ? -<span class="number">1</span> : <span class="number">1</span> + (left&gt;right?left:right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ7 斐波那契数列[剑指offer]</title>
    <url>/2021/08/15/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210815144636.png"><br>[简单、动态规划]</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>斐波那契数列可以采用递归解法，但是递归法重复计算部分太多，因此选择使用动态规划解答。<br>动态规划的特点是：最优子结构、无后效性、子问题重叠。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [a,b] = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        b=a+b;</span><br><span class="line">        a=b-a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">Fibonacci</span> : Fibonacci</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ2 替换空格[剑指offer]</title>
    <url>/2021/08/19/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210819213607.png"><br>[简单、字符串、正则表达式]</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>法（一）：1.查找出空格  2.替换 【可能存在多个空格，因此需要循环】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceSpace</span>(<span class="params"> s </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;s.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] === <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            res += <span class="string">&#x27;%20&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法（二）：正则表达式（全局匹配）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceSpace</span>(<span class="params"> s </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/\s/g</span>,<span class="string">&#x27;%20&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>1.正则表达式 - 修饰符（标记）<br>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。<br>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/pattern/flags <span class="comment">//(其中，pattern为要匹配的内容，flags为修饰符)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210819214842.png"></p>
<p>2.新建正则对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regx = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> s.replace(regx,<span class="string">&#x27;%20&#x27;</span>);</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建vue项目</title>
    <url>/2021/10/25/%E6%90%AD%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1-搭建项目"><a href="#1-搭建项目" class="headerlink" title="1.搭建项目"></a>1.搭建项目</h2><h3 id="1-1使用Vue-UI搭建"><a href="#1-1使用Vue-UI搭建" class="headerlink" title="1.1使用Vue UI搭建"></a>1.1使用Vue UI搭建</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211025155720.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211025155936.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211025160332.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211025160951.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211025161257.png"></p>
]]></content>
      <categories>
        <category>Vue学习</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序[js版]</title>
    <url>/2021/09/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-js%E7%89%88/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>快速排序（Quicksort），简称快排。在平均状况下，排序n个项目要 O(nlogn) 次比较。在最坏状况下则需要O(n<sup>2</sup>)次比较，但这种状况并不常见。</p>
<p>快速排序使用分治法策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。</p>
<p>快速排序步骤为：</p>
<ul>
<li>1.挑选基准值：从数列中挑出一个元素，称为“基准”</li>
<li>2.分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成</li>
<li>3.递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li>
</ul>
<blockquote>
<p>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p>
</blockquote>
<p>【上述内容参考自<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">维基百科</a>】</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210906102722.jpg"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件：数组长度为0或1</span></span><br><span class="line">    <span class="keyword">if</span> (list.length === <span class="number">1</span> || list.length === <span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line">    <span class="comment">// 取数组中间位置索引以及元素</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="built_in">Math</span>.floor(list.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> currentItem = list.splice(index, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// leftList：存储小于中间元素的元素集合</span></span><br><span class="line">    <span class="comment">// rightList：存储大于中间元素的元素集合</span></span><br><span class="line">    <span class="keyword">let</span> leftList = [];</span><br><span class="line">    <span class="keyword">let</span> rightList = [];</span><br><span class="line">    list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item &lt;= currentItem) &#123;</span><br><span class="line">            leftList.push(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightList.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//打印每一次的流程</span></span><br><span class="line">    <span class="built_in">console</span>.log([leftList, currentItem, rightList]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickSort(leftList).concat(currentItem).concat(quickSort(rightList));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(list));</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210906110756.png"></p>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中第K个独一无二的字符串【Leetcode】</title>
    <url>/2022/02/19/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E4%B8%AA%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><b>独一无二的字符串</b> 指的是在一个数组中只出现过 <b>一次</b> 的字符串。</p>
<p>给你一个字符串数组 <code>arr</code> 和一个整数 <code>k</code> ，请你返回 <code>arr</code> 中第 <code>k</code> 个 <b>独一无二的字符串</b> 。如果 <b>少于</b> <code>k</code> 个独一无二的字符串，那么返回 <code>空字符串 &quot;&quot;</code> 。</p>
<p>注意，按照字符串在原数组中的 <b>顺序</b> 找到第 k 个独一无二字符串。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220219142148.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用Map统计数组中元素的个数，筛选Map中数量为1的键，将其放入数组中。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> kthDistinct = <span class="function"><span class="keyword">function</span>(<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> arr)&#123;</span><br><span class="line">        map.set(i,(map.get(i)|| <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// extra = extra || 0;</span></span><br><span class="line">        <span class="comment">// 如果extra 为undefined或者null,false, extra=0 ;否则为原值 --&gt; 很常见的非空判断。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(map)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> map)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item)</span><br><span class="line">        <span class="keyword">if</span>(item[<span class="number">1</span>] === <span class="number">1</span>) res.push(item[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res[k-<span class="number">1</span>]||<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220219142709.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220219142653.png"></p>
<h4 id="知识点-–-常见的非空判断"><a href="#知识点-–-常见的非空判断" class="headerlink" title="知识点 – 常见的非空判断"></a>知识点 – 常见的非空判断</h4><p><code>extra = extra || 0;</code></p>
<p>如果<code>extra</code> 为<code>undefined</code>或者<code>null</code>,<code>false</code>, <code>extra=0</code> ；否则为原值。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>最简分数</title>
    <url>/2022/02/11/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/simplified-fractions/">题目链接</a></p>
<p>给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于  n 的 最简 分数 。分数可以以 任意 顺序返回。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211105400.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目本意实际上是判断两个数是否为互质数，如果是则构成的分数返回。</p>
<p>判断两个数是否为互质数有两种方法：欧几里得算法和更相减损法。</p>
<ol>
<li>欧几里得算法<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211111302.png"><br>算法过程：大数放a中，小数放b中。大数除以小数，余数为零，则小数为最大公约数，不为零则将余数与b比较大的放a,小的放b,如此往复！</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//欧几里得算法（辗转相除法）</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(a&lt;b) [a,b] = [b,a];</span><br><span class="line">      <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b,a%b);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>更相减损法<br>算法过程：用两个数中的较大值减去较小值，直至两数相等，得到的相等的数就是两个数的最大公约数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更相减损法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GXJS</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) a-=b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;b) b-=a;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><ol>
<li><p>欧几里得算法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> simplifiedFractions = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//欧几里得算法（辗转相除法）</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;b) [a,b] = [b,a];</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res =[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gcd(i,j)===<span class="number">1</span>) res.push(i+<span class="string">&#x27;/&#x27;</span>+j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">                </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>更相减损法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> simplifiedFractions = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//更相减损法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">GXJS</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;b) a-=b;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;b) b-=a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res =[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">// if(gcd(i,j)===1) res.push(i+&#x27;/&#x27;+j);</span></span><br><span class="line">            <span class="keyword">if</span>(GXJS(i,j)===<span class="number">1</span>) res.push(i+<span class="string">&#x27;/&#x27;</span>+j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>本地项目上传至GitHub</title>
    <url>/2021/06/08/%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub/</url>
    <content><![CDATA[<p>当你遭受巨大痛苦时，你要懂得自己忍受，尽量不用你的痛苦去搅扰别人。</p>
<h2 id="0-需求说明"><a href="#0-需求说明" class="headerlink" title="0.需求说明"></a>0.需求说明</h2><p>本地创建项目，github上未存在该项目的repository，现在要将该项目上传至github。</p>
<h2 id="1-操作步骤"><a href="#1-操作步骤" class="headerlink" title="1.操作步骤"></a>1.操作步骤</h2><h4 id="1-1-GitHub中新建仓库"><a href="#1-1-GitHub中新建仓库" class="headerlink" title="1.1 GitHub中新建仓库"></a>1.1 GitHub中新建仓库</h4><p><em>注意：GitHub中新建的仓库名称需要与本地的项目文件夹的名称一致</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210609103848.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210609104142.png"></p>
<h4 id="1-2本地项目文件夹下运行命令"><a href="#1-2本地项目文件夹下运行命令" class="headerlink" title="1.2本地项目文件夹下运行命令"></a>1.2本地项目文件夹下运行命令</h4><p>点击“Git Bash Here”，打开git命令行。</p>
<blockquote>
<p>运行命令:</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&#x27;initproject&#x27;</span>(git commit -m <span class="string">&#x27;提交信息说明&#x27;</span>)</span><br><span class="line"></span><br><span class="line">git remote add origin 自己的项目地址</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>此时便已将本地项目上传至github</p>
]]></content>
      <categories>
        <category>GitHub使用</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210813183104.jpg"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210813183119.jpg"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210813183134.jpg"></p>
<h2 id="【补充点】"><a href="#【补充点】" class="headerlink" title="【补充点】"></a>【补充点】</h2><h3 id="1-JS创建正则表达式"><a href="#1-JS创建正则表达式" class="headerlink" title="1.JS创建正则表达式"></a>1.JS创建正则表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.字面量创建方式（两个斜杠之间的，都是用来描述规则的元字符）</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/\d+/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构造函数模式创建，有两个参数：元字符字符串，修饰符字符串</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\\d+&#x27;</span>)</span><br><span class="line"><span class="comment">//当需要把变量加入到正则表达式中时，不能使用字面量的方式创建，只能用构造函数去创建</span></span><br><span class="line"><span class="comment">// var patt=new RegExp(pattern,modifiers);</span></span><br><span class="line"><span class="comment">//pattern（模式） 描述了表达式的模式</span></span><br><span class="line"><span class="comment">//modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配</span></span><br></pre></td></tr></table></figure>
<h3 id="正则表达式由两部分组成"><a href="#正则表达式由两部分组成" class="headerlink" title="正则表达式由两部分组成"></a>正则表达式由两部分组成</h3><ul>
<li>元字符</li>
<li>修饰符</li>
</ul>
<h4 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.量词元字符：设置出现的次数</span></span><br><span class="line">*      零到多次</span><br><span class="line">+      一到多次</span><br><span class="line">?      零次或者一次</span><br><span class="line">&#123;n&#125;    出现n次</span><br><span class="line">&#123;n, &#125;  出现n到多次</span><br><span class="line">&#123;n, m&#125; 出现n到m次</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.特殊元字符：单个或者组合在一起代表特殊的含义</span></span><br><span class="line">\   转义字符（普通-&gt;特殊-&gt;普通）</span><br><span class="line">.   除\n(换行符)以外的任意字符</span><br><span class="line">^   以哪一个元字符作为开始</span><br><span class="line">$   以哪一个元字符作为结束</span><br><span class="line">\n  换行符</span><br><span class="line">\d  <span class="number">0</span>~<span class="number">9</span>之间的一个数字</span><br><span class="line">\D  非<span class="number">0</span>~<span class="number">9</span>之间的一个数字</span><br><span class="line">\w  数字、字母、下划线中的任意一个字符</span><br><span class="line">\W  非数字、字母、下划线中的任意一个字符</span><br><span class="line">\s  一个空白字符（包含空格、制表符、换页符等）</span><br><span class="line">\t  一个制表符（一个TAB键：四个空格）</span><br><span class="line">\b  匹配一个单词的边界</span><br><span class="line">x|y x或者y中的一个字符</span><br><span class="line">[xyz] x、y、z中的一个字符</span><br><span class="line">[^xy] 除了xy以外的任意一个字符</span><br><span class="line">[a-z] 指定a-z这个范围中的任意一个字符 [<span class="number">0</span>-9a-zA-Z_] === \w</span><br><span class="line">[^a-z] 除了a-z这个范围中的任意一个字符</span><br><span class="line">()     正则中的分组符号</span><br><span class="line">(?:)   只匹配不捕获</span><br><span class="line">(?=)   正向预查</span><br><span class="line">(?!)   负向预查</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.普通元字符：代表本身的含义</span></span><br><span class="line">/js/  此正则匹配的就是 <span class="string">&quot;js&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="常用修饰符：i-m-g"><a href="#常用修饰符：i-m-g" class="headerlink" title="常用修饰符：i m g"></a>常用修饰符：i m g</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">i: ignoreCase   忽略单词大小写匹配</span><br><span class="line"><span class="attr">m</span>: multiline    可以进行多行匹配</span><br><span class="line"><span class="attr">g</span>: <span class="built_in">global</span>       全局匹配</span><br><span class="line"></span><br><span class="line">/A/.test(<span class="string">&#x27;lalalala&#x27;</span>)    <span class="comment">//false</span></span><br><span class="line">/A/i.test(<span class="string">&#x27;lalalala&#x27;</span>)   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="元字符详细解析"><a href="#元字符详细解析" class="headerlink" title="元字符详细解析"></a>元字符详细解析</h4><blockquote>
<p>^ $</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^\d/</span>  <span class="comment">//必须以数字开头</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;js&#x27;</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;2021js&#x27;</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;js2021&#x27;</span>)) <span class="comment">//false</span></span><br><span class="line">----------------------------------------</span><br><span class="line">reg = <span class="regexp">/\d$/</span>  <span class="comment">//必须以数字结束</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;js&#x27;</span>))  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;2021js&#x27;</span>)) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;js2021&#x27;</span>)) <span class="comment">//true</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">//^ $两个都不加：字符串中包含符合规则的内容即可</span></span><br><span class="line">reg = <span class="regexp">/\d+/</span>：字符串中包含<span class="number">1</span>到多个数字即可</span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">//^ $两个都加：字符串只能是和规则一致的内容</span></span><br><span class="line">reg = <span class="regexp">/^\d+$/</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">//验证手机号（11为，以1开头）</span></span><br><span class="line">reg = <span class="regexp">/^1\d&#123;10&#125;$/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>\</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^2.3$/</span>   <span class="comment">// .不是小数点，是\n外的任意字符</span></span><br><span class="line">reg.test(<span class="string">&#x27;2.3&#x27;</span>)  <span class="comment">//true</span></span><br><span class="line">reg.test(<span class="string">&#x27;2@3&#x27;</span>)  <span class="comment">//true</span></span><br><span class="line">reg.test(<span class="string">&#x27;23&#x27;</span>)   <span class="comment">//false</span></span><br><span class="line">----------------------------------------</span><br><span class="line">reg = <span class="regexp">/^2\.3$/</span>    <span class="comment">//只能代表2.3了</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">//匹配&quot;\d&quot;</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;\\d&quot;</span>   <span class="comment">//在字符串中\也有特殊含义</span></span><br><span class="line">reg = <span class="regexp">/^\d$/</span>  <span class="comment">//不能匹配str</span></span><br><span class="line">reg = <span class="regexp">/^\\d$/</span></span><br><span class="line">reg.test(<span class="string">&quot;\\d&quot;</span>)  <span class="comment">//正确匹配str</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>x|y</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^18|29$/</span></span><br><span class="line">reg.test(<span class="string">&#x27;18&#x27;</span>)</span><br><span class="line">reg.test(<span class="string">&#x27;29&#x27;</span>)</span><br><span class="line">reg.test(<span class="string">&#x27;129&#x27;</span>)</span><br><span class="line">reg.test(<span class="string">&#x27;189&#x27;</span>)</span><br><span class="line">reg.test(<span class="string">&#x27;1829&#x27;</span>)</span><br><span class="line">reg.test(<span class="string">&#x27;829&#x27;</span>)</span><br><span class="line">reg.test(<span class="string">&#x27;182&#x27;</span>)</span><br><span class="line"><span class="comment">//以上结果全为true</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">//------直接x|y会存在很乱的优先级问题，可以用小括号处理 =&gt; 小括号：分组</span></span><br><span class="line">reg = <span class="regexp">/^(18|29)$/</span>  <span class="comment">//只能是18或者29</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[]</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 中括号中出现的字符一般都代表字符本身的含义</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[@+]+$/</span>   <span class="comment">//@或者+ 出现一到多次</span></span><br><span class="line"></span><br><span class="line">reg = <span class="regexp">/^[\d]$/</span>   <span class="comment">// \d在[]中代表0-9的一个数字</span></span><br><span class="line">reg = <span class="regexp">/^[\\d]$/</span>  <span class="comment">//  \ 或者 d</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">// 2. 中括号中不存在多位数</span></span><br><span class="line">reg = <span class="regexp">/^[18]$/</span>   <span class="comment">//只能匹配1或者8，不能匹配18</span></span><br><span class="line">reg = <span class="regexp">/^[10-29]$/</span>   <span class="comment">// 1或者0-2或者9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】求只包含两种元素的最长连续子序列</title>
    <url>/2022/01/29/%E6%B1%82%E5%8F%AA%E5%8C%85%E5%90%AB%E4%B8%A4%E7%A7%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">题目链接</a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220129182956.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220129183031.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220129183102.png"></p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>题目最终求解的是只包含两种元素的最长的连续子序列。<br>因此需要明确已下几点：</p>
<ul>
<li>如何保证水果的种类只有两种？</li>
<li>当子序列中水果种类已经有两种，如何删除旧的水果种类，添加新的水果种类？</li>
</ul>
<p>对于上述两个问题，答案如下：</p>
<p>设置一个保存水果种类的数组，初始化时填入第一棵树的水果种类。 <code> ftype = [fruits[0]]</code><br>当走到下一棵树时，先判断是否是已经保存的水果种类 <code>ftype.includes(fruits[j]</code>,如果没有包含，则存在下面两种情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 只有一种水果，将新的水果种类加入种类数组中</span></span><br><span class="line"><span class="keyword">if</span>(ftype.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    ftype[<span class="number">1</span>] = fruits[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 当前水果种类已经达到两种：去掉第一种水果，加入新的水果种类</span></span><br><span class="line"><span class="comment">// 此时就要用到第一种水果的结束位置这一变量</span></span><br><span class="line">i= firstFruit;<span class="comment">//更新开始采摘的位置（滑动窗口左边界）</span></span><br><span class="line">ftype[<span class="number">0</span>]=fruits[j-<span class="number">1</span>];</span><br><span class="line">ftype[<span class="number">1</span>]=fruits[j];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，解题时还要注意对于当前种类水果最后一个位置的保存。</p>
<h2 id="解题代码："><a href="#解题代码：" class="headerlink" title="解题代码："></a>解题代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> totalFruit = <span class="function"><span class="keyword">function</span>(<span class="params">fruits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;<span class="comment">//最终结果</span></span><br><span class="line">    <span class="keyword">let</span> subLen = <span class="number">0</span>;<span class="comment">//子序列长度（个数）</span></span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>;<span class="comment">//采摘开始的位置</span></span><br><span class="line">    <span class="keyword">let</span> firstFruit = <span class="number">0</span>;<span class="comment">//第一种水果的结束位置</span></span><br><span class="line">    <span class="keyword">let</span> ftype = [fruits[i]];<span class="comment">//采摘的水果种类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;fruits.length;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ftype.includes(fruits[j]))&#123;<span class="comment">//水果种类未包含</span></span><br><span class="line">            <span class="comment">// 两种情况：1.水果种类少于两种，记录</span></span><br><span class="line">            <span class="comment">// 2.水果种类多余两种</span></span><br><span class="line">            <span class="keyword">if</span>(ftype.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//水果种类少于两种</span></span><br><span class="line">                ftype[<span class="number">1</span>] = fruits[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//水果种类多余两种:去掉第一种水果，加入新的水果种类</span></span><br><span class="line">                i= firstFruit;<span class="comment">//更新开始采摘的位置（滑动窗口左边界）</span></span><br><span class="line">                ftype[<span class="number">0</span>]=fruits[j-<span class="number">1</span>];</span><br><span class="line">                ftype[<span class="number">1</span>]=fruits[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fruits[j]!==fruits[firstFruit])&#123;</span><br><span class="line">            <span class="comment">//更新第一种水果的结束位置</span></span><br><span class="line">            firstFruit = j;</span><br><span class="line">        &#125;</span><br><span class="line">        subLen=j-i+<span class="number">1</span>;</span><br><span class="line">        res = res&gt;subLen?res:subLen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="补充知识："><a href="#补充知识：" class="headerlink" title="补充知识："></a>补充知识：</h2><p><code>Array.includes()</code>方法用来判断一个数组是否包含一个指定的值。<br><code>arr.includes(searchElement, fromIndex)</code></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">searchElement</td>
<td align="left">必须。需要查找的元素值。</td>
</tr>
<tr>
<td align="left">fromIndex</td>
<td align="left">可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</td>
</tr>
</tbody></table>
<p>返回值：<br>包含元素返回true，不包含元素返回false。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词【Leetcode】</title>
    <url>/2022/02/28/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <code>s</code> 和 <code>t </code>，编写一个函数来判断 <code>t </code>是否是 <code>s</code> 的字母异位词。</p>
<p>注意：若<code>s</code>和 <code>t </code>中每个字符出现的次数都相同，则称 <code>s </code>和 <code>t </code>互为字母异位词。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228202029.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>解体的关键在于：统计出包含元素的种类以及包含元素的个数。<br>因此，可以维护一个长度为26的数组【原因：<code>s</code>和<code>t</code>仅包含小写字母】，数组的每一项分别表示<code>a-z</code>中的一项，数组每一项的值代表出现的次数。</p>
<p>要点：</p>
<ul>
<li><p>如何将字符串的单个字符转换为数字？<br>借助JavaScript的 <code>charCodeAt()</code> 方法。<br>charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。<br>语法：<code>stringObject.charCodeAt(index)</code><br><b>注释：</b>字符串中第一个字符的下标是 0。如果 index 是负数，或大于等于字符串的长度，则 charCodeAt() 返回 NaN。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.charCodeAt()); <span class="comment">// 97  [ a的ASCII码 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(s.charCodeAt(<span class="number">1</span>)); <span class="comment">// 98 [ b的ASCII码 ]</span></span><br></pre></td></tr></table></figure></li>
<li><p>补充点：如何将数字（ASCII码）转换为字符？<br>使用JS的<code>fromCharCode</code>方法<br>语法：<code>String.fromCharCode(num1[, ...[, numN]])</code><br>参数<code>num1, ..., numN</code>：一系列 UTF-16 代码单元的数字。范围介于 0 到 65535（0xFFFF）之间。大于 0xFFFF 的数字将被截断。不进行有效性检查。<br>返回值：一个长度为 N 的字符串，由 N 个指定的 UTF-16 代码单元组成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">97</span>;</span><br><span class="line"><span class="built_in">String</span>.fromCharCode(num);  <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">String</span>.fromCharCode(num1);  <span class="comment">// &#x27;d&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length!==t.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> a = <span class="string">&#x27;a&#x27;</span>.charCodeAt(); <span class="comment">//获取a的ASCII码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s)&#123;</span><br><span class="line">        arr[i.charCodeAt()-a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j <span class="keyword">of</span> t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!arr[j.charCodeAt()-a]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        arr[j.charCodeAt()-a]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><p>给你一个字符串数组，请你将 <b>字母异位词</b> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><b>字母异位词</b> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301095554.png"></p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>统计字符串数组每一项的字母出现的次数，并且以此作为键，具有相同键值的元素作为该键的值，就是字母异位词。<br>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301100250.png"></p>
<h4 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> strs)&#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> item)&#123;</span><br><span class="line">            count[i.charCodeAt()-<span class="string">&#x27;a&#x27;</span>.charCodeAt()]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map[count])&#123;</span><br><span class="line">            map[count].push(item);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map[count] = [item];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(map);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>Object.values()方法</p>
<p>返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>
<p>语法：<code>Object.values(obj)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220301101119.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// [&#x27;bar&#x27;, 42]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于数组的对象，具有随机键排序</span></span><br><span class="line"><span class="comment">// 当我们使用数字键时，按照数字键的顺序返回数值。</span></span><br><span class="line"><span class="keyword">var</span> an_obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(an_obj)); <span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFoo 是不可枚举的属性</span></span><br><span class="line"><span class="keyword">var</span> my_obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123; <span class="attr">getFoo</span>: &#123; <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.foo; &#125; &#125; &#125;);</span><br><span class="line">my_obj.foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(my_obj)); <span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非对象参数将被强制转换为对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>【leetcode】比较版本号</title>
    <url>/2021/09/03/%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h2><p>描述：给你两个版本号 version1 和 version2 ，请你比较它们。</p>
<p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p>
<p>返回规则如下：</p>
<ul>
<li>如果 version1 &gt; version2 返回 1，</li>
<li>如果 version1 &lt; version2 返回 -1，</li>
<li>除此之外返回 0。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210903142913.png"></p>
<p>提示：</p>
<ul>
<li>1 &lt;= version1.length, version2.length &lt;= 500</li>
<li>version1 和 version2 仅包含数字和 ‘.’</li>
<li>version1 和 version2 都是 有效版本号</li>
<li>version1 和 version2 的所有修订号都可以存储在 32 位整数 中</li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>思路：</p>
<ul>
<li>1.通过.将字符串进行分割，得到数组</li>
<li>2.取二者的最大长度，作为数组长度，不足长度的使用 0 补全</li>
<li>3.比较数组相同位置的元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> compareVersion = <span class="function"><span class="keyword">function</span>(<span class="params">version1, version2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.通过.将字符串进行分割</span></span><br><span class="line">    <span class="keyword">let</span> v1 = version1.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> v2 = version2.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 2.取二者的最大长度，作为数组长度</span></span><br><span class="line">    <span class="keyword">let</span> len = (v1.length&gt;v2.length ? v1.length:v2.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="comment">// 不足长度的使用 0 补全</span></span><br><span class="line">        <span class="keyword">let</span> num1 = v1[i]?<span class="built_in">parseInt</span>(v1[i]):<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> num2 = v2[i]?<span class="built_in">parseInt</span>(v2[i]):<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 3.比较数组相同位置的元素</span></span><br><span class="line">        <span class="keyword">if</span>(num1&gt;num2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num1&lt;num2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有位置都比较完成，表明二者一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>力扣Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>有序数组中的单一元素【Leetcode】</title>
    <url>/2022/02/14/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0-Leetcode/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">题目链接</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p>
<p>请你找出并返回只出现一次的那个数。</p>
<p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214202717.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求解决方案必须满足 <code>O(log n)</code> 时间复杂度，可以使用二分查找解题。</p>
<p>对于子序列而言，可以通过子序列长度来判断结果是否存在。</p>
<ul>
<li>如果长度为 偶数 ，则结果 不存在</li>
<li>如果长度为 奇数 ，则结果 存在 【因为成双成对的元素中存在一个单身狗】</li>
</ul>
<p>在二分查找过程中存在3种情况：</p>
<ol>
<li>中间元素就是结果，此时 <code>nums[mid]!==nums[mid-1] &amp;&amp; nums[mid]!==nums[mid+1]</code>【最好的情况了】</li>
<li>中间元素与前一个元素相同，此时 <code>nums[mid]===nums[mid-1]</code></li>
<li>中间元素与后一个元素相同，此时 <code>nums[mid]===nums[mid+1]</code><br>对于2,3两种情况，需要通过左右两个子序列的长度判断结果存在哪一侧。</li>
</ol>
<p>当结束二分查找还没有返回结果，那么此时一定是<code>left&gt;right</code>，那么结果就是<code>nums[right]</code></p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNonDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//必须满足 O(log n) 时间复杂度 --&gt; 二分查找</span></span><br><span class="line">    <span class="comment">//对于子序列而言：偶数-&gt;不存在，奇数-&gt;存在</span></span><br><span class="line">    <span class="keyword">let</span> [left,right]=[<span class="number">0</span>,nums.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left+(right-left&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]===nums[mid-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="comment">//此时要判断两边的长度是奇数还是偶数</span></span><br><span class="line">            <span class="keyword">if</span>((right-mid)%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">                right = mid-<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]===nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid-left)%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">                left = mid+<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[right];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="更多的思考"><a href="#更多的思考" class="headerlink" title="更多的思考"></a>更多的思考</h2><p>其实如果抛开题目要求的解决方案必须满足 <code>O(log n)</code> 时间复杂度，还可以采取位运算的方法。</p>
<h4 id="异或操作"><a href="#异或操作" class="headerlink" title="异或操作"></a>异或操作</h4><p>异或是一种基于二进制的位运算，用符号<code>XOR</code>或者 <code>^</code> 表示，其运算法则是对运算符两侧数的每一个二进制位进行比较，同值取0，异值取1。</p>
<p>例如：<code>1^4=3</code> —&gt; <code>(001) ^ (100) = (101)</code></p>
<p><b>异或操作的运算法则</b></p>
<ol>
<li>a ^ b = b ^ a</li>
<li>a ^ b ^ c = (a ^ b) ^ c = a ^ (b ^ c)</li>
<li>d = a ^ b ^ c 可以推出 a = d ^ b ^c</li>
<li>a ^ b ^ a = b 【<em>很重要的一个性质</em>】</li>
</ol>
<p><b>异或操作的典型题目</b></p>
<p>Q1: 对于一个有多个数值的数组，只有一个是唯一的，其他都是成对的，怎样快速找到这个唯一值。</p>
<p>其实就是这道题目的另一种说法，因此本题抛开时间复杂度的话，还可以使用异或操作的方法解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNonDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        res^=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Q2: 给你1-1000个连续自然数，然后从中随机去掉两个，再打乱顺序，要求只遍历一次，求出被去掉的两个数。</p>
<p>方法1：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214210137.png"><br>方法2：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214210512.png"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网ACM模式输入输出</title>
    <url>/2022/02/14/%E7%89%9B%E5%AE%A2%E7%BD%91ACM%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<blockquote>
<p>凡事预则立，不预则废。</p>
</blockquote>
<p><a href="https://ac.nowcoder.com/acm/contest/5657">练习地址</a></p>
<h2 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A + B (1)"></a>A + B (1)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214221602.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = readline())&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = line.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">parseInt</span>(lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">parseInt</span>(lines[<span class="number">1</span>]);</span><br><span class="line">    print(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-2"><a href="#A-B-2" class="headerlink" title="A + B (2)"></a>A + B (2)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214222656.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> len = readline();</span><br><span class="line"><span class="keyword">while</span>(len--)&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = readline().split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">parseInt</span>(lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">parseInt</span>(lines[<span class="number">1</span>]);</span><br><span class="line">    print(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-3"><a href="#A-B-3" class="headerlink" title="A + B (3)"></a>A + B (3)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220214224250.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = readline())&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = line.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">parseInt</span>(lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">parseInt</span>(lines[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(a===<span class="number">0</span> &amp;&amp; b===<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    print(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-4"><a href="#A-B-4" class="headerlink" title="A + B (4)"></a>A + B (4)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220215231917.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220215232009.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = readline())&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = line.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = <span class="built_in">parseInt</span>(lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">        res += <span class="built_in">parseInt</span>(lines[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    print(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="A-B-5"><a href="#A-B-5" class="headerlink" title="A + B (5)"></a>A + B (5)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220215232728.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220215232745.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> len = readline();</span><br><span class="line"><span class="keyword">while</span>(len--)&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = readline().split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> end = <span class="built_in">parseInt</span>(lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=end;++i)&#123;</span><br><span class="line">        res += <span class="built_in">parseInt</span>(lines[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    print(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="A-B-6"><a href="#A-B-6" class="headerlink" title="A + B (6)"></a>A + B (6)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220145030.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220145111.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = readline())&#123;</span><br><span class="line">    <span class="keyword">let</span> lines = line.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> len = (lines[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">        sum += <span class="built_in">parseInt</span>(lines[len+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    print(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="A-B-7"><a href="#A-B-7" class="headerlink" title="A + B (7)"></a>A + B (7)</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220145904.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220145920.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = readline())&#123;</span><br><span class="line">    lines = line.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(lines[<span class="number">0</span>])===<span class="number">0</span>)&#123;</span><br><span class="line">        print(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;lines.length;++i)&#123;</span><br><span class="line">        sum += <span class="built_in">parseInt</span>(lines[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    print(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串排序（1）"><a href="#字符串排序（1）" class="headerlink" title="字符串排序（1）"></a>字符串排序（1）</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220152332.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220152405.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> len = readline();</span><br><span class="line"><span class="keyword">let</span> arr = readline().split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">print(arr.sort().join(<span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="字符串排序（2）"><a href="#字符串排序（2）" class="headerlink" title="字符串排序（2）"></a>字符串排序（2）</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220182815.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220182905.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = readline())&#123;</span><br><span class="line">    lines = line.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    print(lines.sort().join(<span class="string">&#x27; &#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串排序（3）"><a href="#字符串排序（3）" class="headerlink" title="字符串排序（3）"></a>字符串排序（3）</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220184015.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220220184036.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(line = readline())&#123;</span><br><span class="line">    lines = line.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    print(lines.sort().join(<span class="string">&#x27;,&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>牛客网输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title>统计元素出现的次数【Leetcode刷题心得】</title>
    <url>/2022/02/28/%E7%BB%9F%E8%AE%A1%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97%E3%80%91/</url>
    <content><![CDATA[<h2 id="0-情景模拟"><a href="#0-情景模拟" class="headerlink" title="0.情景模拟"></a>0.情景模拟</h2><p>在日常刷题过程中，通常会对字符串或者数组中的元素进行处理，在处理过程中，往往需要统计其中元素出现的次数，因此，本文主要记录日常自己使用的相关方法。</p>
<h2 id="1-对字符串的处理"><a href="#1-对字符串的处理" class="headerlink" title="1.对字符串的处理"></a>1.对字符串的处理</h2><p>以字符串 <code>s = &#39;abcabcaadcce&#39;</code>为例。</p>
<h4 id="1-1-统计字符串s中元素出现的次数"><a href="#1-1-统计字符串s中元素出现的次数" class="headerlink" title="1.1 统计字符串s中元素出现的次数"></a>1.1 统计字符串<code>s</code>中元素出现的次数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcabcaadcce&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.统计字符出现的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; ++i) &#123;</span><br><span class="line">  <span class="keyword">let</span> key = s[i];</span><br><span class="line">  <span class="keyword">if</span> (obj[key]) &#123;</span><br><span class="line">    obj[key]++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj[key] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;统计结果：&#x27;</span>, obj);</span><br></pre></td></tr></table></figure>
<p>统计结果： { a: 4, b: 2, c: 4, d: 1, e: 1 }</p>
<h4 id="1-2-遍历统计对象-键-gt-值"><a href="#1-2-遍历统计对象-键-gt-值" class="headerlink" title="1.2 遍历统计对象(键-&gt;值)"></a>1.2 遍历统计对象(键-&gt;值)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;键：&#x27;</span>, i, <span class="string">&#x27; -&gt; 值：&#x27;</span>, obj[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>键： a  -&gt; 值： 4<br>键： b  -&gt; 值： 2<br>键： c  -&gt; 值： 4<br>键： d  -&gt; 值： 1<br>键： e  -&gt; 值： 1</p>
<h4 id="1-3-对元素出现的次数进行排序"><a href="#1-3-对元素出现的次数进行排序" class="headerlink" title="1.3 对元素出现的次数进行排序"></a>1.3 对元素出现的次数进行排序</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrObj = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  arrObj.push([i, obj[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj转arrObj:&#x27;</span>, arrObj)</span><br><span class="line"></span><br><span class="line">arrObj.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;排序后的结果：&#x27;</span>, arrObj);</span><br></pre></td></tr></table></figure>

<p>obj转arrObj: [ [ ‘a’, 4 ], [ ‘b’, 2 ], [ ‘c’, 4 ], [ ‘d’, 1 ], [ ‘e’, 1 ] ]<br>排序后的结果： [ [ ‘d’, 1 ], [ ‘e’, 1 ], [ ‘b’, 2 ], [ ‘a’, 4 ], [ ‘c’, 4 ] ]</p>
<h4 id="1-4-删除满足条件的元素"><a href="#1-4-删除满足条件的元素" class="headerlink" title="1.4 删除满足条件的元素"></a>1.4 删除满足条件的元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">delete</span> obj[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;删除后的结果&#x27;</span>, obj)</span><br></pre></td></tr></table></figure>

<p>删除后的结果 { b: 2, c: 4, d: 1, e: 1 }</p>
<h2 id="2-对数组的处理"><a href="#2-对数组的处理" class="headerlink" title="2.对数组的处理"></a>2.对数组的处理</h2><p>以数组 <code>arr = [1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 8, 8, 9]</code> 为例。</p>
<h4 id="2-1-统计数组中元素出现的次数"><a href="#2-1-统计数组中元素出现的次数" class="headerlink" title="2.1 统计数组中元素出现的次数"></a>2.1 统计数组中元素出现的次数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">  <span class="keyword">let</span> key = arr[i];</span><br><span class="line">  <span class="keyword">if</span> (obj[key]) &#123;</span><br><span class="line">    obj[key]++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj[key] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;统计结果：&#x27;</span>, obj);</span><br></pre></td></tr></table></figure>
<p>统计结果： { ‘1’: 2, ‘2’: 3, ‘3’: 4, ‘4’: 1, ‘8’: 2, ‘9’: 1 }</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>刷题技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>移除链表元素</title>
    <url>/2022/02/10/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">题目链接</a></p>
<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点。</p>
<p>示例1：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220210195551.png"></p>
<p><b>输入：</b> head = [1,2,6,3,4,5,6], val = 6<br><b>输出：</b> [1,2,3,4,5]</p>
<p>示例2：<br><b>输入：</b> head = [], val = 1<br><b>输出：</b> []</p>
<p>示例3：<br><b>输入：</b> head = [7,7,7,7], val = 7<br><b>输出：</b> []</p>
<p>提示：</p>
<ul>
<li>列表中的节点数目在范围 [0, 104] 内</li>
<li>1 &lt;= Node.val &lt;= 50</li>
<li>0 &lt;= val &lt;= 50</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题目实际上就是删除链表中特定值的节点。</p>
<p>单链表删除节点的操作是将节点.next指向下下个节点，因此如果直接遍历当前节点的话，需要进行记忆当前节点的前一个节点。</p>
<p><b>😊虚拟头节点</b></p>
<p>对此，我们不妨换种思路，如果直接遍历当前节点的下一个节点则不必再去记忆当前节点的前一个节点，但同时会产生一个问题，就是如果当前单链表没有节点，则cur.next不存在。另外如果需要移除的节点是头节点，则操作比起删除其他节点会麻烦一些。解决办法是虚拟一个头节点。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElements = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head); <span class="comment">//避免head为空时，cur.next不存在以及删除头节点操作繁琐</span></span><br><span class="line">    <span class="keyword">let</span> cur = res;</span><br><span class="line">    <span class="keyword">while</span>(cur.next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next.val === val)&#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;<span class="comment">//虚拟头节点之后，结果需要去掉虚拟的头节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式【Observer】</title>
    <url>/2022/04/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E3%80%90Observer%E3%80%91/</url>
    <content><![CDATA[<h1 id="1-观察者模式是什么？"><a href="#1-观察者模式是什么？" class="headerlink" title="1. 观察者模式是什么？"></a>1. 观察者模式是什么？</h1><p>观察者模式，通常又被称为<b>发布订阅者模式</b>或<b>消息机制</b>。<br>它定义了对象间的一种一对多的依赖关系，只要当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新，解决了主体对象与观察者之间功能的耦合，即一个对象改变给其他对象通知的问题。</p>
<h1 id="2-观察者模式中二者分工"><a href="#2-观察者模式中二者分工" class="headerlink" title="2.观察者模式中二者分工"></a>2.观察者模式中二者分工</h1><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220414103356.png"></p>
<h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer_id = <span class="number">0</span>, observed_id = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">观察者类 -- 订阅者</span></span><br><span class="line"><span class="comment">实现功能：构造函数、更新自身的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = observer_id++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update (ob) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;观察者&#x27;</span>, <span class="built_in">this</span>.id, <span class="string">&#x27;检测到被观察者&#x27;</span>, ob.id, <span class="string">&#x27;的变化&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">被观察者类 -- 发布者</span></span><br><span class="line"><span class="comment">实现功能：构造函数、添加观察者方法、删除观察者方法、通知每一个观察者的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observed</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observerList = [];</span><br><span class="line">    <span class="built_in">this</span>.id = observed_id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加观察者</span></span><br><span class="line">  addObserver (ob) &#123;</span><br><span class="line">    <span class="built_in">this</span>.observerList.push(ob);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除观察者</span></span><br><span class="line">  removeObserver (ob) &#123;</span><br><span class="line">    <span class="built_in">this</span>.observerList = <span class="built_in">this</span>.observerList.filter(<span class="function"><span class="params">o</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> o.id != ob.id;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有观察者</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="built_in">this</span>.observerList.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.update(<span class="built_in">this</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obs_d = <span class="keyword">new</span> Observed();</span><br><span class="line"><span class="keyword">let</span> obs_1 = <span class="keyword">new</span> Observer(), obs_2 = <span class="keyword">new</span> Observer();</span><br><span class="line"></span><br><span class="line">obs_d.addObserver(obs_1);</span><br><span class="line">obs_d.addObserver(obs_2);</span><br><span class="line"></span><br><span class="line">obs_d.notify();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;-----------------&#x27;</span>)</span><br><span class="line">obs_d.removeObserver(obs_1);</span><br><span class="line">obs_d.notify();</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220414103913.png"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表【Leetcode】</title>
    <url>/2022/02/24/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E3%80%90Leetcode%E3%80%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220224221951.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220224222027.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目需要解决两个问题：</p>
<ol>
<li>如何判断链表中有环？</li>
<li>链表存在环，如何查找到入口？</li>
</ol>
<p><b>如何判断链表中有环？</b><br>可以采用快慢指针法，慢指针一次走一步，快指针一次走两步，如果链表中存在环，两指针一定会在环内相遇。</p>
<p><b>链表存在环，如何查找到入口？</b></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20220224221327.jpg"></p>
<p>这表明，<b>从头结点出发一个指针，从相遇结点 也出发一个指针，这两个指针每次只走一个结点， 那么当这两个指针相遇的时候就是 环形入口的结点。</b></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [fast,slow] = [head,head];</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.next)&#123;</span><br><span class="line">        <span class="comment">// slow+1，fast+2，一定会相遇，相遇就要抓住相遇点</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">            <span class="keyword">let</span> meet = fast; <span class="comment">// 相遇点</span></span><br><span class="line">            <span class="keyword">let</span> start = head; <span class="comment">// 开始节点</span></span><br><span class="line">            <span class="keyword">while</span>(meet !== start)&#123;</span><br><span class="line">                meet = meet.next;<span class="comment">// 相遇点指针</span></span><br><span class="line">                start = start.next; <span class="comment">// 头节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> meet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>表格删除选中数据的二三事</title>
    <url>/2022/03/31/%E8%A1%A8%E6%A0%BC%E5%88%A0%E9%99%A4%E9%80%89%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="0-需求场景"><a href="#0-需求场景" class="headerlink" title="0.需求场景"></a>0.需求场景</h2><p>最近项目中遇到一个问题，删除表格中选中的数据【注意：选中过程中不能删除，只能在最终点击删除按钮时，执行删除操作】。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220331103520.png"></p>
<h2 id="1-需求转化"><a href="#1-需求转化" class="headerlink" title="1.需求转化"></a>1.需求转化</h2><p>实际上这个问题相当于一道算法题目。<br>给定一个数组<code>A = [9,8,7,6,5,4,2,3,1]</code>和表示数组下标的数组<code>B = [2,4,3]</code>，请删除<code>A</code>中下标在<code>B</code>中的元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>这道问题的难点在于删除数组元素时，需要保证每次删除数组元素时，数组元素的位置不能变。</p>
<p>解决问题的思路：</p>
<ol>
<li>使用<code>Array.filter()</code></li>
</ol>
<p>先将数组进行重新封装，封装成如下格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  <span class="attr">&quot;value&quot;</span> : xxx,</span><br><span class="line">  <span class="attr">&quot;index&quot;</span> : xxx </span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>然后使用<code>Array.filter()</code>进行删除元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">productId</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">productName</span>: <span class="string">&#x27;电视机&#x27;</span>,</span><br><span class="line">        <span class="attr">num</span>: <span class="number">20</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="attr">productId</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">productName</span>: <span class="string">&#x27;洗衣机&#x27;</span>,</span><br><span class="line">        <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="attr">productId</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">productName</span>: <span class="string">&#x27;冰箱&#x27;</span>,</span><br><span class="line">        <span class="attr">num</span>: <span class="number">50</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="attr">productId</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">productName</span>: <span class="string">&#x27;空调&#x27;</span>,</span><br><span class="line">        <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">    arr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item.num != <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220331132547.png"></p>
<ol start="2">
<li>使用<code>map.has()</code><br>将数组<code>B</code>转化为<code>map</code>，循环数组<code>A</code>，判断数组<code>A</code>的下标值是否包含在数组<code>B</code>转化的<code>map</code>中。</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>【leetcode】长度最小的子数组</title>
    <url>/2022/01/28/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%90leetcode%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">题目链接</a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。<br>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr] </code>，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220128221650.png"></p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><ol>
<li><p>方法一：暴力解法<br>通过两个for循环，找出所有满足和 ≥ target的情况，然后取最小值。时间复杂度为O($ n^2 $)。</p>
</li>
<li><p>方法二：滑动窗口法<br>所谓的滑动窗口就是不断调节子序列的起始位置和终止位置，从而得出想要的结果。</p>
</li>
</ol>
<p>模式说明：<br>输入是一个数组或字符串，求解的结果是具有某种特质的子数组或子字符串。这种情况下下，可以使用滑动窗口的方法求解。</p>
<p>应用滑动窗口的<b>注意事项</b>：</p>
<ul>
<li>可以通过两个指针来标识窗口的边界</li>
<li>窗口的长度可固定也可改变，取决于求解问题的性质</li>
<li>维护一个或一组和窗口相关联的状态变量，能有效降低计算量和算法复杂度</li>
</ul>
<h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><p>方法一：暴力解法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span>(<span class="params">target, nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="built_in">Number</span>.MAX_VALUE; <span class="comment">// 存放最终结果,找最小的值-&gt;初始值应为最大的数</span></span><br><span class="line">    <span class="keyword">let</span> [sum,subLen] = [<span class="number">0</span>,<span class="number">0</span>];<span class="comment">//子序列的和，长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="comment">//当子序列的值&gt;=target</span></span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">                subLen = j-i+<span class="number">1</span>;</span><br><span class="line">                res = res&lt;subLen?res:subLen;<span class="comment">//取满足要求的最小长度</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res===<span class="built_in">Number</span>.MAX_VALUE?<span class="number">0</span>:res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：滑动窗口法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span>(<span class="params">target, nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 子序列之和，子序列长度，最终结果</span></span><br><span class="line">    <span class="keyword">let</span> [sum,subLen,res]=[<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">Number</span>.MAX_VALUE];</span><br><span class="line">    <span class="comment">//*定义子序列起始位置【窗口开始位置】</span></span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">            subLen=j-i+<span class="number">1</span>;</span><br><span class="line">            res = res&lt;subLen?res:subLen;</span><br><span class="line">            sum-=nums[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res!==<span class="built_in">Number</span>.MAX_VALUE?res:<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/09/24/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210924102353.png"></p>
<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>链表（Linked List）是一种物理存储单元上<b style="color:red;">非连续、非顺序</b>的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的，由一系列节点组成。<br>每个节点包含两部分：1.存储数据元素的数据域；2.存储下一个节点地址的指针域。3.最后一个节点的指针域指向null。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210924102803.png"></p>
<ul>
<li>data 表示节点存放的数据</li>
<li>next 表示下一个节点指向的内存空间</li>
</ul>
<h4 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h4><p>代码表示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedNode</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.val = node;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// val表示该节点上存储的值</span></span><br><span class="line"><span class="comment">// next表示该节点的下一个节点</span></span><br><span class="line"><span class="comment">// 一般的单向链表的尾节点指向null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><p>一般链表的第一个节点为hed，用来表示这是一个链表存储，在创建链表的时候将链表的第一个节点默认设置为head。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建链表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">&#x27;head&#x27;</span>);     <span class="comment">//头节点</span></span><br><span class="line">    <span class="comment">// 若链表节点为数值，则创建时为this.head = new LinkedNode(521);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表长度"><a href="#链表长度" class="headerlink" title="链表长度"></a>链表长度</h4><p>为了方便链表操作，可以记录链表长度，在操作链表时要对长度进行相应的加减。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="keyword">new</span> LinkedNode(<span class="string">&#x27;head&#x27;</span>);   <span class="comment">// 头节点</span></span><br><span class="line">    <span class="built_in">this</span>.length = <span class="number">0</span>; <span class="comment">// 链表的默认长度为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h4><p>根据next指针遍历下去，直到为null。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">let</span> current = head;</span><br><span class="line"><span class="keyword">while</span>(current)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(current.val)</span><br><span class="line">    current = current.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>向链表中间插入一个元素，可以如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210924121621.png"><br>插入节点的步骤：</p>
<ul>
<li>存储插入位置的前一个节点</li>
<li>存储插入位置的后一个节点</li>
<li>将插入位置的前一个节点的 next 指向插入节点</li>
<li>将插入节点的 next 指向前面存储的 next 节点<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> current = head;</span><br><span class="line"><span class="keyword">while</span>(current &lt; position&gt;)&#123;</span><br><span class="line">    previous = current;</span><br><span class="line">    current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">previous.next = node;</span><br><span class="line">node.next = current;</span><br></pre></td></tr></table></figure>
如果在头节点进行插入操作的时候，会实现previousNode节点为undefined，不适合上述方式。解放方式可以是在头节点前面添加一个虚拟头节点，保证插入行为一致。</li>
</ul>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>链表任意位置删除节点，如下图操作：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210924144130.png"><br>删除节点的步骤：</p>
<ul>
<li>获取删除节点的前一个结点</li>
<li>获取删除节点的后一个结点</li>
<li>将前一个结点的next指向后一个结点</li>
<li>将删除节点的next指向为null<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(current != node)&#123;</span><br><span class="line">    previous = current;</span><br><span class="line">    current = current.next;</span><br><span class="line">    nextNode = current.next;</span><br><span class="line">&#125;</span><br><span class="line">previous.next = nextNode;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等。<br>当缓存空间被占满时，我们可能会使用LRU最近最常使用策略去清除，实现LRU算法的是数据结构是链表，思路如下：</p>
<p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表</p>
<ul>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表头部</li>
<li>如果此数据没在缓存链表中</li>
<li><ul>
<li>如果此时缓存未满，可直接在链表头部插入新节点存储此数据</li>
</ul>
</li>
<li><ul>
<li>如果此时缓存已满，则删除链表尾部节点，再在链表头部插入新节点</li>
</ul>
</li>
</ul>
<p>由于链表插入删除效率极高，达到O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据的情况的时候，都可以使用链表</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>字节青训营-HTTP实用指南</title>
    <url>/2022/01/23/%E9%9D%92%E8%AE%AD%E8%90%A5-HTTP%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="01-初识HTTP"><a href="#01-初识HTTP" class="headerlink" title="01 初识HTTP"></a>01 初识HTTP</h2><p>浏览器地址栏输入URL，到显示界面，经历的过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123145912.png"></p>
<h4 id="HTTP介绍"><a href="#HTTP介绍" class="headerlink" title="HTTP介绍"></a>HTTP介绍</h4><p>Hyper Text Transfer Protocol，超文本传输协议</p>
<ul>
<li>应用层协议，基于TCP</li>
<li>请求响应</li>
<li>简单可扩展</li>
<li>无状态</li>
</ul>
<h2 id="02-协议分析"><a href="#02-协议分析" class="headerlink" title="02 协议分析"></a>02 协议分析</h2><h4 id="发展："><a href="#发展：" class="headerlink" title="发展："></a>发展：</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123151034.png"></p>
<h4 id="报文："><a href="#报文：" class="headerlink" title="报文："></a>报文：</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123151331.png"></p>
<h4 id="字段分析："><a href="#字段分析：" class="headerlink" title="字段分析："></a>字段分析：</h4><h5 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GET</td>
<td align="left">请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据</td>
</tr>
<tr>
<td align="left">POST</td>
<td align="left">用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用</td>
</tr>
<tr>
<td align="left">PUT</td>
<td align="left">用于请求有效载荷替换目标资源的所有当前表示</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">删除指定资源</td>
</tr>
<tr>
<td align="left">HEAD</td>
<td align="left">请求一个 与GET请求的响应 相同的响应</td>
</tr>
<tr>
<td align="left">CONNECT</td>
<td align="left">建立一个到由目标资源标识的服务器的隧道</td>
</tr>
<tr>
<td align="left">OPTIONS</td>
<td align="left">用于描述目标资源的通信选项</td>
</tr>
<tr>
<td align="left">TRACE</td>
<td align="left">沿着到目标资源的路径执行一个消息环回测试</td>
</tr>
<tr>
<td align="left">PATCH</td>
<td align="left">用于对资源应用部分修改</td>
</tr>
</tbody></table>
<p>特性：<br>Safe(安全的)：上述方法中，对于其中不会修改服务器数据的方法，我们认为其是安全的，例如，GET、HEAD、OPTIONS<br>Idempotent(幂等的)：对于同样的请求执行一次与执行多次的效果是一样的，服务器的状态也是一样的，例如，GET、HEAD、OPTIONS、PUT、DELETE</p>
<p><i style="background:#ccffcc"><b>所有的safe方法都是idempotent的</b></i></p>
<h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123154523.png"></p>
<ul>
<li>200 OK-客户端请求成功</li>
<li>301 - 资源（网页等）被永久转移到其他URL</li>
<li>302 - 临时跳转</li>
<li>401 Unauthorized - 请求未经授权</li>
<li>404 - 请求资源不存在</li>
<li>500 - 服务器内部错误</li>
<li>504 Gated Timeout - 网关或代理的服务器无法在规定时间内获得想要的响应</li>
</ul>
<h5 id="常用请求头"><a href="#常用请求头" class="headerlink" title="常用请求头"></a>常用请求头</h5><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">接收类型，表示浏览器支持的MIME类型（对标服务器端返回的Content-Type）</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">客户端发送出去实体内容的类型</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">指定请求和响应遵循的缓存机制，例如no-cache</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">对应服务器端的Last-Modified,用来匹配看文件是否变得，只能精确到1s之内</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">缓存控制，在这个时间内不会请求，直接使用缓存，服务器端事件</td>
</tr>
<tr>
<td align="left">Max-age</td>
<td align="left">代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">对应服务端的ETag，用来匹配文件是否变动（非常精确）</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">有cookie并且同域访问时会自动带上</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">该页面的来源URL（适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段）</td>
</tr>
<tr>
<td align="left">Origin</td>
<td align="left">最初的请求是从哪里发起的（只会精确到端口），Origin比Referer更尊重隐私</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">用户客户端的一些必要的信息，如UA头部等</td>
</tr>
</tbody></table>
<h5 id="常用的响应头"><a href="#常用的响应头" class="headerlink" title="常用的响应头"></a>常用的响应头</h5><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123162231.png"></p>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220123164131.png"></p>
<p>must-revalidate会与max-age结合使用，如果缓存中设置了must-revalidate且max-age到期，即使本地有缓存也无法使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124094913.png"></p>
<h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>当用户第一次访问并登陆一个网站的时候，cookie的设置以及发送会经历以下4个步骤：</p>
<p>(1)客户端发送一个请求到服务器  →  (2)服务器发送一个HttpResponse响应到客户端，其中包含Set-Cookie的头部  →  (3)客户端保存cookie，之后向服务器发送请求时，HttpRequest请求中会包含一个Cookie的头部  →  (4)服务器返回响应数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124100217.png"></p>
<table>
<thead>
<tr>
<th align="left">属性项</th>
<th align="left">属性项介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NAME=VALUE</td>
<td align="left">键值对，可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">Cookie的有效期，在设置的某个时间点后该 Cookie 就会失效</td>
</tr>
<tr>
<td align="left">Domain</td>
<td align="left">限制Cookie 生效的域名，默认为创建cookie的服务域名</td>
</tr>
<tr>
<td align="left">Path</td>
<td align="left">限制指定Cookie的发送范围的文件目录，默认为当前</td>
</tr>
<tr>
<td align="left">Secure</td>
<td align="left">仅在HTTPS安全连接时，才可以发送Cookie</td>
</tr>
<tr>
<td align="left">HTTPOnly</td>
<td align="left">Javascript脚本无法获得Cookie</td>
</tr>
<tr>
<td align="left">SameSite</td>
<td align="left">①None同站、跨站请求都可以发送<br>②Strict仅在同站发送<br>③允许与顶级导航一起发送，并将与第三方网站发起的GET请求一起发送</td>
</tr>
</tbody></table>
<h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>HTTP/2更快、更稳定、更简单</p>
<ul>
<li>帧（frame）：HTTP/2通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li>
<li>消息：与逻辑请求或响应消息对应的完整的一系列帧。</li>
<li>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。</li>
</ul>
<p>HTTP/2连接是永久的，而且仅需要每个来源的一个连接。<br>流控制：阻止 发送方 向 接收方 发送大量数据的机制。<br>服务器推送能力。</p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>https是http经过TSL/SSL加密后得到的</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124110308.png"></p>
<h2 id="03-场景分析"><a href="#03-场景分析" class="headerlink" title="03 场景分析"></a>03 场景分析</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124110955.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124111106.png"></p>
<h4 id="静态资源方案"><a href="#静态资源方案" class="headerlink" title="静态资源方案"></a>静态资源方案</h4><p>静态资源方案：缓存 + CDN + 文件名hash<br>其中：文件名hash可以确保当前文件是最新的</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124112530.png"></p>
<p>通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务</p>
<h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124115113.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124115305.png"></p>
<p>解决方法：</p>
<ul>
<li>CORS</li>
<li>代理服务器</li>
<li><ul>
<li>同源策略是浏览器的安全策略，不是HTTP的</li>
</ul>
</li>
<li>Iframe - 不方便，限制过多，实际场景中使用较少</li>
</ul>
<h4 id="下一次进入页面为什么能记住登陆状态？"><a href="#下一次进入页面为什么能记住登陆状态？" class="headerlink" title="下一次进入页面为什么能记住登陆状态？"></a>下一次进入页面为什么能记住登陆状态？</h4><p>鉴权：<br>Session + cookie</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124120535.png"></p>
<p>JWT(JSON web token)</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124144602.png"></p>
<h4 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h4><ol>
<li>AJAX之XHR<br>XHR：XMLHttpRequest<br>xhr.readyState属性</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124145225.png"></p>
<ol start="2">
<li>AJAX之Fetch</li>
</ol>
<ul>
<li>XMLHttpRequest的升级版</li>
<li>使用promise</li>
<li>模块化设计，Response，Request，Header对象</li>
<li>通过数据流处理对象，支持分块读取</li>
</ul>
<ol start="3">
<li>axios库</li>
</ol>
<ul>
<li>支持浏览器、nodejs环境</li>
<li>丰富的拦截器</li>
</ul>
<h4 id="用户体验方面"><a href="#用户体验方面" class="headerlink" title="用户体验方面"></a>用户体验方面</h4><ol>
<li>网络优化</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124151100.png"></p>
<ol start="2">
<li>稳定性</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124151133.png"></p>
<ul>
<li>重试是保证稳定的有效手段，但要防止加剧恶劣情况</li>
<li>缓存合理使用，作为最后一道防线</li>
</ul>
<h2 id="05拓展"><a href="#05拓展" class="headerlink" title="05拓展"></a>05拓展</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124151328.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220124151403.png"></p>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
  </entry>
  <entry>
    <title>青训营-如何写好JS</title>
    <url>/2022/02/11/%E9%9D%92%E8%AE%AD%E8%90%A5-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BDJS/</url>
    <content><![CDATA[<h2 id="01-各司其责"><a href="#01-各司其责" class="headerlink" title="01 各司其责"></a>01 各司其责</h2><p>JavaScript – Behavioral<br>CSS – Presentational<br>HTML – Structual</p>
<h5 id="例子-夜间模式的实现"><a href="#例子-夜间模式的实现" class="headerlink" title="例子 夜间模式的实现"></a>例子 夜间模式的实现</h5><ol>
<li>版本一</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;modeBtn&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.target.innerHTML === <span class="string">&#x27;太阳模式&#x27;</span>) &#123;</span><br><span class="line">    body.style.backgroundcolor = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">    body.style.color = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">    e.target.innerHTML = <span class="string">&#x27;月亮模式&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    body.style.backgroundcolor = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">    body.style.color = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">    e.target.innerHTML = <span class="string">&#x27;太阳模式&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实现功能没有问题，但是存在 使用JS操作CSS应该实现的功能 的问题。</p>
<ol start="2">
<li>版本二</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;modeBtn&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">  <span class="keyword">if</span> (body.className !== <span class="string">&#x27;night&#x27;</span>) &#123;</span><br><span class="line">    body.className = <span class="string">&#x27;night&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    body.className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>版本二的优点是通过JS控制状态的变化，具体的样式则交由CSS来实现。</p>
<ol start="3">
<li>版本三<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;modeCheckBox&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;modeBtn&quot;</span> <span class="attr">for</span>=<span class="string">&quot;modeCheckBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#modeCheckBox</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeCheckBox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
要实现的功能仅为纯展示功能，因此可以通过HTML+CSS来实现即可。</li>
</ol>
<p><b>小结：</b></p>
<ul>
<li>HTML/CSS/JS 各司其责</li>
<li>避免不必要的由JS直接操作样式</li>
<li>可以通过class来表示状态</li>
<li>纯展示类交互寻求零JS方案</li>
</ul>
<p>自己动手实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%BD%95%E5%88%B6_2022_02_11_17_11_54_118.gif"></p>
<p><a href="https://codepen.io/qw-null/pen/mdqwJxM">在线效果</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>ChangeMode<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;modeCheckBox&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;modeBtn&quot;</span> <span class="attr">for</span>=<span class="string">&quot;modeCheckBox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">justify-content</span>:center;</span><br><span class="line">  <span class="attribute">align-items</span>:center;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeCheckBox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeCheckBox</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeBtn</span>&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>:<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>:pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeBtn</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;🌞&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeCheckBox</span><span class="selector-pseudo">:checked</span> + <span class="selector-id">#modeBtn</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;🌜&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.dark</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bright</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> changeMode = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> modeCheck = <span class="built_in">document</span>.getElementById(<span class="string">&quot;modeCheckBox&quot;</span>);</span><br><span class="line">  modeCheck.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modeCheck.checked) &#123;</span><br><span class="line">      <span class="built_in">document</span>.body.className = <span class="string">&#x27;dark&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.body.className = <span class="string">&#x27;bright&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeMode();</span><br></pre></td></tr></table></figure>

<p>实现时通过js控制body的类名来改变效果。</p>
<p>🌞与🌜的切换是通过<code>input + label</code>的方式实现：</p>
<p>input选中时显示🌜，未选中显示🌞。</p>
<p><em>之前写过的一个项目的手机版的下拉菜单图标的展示也是通过这种方式进行切换。</em></p>
<h2 id="02-组件封装"><a href="#02-组件封装" class="headerlink" title="02 组件封装"></a>02 组件封装</h2><p>组件是指Web页面上抽出来一个个包含模板（HTML）、功能（JS）和样式（CSS）的单元。</p>
<p>好的组件具备封装性、正确性、拓展性、复用性。</p>
<p>(有些难)</p>
<h2 id="03-过程抽象"><a href="#03-过程抽象" class="headerlink" title="03 过程抽象"></a>03 过程抽象</h2><p>用来处理局部细节控制的一些方法</p>
<p>函数式编程思想的基础应用</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211203005.png"></p>
<p>什么是过程抽象呢？举个例子，比如你有间小房子，房子有门、有窗，这里门和窗也就是数据。那么你可以开门，也可以开窗，开门和开窗就属于过程。我们不仅仅可以抽象数据，还可以抽象这个过程。</p>
<h5 id="例子-操作次数限制"><a href="#例子-操作次数限制" class="headerlink" title="例子 操作次数限制"></a>例子 操作次数限制</h5><ul>
<li>一些异步交互</li>
<li>一次性的HTTP请求</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Task1：学习 html<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Task2：学习 css<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Task3：学习 JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> ulElem = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> liElems = ulElem.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">liElems.forEach(<span class="function"><span class="params">liElem</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    liElem.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        e.target.className = <span class="string">&#x27;completed&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            ulElem.removeChild(e.target);</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="number">2000</span>);</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码实现的效果是完成一个任务之后，点击后将其删除，但是需要点击2s之后才能完成删除，如果在2s之内再去点击 已经点击了要删除的任务，就会报错。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211204137.png"><br>报错的原因实际上就是点击了已经删除的数据项，已经不存在，所以也就无法删除。</p>
<p>因此，解决方法也很简单了，只要限制只能执行一次删除造作就好了。因此可以封装一个高级函数<code>once</code>，这个函数的目标就是保证删除操作只能执行一次，确保操作安全。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fn)&#123;</span><br><span class="line">      <span class="keyword">const</span> res = fn.apply(<span class="built_in">this</span>,args);</span><br><span class="line">      fn = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">liElems.forEach(<span class="function"><span class="params">liElem</span> =&gt;</span> &#123;</span><br><span class="line">    liElem.addEventListener(<span class="string">&#x27;click&#x27;</span>, once(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        e.target.className = <span class="string">&#x27;completed&#x27;</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            ulElem.removeChild(e.target);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码中的高级函数<code>once</code>实际上就是为了让函数只执行一次。为了能够让“只执行一次”的需求覆盖不同的事件处理，我们可以将这个需求剥离出来。这个过程称为<b style="color:red;">过程抽象</b>。</p>
<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><ul>
<li>以函数作为参数</li>
<li>以函数作为返回值</li>
<li>常用于作为函数修饰器</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211205700.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220211205725.png"></p>
<p><b>函数节流</b></p>
<p>概念：限制一个函数在一定时间内只能执行一次。</p>
<blockquote>
<p>举个栗子，坐火车或地铁，过安检的时候，在一定时间（例如10秒）内，只允许一个乘客通过安检入口，以配合安检人员完成安检工作。上例中，每10秒内，仅允许一位乘客通过，分析可知，“函数节流”的要点在于，在 一定时间 之内，限制 一个动作 只 执行一次 。</p>
</blockquote>
<p><B>Q: 为什么需要函数节流？</B><br>前端开发过程中，有一些函数或者事件会在多时间内被多次触发，例如 <code>onresize</code>、<code>scroll</code>、<code>mousehover</code>等，这些事件的触发频率很高，如果在这些函数内部执行了其他函数，尤其是DOM操作的函数，会严重浪费计算机的资源，降低程序速度，甚至造成浏览器卡死、崩溃。因此需要限制执行次数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定时器方案</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数节流的使用场景：</p>
<ol>
<li>懒加载、滚动加载、加载更多或监听滚动条位置；</li>
<li>百度搜索框，搜索联想功能；</li>
<li>防止高频点击提交，防止表单重复提交；</li>
</ol>
<p><b>函数防抖</b><br>概念：函数防抖（debounce），就是指触发事件后，在 n 秒内函数只能执行一次，如果触发事件后在 n 秒内又触发了事件，则会重新计算函数延执行时间。</p>
<blockquote>
<p>举个栗子，坐电梯的时候，如果电梯检测到有人进来（触发事件），就会多等待 10 秒，此时如果又有人进来（10秒之内重复触发事件），那么电梯就会再多等待 10 秒。在上述例子中，电梯在检测到有人进入 10 秒钟之后，才会关闭电梯门开始运行，因此，“函数防抖”的关键在于，在 一个事件 发生 一定时间 之后，才执行 特定动作。</p>
</blockquote>
<p><B>Q: 为什么需要函数防抖？</B><br>前端开发过程中，有一些函数或者事件会在多时间内被多次触发，例如 <code>onresize</code>、<code>scroll</code>、<code>mousehover</code>等，这些事件的触发频率很高，如果在这些函数内部执行了其他函数，尤其是DOM操作的函数，会严重浪费计算机的资源，降低程序速度，甚至造成浏览器卡死、崩溃。因此需要限制执行次数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数防抖的使用场景：</p>
<ol>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求；</li>
<li>用户名、手机号、邮箱输入验证；</li>
<li>浏览器窗口大小改变后，只需窗口调整完后，再执行 resize 事件中的代码，防止重复渲染。</li>
</ol>
<p><b>iterative</b></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检验是否可迭代</span></span><br><span class="line"><span class="keyword">const</span> isIterable = <span class="function"><span class="params">obj</span> =&gt;</span> obj !== <span class="literal">null</span></span><br><span class="line">    &amp;&amp; <span class="keyword">typeof</span> obj[<span class="built_in">Symbol</span>.iterator] === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterative</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">subject, ...rest</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isIterable(subject)) &#123;</span><br><span class="line">            <span class="comment">// 把所有的执行结果存储于 result 中并返回</span></span><br><span class="line">            <span class="keyword">const</span> result = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> obj <span class="keyword">of</span> subject) &#123;</span><br><span class="line">                result.push(fn.apply(<span class="built_in">this</span>, [obj, ...rest]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, [subject, ...rest]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="纯函数-amp-非纯函数"><a href="#纯函数-amp-非纯函数" class="headerlink" title="纯函数 &amp; 非纯函数"></a>纯函数 &amp; 非纯函数</h4><p><b>纯函数：</b>输入值确定，则输出值就会确定，不会因为执行次序，执行环境等的改变而改变</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述计算两个数之和的方法，不论在什么时候，两个加数确定则最终结果就会确定。</p>
<p><b>非纯函数：</b>执行顺序，执行环境不同会造成最终呈现的结果不同。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">setColor</span>(<span class="params">elems, color</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">const</span> elem <span class="keyword">of</span> elems) &#123;</span></span><br><span class="line"><span class="javascript">            elem.style.color = color;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> els1 = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li:nth-child(2n+1)&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> els2 = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li:nth-child(3n+1)&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    setColor(els2, <span class="string">&#x27;blue&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    setColor(els1, <span class="string">&#x27;red&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，两个 <code>setColor</code> 的调用顺序如果更换，执行的结果会不一样，所以它的结果会受外部环境的影响，是非纯函数。</p>
<p>使用高阶函数，可以减少系统里面非纯函数的数量，从而使得系统的稳定性和可靠性加强。</p>
<p>比如说，我们现在需要实现两个函数，一个是 <code>setColor(elem, color)</code>，一次改变一个元素的颜色，还有一个 <code>setColors(elems, color)</code>，一次改变多个元素的颜色。显然这两个函数都是非纯函数，但是我们可以选择直接定义：</p>
<p><code>const setColors = iterative(setColor);</code></p>
<p>这样就减少了一个非纯函数，有利于我们进行单元测试。</p>
<h4 id="命令式-amp-声明式"><a href="#命令式-amp-声明式" class="headerlink" title="命令式 &amp; 声明式"></a>命令式 &amp; 声明式</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220212225631.png"></p>
<p>命令式代码更加强调执行的过程，强调怎么做。</p>
<hr>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220212225909.png"></p>
<p>声明式代码强调是什么，而不是过程。</p>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑面试题：猴子搬香蕉</title>
    <url>/2021/06/15/%E9%80%BB%E8%BE%91%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%8C%B4%E5%AD%90%E6%90%AC%E9%A6%99%E8%95%89/</url>
    <content><![CDATA[<h2 id="01-故事起源"><a href="#01-故事起源" class="headerlink" title="01 故事起源"></a>01 故事起源</h2><p>一只小猴子边上有100根香蕉，此地距离它家50米，小猴想搬香蕉回家，但有以下几个条件：  </p>
<ul>
<li>每次最多搬运50根香蕉</li>
<li>每走1m就要吃掉一根香蕉</li>
</ul>
<p>请问小猴子最多能把多少根香蕉搬回家？<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210615144312.jpg"></p>
<h2 id="02-初步思考"><a href="#02-初步思考" class="headerlink" title="02 初步思考"></a>02 初步思考</h2><p>小猴子最多只能搬50根香蕉，那就搬起50根香蕉往家走。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615144538.jpg"><br>可以发现，剩余香蕉和行走距离之间是线性关系。最终走到家，剩余香蕉数目为0根。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615144724.jpg"></p>
<p>小猴子搬运香蕉的过程可以看成是运输过程，之所以出现上面的问题，就在于运输效率会线性下降，快到家时，虽然身上只有几根香蕉，但油耗（吃掉香蕉数目）依然不变。<br>因此解决的办法是通过中转来提高运输效率，尽量载满。</p>
<h2 id="03-建立中转站"><a href="#03-建立中转站" class="headerlink" title="03 建立中转站"></a>03 建立中转站</h2><p>总共100根，所以转运最多2趟。而且小猴同学不用返回出发地，所以中转地与出发地之间往返3次。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615145322.jpg"><br>中转是为了下一次能够一次运输完，所以到达中转地之后，香蕉数要小于等于50。<br>设到中转站距离开始位置x米，则100-3x&lt;=50，x=17米。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615145509.jpg"><br>所以第一次搬50到17米处吃掉17根香蕉，再拿17根香蕉返回出发地，此时中转站留下16根香蕉。第二次搬50根到中转站剩下33根，总共49根。然后拿上49根回家，还剩下16根。</p>
<h2 id="04-深入思考"><a href="#04-深入思考" class="headerlink" title="04 深入思考"></a>04 深入思考</h2><p>这里借用一下微分的思想，将中转无限分段，假设每隔1米转运1次，那么每一段之间都是往返3次。如果再把这些区间积起来，其实就和上面的思想一样了。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615150600.jpg"><br>走到16米的地方还有一个特别的点。现在还有52根香蕉，距离家还有34米。此时只拿50根回家，不要多出的2根，也能搬回16根香蕉。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210615150707.jpg"></p>
<h2 id="05-总结"><a href="#05-总结" class="headerlink" title="05 总结"></a>05 总结</h2><p>这类问题最直观的第一感觉，就是越到后面阶段，运输效率越低，所以能想到中转。跟现实生活中的快递运输是一样的，快递也会有很多的中转站。中转站的设立是可以无限微分划区间，再用积分来计算，但这样就太复杂了，所以用分段的思想能解决大部分的问题。</p>
<p><strong>文章来源：小K算法</strong></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>逻辑思维</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里iconfont使用方法</title>
    <url>/2021/07/20/%E9%98%BF%E9%87%8Ciconfont%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>阿里巴巴iconfont的使用方式分为两种：1.本地使用  2.线上引用<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211013192203.jpg" width="150%" height="150%"/></p>
<p><a href="https://www.iconfont.cn/">iconfont-阿里巴巴矢量图标库</a></p>
<h2 id="0-前期准备"><a href="#0-前期准备" class="headerlink" title="0.前期准备"></a>0.前期准备</h2><p>使用时先到网站上选中需要使用的图标添加至项目<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720101011.png?1000x"></p>
<h2 id="1-本地使用"><a href="#1-本地使用" class="headerlink" title="1.本地使用"></a>1.本地使用</h2><p>1.下载项目至本地<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720101230.png"><br>2.解压到项目中<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720103442.png"><br>3.在页面中引入样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>iconfont的使用--本地引入<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">		<span class="keyword">@font-face</span> &#123;</span></span><br><span class="line"><span class="css">		  <span class="attribute">font-family</span>: <span class="string">&#x27;iconfont&#x27;</span>;</span></span><br><span class="line"><span class="css">		  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;./iconfont/iconfont.woff2?t=1626747157081&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span></span><br><span class="line"><span class="css">		       <span class="built_in">url</span>(<span class="string">&#x27;./iconfont/iconfont.woff?t=1626747157081&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),</span></span><br><span class="line"><span class="css">		       <span class="built_in">url</span>(<span class="string">&#x27;./iconfont/iconfont.ttf?t=1626747157081&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>);</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">		<span class="selector-class">.iconfont</span> &#123;</span></span><br><span class="line"><span class="css">		  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span> <span class="meta">!important</span>;</span></span><br><span class="line"><span class="css">		  <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">		  <span class="attribute">font-style</span>: normal;</span></span><br><span class="line"><span class="css">		  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="css">		  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span>&gt;</span><span class="symbol">&amp;#xe89a;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>@font-face中的url需要依据项目修改</li>
<li>使用方式：    &lt;span class=”iconfont”&gt;&amp;#xe89a;&lt;/span&gt;</li>
</ul>
<h2 id="2-线上引用"><a href="#2-线上引用" class="headerlink" title="2.线上引用"></a>2.线上引用</h2><h4 id="2-1-unicode引用"><a href="#2-1-unicode引用" class="headerlink" title="2.1 unicode引用"></a>2.1 unicode引用</h4><p>将本地使用代码中的@font-face进行替换即可<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720111233.png"></p>
<h4 id="2-2-Font-class形式引入："><a href="#2-2-Font-class形式引入：" class="headerlink" title="2.2 Font class形式引入："></a>2.2 Font class形式引入：</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720111005.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>iconfont的使用--线上引用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://at.alicdn.com/t/font_2686372_j1gr8zzfq9.css&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">		<span class="selector-class">.iconfont</span> &#123;</span></span><br><span class="line"><span class="css">		  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span> <span class="meta">!important</span>;</span></span><br><span class="line"><span class="css">		  <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">		  <span class="attribute">font-style</span>: normal;</span></span><br><span class="line"><span class="css">		  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="css">		  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-chazuo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在Vue中使用方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--App.vue中引入样式文件，用线上链接即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">	<span class="keyword">@import</span> <span class="string">&quot;xxxxxxx/iconfont.css&quot;</span>;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--class方式引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-qianbao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-3-symbol引用"><a href="#2-3-symbol引用" class="headerlink" title="2.3 symbol引用"></a>2.3 symbol引用</h4><ul>
<li>支持多色图标了，不再受单色限制。</li>
<li>通过一些技巧，支持像字体那样，通过,来调整样式。</li>
<li>兼容性较差，支持 ie9+及现代浏览器。</li>
<li>浏览器渲染svg的性能一般，还不如png。<blockquote>
<p>使用步骤：</p>
</blockquote>
</li>
</ul>
<p>1.第一步：拷贝项目下面生成的symbol代码：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210720112720.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://拷贝的地址&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.第二步：加入通用css代码（引入一次就行）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-class">.icon</span> &#123;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">1em</span>; <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">       <span class="attribute">vertical-align</span>: -<span class="number">0.15em</span>;</span><br><span class="line">       fill: currentColor;</span><br><span class="line">       <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>3.第三步：挑选相应图标并获取类名，应用于页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#icon-xxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>iconfont的使用--线上引用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://at.alicdn.com/t/font_2686372_j1gr8zzfq9.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">src</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">		<span class="selector-class">.iconfont</span> &#123;</span></span><br><span class="line"><span class="css">		  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span> <span class="meta">!important</span>;</span></span><br><span class="line"><span class="css">		  <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">		  <span class="attribute">font-style</span>: normal;</span></span><br><span class="line"><span class="css">		  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span><br><span class="line"><span class="css">		  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#icon-chazuo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>阿里iconfont</category>
      </categories>
      <tags>
        <tag>阿里iconfont</tag>
      </tags>
  </entry>
  <entry>
    <title>字节青训营-前端与HTML</title>
    <url>/2022/01/16/%E9%9D%92%E8%AE%AD%E8%90%A51-%E5%89%8D%E7%AB%AF%E4%B8%8EHTML/</url>
    <content><![CDATA[<h2 id="0-什么是前端？"><a href="#0-什么是前端？" class="headerlink" title="0.什么是前端？"></a>0.什么是前端？</h2><p>使用web技术栈，解决多端【PC/移动浏览器、客户端、小程序、VR/AR等】图形用户界面下人机交互问题<br>前端技术栈：html(内容) + css(样式) + js(行为)</p>
<h2 id="1-HTML"><a href="#1-HTML" class="headerlink" title="1.HTML"></a>1.HTML</h2><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116115240.png"></p>
<p>浏览器会将html文件解析成一棵DOM树<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116120500.png"></p>
<h3 id="1-1-HTML-语法"><a href="#1-1-HTML-语法" class="headerlink" title="1.1 HTML 语法"></a>1.1 HTML 语法</h3><p>标签属性不区分大小写（推荐：小写）、属性值使用双引号包裹、空标签可以不闭合、某些属性值可以省略（readonly、required）</p>
<ul>
<li>空标签<br>没有闭合标签的标签被称作为空标签。<br>常见的空标签：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span> 换行标签，通常用于文本格式换行</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> /&gt;</span>  用于为基于Web的表单创建交互式控件，以便接受来自用户的数据。</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> /&gt;</span> 代表文档中的一个图像。</span><br><span class="line"><span class="tag">&lt;<span class="name">isindex</span> /&gt;</span> 使浏览器显示一个对话框，提示用户输入单行文本。</span><br><span class="line"><span class="tag">&lt;<span class="name">area</span> /&gt;</span> 在图片上定义一个热点区域</span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> /&gt;</span> 指定用于一个文档中包含的所有相对URL的基本URL。</span><br><span class="line"><span class="tag">&lt;<span class="name">basefont</span> /&gt;</span> 用来设置文档的默认字体大小。（目前已废弃 ）</span><br><span class="line"><span class="tag">&lt;<span class="name">bgsound</span> /&gt;</span> IE浏览器中设置网页背景音乐的元素。</span><br><span class="line"><span class="tag">&lt;<span class="name">col</span> /&gt;</span> 定义表格中的列，并用于定义所有公共单元格上的公共语义。它通常位于`<span class="tag">&lt;<span class="name">colgroup</span>&gt;</span>`元素内。</span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> /&gt;</span> 用于表示一个外部应用或交互式内容的集合点，换句话说，就是一个插件。 </span><br><span class="line"><span class="tag">&lt;<span class="name">frame</span> /&gt;</span> ，它定义了一个特定区域，另一个 HTML 文档可以在里面展示。(已废弃)</span><br><span class="line"><span class="tag">&lt;<span class="name">keygen</span> /&gt;</span>  为了方便生成密钥材料和提交作为 [HTML form]的一部分的公钥.这种机制被用于设计基于 Web 的证书管理系统。(已废弃)</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> /&gt;</span> 指定了外部资源与当前文档的关系. 这个元素的使用方法包括为导航定义关系框架.这个元素经常用来链接css文件。</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> /&gt;</span> 元素表示那些不能由其它HTML元相关元素 (<span class="tag">&lt;<span class="name">base</span>&gt;</span>, <span class="tag">&lt;<span class="name">link</span>&gt;</span>, <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml">, <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="xml"> 或 <span class="tag">&lt;<span class="name">title</span>&gt;</span>) 之一表示的任何元数据信息.</span></span></span></span><br><span class="line"><span class="xml"><span class="xml"><span class="handlebars"><span class="tag">&lt;<span class="name">nextid</span> /&gt;</span>  是一个过时的 HTML 元素, 它使下一个 web 设计工具能够为其定位点生成自动名称标签。它是由该 web 编辑工具自动生成的, 不需要手动调整或输入。这个元素的区别是成为第一个元素, 成为一个 &quot;丢失的标签&quot; 被淘汰的官方公共 DTD 的 HTML 版本。</span></span></span></span><br><span class="line"><span class="xml"><span class="xml"><span class="handlebars"><span class="tag">&lt;<span class="name">param</span> /&gt;</span>  定义了 <span class="tag">&lt;<span class="name">object</span>&gt;</span>的参数</span></span></span></span><br><span class="line"><span class="xml"><span class="xml"><span class="handlebars"><span class="tag">&lt;<span class="name">plaintext</span> /&gt;</span> 将起始标签后面的任何东西渲染为纯文本，不会解释为 HTML。它没有闭合标签，因为任何后面的东西都会看做纯文本。(已废弃)</span></span></span></span><br><span class="line"><span class="xml"><span class="xml"><span class="handlebars"><span class="tag">&lt;<span class="name">spacer</span> /&gt;</span> 它可以向页面插入间隔。它由 Netscape 设计，用于实现单像素布局图像的相同效果，Web 设计师用它来向页面添加空白，而不需要实际使用图片。（已废弃）</span></span></span></span><br><span class="line"><span class="xml"><span class="xml"><span class="handlebars"><span class="tag">&lt;<span class="name">wbr</span> /&gt;</span> 一个文本中的位置，其中浏览器可以选择来换行，虽然它的换行规则可能不会在这里换行。</span></span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-2-HTML-标签"><a href="#1-2-HTML-标签" class="headerlink" title="1.2 HTML 标签"></a>1.2 HTML 标签</h3><ol>
<li><p>h1~h6 标题标签</p>
</li>
<li><p>列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 1.有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Aa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Bb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 2.无序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Cc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Dd<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 3.自定义列表</span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>学校：<span class="tag">&lt;/<span class="name">dt</span>&gt;</span> <span class="comment">&lt;!-- 代表title --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>UCAS<span class="tag">&lt;/<span class="name">dd</span>&gt;</span> <span class="comment">&lt;!-- title -&gt; value --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>校区<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>雁栖湖校区<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>玉泉路校区<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116123525.png"></p>
</li>
<li><p>链接<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116132541.png"></p>
</li>
<li><p>视频、音频</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>输入<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116124307.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116124609.png"><br>选择框：type=”checkbox”<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116124631.png"></p>
<hr/>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116124721.png"><br>单选框：type=”radio” 、通过name属性的值控制单选<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116124835.png"></p>
<hr></li>
</ol>
<p>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116125023.png"><br>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116125040.png"><br>  <hr></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116125151.png"><br>  通过list设置为用户的提示信息，datalist标签指定快捷输入数据<br>6. 引用</p>
<ul>
<li>blockquote：<br>&lt;blockquote&gt; 标签定义摘自另一个源的块引用。<br>浏览器通常会对 &lt;blockquote&gt; 元素进行缩进。<br>属性：cite →指定引用的来源</li>
<li>cite:<br> &lt;cite&gt; 标签通常表示它所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。按照惯例，引用的文本将以斜体显示。</li>
<li>q：<br>&lt;q&gt;标签用于定义短引文（行内引文）。浏览器将自动为短引文添加引号。</li>
</ul>
<p>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116130237.png"><br>  <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116130434.png"></p>
<ol start="7">
<li><p>代码标签<br>&lt;code&gt;&lt;/code&gt;<br>引用多行代码时，使用&lt;pre&gt;包裹&lt;code&gt;<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116130638.png"></p>
</li>
<li><p>表示强调<br>&lt;strong&gt;&lt;strong&gt; → 加粗<br>&lt;em&gt;&lt;em&gt;</p>
</li>
<li><p>页面内容划分<br> <img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116131124.png"></p>
</li>
</ol>
<h3 id="1-3-HTML-语义化"><a href="#1-3-HTML-语义化" class="headerlink" title="1.3 HTML 语义化"></a>1.3 HTML 语义化</h3><p>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码，同时让浏览器的爬虫和机器能很好地解析。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220116131858.png"></p>
<p>Q：为什么要语义化？</p>
<ul>
<li>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构：<span style="background:yellow;"><b>为了裸奔时好看</b></span>；</li>
<li><span style="background:yellow;"><b>用户体验</b></span>：例如title、alt用于解释名词或解释图片信息、label标签的活用；</li>
<li><span style="background:yellow;"><b>有利于SEO</b></span>：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li>
<li>方便其他设备<span style="background:yellow;"><b>解析</b></span>（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li>
<li><span style="background:yellow;"><b>便于团队开发和维护</b></span>，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li>
</ul>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>青训营-数据可视化基础</title>
    <url>/2022/02/21/%E9%9D%92%E8%AE%AD%E8%90%A5-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="01-数据可视化的概念和基本原则"><a href="#01-数据可视化的概念和基本原则" class="headerlink" title="01 数据可视化的概念和基本原则"></a>01 数据可视化的概念和基本原则</h2><h4 id="什么是数据可视化？"><a href="#什么是数据可视化？" class="headerlink" title="什么是数据可视化？"></a>什么是数据可视化？</h4><p>Anything that converts <b>data</b> into a <b>visual representation</b> (like charts,graphs,maps,sometimes even just tables)</p>
<h4 id="为什么数据可视化？"><a href="#为什么数据可视化？" class="headerlink" title="为什么数据可视化？"></a>为什么数据可视化？</h4><ol>
<li>记录信息</li>
<li>分析推理</li>
<li>证实假设</li>
<li>交流思想</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221124425.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221124441.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221124458.png"></p>
<p>可视化实现了 从看到物体 到 获取知识。<br>可视化可以更加直观的展现数据之间的关系，便于分析与研究。</p>
<h4 id="可视化设计原则"><a href="#可视化设计原则" class="headerlink" title="可视化设计原则"></a>可视化设计原则</h4><p>能够<b>正确</b>地表达数据中的信息而<b>不产生偏差与歧义</b></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125543.png"></p>
<h4 id="常见的错误可视化"><a href="#常见的错误可视化" class="headerlink" title="常见的错误可视化"></a>常见的错误可视化</h4><ol>
<li>透视失真</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125153.png"></p>
<ol start="2">
<li>图形设计 &amp; 数据尺度</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125240.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125309.png"></p>
<ol start="3">
<li>数据上下文</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125347.png"></p>
<blockquote>
<p>一个出色的可视化设计可在最短的时间内，是用最少的空间、用最少的笔墨为观众提供最多的信息内涵。</p>
</blockquote>
<h4 id="Data-ink-Ratio"><a href="#Data-ink-Ratio" class="headerlink" title="Data-ink Ratio"></a>Data-ink Ratio</h4><p>最大化数据墨水占比 Data-ink Ratio</p>
<ul>
<li>可视化图形由墨水和空白区域构成</li>
<li>数据墨水：可视化图形当中不可擦除的核心部分被称为“数据墨水”</li>
<li>擦除数据墨水将减少图形所传达的信息</li>
<li>数据墨水占比：可视化图形中用于展示核心数据的“墨水”在整体可视化所使用的墨水中的比例</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221125942.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221130007.png"></p>
<h2 id="02-视觉感知"><a href="#02-视觉感知" class="headerlink" title="02 视觉感知"></a>02 视觉感知</h2><p>可视化致力于外部认知，即怎样利用大脑以外的资源来增强大脑本身的认知能力。</p>
<h4 id="感知"><a href="#感知" class="headerlink" title="感知"></a>感知</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221130218.png"></p>
<h4 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221130240.png"></p>
<p>人类的视觉系统观察的是变化，而不是绝对值，并且容易被边界吸引。<br>在可视化设计第过程中，设计者需要充分考虑到人类感知系统的这些现象，以使得设计的可视化结果不会存在阻碍或者误导用户的可视化元素。</p>
<h2 id="03-数据可视化工具"><a href="#03-数据可视化工具" class="headerlink" title="03 数据可视化工具"></a>03 数据可视化工具</h2><h4 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h4><p>D3.js用于数据可视化的开源的JavaScript函数库。<br><a href="https://www.d3js.org.cn/">D3.js官网</a></p>
<h4 id="Vega"><a href="#Vega" class="headerlink" title="Vega"></a>Vega</h4><p>Vega是一种可视化语法。通过其声明式语言，可以用json格式描述可视化的视觉外观和交互行为，并使用Canvas或SVG生成视图。<br><a href="http://vega.github.io/">Vega官网</a></p>
<h4 id="G2"><a href="#G2" class="headerlink" title="G2"></a>G2</h4><p>G2 是一套基于图形语法理论的可视化底层引擎，以数据驱动，提供图形语法与交互语法，具有高度的易用性和扩展性。使用 G2，你可以无需关注图表各种繁琐的实现细节，一条语句即可使用 Canvas 或 SVG 构建出各种各样的可交互的统计图表。<br><a href="https://g2.antv.vision/zh/docs/manual/about-g2">G2官网</a></p>
<h4 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220221131327.png"></p>
<p><a href="https://echarts.apache.org/zh/index.html">Echarts官网</a></p>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
  </entry>
  <entry>
    <title>面试题目汇总(CSS部分)</title>
    <url>/2021/07/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="margin和padding的区别"><a href="#margin和padding的区别" class="headerlink" title="margin和padding的区别"></a>margin和padding的区别</h3><ul>
<li>margin是指从自身边框到另一个容器边框之间的距离，指两个容器之间的距离。（外边距）</li>
<li>padding是指自身边框到自身内部的另一个容器之间的距离，指容器内距离。（内边框）</li>
</ul>
<p>1.语法结构：(以margin为例，padding相同)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>:<span class="number">10px</span>;  //左外边距<span class="number">10px</span></span><br><span class="line">// 还有 <span class="attribute">margin-right</span>,<span class="attribute">margin-top</span>,<span class="attribute">margin-bottom</span></span><br><span class="line"><span class="attribute">margin</span>:<span class="number">10px</span>; // 上下左右外边距均为<span class="number">10px</span></span><br><span class="line">marin:<span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span> <span class="number">40px</span>;//上<span class="number">10px</span> 右<span class="number">20px</span> 下<span class="number">30px</span> 左<span class="number">40px</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>margin只有一个值表示上右下左。如果 margin 只有两个值第一个值表示上下，第二个值为左右。margin有三个值表示上,左右,下。margin有四个值表示上下左右四个方向。</p>
</blockquote>
<p>2.区别：<br>（1）二者相邻是否会抵消</p>
<ul>
<li>上下相连的两个盒子之间的空白需要相互抵消时，比如15px+20px的margin，将得到20px的空白。(保留下最大的)</li>
<li>上下相连的两个盒子之间的空白希望等于两者之和时，比如15px+20px的padding，将得到35px的空白。（会相加）<br>例子：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.content1</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-bottom</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.content2</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: <span class="number">250px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210727232843.png"><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.content2</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">5px</span> yellow solid;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding-top</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210728000622.png"><br>（2）负值问题</li>
<li>padding 设置为负值无效</li>
<li>margin 设置为负值：（1）元素本身没有宽度，会增加元素宽度；（2）元素本身有宽度，会产生位移；（3）margin-top为负值，不管是否设置高度，都不会增加高度，而是会产生向上的位移；（4）margin-bottom为负值的时候不会位移,而是会减少自身供css读取的高度【理解：本元素的高度和定位不受影响，但时候其后的元素会向上位移100px，因为后元素（粉）所能看到的前元素（绿）的申明高度因为负margin的缘故减少了100px 】</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 情况（2）</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"> <span class="selector-class">.content</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.content1</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: red;  </span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.content2</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">5px</span> yellow solid;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css">&lt;/&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210728094233.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 情况（4）</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content3&quot;</span>&gt;</span>后续元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.content</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-left</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.content1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;  </span></span><br><span class="line"><span class="css">        <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.content2</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">5px</span> yellow solid;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-bottom</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.content3</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20210728103755.png"></p>
<h3 id="介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？"><a href="#介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？"></a>介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h3><p>相关知识点：</p>
<blockquote>
<blockquote>
<p>（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）<br>（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分<br>IE盒模型和W3C标准盒模型的区别：<br>（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding<br>（2）IE盒模型：属性width，height包含content、border和padding，指的是content<br>+padding+border。<br>在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；<br>如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE<br>盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</p>
</blockquote>
</blockquote>
<p>回答：<br>盒模型都是由四个部分组成的，分别是margin、border、padding和content。</p>
<p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的<br>范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。</p>
<p>一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>字节青训营-Web标准与前端开发</title>
    <url>/2022/01/19/%E9%9D%92%E8%AE%AD%E8%90%A54-Web%E6%A0%87%E5%87%86%E4%B8%8E%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="01-关于前端开发"><a href="#01-关于前端开发" class="headerlink" title="01.关于前端开发"></a>01.关于前端开发</h2><h3 id="1-起源、架构、变迁"><a href="#1-起源、架构、变迁" class="headerlink" title="1.起源、架构、变迁"></a>1.起源、架构、变迁</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119102240.png"></p>
<p>web最基本的架构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119102430.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119102729.png"></p>
<h3 id="2-前端应用的领域"><a href="#2-前端应用的领域" class="headerlink" title="2.前端应用的领域"></a>2.前端应用的领域</h3><p>浏览器:</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119103438.png"></p>
<p>服务器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119103711.png"><br>Deno可以了解一下！</p>
<p>终端和跨端：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119103754.png"></p>
<h3 id="3-语言、框架、工具"><a href="#3-语言、框架、工具" class="headerlink" title="3.语言、框架、工具"></a>3.语言、框架、工具</h3><p>语言：<br>HTML、CSS、JavaScript、WebAssembly</p>
<p>框架：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119104211.png"></p>
<p>*深入理解现代浏览器：</p>
<p><a href="https://blog.csdn.net/qihoo_tech/article/details/91921777">详情</a></p>
<p>*An overview of HTTP:</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview">详情</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119105012.png"></p>
<h3 id="4-前端学习路线图"><a href="#4-前端学习路线图" class="headerlink" title="4.前端学习路线图"></a>4.前端学习路线图</h3><p><a href="https://roadmap.sh/frontend">详情</a></p>
<h2 id="02-关于Web标准"><a href="#02-关于Web标准" class="headerlink" title="02.关于Web标准"></a>02.关于Web标准</h2><h3 id="1-了解Web标准组织"><a href="#1-了解Web标准组织" class="headerlink" title="1.了解Web标准组织"></a>1.了解Web标准组织</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119110421.png"></p>
<h3 id="2-W3C与Ecma会员"><a href="#2-W3C与Ecma会员" class="headerlink" title="2.W3C与Ecma会员"></a>2.W3C与Ecma会员</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119111139.png"></p>
<h3 id="3-W3C流程"><a href="#3-W3C流程" class="headerlink" title="3.W3C流程"></a>3.W3C流程</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119111111.png"></p>
<h3 id="4-TC39流程"><a href="#4-TC39流程" class="headerlink" title="4.TC39流程"></a>4.TC39流程</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119111226.png"></p>
<h3 id="5-如何参与"><a href="#5-如何参与" class="headerlink" title="5.如何参与"></a>5.如何参与</h3><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119111342.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220119111505.png"></p>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
  </entry>
  <entry>
    <title>字节青训营-理解css</title>
    <url>/2022/01/16/%E9%9D%92%E8%AE%AD%E8%90%A52-%E7%90%86%E8%A7%A3css/</url>
    <content><![CDATA[<h2 id="CSS是什么？"><a href="#CSS是什么？" class="headerlink" title="CSS是什么？"></a>CSS是什么？</h2><p>css(cascading style sheets):用来定义页面元素的样式。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0323042c94648ebb71b785f0b3a70d1~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="页面使用css"><a href="#页面使用css" class="headerlink" title="页面使用css"></a>页面使用css</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 1. 外链形式</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/assets/style.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 2.嵌入形式</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 3.内联形式</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red;&quot;</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="css如何工作？"><a href="#css如何工作？" class="headerlink" title="css如何工作？"></a>css如何工作？</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a53824239cb443b8f6ca103b4b99c32~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="选择器Selector"><a href="#选择器Selector" class="headerlink" title="选择器Selector"></a>选择器Selector</h2><p>找出页面中元素的位置，以便给其设置样式</p>
<p>选择页面元素的方式：</p>
<ul>
<li>标签名、类名、id</li>
<li>属性</li>
<li>DOM树中的位置</li>
</ul>
<p>选择器种类：通配选择器、标签选择器、id选择器、类选择器、属性选择器、伪类选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 属性选择器</span><br><span class="line"><span class="selector-attr">[disabled]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择器的组合使用"><a href="#选择器的组合使用" class="headerlink" title="选择器的组合使用"></a>选择器的组合使用</h2><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">语法</th>
<th align="left">说明</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">直接组合</td>
<td align="center">AB</td>
<td align="left">满足A的同时满足B</td>
<td align="center"><code>input:focus</code></td>
</tr>
<tr>
<td align="left">后代组合</td>
<td align="center">A B</td>
<td align="left">选中B，如果他是A的子孙</td>
<td align="center"><code>nav a </code></td>
</tr>
<tr>
<td align="left">亲子组合</td>
<td align="center">A &gt; B</td>
<td align="left">选中B，如果他是A的子元素</td>
<td align="center"><code>selection &gt; p</code></td>
</tr>
<tr>
<td align="left">兄弟选择器</td>
<td align="center">A ~ B</td>
<td align="left">选中B，如果他在A后且和A同级</td>
<td align="center"><code>h2 ~ p</code></td>
</tr>
<tr>
<td align="left">相邻选择器</td>
<td align="center">A + B</td>
<td align="left">选中B，如果他<b>紧跟</b>在A的后面</td>
<td align="center"><code>h2 + p</code></td>
</tr>
</tbody></table>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>RGB</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a228ad26abb4bcaa8d5ea27ba31dc32~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>HSL</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/392aec0267444896883b6e5f64ef8208~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4c43482dfad478cac01c596feb73575~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd845c3faa8a4c748df64b56e37ec421~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>color：用来设置字体颜色</p>
<p>font-size:字体大小</p>
<ul>
<li>和font-size相关的单位：</li>
<li>em 相当于当前元素的一个font-size</li>
<li>rem相当于根元素的一个font-size</li>
</ul>
<p>font-family:字体族（字体的格式），可选值：（字体分类）</p>
<ul>
<li>serif 衬线字体</li>
<li>sans-serif 非衬线字体</li>
<li>monospave 等宽字体</li>
</ul>
<p>指定字体类别，浏览器会自动使用该类别下的字体，font-family可以同时指定多个字体，多个字体间使用,隔开，字体生效时优先使用第一个，第一个无法使用则使用第二个，以此类推</p>
<p>@font-face可以将服务器中的字体直接提供给用户去使用。</p>
<p>存在问题：</p>
<ul>
<li>1.加载速度</li>
<li>2.版权</li>
<li>3.字体格式</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac410a72e0c642e39256fc7f5f534699~tplv-k3u1fbpfcp-zoom-1.image"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;myfont&#x27;</span>; <span class="comment">/* 指定字体名字 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">/* 服务器端中的地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;myfont&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>font-weight 字重，字体加粗<br>可选值：</p>
<ul>
<li>normal 默认值，不加粗</li>
<li>blod 加粗</li>
<li>100-900 九个级别（没什么用）</li>
</ul>
<p>font-style 字体风格<br>可选值：</p>
<ul>
<li>normal 正常的</li>
<li>italic 斜体</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font</span>: style weight size/height family;</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/368829e3fe43434a99e9a1ddce0a06ea~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>text-aligh 设置文字对齐样式<br>可选值：</p>
<ul>
<li>left 左对齐 </li>
<li>center 居中对齐 </li>
<li>right 右对齐 </li>
<li>justify 两端对齐（对最后一行的文字不生效）</li>
</ul>
<p>letter-spacing:调整文字字母之间的间距<br>word-spacing:调整单词之间的距离<br>text-index:设置文字缩进</p>
<p>text-decoration 设置文本修饰<br>可选值：</p>
<ul>
<li>none 默认值，什么都没有</li>
<li>underline 下划线</li>
<li>line-through 删除线</li>
<li>overline 上划线</li>
</ul>
<p>white-space 设置网页如何处理空白<br>可选值：</p>
<ul>
<li>normal 默认值，正常</li>
<li>nowrap 不换行</li>
<li>pre 保留空白（源代码中文本格式不做处理，保留）</li>
<li>pre-wrap 一行内容显示不全会换行</li>
<li>pre-line 会保留换行</li>
</ul>
<h2 id="调试CSS"><a href="#调试CSS" class="headerlink" title="调试CSS"></a>调试CSS</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15843ca7bdfa44be9daca4ffc9257cb0~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>某些属性会自动继承其父元素的计算值，除非显式指定一个值。<br>一般与文字相关的样式都会被继承，与宽度、高度、盒模型相关的不会被继承。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 显示继承</span><br><span class="line">*&#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.some-widget</span>&#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a93cd90dc08e431abc172a2ca646f94d~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="CSS求值过程"><a href="#CSS求值过程" class="headerlink" title="CSS求值过程"></a>CSS求值过程</h2><p>如何从一个DOM节点生成一棵渲染树或渲染节点</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09d977f8411a4823bc1bf64381fa3542~tplv-k3u1fbpfcp-zoom-1.image"></p>
<ul>
<li>第一步：筛选出节点对应的样式（样式个数：0~多个）</li>
<li>第二步：筛选出样式中优先级最高的样式</li>
<li>第三步：查看样式是否为空，若是空的，则依据继承或者初始值</li>
<li>第四步：将一些相对值转化为绝对值（rem → px、相对路径 →  绝对路径等），这些绝对值是在浏览器未进行实际布局的情况下得到的具体值，其中会包含百分数。</li>
<li>第五步：将计算值进一步计算，即将百分比转化为具体数值等</li>
<li>第六步：上一步的计算值中可能会出现100.2px、超出min-width或max-width的情况，需要进一步将其转化为整数值</li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局相关技术：常规流、浮动、绝对定位</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e93f05f2ccaf46beb0939b197cfdfb2b~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="width和height"><a href="#width和height" class="headerlink" title="width和height"></a>width和height</h4><ul>
<li>指定content box 的宽度和高度；</li>
<li>取值为长度、百分比、auto【百分比时，只有元素的容器指定width和height的具体值时才会生效】</li>
</ul>
<h4 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/441bde485d5d4fa38e2f48007a75702c~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>设置数值为百分数时，是相对于元素容器宽度</p>
<h4 id="border"><a href="#border" class="headerlink" title="border"></a>border</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a312738c01b4bc5b10a4123a1a94bbd~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>使用border属性生成三角形 → <a href="https://qw-null.github.io/2021/09/22/CSS%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/#2-%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2">详情</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>:<span class="number">50px</span> solid red;</span><br><span class="line">  <span class="attribute">border-top</span>:<span class="number">50px</span> solid green;</span><br><span class="line">  <span class="attribute">border-right</span>:<span class="number">50px</span> solid blue;</span><br><span class="line">  <span class="attribute">border-bottom</span>:<span class="number">50px</span> solid yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca9e85b6ce224e0abab99b0b32343f34~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5950db38bc4b4843a2c889591fb82bb8~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><b>margin collapse问题（边距折叠）</b><br>仅仅发生在垂直方向上，水平方向上不会存在这个问题</p>
<ol>
<li>兄弟元素：兄弟元素间的相邻垂直外边距会取两者之间的较大值（正值），特殊情况：如果相邻的外边距一正一负，则取两者的和；如果相邻的外边距都是负值，则取两者中绝对值较大的</li>
<li>父子元素：父子元素间的相邻外边距，子元素的会传递给父元素（上外边距）</li>
</ol>
<h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p>默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定。<br>box-sizing 用来设置盒子尺寸的计算方式（设置width和height的作用）<br>可选值：</p>
<ul>
<li>content-box 默认值，宽度和高度用来设置内容区的大小</li>
<li>border-box 宽度和高度用来设置整个盒子可见框的大小（width和height指的是内容区、内边距和边框的总大小）</li>
</ul>
<h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><p>overflow属性用来设置父元素如何处理溢出的子元素<br>可选值：</p>
<ul>
<li>visible，默认值，子元素会从父元素中溢出，在父元素外部的位置显示</li>
<li>hidden，溢出的内容将会被裁剪不会显示</li>
<li>scroll，生成两个滚动条，通过滚动条来查看完整内容</li>
<li>auto，根据需要生成滚动条</li>
</ul>
<h4 id="块级-VS-行级"><a href="#块级-VS-行级" class="headerlink" title="块级 VS 行级"></a>块级 VS 行级</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f73e0eda7fd48078e965f79efc442e6~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b604b67902f46b6b0381e98a4aa3b1c~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h4><p>可选值：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0db732fa41da45fc9f92e79c2739ec85~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="常规流-Normal-Flow-文档流"><a href="#常规流-Normal-Flow-文档流" class="headerlink" title="常规流 Normal Flow (文档流)"></a>常规流 Normal Flow (文档流)</h4><ul>
<li>根元素、浮动和绝对定位的元素会脱离常规流</li>
<li>其他元素都在常规流之中</li>
<li>常规流中的盒子，在某种排版上下文中参与布局，可通过display属性设置</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8262764db73b437a8090b9a0a1b133ae~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h5 id="行级排版上下文"><a href="#行级排版上下文" class="headerlink" title="行级排版上下文"></a>行级排版上下文</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b0f2ac6b711436e9c299a24ee0a034e~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h5 id="块级排版上下文"><a href="#块级排版上下文" class="headerlink" title="块级排版上下文"></a>块级排版上下文</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/787387e2b30f4a279f0eb9cb47060e19~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h5 id="Flex-Box"><a href="#Flex-Box" class="headerlink" title="Flex Box"></a>Flex Box</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4e8bf862b9b47c98a290965e55685f4~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
flex-direction 指定容器中弹性元素的排列方式（主轴方向）

<p>   可选值：</p>
<ul>
<li>row 默认值，弹性元素在容器中水平排列（自左向右）</li>
<li>row-reverse 弹性元素在容器中反向水平排列（自右向左）</li>
<li>column 弹性元素纵向排列（自上向下）</li>
<li>column-reverse 弹性元素反向纵向排列（自下向上）</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffb6b591c2b64756af3876ad527a1a66~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de37ef63f41746a38c172e0b6dae4583~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
justify-content 如何分配主轴上的空白空间（主轴上的元素如何排列）

<p>   可选值：</p>
<ul>
<li>flex-start 元素沿着主轴的起边排列</li>
<li>flex-end 元素沿着主轴的终边排列</li>
<li>center 元素居中排列</li>
<li>space-around 空白分布到元素的两个</li>
<li>space-between 空白均匀分布到元素间</li>
<li>space-evenly 空白分布到元素的单侧</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01cb8f4b015040a58c05231eee8c38e4~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
align-items 定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式（元素间关系）

<p>   可选值：</p>
<ul>
<li>stretch 默认值，将元素的长度设置为相同的值</li>
<li>flex-start 元素不会拉伸，沿着辅轴起边对齐</li>
<li>flex-end 元素不会拉伸，沿着辅轴终边对齐</li>
<li>center 居中对齐</li>
<li>baseline 基线对齐</li>
</ul>
<p>  ** align-self 用来覆盖当前弹性元素上的align-items</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c9fe55c05bc4e3ab2bb914449a2359a~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3d3694162d942ada4dcceb0ac00ef7a~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
Flexibility

<ul>
<li>可以设置子项的弹性：当容器有剩余空间时，会伸展；容器空间不够时，会收缩。</li>
<li>flex-grow 有剩余空间时的伸展能力</li>
<li>flex-shrink 容器空间不足时收缩的能力</li>
<li>flex-basis 没有伸展或收缩时的基础长度</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b61f6dfc2e0b473a95dc952d36b19507~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h5 id="Grid-布局"><a href="#Grid-布局" class="headerlink" title="Grid 布局"></a>Grid 布局</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0af06cb54fc043c28538c5f755b612dc~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>Flex仅可以设置一个方向的布局，Grid是一个二维布局方式</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a28a40f5fdc04a95aac76a533beca73b~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
划分网格：

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">200px</span>;</span><br><span class="line">grid-template-rows: <span class="number">100px</span> <span class="number">100px</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/397276cb11a245fa8eeb1306659b1965~tplv-k3u1fbpfcp-zoom-1.image"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">30%</span> <span class="number">30%</span> auto;</span><br><span class="line">grid-template-rows: <span class="number">100px</span> auto;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fed64fe6060240128f8fefa4c792a760~tplv-k3u1fbpfcp-zoom-1.image"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">// fr表示一份</span><br><span class="line">// 含义：除去第一部分<span class="number">100px</span>外，剩余的第二部分、第三部分各占剩余部分的一份。</span><br><span class="line">grid-template-rows: <span class="number">100px</span> <span class="number">1</span>fr;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56556798271c413885435dfc7fc71057~tplv-k3u1fbpfcp-zoom-1.image"></p>
<hr/>
grid line网格线：

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/080fb704459b472699e90be75af5e271~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>grid area 网格区域：<br>网格区域使用网格线表示</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd7708ed23f24aa39f1afcc2f5fdfd77~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fae3b461f78c4000b6d2076ecb9a3809~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="浮动-Float"><a href="#浮动-Float" class="headerlink" title="浮动 Float"></a>浮动 Float</h4><p>通过浮动可以使一个元素向其父元素的左侧或者右侧移动，通过float属性来设置元素的浮动。<br>float可选值:</p>
<ul>
<li>none 默认值，元素不浮动</li>
<li>left 元素向左浮动</li>
<li>right 元素向右浮动</li>
</ul>
<h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>定位(position)，是一种更加高级的布局手段，通过定位可以将元素摆放在页面的任意位置，使用position属性来设置定位<br>可选值：</p>
<ul>
<li>static 默认值，元素是静止的没有开启定位</li>
<li>relative 开启元素相对定位</li>
<li>absolute 开启元素绝对定位</li>
<li>fixed 开启元素的固定定位</li>
<li>sticky 开启元素的粘滞定位</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5784d5476cf4490180f20e81e285f002~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/949b3423a1084ffe9fecd71f8a8d2126~tplv-k3u1fbpfcp-zoom-1.image"></p>
]]></content>
      <categories>
        <category>字节青训营</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
