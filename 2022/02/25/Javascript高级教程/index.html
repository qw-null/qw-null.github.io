<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Javascript高级教程"><meta name="keywords" content="JavaScript"><meta name="author" content="qinwei"><meta name="copyright" content="qinwei"><title>Javascript高级教程 | QW's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E6%B7%B1%E5%85%A5"><span class="toc-text">1.基础总结深入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.1数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-undefined%E4%B8%8Enull%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.undefined与null的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%BB%99%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E4%B8%BAnull"><span class="toc-text">2.什么时候给变量赋值为null?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%A5%E6%A0%BC%E5%8C%BA%E5%88%AB%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">3.严格区别变量类型与数据类型？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8F%98%E9%87%8F%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-text">1.2 数据，变量与内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-text">1.2.1 什么是数据？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-text">1.2.2 什么是内存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-text">1.2.3 什么是变量？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E5%86%85%E5%AD%98%E3%80%81%E6%95%B0%E6%8D%AE%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">1.2.4 内存、数据、变量三者之间的关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">1.2.5 相关问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%AD%90-var-a-xxx%EF%BC%8Ca%E5%86%85%E5%AD%98%E4%B8%AD%E5%88%B0%E5%BA%95%E4%BF%9D%E5%AD%98%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">⭐ var a &#x3D; xxx，a内存中到底保存的是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%AD%90-%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">⭐ 关于引用变量赋值问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%AD%90-%E5%9C%A8JS%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%97%B6%E4%BC%A0%E9%80%92%E5%8F%98%E9%87%8F%E5%8F%82%E6%95%B0%EF%BC%8C%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-text">⭐ 在JS调用函数时传递变量参数，是值传递还是引用传递？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%AD%90-JS%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-text">⭐ JS引擎如何管理内存？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.3 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">1.3.1 什么是对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">1.3.2 为什么用对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">1.3.3 对象的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-text">1.3.4 如何访问对象内部数据？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%AD%90-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-39-%E5%B1%9E%E6%80%A7%E5%90%8D-39-%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">⭐ 什么情况下必须使用[&#39;属性名&#39;]的方式？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%87%BD%E6%95%B0"><span class="toc-text">1.4 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">1.4.1 什么是函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">1.4.2 为什么要用函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">1.4.3 如何定义函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%EF%BC%88%E6%89%A7%E8%A1%8C%EF%BC%89%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">1.4.4 如何调用（执行）函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">1.4.4 回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">什么是回调函数？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">常见的回调函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-5-IIFE"><span class="toc-text">1.4.5 IIFE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-6-%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this"><span class="toc-text">1.4.6 函数中的this</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#this-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">this 是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Athis%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="toc-text">如何确定this的值？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7"><span class="toc-text">2.函数高级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">2.1原型与原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%8E%9F%E5%9E%8B%EF%BC%88prototype%EF%BC%89"><span class="toc-text">2.1.1 原型（prototype）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E6%98%BE%E5%BC%8F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B"><span class="toc-text">2.1.2 显式原型与隐式原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">2.1.3 原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-text">小结：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%B1%9E%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">原型链的属性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-instanceof"><span class="toc-text">2.1.4 instanceof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">2.1.5 面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%80%E5%BC%A0%E5%9B%BE"><span class="toc-text">原型链一张图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88"><span class="toc-text">2.2执行上下文与执行上下文栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-text">2.2.1 变量提升与函数提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">2.2.2 执行上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88"><span class="toc-text">2.2.3 执行上下文栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">2.3作用域与作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">2.3.1 作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">2.3.2 作用域与执行上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">2.3.3 作用域链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">2.3.4 面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E9%97%AD%E5%8C%85"><span class="toc-text">2.4闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-text">2.4.1 常见的闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">2.4.2 闭包的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E9%97%AD%E5%8C%85%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">2.4.3 闭包的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%AE%9A%E4%B9%89JS%E6%A8%A1%E5%9D%97"><span class="toc-text">2.4.3 闭包的应用：定义JS模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E9%97%AD%E5%8C%85%E7%9A%84%E7%BC%BA%E7%82%B9%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-text">2.4.4 闭包的缺点及解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">2.4.5 面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7"><span class="toc-text">3.面向对象高级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F"><span class="toc-text">3.1 对象创建模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">3.2 原型链继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">3.2.1 方式一： 原型链继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A-%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%EF%BC%88%E5%81%87%E7%9A%84%EF%BC%89"><span class="toc-text">3.2.2 方式二： 借用构造函数继承（假的）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%93%BE-%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">3.2.3 方式三： 组合继承（原型链 + 借用构造函数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E8%A1%A5%E5%85%85%EF%BC%9Anew%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%83%8C%E5%90%8E%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3.2.4 补充：new一个对象背后做了什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">4.线程机制与事件机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">4.1 进程与线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="toc-text">4.2 浏览器内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-text">4.3 定时器引发的思考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-JS%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-text">4.4 JS是单线程执行的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88%E8%BD%AE%E8%AF%A2%EF%BC%89%E6%A8%A1%E5%9E%8B"><span class="toc-text">4.5 事件循环（轮询）模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E6%A8%A1%E5%9E%8B%E5%8E%9F%E5%9E%8B%E5%9B%BE"><span class="toc-text">4.5.1 模型原型图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">4.5.2 相关概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-H5-Web-Workers%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="toc-text">4.6 H5 Web Workers（多线程）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E9%97%AE%E9%A2%98"><span class="toc-text">补充问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E5%88%86%E5%8F%B7%E9%97%AE%E9%A2%98"><span class="toc-text">JS分号问题</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20211013182113.JPG"></div><div class="author-info__name text-center">qinwei</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/qw-null">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">154</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">43</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/qw-null/BlogImages/223.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">QW's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/archives">创作时间线</a><a class="site-page" target="_blank" rel="noopener" href="https://github.com/qw-null">Github</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Javascript高级教程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript/">JavaScript</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">11.7k</span><span class="post-meta__separator">|</span><span>阅读时长: 43 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14s411E7qf?share_source=copy_web">尚硅谷JavaScript高级教程(javascript实战进阶)</a></p>
<h2 id="1-基础总结深入"><a href="#1-基础总结深入" class="headerlink" title="1.基础总结深入"></a>1.基础总结深入</h2><h3 id="1-1数据类型"><a href="#1-1数据类型" class="headerlink" title="1.1数据类型"></a>1.1数据类型</h3><p>两大类：1.基本（值）类型  2.对象（引用）类型</p>
<ol>
<li><p>基本（值）类型<br>String：任意字符串<br>Number：任意数字<br>Symbol：代表创建后独一无二且不可变的数据类型【它的出现我认为是为了解决可能出现的全局变量冲突的问题】<br>Boolean：true / false<br>Undefined：undefined<br>Null：null</p>
</li>
<li><p>对象（引用）类型<br>Object：任意对象<br>Function：一种特别的对象（特别在可以执行）<br>Array：一种特别的对象（特别在属性为数值下标，内部数据是有序的）</p>
</li>
<li><p>判断数据类型</p>
</li>
</ol>
<ul>
<li>typeof  ： 可以判断：undefined / 数值 / 字符串 / 布尔值</li>
<li>typeof  ： 不可以判断：<b style="background:yellow;">null与object、object与array</b></li>
<li>instanceof ：判断对象的具体类型</li>
<li>===  ： 可以判断：undefined / null （因为这两者只有一个数值）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.基本数据类型</span></span><br><span class="line"><span class="comment">// typeof 返回数据类型的字符串表达</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Undefined</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a, <span class="keyword">typeof</span> a, <span class="keyword">typeof</span> a === <span class="string">&#x27;undefined&#x27;</span>, a === <span class="literal">undefined</span>); <span class="comment">// undefined  &#x27;undefined&#x27;  true  true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String</span></span><br><span class="line">a = <span class="string">&#x27;angle&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean</span></span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a === <span class="string">&#x27;boolean&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Null</span></span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="literal">null</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.对象数据类型</span></span><br><span class="line"><span class="keyword">var</span> b1 = &#123;</span><br><span class="line">  <span class="attr">b2</span>: [<span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="built_in">console</span>.log],</span><br><span class="line">  <span class="attr">b3</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b3&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.b2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>, b1.b2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// true true</span></span><br><span class="line"><span class="built_in">console</span>.log(b1.b3 <span class="keyword">instanceof</span> <span class="built_in">Function</span>, b1.b3 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// true true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1.b3 === <span class="string">&#x27;function&#x27;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>为什么<code>b1.b3 instanceof Object</code> 是 <code>true</code>，这是因为函数是一种特殊的对象。</p>
<p>对于上述定义中的<code>b2</code>的第三个元素<code>console.log</code>进行类型判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1.b2[<span class="number">2</span>] === <span class="string">&#x27;function&#x27;</span>);<span class="comment">//true</span></span><br><span class="line">b1.b2[<span class="number">2</span>](<span class="number">4</span>);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="1-undefined与null的区别是什么？"><a href="#1-undefined与null的区别是什么？" class="headerlink" title="1.undefined与null的区别是什么？"></a>1.undefined与null的区别是什么？</h4><ul>
<li>undefined 代表定义未赋值</li>
<li>null表示定义了变量并且赋值为null</li>
</ul>
<h4 id="2-什么时候给变量赋值为null"><a href="#2-什么时候给变量赋值为null" class="headerlink" title="2.什么时候给变量赋值为null?"></a>2.什么时候给变量赋值为null?</h4><ul>
<li>初始赋值为null，表明将要赋值为对象。</li>
<li>结束前，让对象成为垃圾对象（被垃圾回收器回收）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起始</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">null</span>; <span class="comment">// 初始赋值为null，表明将要赋值为对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定对象就要赋值</span></span><br><span class="line">b = [<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后</span></span><br><span class="line">b = <span class="literal">null</span>; <span class="comment">// 释放对象：让b指向的对象成为垃圾对象（被垃圾回收器回收）</span></span><br></pre></td></tr></table></figure>
<h4 id="3-严格区别变量类型与数据类型？"><a href="#3-严格区别变量类型与数据类型？" class="headerlink" title="3.严格区别变量类型与数据类型？"></a>3.严格区别变量类型与数据类型？</h4><p>数据的类型：*基本类型  *对象类型<br>变量类型（变量内存值的类型）：<br>*基本类型：保存基本类型的数据<br>*引用类型：保存地址值</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228110010.png"></p>
<p>对于上图中的变量<code>a</code>和<code>b</code>，因为其存储的是基本类型，所以数据直接保存在栈内存中，而对于变量<code>c</code>而言，其代表对象，因此在栈内存中只存储该对象在堆内存中的地址。</p>
<h3 id="1-2-数据，变量与内存"><a href="#1-2-数据，变量与内存" class="headerlink" title="1.2 数据，变量与内存"></a>1.2 数据，变量与内存</h3><h4 id="1-2-1-什么是数据？"><a href="#1-2-1-什么是数据？" class="headerlink" title="1.2.1 什么是数据？"></a>1.2.1 什么是数据？</h4><p>● 存储在内存中的代表特定信息的东西，本质上是0101……<br>● 数据的特点：可传递、可运算<br>● 一切皆数据<br>● 内存中所有操作的目标：数据【*算术运算 、 *逻辑运算、 <em>赋值运算 、</em>运行函数】</p>
<h4 id="1-2-2-什么是内存？"><a href="#1-2-2-什么是内存？" class="headerlink" title="1.2.2 什么是内存？"></a>1.2.2 什么是内存？</h4><p>● 内存条通电之后产生的可存储数据的空间（临时的）；<br>● 内存的产生和死亡：内存条（电路板） → 通电  → 产生内存空间  → 存储数据  → 处理数据  →  断电  →  内存空间和数据都消失；<br>● 一块小内存可以保存的2种数据：内部存储的数据 + 地址值<br>● 内存的分类：<br>  栈：全局变量和局部变量（空间较小）<br>  堆：对象（空间较大）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br></pre></td></tr></table></figure>
<p>上述代码在打印时，首先读取的是<code>obj</code>，此时读取的是<code>obj</code>的内容值，只不过内容值当中存储的是<code>obj</code>的地址值。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228114525.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228114817.png"></p>
<h4 id="1-2-3-什么是变量？"><a href="#1-2-3-什么是变量？" class="headerlink" title="1.2.3 什么是变量？"></a>1.2.3 什么是变量？</h4><p>可变化的量，由变量名和变量值组成；<br>每个变量都对应一小块内存，变量名用来查找对应的内存，变量值就是内存中保存的数据</p>
<h4 id="1-2-4-内存、数据、变量三者之间的关系？"><a href="#1-2-4-内存、数据、变量三者之间的关系？" class="headerlink" title="1.2.4 内存、数据、变量三者之间的关系？"></a>1.2.4 内存、数据、变量三者之间的关系？</h4><p>● 内存：用来存储数据的的空间<br>● 变量：是内存的标识</p>
<h4 id="1-2-5-相关问题："><a href="#1-2-5-相关问题：" class="headerlink" title="1.2.5 相关问题："></a>1.2.5 相关问题：</h4><h5 id="⭐-var-a-xxx，a内存中到底保存的是什么？"><a href="#⭐-var-a-xxx，a内存中到底保存的是什么？" class="headerlink" title="⭐ var a = xxx，a内存中到底保存的是什么？"></a>⭐ var a = xxx，a内存中到底保存的是什么？</h5><ul>
<li>xxx是基本数据，保存的是这个数据</li>
<li>xxx是对象，保存的是对象的地址值</li>
<li>xxx是一个变量，保存的是xxx的内容值（可能是基本数据，也可能是地址值）</li>
</ul>
<h5 id="⭐-关于引用变量赋值问题？"><a href="#⭐-关于引用变量赋值问题？" class="headerlink" title="⭐ 关于引用变量赋值问题？"></a>⭐ 关于引用变量赋值问题？</h5><p>● n个引用变量指向同一个对象，通过一个变量修改对象内部的数据，其他所有变量看到的是修改之后的数据。</p>
<p>● 2个引用对象指向同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br></pre></td></tr></table></figure>
<p>上述代码中，实现了将<code>obj1</code>的内容保存的<code>obj2</code>【<code>obj1</code>中保存的是地址值】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name) <span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// Bob</span></span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">age</span>:<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = &#123;<span class="attr">name</span>:<span class="string">&#x27;Bob&#x27;</span>,<span class="attr">age</span>:<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b.age,a.name,a.age); <span class="comment">// 12 Bob 13</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj = &#123;<span class="attr">age</span>:<span class="number">15</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fn2(a);</span><br><span class="line"><span class="built_in">console</span>.log(a.age); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>上述第二部分代码图示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220302084101.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220228154520.png"></p>
<p>代码执行完毕之后，<code>age:15</code>会在哪里？<br>变量<code>obj</code>是函数的局部变量，在函数执行完毕之后，局部变量会被释放，一旦局部变量<code>obj</code>被释放，那么其指向的<code>age:15</code>就会被当作垃圾对象回收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  obj.name = <span class="string">&#x27;Lily&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn3(a);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Lily</span></span><br></pre></td></tr></table></figure>
<p>实际上只要是没有切断变量与堆内存中存储内容之间的执行，修改其中一个，其他都会跟着变。</p>
<h5 id="⭐-在JS调用函数时传递变量参数，是值传递还是引用传递？"><a href="#⭐-在JS调用函数时传递变量参数，是值传递还是引用传递？" class="headerlink" title="⭐ 在JS调用函数时传递变量参数，是值传递还是引用传递？"></a>⭐ 在JS调用函数时传递变量参数，是值传递还是引用传递？</h5><p>答案：</p>
<ul>
<li>理解1：都是值传递，值分为两种：基本值和地址值。</li>
<li>理解2：可能是值传递，也可能是引用传递（地址值）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(a);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220302091425.png"></p>
<h5 id="⭐-JS引擎如何管理内存？"><a href="#⭐-JS引擎如何管理内存？" class="headerlink" title="⭐ JS引擎如何管理内存？"></a>⭐ JS引擎如何管理内存？</h5><p>1.内存生命周期</p>
<ul>
<li>分配小内存空间，得到它的使用权</li>
<li>存储数据，可以反复进行操作</li>
<li>释放小内存空间</li>
</ul>
<p>2.释放内存</p>
<ul>
<li>局部变量：函数执行完自动释放</li>
<li>对象：成为垃圾对象，由垃圾回收器回收</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码中共使用几个内存空间？<br>3个内存空间。一个是栈内存a，存储数据3；一个是栈内存obj，存储数据{}（堆内存）的地址；另一个是堆内存中存储的{}。</p>
<hr>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码中共使用几个内存空间？<br>2个内存空间。一个是栈内存a，存储数据3；一个是栈内存obj，存储值为null。堆内存中存储的{}被回收。</p>
<hr>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p>上述代码中的b在函数<code>fn()</code>执行完毕之后会自动释放，而b指向的对象是在后面的某个时刻由垃圾回收器回收。</p>
<h3 id="1-3-对象"><a href="#1-3-对象" class="headerlink" title="1.3 对象"></a>1.3 对象</h3><h4 id="1-3-1-什么是对象？"><a href="#1-3-1-什么是对象？" class="headerlink" title="1.3.1 什么是对象？"></a>1.3.1 什么是对象？</h4><p>多个数据的封装体 或者 是用来保存多个数据的容器；<br>一个对象代表现实中的一个事物</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-为什么用对象？"><a href="#1-3-2-为什么用对象？" class="headerlink" title="1.3.2 为什么用对象？"></a>1.3.2 为什么用对象？</h4><p>统一管理多个数据</p>
<h4 id="1-3-3-对象的组成"><a href="#1-3-3-对象的组成" class="headerlink" title="1.3.3 对象的组成"></a>1.3.3 对象的组成</h4><p>属性 + 方法<br>♥ 属性：属性名（字符串）和属性值（任意类型）组成<br>♥ 方法：是一种特别的属性（属性值是函数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">13</span>,</span><br><span class="line">  <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">setAge</span>: <span class="function"><span class="keyword">function</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name, person.setName)</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220302110213.png"></p>
<h4 id="1-3-4-如何访问对象内部数据？"><a href="#1-3-4-如何访问对象内部数据？" class="headerlink" title="1.3.4 如何访问对象内部数据？"></a>1.3.4 如何访问对象内部数据？</h4><p>※ 第一种方式：<code>.属性名</code>，编码简单，有时不能用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.setName(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line">p.name;</span><br></pre></td></tr></table></figure>
<p>※ 第二种方式：<code>[&#39;属性名&#39;]</code>，编码麻烦，能通用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">&#x27;setAge&#x27;</span>](<span class="number">23</span>);</span><br><span class="line">p[<span class="string">&#x27;age&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h5 id="⭐-什么情况下必须使用-39-属性名-39-的方式？"><a href="#⭐-什么情况下必须使用-39-属性名-39-的方式？" class="headerlink" title="⭐ 什么情况下必须使用[&#39;属性名&#39;]的方式？"></a>⭐ 什么情况下必须使用<code>[&#39;属性名&#39;]</code>的方式？</h5><p>1.属性名包含特殊字符：- 、空格<br>2.属性名不确定（属性名是个变量）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;&#125;</span><br><span class="line"><span class="number">1.</span>给p对象添加一个属性：content-type : text/json</span><br><span class="line">p.content-type = <span class="string">&#x27;text/json&#x27;</span>  <span class="comment">// 不能用</span></span><br><span class="line">p[<span class="string">&#x27;content-type&#x27;</span>] = <span class="string">&#x27;text/json&#x27;</span> <span class="comment">//可以使用</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>属性名不确定（属性名是个变量）</span><br><span class="line"><span class="keyword">var</span> propName = <span class="string">&#x27;myAge&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">18</span>;</span><br><span class="line">p.propName = value; <span class="comment">//不能用</span></span><br><span class="line">p[propName] = value; <span class="comment">//可以使用</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-函数"><a href="#1-4-函数" class="headerlink" title="1.4 函数"></a>1.4 函数</h3><h4 id="1-4-1-什么是函数？"><a href="#1-4-1-什么是函数？" class="headerlink" title="1.4.1 什么是函数？"></a>1.4.1 什么是函数？</h4><p>实现特定功能的n条语句的封装体<br>只有函数是可以执行的，其他类型的数据不能执行</p>
<h4 id="1-4-2-为什么要用函数？"><a href="#1-4-2-为什么要用函数？" class="headerlink" title="1.4.2 为什么要用函数？"></a>1.4.2 为什么要用函数？</h4><p>提高代码复用、便于阅读交流</p>
<h4 id="1-4-3-如何定义函数？"><a href="#1-4-3-如何定义函数？" class="headerlink" title="1.4.3 如何定义函数？"></a>1.4.3 如何定义函数？</h4><p>函数声明<br>表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>函数声明</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn1()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>表达式</span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn2()&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-4-如何调用（执行）函数？"><a href="#1-4-4-如何调用（执行）函数？" class="headerlink" title="1.4.4 如何调用（执行）函数？"></a>1.4.4 如何调用（执行）函数？</h4><p>直接调用：<code>test()</code><br>通过对象调用：<code>obj.test()</code><br>new调用：<code>new test()</code><br>临时让test成为obj的方法进行调用：<code>test.call(obj) </code>、<code> test.apply(obj)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.xx = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* obj.test(); <span class="comment">// 不能直接调用，因为obj中根本没有这个函数</span></span><br><span class="line"></span><br><span class="line">test.call(obj) <span class="comment">//可以让一个函数成为指定任意对象的方法进行调用</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.xx) <span class="comment">// Hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-4-4-回调函数"><a href="#1-4-4-回调函数" class="headerlink" title="1.4.4 回调函数"></a>1.4.4 回调函数</h4><h5 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a>什么是回调函数？</h5><p>3个特点：<br>1）自己定义的<br>2）没有调用<br>3）最终执行了（在某个时刻 或者 某个条件下）</p>
<h5 id="常见的回调函数"><a href="#常见的回调函数" class="headerlink" title="常见的回调函数"></a>常见的回调函数</h5><ul>
<li>dom事件的回调函数 ➡ this指的是发生事件的dom元素</li>
<li>定时器回调函数 ➡ this指的是window</li>
<li>ajax请求回调函数</li>
<li>生命周期回调函数</li>
</ul>
<h4 id="1-4-5-IIFE"><a href="#1-4-5-IIFE" class="headerlink" title="1.4.5 IIFE"></a>1.4.5 IIFE</h4><p>Immediately-Invoked Function Expression，立即调用函数表达式<br>匿名函数自调用 = IIFE<br>IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数自调用</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p><b> ♥ 作用：</b></p>
<ul>
<li>隐藏实现</li>
<li>不会污染外部（全局）命名空间</li>
<li>用它来编写js模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//向外暴露一个全局函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">test</span>: test</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">$().test() <span class="comment">// 1.$是一个函数 2.$执行后返回的是一个对象</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-6-函数中的this"><a href="#1-4-6-函数中的this" class="headerlink" title="1.4.6 函数中的this"></a>1.4.6 函数中的this</h4><h5 id="this-是什么？"><a href="#this-是什么？" class="headerlink" title="this 是什么？"></a>this 是什么？</h5><ul>
<li>任何函数本质上都是通过某个对象来调用的</li>
<li>所有函数内部都有一个变量this</li>
<li>它的值是调用函数的当前对象</li>
</ul>
<h5 id="如何确定this的值？"><a href="#如何确定this的值？" class="headerlink" title="如何确定this的值？"></a>如何确定this的值？</h5><ul>
<li><code>test()</code> ：window</li>
<li><code>p.test()</code> ：p</li>
<li><code>new test()</code> ：新创建的对象</li>
<li><code>p.call(obj)</code>：obj</li>
</ul>
<blockquote>
<ol>
<li>函数调用时，指向window </li>
<li>以方法调用时，指向调用该方法的对象 </li>
<li>使用new创建一个对象时，指向新创建的对象 </li>
<li>call,apply ,bind可以改变this指向，this指向指定的那个对象</li>
<li>在全局作用域中this代表window</li>
</ol>
</blockquote>
<h2 id="2-函数高级"><a href="#2-函数高级" class="headerlink" title="2.函数高级"></a>2.函数高级</h2><h3 id="2-1原型与原型链"><a href="#2-1原型与原型链" class="headerlink" title="2.1原型与原型链"></a>2.1原型与原型链</h3><h4 id="2-1-1-原型（prototype）"><a href="#2-1-1-原型（prototype）" class="headerlink" title="2.1.1 原型（prototype）"></a>2.1.1 原型（prototype）</h4><p><b>1.函数的<code>prototype</code>属性</b></p>
<ul>
<li>每个函数都有一个<code>prototype</code>属性，它默认指向一个<code>Object</code>空对象（即称为：原型对象）<blockquote>
<p>何为Object空对象？ 没有我们自己定义的属性</p>
</blockquote>
</li>
<li>原型对象中有一个属性<code>constructor </code>，它指向函数对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype.constructor === <span class="built_in">Date</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(fun.prototype.constructor === fun); <span class="comment">//true（fun为自定义函数）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220303112643.png"><br>⭐ 构造函数和它的原型对象是一个相互引用的关系。<br>解释相互引用：当前存在两个对象<code>A</code>和<code>B</code>，<code>A</code>当中有一个属性可以找到<code>B</code>，<code>B</code>当中有一个属性可以找到<code>A</code>。</p>
<p><b>2.给原型对象添加属性（这里的属性一般都是方法）</b><br>给原型对象添加属性（一般是方法）➡ 实例对象可以访问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给原型对象添加属性（一般是方法）➡ 实例对象可以访问</span></span><br><span class="line">Fun.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;test方法&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> Fun();</span><br><span class="line">fun.test();<span class="comment">// test方法</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-显式原型与隐式原型"><a href="#2-1-2-显式原型与隐式原型" class="headerlink" title="2.1.2 显式原型与隐式原型"></a>2.1.2 显式原型与隐式原型</h4><ol>
<li>每个函数<code>function</code>都有一个<code>prototype</code>，即显式原型（属性）</li>
<li>每个实例对象都有一个<code>__proto__</code>，可称为隐式原型（属性）</li>
<li>对象的隐式原型的值为其对应构造函数的显式原型的值</li>
<li>总结：</li>
</ol>
<ul>
<li>函数的<code>prototype</code>属性：在定义函数时自动添加的，默认为一个空Object对象</li>
<li>对象的<code>__proto__</code>属性：在创建对象时自动添加的，默认值为构造函数的<code>prototype</code>属性值</li>
<li>程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 内部语句：this.prototype = &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 每个函数function都有一个prototype，即显式原型（属性），默认指向一个空Object对象</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.每个实例对象都有一个__proto__，可称为隐式原型（属性）</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn(); <span class="comment">// 内部语句：this.__proto__ = Fn.prototype;</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.__proto__);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.对象的隐式原型的值为其对应构造函数的显式原型的值</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype === fn.__proto__) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给原型添加方法</span></span><br><span class="line">Fn.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过实例对象调用原型的方法</span></span><br><span class="line">fn.test()</span><br></pre></td></tr></table></figure>
<p>上述代码内存结构图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220304121321.png"></p>
<h4 id="2-1-3-原型链"><a href="#2-1-3-原型链" class="headerlink" title="2.1.3 原型链"></a>2.1.3 原型链</h4><p>访问一个对象的属性时：</p>
<ul>
<li>先在自身属性中查找，如果找到则返回</li>
<li>如果未找到，再沿着<code>__proto__</code>这条链向上查找，找到返回</li>
<li>如果最终没有找到，返回<code>undefined</code></li>
</ul>
<p>原型链的别名是隐式原型链。<br>原型链的作用：查找对象的属性（方法），只是用来查找，如果是一些赋值操作等，则不会查找原型链。</p>
<p><b style="background:#f8df70">原型链的本质是隐式原型链。</b><br>原型链的尽头是<code>Object的原型对象</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.test1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test1()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype);</span><br><span class="line">Fn.prototype.test2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;test2()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn()</span><br><span class="line"></span><br><span class="line">fn.test1(); <span class="comment">// test1()</span></span><br><span class="line">fn.test2(); <span class="comment">// test2()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn.toString()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.test3); <span class="comment">// undefined</span></span><br><span class="line">fn.test3(); <span class="comment">//  &quot;TypeError: fn.test3 is not a function</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220305205820.png"><br>原型链的尽头是<code>Object的原型对象</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220305214943.png"><br>创建两个实例对象，实例对象有隐式原型属性<code>__proto__</code>，这个隐式原型属性指向的是Object的原型对象，（隐式原型属性<code>__proto__</code>的值是将<code>prototype</code>的值赋给它得到的）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220306140152.png"></p>
<ul>
<li><p>所有函数的<code>__proto__</code>都是一样的，都是通过<code>new Function()</code>产生的</p>
</li>
<li><p>任何函数都是通过<code>new Function()</code>产生的.因此，所有函数对象的隐式原型都指向<code>Function.prototype</code></p>
</li>
<li><p>实例对象的隐式原型属性等于构造函数的显示原型属性</p>
</li>
</ul>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li><p>函数的显式原型指向的对象：默认是空Object实例对象【但是Object不满足】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.test1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test1()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307084657.png"><br>( 😀 因此，上图中存在绿色部分)</p>
</li>
<li><p>所有函数都是Function的实例，包括Function它自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>Object 的原型对象是原型链的尽头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="原型链的属性问题"><a href="#原型链的属性问题" class="headerlink" title="原型链的属性问题"></a>原型链的属性问题</h4><ul>
<li>读取对象属性值时：会自动到原型链中查找</li>
<li>设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加属性并设置其值</li>
<li>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</li>
</ul>
<p>※ <i style = "background:#a7ed3d">原型链是用来查找属性的，当为一个对象添加属性时，不会看原型链</i></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.a = <span class="string">&#x27;AAA&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(fn1.a); <span class="comment">// AAA</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> Fn();</span><br><span class="line">fn2.a = <span class="string">&#x27;BBB&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fn1.a, fn2.a); <span class="comment">// AAA BBB</span></span><br></pre></td></tr></table></figure>
<p>此时<code>fn1</code>的内容为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307101504.png"><br>⭐ 查找<code>fn1</code>的<code>a</code>属性值时，发现<code>fn1</code>本身没有属性<code>a</code>，所以会自动到原型链中查找属性<code>a</code>。</p>
<p>此时<code>fn2</code>的内容为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307101627.png"><br>⭐ 查找<code>fn2</code>的<code>a</code>属性值时，发现<code>fn2</code>本身有属性<code>a</code>，所以直接输出该属性值，不再去查找原型链，但是原型链中实际上仍存在属性<code>a</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line">p1.setName(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br></pre></td></tr></table></figure>
<p>⭐ 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Lily&#x27;</span>, <span class="number">13</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__ === p2.__proto__) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>⭐ 实例对象的隐式原型等于构造函数的显式原型</p>
<h4 id="2-1-4-instanceof"><a href="#2-1-4-instanceof" class="headerlink" title="2.1.4 instanceof"></a>2.1.4 instanceof</h4><p>instanceof 作用：<code>a instanceof b</code> → 判断<code>a</code>是否是<code>b</code>的实例【其中，a是实例对象，b是构造函数】</p>
<ul>
<li>instanceof 是如何判断的？<br>表达式：<code>A instanceof B</code><br>如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220307113311.png"></p>
<hr>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> Foo); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E6%97%A0%E6%A0%87%E9%A2%98.png"></p>
<h4 id="2-1-5-面试题"><a href="#2-1-5-面试题" class="headerlink" title="2.1.5 面试题"></a>2.1.5 面试题</h4><p><b>题目1</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">A.prototype.n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">A.prototype = &#123; <span class="comment">//这步操作直接改变了原型对象</span></span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> A()</span><br><span class="line"><span class="built_in">console</span>.log(b.n, b.m, c.n, c.m);<span class="comment">// 1 undefined  2 3</span></span><br></pre></td></tr></table></figure>

<p>上述代码在内存中的示意图：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220308130123.png"><br>（<em>最开始是是红色指示线，后来变为蓝色指示线</em>）</p>
<p>两种表达方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">表达方式<span class="number">1</span>：</span><br><span class="line">B.prototype.n = <span class="number">1</span>;</span><br><span class="line">表达方式<span class="number">2</span>：</span><br><span class="line">B.prototype = &#123; </span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中表达方式1会影响原有的实例对象，因为表达方式1是在原有的实例对象上添加到。<br>表达方式2不会影响原有的实例对象，因为表达方式2直接改变了实例对象原型。</p>
<p>对于代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.prototype = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的理解：现在堆内存中创建对象<code>&#123;n:2,m:3&#125;</code>，然后改变<code>A.prototype</code>的指向。（<em>蓝色指示线部分</em>）</p>
<p><b>题目2</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b()&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> F();</span><br><span class="line">fn.a(); <span class="comment">// a()</span></span><br><span class="line">fn.b(); <span class="comment">// TypeError: fn.b is not a function</span></span><br><span class="line">F.a(); <span class="comment">// a()</span></span><br><span class="line">F.b(); <span class="comment">// b()</span></span><br></pre></td></tr></table></figure>

<h4 id="原型链一张图"><a href="#原型链一张图" class="headerlink" title="原型链一张图"></a>原型链一张图</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg"></p>
<p><b>实记口诀：</b></p>
<ol>
<li>函数都是<code>Function</code>构造出来的</li>
<li>一切函数都是对象，只要是函数对象，就会有原型<code>prototype</code>和隐式原型<code>__proto__</code>两个属性</li>
<li>普通对象身上只有<code>__proto__</code>，没有<code>prototype</code></li>
<li>实例化对象的<code>__proto__</code>都指向构造函数的<code>prototype</code></li>
<li>所有函数的<code>prototype</code>都指向自身的<code>prototype</code></li>
<li>所有的<code>prototype</code>的<code>__proto__</code>都指向<code>Object.prototype</code>（Object除外）</li>
<li>所有函数对象的<code>__proto__</code>都指向<code>Function.prototype</code>（包括Function自身）</li>
<li>所有对象身上都有<code>constructor</code>指向函数自身</li>
</ol>
<h3 id="2-2执行上下文与执行上下文栈"><a href="#2-2执行上下文与执行上下文栈" class="headerlink" title="2.2执行上下文与执行上下文栈"></a>2.2执行上下文与执行上下文栈</h3><h4 id="2-2-1-变量提升与函数提升"><a href="#2-2-1-变量提升与函数提升" class="headerlink" title="2.2.1 变量提升与函数提升"></a>2.2.1 变量提升与函数提升</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面试题：程序最终输出什么？</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上述代码的实际执行过程是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//undefined   </span></span><br><span class="line">fn2(); <span class="comment">// fn2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn2&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在执行<code>console.log</code>时，变量<code>b</code>和函数<code>fn2</code>均未提前声明，但是仍然可以执行。原因是变量<code>b</code>进行了变量提升，函数<code>fn2</code>进行了函数提升。</p>
<ol>
<li>变量（声明）提升<br>通过<code>var</code>定义（声明）的变量，在定义语句之前就可以访问到，值为<code>undefined</code></li>
<li>函数（声明）提升<br>通过<code>function</code>声明的函数，在之前就可以直接调用，值为函数定义。<br>函数提升必须使用声明的方式。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn2&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309091249.png"></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn3); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn3&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码遵循的是变量提升。</p>
<h4 id="2-2-2-执行上下文"><a href="#2-2-2-执行上下文" class="headerlink" title="2.2.2 执行上下文"></a>2.2.2 执行上下文</h4><p><b>1.代码分类</b><br>全局代码 和 函数（局部）代码</p>
<p><b>2.全局执行上下文</b><br>在执行全局代码前将<code>window</code>确定为全局执行上下文。</p>
<p>对全局数据进行预处理:</p>
<ul>
<li><code>var</code>定义的全局变量 → <code>undefined</code>，添加为<code>window</code>的属性</li>
<li><code>function</code>声明的全局函数 → 赋值（<code>fun</code>）,添加为<code>window</code>的方法</li>
<li><code>this</code> → 赋值（<code>var</code>）</li>
</ul>
<p>–上述过程是在全局代码执行之前就会进行的操作</p>
<ul>
<li>执行全局代码</li>
</ul>
<p><b>3.函数执行上下文</b><br>在调用函数时，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈中）</p>
<p>对局部数据进行预处理：</p>
<ul>
<li>形参变量 → 赋值（实参） → 添加为执行上下文的属性</li>
<li><code>arguments</code> → 赋值（实参列表），添加为执行上下文的属性</li>
<li><code>var</code>定义的局部变量 → undefined，添加为执行上下文的属性</li>
<li><code>function</code>声明的函数 → 赋值（fun），添加为执行上下文的方法</li>
<li><code>this</code> → 赋值（调用函数的对象）</li>
</ul>
<p>开始执行函数体代码</p>
<h4 id="2-2-3-执行上下文栈"><a href="#2-2-3-执行上下文栈" class="headerlink" title="2.2.3 执行上下文栈"></a>2.2.3 执行上下文栈</h4><ol>
<li>在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象</li>
<li>在全局执行上下文（window）确定后，将其添加到栈中（压栈）</li>
<li>在函数执行上下文创建后，将其添加到栈中（压栈）</li>
<li>在当前函数执行完成后，将栈顶的对象移除（出栈）</li>
<li>当所有的代码执行完后，栈中只剩下window</li>
</ol>
<p><span style="background-color:#f9c116"> 处于活动状态的执行上下文环境只有一个。</span><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309154025.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.进入全局执行上下文</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  fn(x + b);<span class="comment">// 3. 进入foo执行上下文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a + c + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(<span class="number">10</span>);<span class="comment">// 2.进入bar函数执行上下文</span></span><br></pre></td></tr></table></figure>
<p>上述代码结果为30。</p>
<p>执行上下文栈结构图如下所示：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309153021.png"></p>
<p>栈的底部始终是<code>window</code>，因为第一个产生的是<code>window</code>，要放入栈中进行管理。<br>执行上下文个数遵循 <code>n + 1</code>的原则，其中<code>n</code>指的是调用函数的次数，<code>1</code>指的是<code>window</code>。</p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p><b>⭐ 1.依次输出什么？整个过程中产生了几个执行上下文？</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;global begin:&#x27;</span> + i);</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo begin:&#x27;</span> + i);</span><br><span class="line">  foo(i + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo end:&#x27;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;global end:&#x27;</span> + i);</span><br></pre></td></tr></table></figure>
<p>依次输出的结果：</p>
<blockquote>
<p>global begin:undefidned<br>foo begin:1<br>foo begin:2<br>foo begin:3<br>foo end:3<br>foo end:2<br>foo end:1<br>global end:1</p>
</blockquote>
<p>整个过程中产生了5个执行上下文。<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220309163434.png"></p>
<p><b>⭐ 2.函数提升与变量提升顺序</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上述代码先执行函数提升，再执行变量提升，但是变量未进行赋值操作，所以是function。<br>具体参考：<a href="https://qw-null.github.io/2022/03/09/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/">变量提升和函数提升的优先级问题</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(b <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>); <span class="comment">// TypeError: c is not a function</span></span><br></pre></td></tr></table></figure>
<p>上述代码相当于：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220311102431.png"></p>
<h3 id="2-3作用域与作用域链"><a href="#2-3作用域与作用域链" class="headerlink" title="2.3作用域与作用域链"></a>2.3作用域与作用域链</h3><h4 id="2-3-1-作用域"><a href="#2-3-1-作用域" class="headerlink" title="2.3.1 作用域"></a>2.3.1 作用域</h4><ol>
<li>理解<br>作用域就像是一块“地盘”，一个代码所在的区域。它是静态的（相对于 执行上下文对象 而言，因为执行上下文对象只有代码执行时才会产生），在编写代码时就确定了。</li>
<li>分类<br>全局作用域、函数作用域、块级作用域（ES6出现）</li>
<li>作用<br>隔离变量，不同作用域下同名变量不会有冲突</li>
<li>作用域个数<br>作用域个数遵循<code>n + 1</code>的原则（与执行上下文相同），其中<code>n</code>指的是定义的函数的个数，<code>1</code>指的是全局作用域。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220314203108.png"><br>结果为：<br>fn() 100 20 300 10<br>bar() 1000 20 300 400 100<br>bar() 1000 20 300 400 200</p>
<h4 id="2-3-2-作用域与执行上下文"><a href="#2-3-2-作用域与执行上下文" class="headerlink" title="2.3.2 作用域与执行上下文"></a>2.3.2 作用域与执行上下文</h4><ol>
<li>区别：<br>⭐全局作用域之外，每个函数都会创建自己的作用域。作用域在函数定义时就已经确定了，而不是在函数调用时。全局执行上下文环境是在全局作用域确定之后，JS代码马上执行之前创建；函数执行上下文环境是在调用函数时，函数代码执行之前创建。<br>⭐作用域是静态的，只要函数定义好了就一直存在，且不会再变化。执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放。</li>
<li>联系<br>执行上下文（对象）是从属于所作用域。全局上下文环境 → 全局作用域；函数上下文环境 → 对应的函数作用域。</li>
</ol>
<h4 id="2-3-3-作用域链"><a href="#2-3-3-作用域链" class="headerlink" title="2.3.3 作用域链"></a>2.3.3 作用域链</h4><ol>
<li>理解<br>多个上下级关系的作用域形成的链，它的方向是从下向上（从内到外）；查找变量时就是沿着作用域链来查找的</li>
<li>查找一个变量的查找规则<br>① 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入②；<br>② 在上一级作用域的执行上下文中查找对应的属性，如果有直接返回，否则进入③；<br>③ 在执行②的相同操作，直到全局作用域，如果还找不到就排除找不到的异常。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">  &#125;</span><br><span class="line">  fn2()</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220314230130.png"></p>
<h4 id="2-3-4-面试题"><a href="#2-3-4-面试题" class="headerlink" title="2.3.4 面试题"></a>2.3.4 面试题</h4><p>⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line">show(fn); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315140359.png"><br>执行函数<code>fn()</code>时，会先在<code>fn</code>的作用域中查找<code>x</code>，没有找到后会跳到其外部的作用域中继续寻找，<code>fn</code>的作用域和<code>show</code>的作用域是同级的不会相互查找。<br>⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">fn2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fn2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn2();</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315142215.png"><br>报错的原因是<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315142435.png"><br>在函数作用域中查找不到<code>fn2</code>，会到全局作用域中继续查找，在全局作用域中不存在<code>fn2</code>。<br>※ 如果想要调用<code>fn2</code>，应该修改代码为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">fn2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.fn2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn2(); <span class="comment">// 结果为打印fn2</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4闭包"><a href="#2-4闭包" class="headerlink" title="2.4闭包"></a>2.4闭包</h3><ol>
<li><p>如何产生闭包？<br>当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包。</p>
</li>
<li><p>闭包是什么？<br>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<blockquote>
<p>使用chrome调试查看：<br>※ 理解一：闭包是嵌套的内部函数（该函数中引用了外部函数的变量）<br>※ 理解二：包含被引用变量（函数）的对象<br><b>注意：</b>闭包存在于嵌套的内部函数中</p>
</blockquote>
</li>
<li><p>产生闭包的条件？</p>
</li>
</ol>
<ul>
<li>函数嵌套</li>
<li>内部函数引用了外部函数的数据（变量 \ 函数）</li>
<li>执行了外部函数</li>
</ul>
<h4 id="2-4-1-常见的闭包"><a href="#2-4-1-常见的闭包" class="headerlink" title="2.4.1 常见的闭包"></a>2.4.1 常见的闭包</h4><ol>
<li>将函数作为另一个函数的返回值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn1();</span><br><span class="line"><span class="built_in">console</span>.log(f);</span><br></pre></td></tr></table></figure>
结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315154451.png"><br>上述过程中<b>创建了1个闭包</b>。通过代码<code>fn1()</code>产生。<br>再执行下列代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(); <span class="comment">// 3</span></span><br><span class="line">f(); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li>
<li>将函数作为实参传递给另一个函数调用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDelay</span> (<span class="params">msg, time</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg)</span><br><span class="line">  &#125;, time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showDelay(<span class="string">&#x27;延迟输出&#x27;</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
上述代码在执行过程中产生了闭包。因为<br>嵌套的内部函数引用了外部函数的变量<code>msg</code><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220315160727.png"><br>若将代码修改如下，就不会产生闭包<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDelay</span> (<span class="params">msg, time</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;无闭包产生&#x27;</span>)；</span><br><span class="line">  &#125;, time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showDelay(<span class="string">&#x27;延迟输出&#x27;</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-4-2-闭包的作用"><a href="#2-4-2-闭包的作用" class="headerlink" title="2.4.2 闭包的作用"></a>2.4.2 闭包的作用</h4><ol>
<li><p>使得函数内部的变量在函数执行完后，仍存活在内存中（延长了局部变量的生命周期）</p>
</li>
<li><p>让函数外部可以操作（读写）到函数内部的数据（变量/函数）</p>
</li>
</ol>
<p>问题：<br><b>※ 1. 函数执行完后，函数内部声明的局部变量是否还在？</b><br>一般是不存在，存在于闭包中的变量才可能存在</p>
<p><b>※ 2. 在函数外部能直接访问函数内部的局部变量吗？</b><br>不能，但是通过闭包可以让外部操作它</p>
<h4 id="2-4-3-闭包的生命周期"><a href="#2-4-3-闭包的生命周期" class="headerlink" title="2.4.3 闭包的生命周期"></a>2.4.3 闭包的生命周期</h4><ol>
<li>产生：在嵌套内部函数定义执行完时就产生了（不是在调用时）</li>
<li>死亡：在嵌套的内部函数成为垃圾对象时 </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此时闭包就已经产生了（函数提升，内部函数对象已经创建了）</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = fn1();</span><br><span class="line">f(); <span class="comment">// 3</span></span><br><span class="line">f(); <span class="comment">// 4</span></span><br><span class="line">f = <span class="literal">null</span>;<span class="comment">// 闭包死亡（包含必报的函数对象成为垃圾对象）</span></span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-闭包的应用：定义JS模块"><a href="#2-4-3-闭包的应用：定义JS模块" class="headerlink" title="2.4.3 闭包的应用：定义JS模块"></a>2.4.3 闭包的应用：定义JS模块</h4><p>JS模块是具有特定功能的JS文件，将所有的数据和功能都封装在一个函数内部（私有的），只向外暴露一个包含n个方法的对象或者函数，模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能。</p>
<p><b>※ 方式一</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myModule</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&quot;My module&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 操作数据的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doSomething()&#x27;</span>, msg.toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doOtherthing()&#x27;</span>, msg.toLowerCase());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露对象（给外部使用的方法）</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>※ 方式二</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&quot;My module&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 操作数据的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doSomething()&#x27;</span>, msg.toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;doOtherthing()&#x27;</span>, msg.toLowerCase());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露对象（给外部使用的方法）</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h4 id="2-4-4-闭包的缺点及解决"><a href="#2-4-4-闭包的缺点及解决" class="headerlink" title="2.4.4 闭包的缺点及解决"></a>2.4.4 闭包的缺点及解决</h4><ol>
<li>缺点：<br>■ 函数执行完后，函数内的局部变量没有释放，占用内存时间会变长<br>■ 容易造成内存泄漏 【内存泄漏：内存占用却不使用】</li>
<li>解决：<br>■ 能不用闭包就不用<br>■ 及时释放</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>[<span class="number">100000</span>];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = fn1();</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">f = <span class="literal">null</span>;<span class="comment">// 让内部函数成为垃圾对象 --&gt; 回收闭包</span></span><br></pre></td></tr></table></figure>
<p>补充知识点：<a href="https://qw-null.github.io/2022/03/20/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">内存溢出与内存泄漏</a></p>
<h4 id="2-4-5-面试题"><a href="#2-4-5-面试题" class="headerlink" title="2.4.5 面试题"></a>2.4.5 面试题</h4><p><b>⭐ 题目 1</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;This Window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());</span><br></pre></td></tr></table></figure>
<p>输出的结果为<code>This Window</code>，原因是函数调用时，<code>this</code>指向<code>window</code>，因此<code>this.name</code>指的是全局变量<code>name</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;This Window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());</span><br></pre></td></tr></table></figure>
<p>输出的结果为<code>My Object</code>，原因是<code>this</code>是在对象<code>object</code>的方法<code>getNameFunc</code>中进行调用的，以方法调用时，<code>this</code>指向调用该方法的对象，因此<code>that.name</code>相当于<code>object.name</code>。</p>
<p><b>⭐ 题目 2</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">n, o</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">fun</span>: <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fun(m, n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>); <span class="comment">// undefidned</span></span><br><span class="line">a.fun(<span class="number">1</span>); a.fun(<span class="number">2</span>); a.fun(<span class="number">3</span>);<span class="comment">// ? ? ?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>);<span class="comment">// undefined ? ? ?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);<span class="comment">// undefined ?</span></span><br><span class="line">c.fun(<span class="number">2</span>); c.fun(<span class="number">3</span>);<span class="comment">// ? ?</span></span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">undefidned 0 0 0</span><br><span class="line">undefidned 0 1 2</span><br><span class="line">undefidned 0 1 1</span><br></pre></td></tr></table></figure>




<h2 id="3-面向对象高级"><a href="#3-面向对象高级" class="headerlink" title="3.面向对象高级"></a>3.面向对象高级</h2><h3 id="3-1-对象创建模式"><a href="#3-1-对象创建模式" class="headerlink" title="3.1 对象创建模式"></a>3.1 对象创建模式</h3><p>⭐ 方式一：Object构造函数模式</p>
<ul>
<li>套路：先创建空<code>Object</code>对象，再动态添加属性/方法</li>
<li>使用场景：起始时不确定对象内部数据</li>
<li>问题：语句太多</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个人：name:&quot;Tom&quot;,age:12</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">p.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">p.age = <span class="number">12</span>;</span><br><span class="line">p.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">p.setName(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure>
<p>结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220321112724.png"></p>
<p>⭐ 方式二：对象字面量模式</p>
<ul>
<li>套路：使用{}创建对象，同时指定属性/方法</li>
<li>使用场景：起始时对象内部数据是确定的</li>
<li>问题：如果创建多个对象，有重复代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个人：name:&quot;Tom&quot;,age:12</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">p.setName(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.name, p.age); <span class="comment">// Jack 12</span></span><br></pre></td></tr></table></figure>

<p>⭐ 方式三：工厂模式</p>
<ul>
<li>套路：通过工厂函数动态创建对象并返回</li>
<li>适用场景：需要创建多个对象</li>
<li>问题：对象没有一个具体的类型，都是object类型</li>
</ul>
<p>※ 何为工厂函数？  —— 返回一个对象的函数成为工厂函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">age</span>: age,</span><br><span class="line">    <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建2个人</span></span><br><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">&#x27;Jack&#x27;</span>,<span class="number">14</span>);</span><br></pre></td></tr></table></figure>

<p>⭐ 方式四：自定义构造函数模式</p>
<ul>
<li>套路：自定义构造函数，通过new创建对象</li>
<li>适用场景：需要创建多个类型确定的对象</li>
<li>问题：每个对象都有相同的数据，浪费内存</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">p1.setName(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但是此种方式创建的对象，每个对象中都包含<code>setName</code>方法，占用内存。</p>
<p>⭐ 方式五：构造函数+原型的组合模式</p>
<ul>
<li>套路：自定义构造函数，属性在函数中初始化，方法添加到原型上</li>
<li>适用场景：需要创建多个类型确定的对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在构造函数中，只初始化一般属性</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">13</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1, p2)</span><br></pre></td></tr></table></figure>
结果为：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220321135956.png"></li>
</ul>
<h3 id="3-2-原型链继承"><a href="#3-2-原型链继承" class="headerlink" title="3.2 原型链继承"></a>3.2 原型链继承</h3><h4 id="3-2-1-方式一：-原型链继承"><a href="#3-2-1-方式一：-原型链继承" class="headerlink" title="3.2.1 方式一： 原型链继承"></a>3.2.1 方式一： 原型链继承</h4><p>过程如下：</p>
<ol>
<li>定义父类型构造函数</li>
<li>给父类型的原型添加方法</li>
<li>定义子类型的构造函数</li>
<li>创建父类型的对象赋值给子类型的原型</li>
<li>将子类型原型的构造属性设置为子类型</li>
<li>给子类型原型添加方法</li>
<li>创建子类型的对象：可以调用父类型的方法</li>
</ol>
<p><b>⭐ 关键点：子类型的原型为父类型的一个实例对象</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义父类型构造函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Supper</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.supProp = <span class="string">&#x27;Supper Property&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> 给父类型的原型添加方法</span><br><span class="line">Supper.prototype.showSupperProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.supProp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 定义子类型的构造函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subProp = <span class="string">&#x27;Sub Property&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类型的原型为父类型的一个实例对象</span></span><br><span class="line"><span class="number">4.</span> 创建父类型的对象赋值给子类型的原型</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Supper();</span><br><span class="line"><span class="number">5.</span> 将子类型原型的构造属性设置为子类型</span><br><span class="line">Sub.prototype.constructor = Sub</span><br><span class="line"><span class="number">6.</span> 给子类型原型添加方法</span><br><span class="line">Sub.prototype.showSubProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.subProp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 创建子类型的对象：可以调用父类型的方法</span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line">sub.showSupperProp();</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220321171328.png"></p>
<h4 id="3-2-2-方式二：-借用构造函数继承（假的）"><a href="#3-2-2-方式二：-借用构造函数继承（假的）" class="headerlink" title="3.2.2 方式二： 借用构造函数继承（假的）"></a>3.2.2 方式二： 借用构造函数继承（假的）</h4><p>过程如下：</p>
<ol>
<li>定义父类型构造函数</li>
<li>定义子类型构造函数</li>
<li>在子类型构造函数中调用父类型构造</li>
</ol>
<p><b>⭐ 关键点：在子类型构造函数中通过<code>call()</code>调用父类型构造函数</b></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义父类型构造函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 定义子类型构造函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  <span class="number">3.</span> 在子类型构造函数中调用父类型构造</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age); <span class="comment">//相当于 this.Person(name,age)</span></span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>, <span class="number">13000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<p>结果为：<code>Student &#123; name: &#39;Tom&#39;, age: 12, price: 13000 &#125;</code></p>
<h4 id="3-2-3-方式三：-组合继承（原型链-借用构造函数）"><a href="#3-2-3-方式三：-组合继承（原型链-借用构造函数）" class="headerlink" title="3.2.3 方式三： 组合继承（原型链 + 借用构造函数）"></a>3.2.3 方式三： 组合继承（原型链 + 借用构造函数）</h4><p>过程如下： </p>
<ol>
<li>利用原型链实现对父类型对象的方法继承</li>
<li>利用<code>call()</code>借用父类型构造函数初始化相同属性</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age); <span class="comment">// 为了得到属性</span></span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person(); <span class="comment">// 为了能看到父类型的方法</span></span><br><span class="line">Student.prototype.constructor = Student; <span class="comment">// 修正constructor属性</span></span><br><span class="line">Student.prototype.setPrice = <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>, <span class="number">13000</span>);</span><br><span class="line">s.setName(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">s.setPrice(<span class="number">15000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<p>结果为<code>Student &#123; name: &#39;Jack&#39;, age: 12, price: 15000 &#125;</code></p>
<h4 id="3-2-4-补充：new一个对象背后做了什么？"><a href="#3-2-4-补充：new一个对象背后做了什么？" class="headerlink" title="3.2.4 补充：new一个对象背后做了什么？"></a>3.2.4 补充：new一个对象背后做了什么？</h4><ul>
<li>创建一个空对象</li>
<li>给对象设置<code>__proto__</code>，值为构造函数对象的<code>prototype</code>属性值</li>
<li>执行构造函数体（给对象添加属性 / 方法）</li>
</ul>
<h2 id="4-线程机制与事件机制"><a href="#4-线程机制与事件机制" class="headerlink" title="4.线程机制与事件机制"></a>4.线程机制与事件机制</h2><h3 id="4-1-进程与线程"><a href="#4-1-进程与线程" class="headerlink" title="4.1 进程与线程"></a>4.1 进程与线程</h3><p><b>进程（process）：</b>程序的一次执行，它占有一片独有的内存空间。可以通过window任务管理器查看进程。<br><b>线程（thread）：</b>线程是进程内一个独立执行的单元，是程序执行的一个完整流程，是CPU的最小的调度单元。</p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220322145958.png"><br>如果一个程序有2个进程，每个进程包含1个线程，则该程序是单线程程序。</p>
<p>⭐ 相关知识：</p>
<ol>
<li>应用程序必须运行在某个进程的某个线程上</li>
<li>一个进程至少有一个运行的线程：主线程（线程启动后自动创建）</li>
<li>一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的</li>
<li>一个进程内的数据可以供其中的多个线程直接共享</li>
<li>多个进程之间的数据是不能直接共享的</li>
<li>线程池（thread pool）：保存多个线程对象的容器，实现线程对象的反复利用</li>
</ol>
<p>⭐ 相关问题：</p>
<ol>
<li>何为多进程与多线程？<br>多进程运行：一个应用程序可以启动多个实例运行<br>多线程：在一个进程内，同时有多个线程运行</li>
<li>比较单线程与多线程？<br>多线程：【优点】能有效提升CPU的利用率 【缺点】创建多线程开销，线程间切换开销，死锁与状态同步问题<br>单线程：【优点】顺序变成简单易懂 【缺点】效率低</li>
<li>JS是单线程还是多线程？<br>JS是单线程运行的。但使用H5中的Web Workers可以多线程运行。</li>
<li>浏览器运行是单线程还是多线程？<br>浏览器运行是多线程。</li>
<li>浏览器运行是单进程还是多进程？<br>有单进程也有多进程。其中，单进程：firefox、老版IE，多进程：chrome、Edge。<h3 id="4-2-浏览器内核"><a href="#4-2-浏览器内核" class="headerlink" title="4.2 浏览器内核"></a>4.2 浏览器内核</h3></li>
</ol>
<table>
<thead>
<tr>
<th>浏览器名称</th>
<th>内核</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome、Safari</td>
<td>webkit</td>
</tr>
<tr>
<td>firefox</td>
<td>Gecko</td>
</tr>
<tr>
<td>IE</td>
<td>Trident</td>
</tr>
<tr>
<td>360，搜狗等国内浏览器</td>
<td>Trident + webkit</td>
</tr>
</tbody></table>
<p>浏览器内核由很多模块组成，其中包括：</p>
<ul>
<li>js引擎模块：负责js程序的编译与运行</li>
<li>html，css文档解析模块：负责页面文本解析</li>
<li>DOM/CSS模块：负责dom/css在内存中的相关处理</li>
<li>布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）</li>
</ul>
<p><b>【上述部分运行在主线程】</b></p>
<ul>
<li>……</li>
<li>定时器模块：负责定时器的管理</li>
<li>DOM事件响应模块：负责事件管理</li>
<li>网络请求模块：负责ajax请求</li>
</ul>
<p><b>【上述部分运行在分线程】</b></p>
<h3 id="4-3-定时器引发的思考"><a href="#4-3-定时器引发的思考" class="headerlink" title="4.3 定时器引发的思考"></a>4.3 定时器引发的思考</h3><p>相关问题：</p>
<ol>
<li>定时器真的是定时执行的吗？<br>定时器并不能保证真正定时执行，一般会延迟一丁点（可以接受），也可能延迟很长时间（不能接收）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;启动定时器前……&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;定时器执行了&#x27;</span>, <span class="built_in">Date</span>.now() - start);</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
多次执行结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324103330.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324103357.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324103437.png"></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;启动定时器前……&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;定时器执行了&#x27;</span>, <span class="built_in">Date</span>.now() - start);</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多次执行结果为<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324110425.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324110514.png"></p>
<ol start="2">
<li><p>定时器回调函数是在哪个线程执行的？<br>在主线程执行（JS是单线程的）</p>
</li>
<li><p>定时器是如何实现的？<br>事件循环模型（详情见后续内容）</p>
</li>
</ol>
<h3 id="4-4-JS是单线程执行的"><a href="#4-4-JS是单线程执行的" class="headerlink" title="4.4 JS是单线程执行的"></a>4.4 JS是单线程执行的</h3><ol>
<li>如何证明JS执行是单线程的？<br>setTimeout()的回调函数是在主线程执行的<br>定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 2000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 1000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn函数执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
执行结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324113636.png"></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 2000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 1000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn函数执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;alert之前&#x27;</span>);</span><br><span class="line">alert(<span class="string">&#x27;---------&#x27;</span>); <span class="comment">// 暂停当前主线程的执行，同时暂停计时，点击确定之后，恢复程序的执行和计时</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;alert之后&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324114233.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324114309.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324114353.png"></p>
<ol start="2">
<li><p>为什么JS要用单线程模式，而不用多线程模式？<br>Javascript的单线程与它的用途有关，作为浏览器脚本语言，Javascript的主要用途是与用户互动以及操作DOM，这决定了它只能是单线程的，负责会带来很复杂的同步问题。</p>
</li>
<li><p>代码分类</p>
</li>
</ol>
<ul>
<li>初始化代码</li>
<li>回调代码</li>
</ul>
<ol start="4">
<li>JS引擎执行代码的基本流程<br>先执行初始化代码【包含一些特别的代码：设置定时器、绑定监听、发送ajax请求】，后面的某一个时刻才会执行回调代码</li>
</ol>
<blockquote>
<p>其中，设置定时器指的是setTimeout(),不包括内部的回调函数，其内部的回调函数需要在初始化代码执行完毕之后再执行</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 2000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 1000&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout --&gt; 0&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn函数执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;alert之前&#x27;</span>);</span><br><span class="line">alert(<span class="string">&#x27;---------&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;alert之后&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>最终结果执行顺序：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324143955.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324144022.png"><br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220324144050.png"></p>
<h3 id="4-5-事件循环（轮询）模型"><a href="#4-5-事件循环（轮询）模型" class="headerlink" title="4.5 事件循环（轮询）模型"></a>4.5 事件循环（轮询）模型</h3><h4 id="4-5-1-模型原型图"><a href="#4-5-1-模型原型图" class="headerlink" title="4.5.1 模型原型图"></a>4.5.1 模型原型图</h4><p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/2356897452565.png"><br>对于JS代码可以分为两类：</p>
<ol>
<li>初始化执行代码（同步代码）：包含绑定dom事件监听，设置定时器，发送ajax请求的代码</li>
<li>回调执行代码（异步代码）：处理回调逻辑</li>
</ol>
<p><b>JS引擎执行代码的基本流程：</b>初始化代码 ➡ 回调代码</p>
<p><b>模型的两个重要组成部分：</b>事件管理模块、回调队列</p>
<p><b>🍎 模型的运转流程：</b>执行初始化代码，将事件回调函数交给对应模块管理 ➡ 当事件发生时，管理模块会将回调函数及其数据添加到回调队列中 ➡ 只有当初始化代码执行完成后（可能需要一段时间），才会遍历读取回调队列中的回调函数执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;执行fn1()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;点击了btn&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;执行了定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;执行fn2()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn2();</span><br></pre></td></tr></table></figure>
<p>上述代码的执行结果不唯一，首先确定的结果是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行fn1()</span><br><span class="line">执行fn2()</span><br></pre></td></tr></table></figure>
<p>剩余的<code>执行了定时器</code>和<code>点击了btn</code>，需要看点击btn的时机，如果点击btn在前，则执行顺序为<code>点击了btn</code>、<code>执行了定时器</code>，否则为<code>执行了定时器</code>、<code>点击了btn</code>。但是无论怎样<code>执行fn1()</code>和<code>执行fn2()</code>的顺序是不会改变的，因为这个为初始化执行代码。</p>
<h4 id="4-5-2-相关概念"><a href="#4-5-2-相关概念" class="headerlink" title="4.5.2 相关概念"></a>4.5.2 相关概念</h4><ul>
<li>执行栈（execution stack）：所有代码都是在此空间中执行的</li>
<li>浏览器内核（browser core）:js引擎模块（在主线程）、其他模块（在主/分线程处理）</li>
<li>任务队列（task queue）、消息队列（message queue）、事件队列（event queue）：同一个callback queue</li>
<li>事件轮询（event loop）：从任务队列中循环取出回调函数放入执行栈中处理（一个接一个）</li>
</ul>
<h3 id="4-6-H5-Web-Workers（多线程）"><a href="#4-6-H5-Web-Workers（多线程）" class="headerlink" title="4.6 H5 Web Workers（多线程）"></a>4.6 H5 Web Workers（多线程）</h3><p>H5提供了JS分线程的实现，取名为：<code>Web Workers</code>，我们可以将一些大计算量的代码交由web Worker 运行而不冻结用户界面。但是子线程完全受主线程控制，且不操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>相关API：</p>
<ul>
<li><code>Worker</code>：构造函数，加载分线程执行的JS文件</li>
<li><code>Worker.prototype.onmessage</code>：用于接收另一个线程的回调函数</li>
<li><code>Worker.prototype.postMessage</code>：向另一个线程发送消息</li>
</ul>
<p>不足之处：</p>
<ol>
<li><code>Worker</code>内代码不能操作DOM（更新UI）</li>
<li>不能跨域加载JS</li>
<li>不是每个浏览器都支持这个新特性</li>
<li>速度慢</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;number&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> number = input.value;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建一个Worker对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;work.js&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定接收消息的监听</span></span></span><br><span class="line"><span class="javascript">    worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;主线程接收分线程返回的数据&#x27;</span> + event.data);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 向分线程发送消息</span></span></span><br><span class="line"><span class="javascript">    worker.postMessage(number);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;主线程向分线程发送数据&#x27;</span> + number);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// work.js文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt;= <span class="number">2</span> ? <span class="number">1</span> : fn(n - <span class="number">1</span>) + fn(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;分线程接收主线程发送的数据&#x27;</span> + event.data);</span><br><span class="line">  <span class="keyword">var</span> result = fn(event.data);</span><br><span class="line">  postMessage(result);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;分线程向主线程发送数据&#x27;</span> + result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142438.png"><br>结果：<br><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142359.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/qw-null/BlogImages/20220329142107.png"></p>
<p>主线程中的<code>this</code>是<code>window</code>，而work线程中的<code>this</code>是一个专门为 <code>Worker</code> 定制的全局对象。</p>
<h2 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h2><h4 id="JS分号问题"><a href="#JS分号问题" class="headerlink" title="JS分号问题"></a>JS分号问题</h4><ul>
<li>JS一条语句的后面可以不加分号</li>
<li>是否加分号是编码风格问题，没有应该不应该，只有开发者喜欢与否</li>
<li>下面两种情况不加分号会报错<br>※ 小括号开头的前一条语句 （匿名函数自调用）<br>※ 中方括号开头的前一条语句<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>小括号开头的前一条语句 （匿名函数自调用）</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line">错误理解：</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>中方括号开头的前一条语句</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">;[<span class="number">3</span>,<span class="number">4</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">错误理解：</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>[<span class="number">3</span>,<span class="number">4</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
⭐解决方法：在行首加分号</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">qinwei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://qw-null.github.io/2022/02/25/Javascript高级教程/">https://qw-null.github.io/2022/02/25/Javascript高级教程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://qw-null.github.io">QW's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/02/28/%E7%BB%9F%E8%AE%A1%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97%E3%80%91/"><i class="fa fa-chevron-left">  </i><span>统计元素出现的次数【Leetcode刷题心得】</span></a></div><div class="next-post pull-right"><a href="/2022/02/24/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E3%80%90Leetcode%E3%80%91/"><span>环形链表【Leetcode】</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '44447f6848cb1055dfc7',
  clientSecret: '62722601a7b62e7a2f93add8216a30d9f047a2eb',
  repo: 'CommentData',
  owner: 'qw-null',
  admin: 'qw-null',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/qw-null/BlogImages/223.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2024 By qinwei</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>